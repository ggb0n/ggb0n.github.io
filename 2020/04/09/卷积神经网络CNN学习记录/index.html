<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="卷积神经网络CNN入门"><meta name="keywords" content="Machine Learning,Neural Network"><meta name="author" content="ggb0n"><meta name="copyright" content="ggb0n"><title>卷积神经网络CNN入门 | ggb0n's Blog</title><link rel="shortcut icon" href="http://www.ggb0n.cool/images/icon2.png"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#卷积神经网络概述"><span class="toc-number">1.</span> <span class="toc-text">卷积神经网络概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卷积神经网络结构"><span class="toc-number">2.</span> <span class="toc-text">卷积神经网络结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#输入层"><span class="toc-number">2.1.</span> <span class="toc-text">输入层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卷积层"><span class="toc-number">2.2.</span> <span class="toc-text">卷积层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReLU层"><span class="toc-number">2.3.</span> <span class="toc-text">ReLU层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#池化层"><span class="toc-number">2.4.</span> <span class="toc-text">池化层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全连接层"><span class="toc-number">2.5.</span> <span class="toc-text">全连接层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#卷积神经网络的结构"><span class="toc-number">3.</span> <span class="toc-text">卷积神经网络的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#层的排列规律"><span class="toc-number">3.1.</span> <span class="toc-text">层的排列规律</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#卷积层的大小选择"><span class="toc-number">3.2.</span> <span class="toc-text">卷积层的大小选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#层的尺寸设置"><span class="toc-number">3.3.</span> <span class="toc-text">层的尺寸设置</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://www.ggb0n.cool/images/header2.jpg"></div><div class="author-info__name text-center">ggb0n</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/ggb0n" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">24</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">92</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Friends Links</div><a class="author-info-links__name text-center" href="https://f61d.github.io" target="_blank" rel="noopener">f61d</a><a class="author-info-links__name text-center" href="https://15h3na0.xyz" target="_blank" rel="noopener">15h3na0</a><a class="author-info-links__name text-center" href="https://sxadmin.github.io" target="_blank" rel="noopener">Myself'</a><a class="author-info-links__name text-center" href="https://diao-diaoupup.cn" target="_blank" rel="noopener">51nd0re1</a><a class="author-info-links__name text-center" href="http://caoyi.site" target="_blank" rel="noopener">Amateur</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/ph1sh" target="_blank" rel="noopener">ph1sh</a><a class="author-info-links__name text-center" href="http://129.204.207.114:99" target="_blank" rel="noopener">HyyMbb</a><a class="author-info-links__name text-center" href="https://ajatars.github.io/" target="_blank" rel="noopener">Ajatar</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://www.ggb0n.cool/images/back2.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">ggb0n's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/links">Friend links</a><a class="site-page" href="/about">About</a><a class="site-page" href="/tools">Tools</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">卷积神经网络CNN入门</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">7.7k</span><span class="post-meta__separator">|</span><span>Reading time: 23 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文主要是记录一下对<code>卷积神经网络</code>（<code>CNN</code>）的学习，这是在机器学习，具体来说是深度学习中的第一步，认真学习、好好记录。</p>
<p>CNN曾经被<code>AlphaGo</code>的开发团队用于其开发，从而也一度引起业内人士的青睐，不过有些时候会出现对CNN的盲目崇拜，比如你面试的时候，对面可能会问：你做过机器学习吗？你为什么没有采用CNN算法呢？<br>这可能让人无法回答，其实CNN虽然相对于<code>深度神经网络</code>（<code>DNN</code>）更加简便，效能也很好，不过CNN只是用于图像处理，或者具有与图像处理要素相当的一些问题的处理中，就比如<code>AlphaGo</code>的下围棋，其实就相当于把棋盘当做了图像来进行处理，因此，如果你需要利用神经网络实现某些项目，一定要考虑好它具备与图像处理相当的要素没有。</p>
<p>这里提供一个比较好的学习视频，是<a href="https://www.bilibili.com/video/BV1hp411d7ij/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">李宏毅老师的教学视频</a>。好了，下面进入学习记录了。</p>
<h3 id="卷积神经网络概述"><a href="#卷积神经网络概述" class="headerlink" title="卷积神经网络概述"></a>卷积神经网络概述</h3><p>卷积神经网络，是深度学习算法应用最成功的领域之一，卷积神经网络包括一维卷积神经网络，二维卷积神经网络以及三维卷积神经网络。一维卷积神经网络主要用于<code>序列类</code>的数据处理，二维卷积神经网络常应用于<code>图像类文本</code>的识别，三维卷积神经网络主要应用于<code>医学图像</code>以及<code>视频类</code>数据识别。</p>
<p>其结构模型如下：<br><img src="http://ggb0n.cool/images/moxing1.png" alt=""></p>
<p>与常规神经网络不同，卷积神经网络的各层中的神经元是<code>3维</code>排列的：<code>宽度</code>、<code>高度</code>和<code>深度</code>。其中的宽度和高度是很好理解的，因为本身卷积就是一个二维模板，但是在卷积神经网络中的深度指的是<strong>激活数据体</strong>的第三个维度，而不是整个网络的深度，整个网络的深度指的是网络的层数。</p>
<h3 id="卷积神经网络结构"><a href="#卷积神经网络结构" class="headerlink" title="卷积神经网络结构"></a>卷积神经网络结构</h3><p>卷积神经网络主要由这几类层构成：<code>输入层</code>、<code>卷积层</code>，<code>ReLU层</code>、<code>池化（Pooling）层</code>(有时也称降采样、下采样层)和<code>全连接层</code>（全连接层和常规神经网络中的一样）。通过将这些层叠加起来，就可以构建一个完整的卷积神经网络，如下图：</p>
<p><img src="http://ggb0n.cool/images/moxing2.png" alt=""></p>
<p>各层的主要作用如下：</p>
<ul>
<li>输入层：用于数据的输入；</li>
<li>卷积层：使用卷积核进行特征提取和特征映射；</li>
<li>池化层：进行下采样，对特征图稀疏处理，减少数据运算量；</li>
<li>激励层：由于卷积也是一种线性运算，因此需要增加非线性映射；</li>
<li>全连接层：通常在CNN的尾部进行重新拟合，减少特征信息的损失。</li>
</ul>
<h4 id="输入层"><a href="#输入层" class="headerlink" title="输入层"></a>输入层</h4><p>该层除了输入数据，还会对数据进行一些预处理，包括：<code>去均值</code>、<code>归一化</code>、<code>PCA</code>、<code>白化</code></p>
<blockquote>
<p>PCA：是指通过抛弃携带信息量较少的维度，保留主要的特征信J自，来对数据进行降维处理，思路上是使用少数几个有代表性、互不相关的特征来代替原先的..k量的、存在一定相关性的特征，从而加速机器学习进程。PCA可用于特征提取，数据压缩，去噪声，降维等操作。</p>
</blockquote>
<blockquote>
<p>白化：目的是去掉数据之间的相关联度和令方差均一化，由于图像中相邻像素之间具有很强的相关性，所以用于训练时很多输入是冗余的。这时候去相关的操作就可以采用自化操作，从而使得：</p>
<ul>
<li>1、减少特征之间的相关性</li>
<li>2、特征具有相同的方差</li>
</ul>
</blockquote>
<h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>卷积层是构建卷积神经网络的<strong>核心层</strong>，因此该层也是学习的重点。它产生了网络中大部分的<strong>计算量</strong>，注意是计算量而不是参数量。</p>
<p><strong>卷积层的作用</strong></p>
<p>主要有三点：</p>
<ul>
<li><p>滤波器的作用或者说是卷积的作用</p>
<blockquote>
<p>卷积层的参数是有一些可学习的<code>滤波器</code>（<code>Filter</code>）集合构成的。每个滤波器在空间上（宽度和高度）都比较小，<strong>但是深度和输入数据一致</strong>。<br>直观地来说，网络会让滤波器学习到当它看到某些类型的视觉特征时就激活，具体的视觉特征可能是某些方位上的边界，或者在第一层上某些颜色的斑点，甚至可以是网络更高层上的蜂巢状、车轮状的图案。</p>
</blockquote>
</li>
<li><p>可以看做神经元的一个输出</p>
<blockquote>
<p>神经元只观察输入数据中的一小部分，并且和空间上左右两边的所有神经元共享参数（因为这些数字都是使用同一个滤波器得到的结果）。</p>
</blockquote>
</li>
<li><p>减少参数数量</p>
<blockquote>
<p>这个由于卷积具有“<code>权值共享</code>”这样的特性，可以降低参数数量，达到降低计算开销，防止由于参数过多而造成过拟合。</p>
</blockquote>
</li>
</ul>
<p><strong>感受野</strong></p>
<p>在处理图像这样的高维度输入时，让每个神经元都与前一层中的所有神经元进行全连接是不现实的。而是让每个神经元只与输入数据的一个局部区域连接，该连接的空间大小叫做神经元的<code>感受野（receptive field）</code>，它的尺寸是一个超参数（滤波器的空间尺寸）。注意：在深度方向上，这个连接的大小总是和输入的深度相等。</p>
<p><strong>神经元的空间排列</strong></p>
<p>感受野讲解了卷积层中每个神经元与<strong>输入数据体</strong>之间的连接方式，但是尚未讨论输出数据体中神经元的数量，以及它们的排列方式。3个超参数控制着输出数据体的尺寸：<code>深度</code>（<code>depth</code>），<code>步长</code>（<code>stride</code>）和<code>零填充</code>（<code>zero-padding</code>）：</p>
<ul>
<li>深度：一个超参数，和使用的滤波器的数量一致，而每个滤波器在输入数据中寻找一些不同的东西，即图像的某些特征。</li>
<li>步长：在滑动滤波器的时候，必须指定步长。当步长为1，滤波器每次移动1个像素；当步长为2，滤波器滑动时每次移动2个像素，依次类推。这个操作会让输出数据体在空间上变小。</li>
<li>零填充：有时候将输入数据体用<code>0</code>在边缘处进行填充是很方便的。零填充的尺寸是一个超参数。它具有一个良好性质，即可以控制输出数据体的空间尺寸（最常用的是用来保持输入数据体在空间上的尺寸，使得输入和输出的宽高都相等）。</li>
</ul>
<p>输出数据体在空间上的尺寸 <code>W2*H2*D2</code>可以通过输入数据体尺寸<code>W1*H1*D1</code>、卷积层中神经元的感受野尺寸<code>F</code>、步长<code>S</code>、滤波器数量<code>K</code>和零填充的数量<code>P</code>计算输出出来：</p>
<p><img src="http://ggb0n.cool/images/size.jpg" alt=""></p>
<p>注意这些空间排列的超参数之间是相互限制的。举例说来，当输入尺寸<code>W=10</code>，不使用零填充<code>P=0</code>，滤波器尺寸 <code>F=3</code>，此时步长<code>S=2</code>是行不通，因为<code>(W-F+2P)/S+1=(10-3+0)/2+1=4.5</code>，结果不是整数，这就是说神经元不能整齐对称地滑过输入数据体。<br>因此，这些超参数的设定就被认为是无效的，一个卷积神经网络库可能会报出一个错误，通过修改零填充值、修改输入数据体尺寸，或者其他什么措施来让设置合理。合理地设置网络的尺寸让所有的维度都能正常工作，是相当让人头痛的事，而使用零填充和遵守其他一些设计策略将会有效解决这个问题。</p>
<p><strong>权值共享</strong></p>
<p>在卷积层中<code>权值共享</code>是用来控制参数的数量。假如在一个卷积核中，每一个感受野采用的都是不同的权重值（卷积核的值不同），那么这样的网络中参数数量将是十分巨大的。</p>
<p>权值共享是基于这样的一个合理的假设：如果一个特征在计算某个空间位置<code>(x1,y1)(x1,y1)</code>的时候有用，那么它在计算另一个不同位置<code>(x2,y2)(x2,y2)</code>的时候也有用。基于这个假设，可以显著地减少参数数量。<br>换言之，就是将深度维度上一个单独的2维切片看做<code>深度切片</code>（<code>depth slice</code>），比如一个数据体尺寸为<code>[55x55x96]</code>的就有96个深度切片，每个尺寸为<code>[55x55]</code>，其中在每个深度切片上的结果都使用同样的权重和偏差获得的。<br>在这样的参数共享下，假如一个例子中的第一个卷积层有96个卷积核，那么就有96个不同的权重集了，一个权重集对应一个深度切片，如果卷积核的大小是<code>11x11</code>的，图像是RGB3通道的，那么就共有<code>96x11x11x3=34,848</code>个不同的权重，总共有<code>34,944</code>个参数（因为要+96个偏差），并且在每个深度切片中的<code>55x55</code>的结果使用的都是同样的参数。</p>
<p>在反向传播的时候，都要计算每个神经元对它的权重的梯度，但是需要把同一个深度切片上的所有神经元对权重的梯度累加，这样就得到了对共享权重的梯度。这样，每个切片只更新一个权重集。原理如下图：</p>
<p><img src="http://ggb0n.cool/images/CNN02.png" alt=""></p>
<p><img src="http://ggb0n.cool/images/CNN03.png" alt=""></p>
<p>如上两图所示，左侧的神经元是将每一个感受野展开为一列之后串联起来（就是展开排成一列，同一层神经元之间不连接）。右侧的<code>Deep1i</code>是深度为<code>1</code>的神经元的第<code>i</code>个，<code>Deep2i</code>是深度为<code>2</code>的神经元的第<code>i</code>个，同一个深度的神经元的权值都是相同的，黄色的都是相同的（上面4个与下面4个的参数相同），蓝色也都是相同的。</p>
<p>所以现在回过头来看上面说的卷积神经网络的反向传播公式对梯度进行累加求和也是基于这点考虑（同一深度的不同神经元共用一组参数，所以累加）；而每个切片只更新一个权重集的原因也是这样的，因为从图中可以看到，不同深度的神经元不会公用相同的权重，所以只能更新一个权重集。</p>
<blockquote>
<p>注意：如果在一个深度切片中的所有权重都使用同一个权重向量，那么卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的卷积（这就是“<code>卷积层</code>”名字由来）。这也是为什么总是将这些权重集合称为滤波器（或<code>卷积核</code>（<code>kernel</code>）），因为它们和输入进行了卷积。</p>
</blockquote>
<blockquote>
<p>注意：有时候参数共享假设可能没有意义，特别是当卷积神经网络的输入图像是一些明确的中心结构时候。这时候我们就应该期望在图片的不同位置学习到完全不同的特征（而一个卷积核滑动地与图像做卷积都是在学习相同的特征）。一个具体的例子就是输入图像是人脸，人脸一般都处于图片中心，而我们期望在不同的位置学习到不同的特征，比如眼睛特征或者头发特征可能（也应该）会在图片的不同位置被学习。在这个例子中，通常就放松参数共享的限制，将层称为局部连接层（<code>Locally-Connected Layer</code>）。</p>
</blockquote>
<p><strong>卷积层的超参数及选择</strong></p>
<p>由于参数共享，每个滤波器包含<code>F*F*D1</code>个权重，卷积层一共有<code>F*F*D1*K</code>个权重和<code>K</code>个偏移。在输出数据体中，第<code>d</code>个深度切片（空间尺寸是<code>W2*H2</code>），用第<code>d</code>个滤波器和输入数据进行有效卷积运算的结果（使用步长<code>S</code>），最后在加上第<code>d</code>个偏差。</p>
<p>对这些超参数，常见的设置是<code>F=3</code>，<code>S=1</code>，<code>P=1</code>，<code>F=3</code>，<code>S=1</code>，<code>P=1</code>。</p>
<p><strong>卷积层演示</strong></p>
<p>因为3D数据难以可视化，所以所有的数据（<code>输入数据体是蓝色</code>，<code>权重数据体是红色</code>，<code>输出数据体是绿色</code>）都采取将深度切片按照列的方式排列展现。输入数据体的尺寸是<code>W1=5</code>，<code>H1=5</code>，<code>D1=3</code>，<code>W1=5</code>，<code>H1=5</code>，<code>D1=3</code>，卷积层参数<code>K=2</code>，<code>F=3</code>，<code>S=2</code>，<code>P=1</code>，<code>K=2</code>，<code>F=3</code>，<code>S=2</code>，<code>P=1</code>。就是说，有<code>2</code>个滤波器，滤波器的尺寸是<code>3*33*3</code>，它们的步长是<code>2</code>。因此，输出数据体的空间尺寸是<code>(5−3+2)/2+1=3(5−3+2)/2+1=3</code>。注意输入数据体使用了零填充<code>P=1</code>，所以输入数据体外边缘一圈都是<code>0</code>。<br>下面的例子在绿色的输出激活数据上循环演示，展示了其中每个元素都是先通过蓝色的输入数据和红色的滤波器逐元素相乘，然后求其总和，最后加上偏差得来。<br><img src="http://ggb0n.cool/images/juanji.jpg" alt=""></p>
<p><strong>卷积操作形式</strong></p>
<p>卷积操作的形式比较多，这里主要介绍三点：<code>矩阵乘法实现卷积</code>、<code>1*1卷积</code>、<code>扩张卷积</code>。</p>
<ul>
<li>用矩阵乘法实现卷积</li>
</ul>
<blockquote>
<p>卷积运算本质上就是在滤波器和输入数据的局部区域间做点积。卷积层的常用实现方式就是利用这一点，将卷积层的前向传播变成一个巨大的矩阵乘法。</p>
<p>(1) 输入图像的局部区域被<code>im2coim2col</code>操作拉伸为列。比如输入是<code>[227x227x3]</code>，要与尺寸为<code>11x11x3</code>的滤波器以步长为<code>4</code>进行卷积，就依次取输入中的<code>[11x11x3]</code>数据块，然后将其拉伸为长度为<code>11x11x3=363</code>的列向量。重复进行这一过程，因为步长为<code>4</code> ，所以经过卷积后的宽和高均为<code>(227-11)/4+1=55</code>，共有<code>55x55=3,025</code>个神经元。因为每一个神经元实际上都是对应有<code>363</code>的列向量构成的感受野，即一共要从输入上取出<code>3025</code>个<code>363</code>维的列向量。所以经过<code>im2col</code>操作得到的输出矩阵的尺寸是<code>[363x3025]</code>，其中每列是拉伸的感受野。注意因为感受野之间有重叠，所以输入数据体中的数字在不同的列中可能有重复。</p>
<p>(2) 卷积层的权重也同样被拉伸成行。举例：如果有96个尺寸为<code>[11x11x3]</code>的滤波器，就生成一个矩阵，尺寸为<code>[96x363]</code>。</p>
<p>(3) 现在卷积的结果和进行一个大矩阵乘法<code>np.dot(Wrow,Xcol)np.dot(Wrow,Xcol)</code>是等价的了，能得到每个滤波器和每个感受野间的点积。在我们的例子中，这个操作的输出是<code>[96x3025]</code>，给出了每个滤波器在每个位置的点积输出。注意其中的<code>np.dotnp.dot</code>计算的是矩阵乘法而不是点积。</p>
<p>(4) 结果最后必须被重新变为合理的输出尺寸<code>[55x55x96]</code>。</p>
</blockquote>
<p>这个方法的缺点就是占用内存太多，因为在输入数据体中的某些值在<code>XcolXcol</code>中被复制了多次；优点在于矩阵乘法有非常多的高效底层实现方式。</p>
<ul>
<li>1*1卷积</li>
</ul>
<p>具有信号处理专业知识的人刚开始看见这个<code>1*1卷积</code>的时候可能会比较困惑，因为信号是<code>2</code>维的，所以<code>1*1卷积</code>就没有意义。但是，在卷积神经网络中不是这样，因为这里是对<code>3</code>个维度进行操作，滤波器和输入数据体的深度是一样的。比如，如果输入是<code>[32x32x3]</code>，那么<code>1*1卷积</code>就是在高效地进行<code>3</code>维<code>点积</code>（因为输入深度是3个通道）；另外的一种想法是将这种卷积的结果看作是全连接层的一种实现方式，后面讲到全连接层会提到。</p>
<ul>
<li>扩张卷积</li>
</ul>
<p>我们前面提到的滤波器都是连续的，但是，让滤波器中元素之间有间隙也是可以的，这就叫做扩张，如图：</p>
<p><img src="http://ggb0n.cool/images/kuozhang.jpg" alt=""></p>
<p>在某些设置中，扩张卷积与正常卷积结合起来非常有用，因为这可以在很少的层数内更快地汇集输入图片的大尺度特征。比如，如果上下重叠<code>2</code>个<code>3*3</code>的卷积层，那么第二个卷积层的神经元的感受野是输入数据体中<code>5*5</code>的区域（可以称这些神经元的有效感受野是5*5）。如果我们对卷积进行扩张，那么这个有效感受野就会迅速增长。</p>
<p>至此，对卷积层的学习告一段落，下一层是池化层。</p>
<h4 id="ReLU层"><a href="#ReLU层" class="headerlink" title="ReLU层"></a>ReLU层</h4><p>也称线性整流层（<code>Rectified Linear Units layer, ReLU layer</code>），使用<a href="https://zh.wikipedia.org/wiki/线性整流函数" target="_blank" rel="noopener">线性整流函数</a>（<code>Rectified Linear Units, ReLU</code>）<code>f(x)=max(0,x)</code>作为这一层神经的激励函数（<code>Activation function</code>）。它可以增强判定函数和整个神经网络的非线性特性，而本身并不会改变卷积层。</p>
<p>事实上，其他的一些函数也可以用于增强网络的非线性特性，如<a href="https://zh.wikipedia.org/wiki/双曲正切函数" target="_blank" rel="noopener">双曲正切函数</a> <code>f(x)=tanh(x)</code>、<code>f(x)=|tanh(x)|</code>，或者<a href="https://zh.wikipedia.org/wiki/S函数" target="_blank" rel="noopener">Sigmoid函数</a><code>f(x)=(1+e^(-x))^(-1)</code>。相比其它函数来说，ReLU函数更受青睐，这是因为它可以将神经网络的训练速度提升数倍，而并不会对模型的泛化准确度造成显著影响。</p>
<h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>通常在连续的卷积层之间会周期性地插入一个<code>池化层</code>（<code>Pooling</code>），它的作用是逐渐降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合。如下图：</p>
<p><img src="http://ggb0n.cool/images/pooling.png" alt=""></p>
<p>池化层使用<code>MAX</code>操作，对输入数据体的每一个深度切片独立进行操作，改变它的空间尺寸。最常见的形式是使用尺寸<code>2*2</code>的滤波器，以步长为<code>2</code>来对每个深度切片进行降采样，将其中<code>75%</code>的激活信息都丢掉。每个<code>MAX</code>操作是从<code>4</code>个数字中取最大值（也就是在深度切片中某个<code>2*2</code>的区域），深度保持不变。</p>
<p>池化层的计算：输入数据体尺寸<code>W1*H1*D1</code>，有两个超参数：空间大小<code>F</code>和步长<code>S</code>；输出数据体的尺寸<code>W2*H2*D2</code>，其中：</p>
<p><img src="http://ggb0n.cool/images/poolingcalc.jpg" alt=""></p>
<p>这里面与之前的卷积的尺寸计算的区别主要在于两点：首先在池化的过程中基本不会进行另补充；其次池化前后深度不变。</p>
<p><strong>普通池化（General Pooling）</strong>：除了常用的最大池化，池化单元还可以使用其他的函数，比如<code>平均池化</code>（<code>average pooling</code>）或<code>L-2范式池化</code>（<code>L2-norm pooling</code>）。平均池化历史上比较常用，但是现在已经很少使用了。因为实践证明，最大池化的效果比平均池化要好。</p>
<p><strong>反向传播</strong>：回顾一下反向传播的内容，其中<code>max(x,y)</code>函数的反向传播可以简单理解为将梯度只沿最大的数回传。因此，在向前传播经过汇聚层的时候，通常会把池中最大元素的索引记录下来（有时这个也叫作<code>道岔</code>（<code>switches</code>）），这样在反向传播的时候梯度的路由就很高效。</p>
<p><strong>不使用池化层</strong>：有些时候，被当做图像处理的问题其实也并不完全等同于图像处理，比如AlphaGo的下围棋：棋盘是不能摘除一部分位置进行缩小的，因此也就不能进行池化，事实上AlphaGo也并没有采用池化层。<br>通过在卷积层中使用更大的步长来降低数据体的尺寸。有发现认为有时候，在训练一个良好的生成模型时，弃用汇聚层也是很重要的。比如<code>变化自编码器</code>（<code>VAEs：variational autoencoders</code>）和<code>生成性对抗网络</code>（<code>GANs：generative adversarial networks</code>）。未来的卷积网络结构中，池化层的发展还真不能确定。</p>
<h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>全连接层（简称<code>FC</code>）将每一个结点都与上一层的所有结点相连，用来把前边提取到的特征综合起来。全连接层可以整合卷积层或者池化层中具有类别区分性的局部信息。</p>
<p>为了提升 CNN 网络性能，全连接层每个神经元的激励函数一般采用ReLU函数。最后一层全连接层的输出值被传递给一个输出，可以采用<code>softmax</code>逻辑回归（<code>softmax regression</code>）进行分类，该层也可称为<code>softmax</code>层（<code>softmax laye</code>）。</p>
<p><strong>将卷积层转化为全连接层</strong></p>
<p>对于任一个卷积层，都存在一个能实现和它一样的前向传播函数的全连接层。该全连接层的权重是一个巨大的矩阵，除了某些特定块（感受野），其余部分都是<code>0</code>；而在非<code>0</code>部分中，大部分元素都是相等的（权值共享）。<br>如果把全连接层转化成卷积层，以输出层的<code>Deep11</code>为例，与它有关的输入神经元只有上面四个，所以在权重矩阵中与它相乘的元素，除了它所对应的<code>4</code>个，剩下的均为<code>0</code>，这也就解释了为什么权重矩阵中有为零的部分。<br>另外要把“<code>将全连接层转化成卷积层</code>”和“<code>用矩阵乘法实现卷积</code>”区别开，这两者是不同的，后者本身还是在计算卷积，只不过将其展开为矩阵相乘的形式，并不是”将全连接层转化成卷积层”，所以除非权重中本身有零，否则用矩阵乘法实现卷积的过程中不会出现值为<code>0</code>的权重。</p>
<p><strong>将全连接层转化为卷积层</strong></p>
<p>任何全连接层都可以被转化为卷积层。比如，一个<code>K=409</code>6的全连接层，输入数据体的尺寸是 <code>7*7*5127*7*512</code>，这个全连接层可以被等效地看做一个<code>F=7</code>，<code>P=0</code>，<code>S=1</code>，<code>K=4096</code>，<code>F=7</code>，<code>P=0</code>，<code>S=1</code>，<code>K=4096</code>的卷积层。换句话说，就是将滤波器的尺寸设置为和输入数据体的尺寸设为一致的。因为只有一个单独的深度列覆盖并滑过输入数据体，所以输出将变成<code>1*1*40961*1*4096</code>，这个结果就和使用初始的那个全连接层一样了。<br>这个实际上也很好理解，因为，对于其中的一个卷积滤波器，这个滤波器的的深度为<code>512</code>，也就是说，虽然这个卷积滤波器的输出只有<code>1</code>个，但是它的权重有<code>7*7*5127*7*512</code>，相当于卷积滤波器的输出为一个神经元，这个神经元与上一层的所有神经元相连接，而这样与前一层所有神经元相连接的神经元一共有<code>4096</code>个，这不就是一个全连接网络。</p>
<p>在上述的两种变换中，<code>将全连接层转化为卷积层</code>在实际运用中更加有用。假设一个卷积神经网络的输入是<code>224*224*3</code>的图像，一系列的卷积层和汇聚层将图像数据变为尺寸为<code>7*7*512</code>的激活数据体（在AlexNet中就是这样，通过使用5个汇聚层来对输入数据进行空间上的降采样，每次尺寸下降一半，所以最终空间尺寸为<em>224/2/2/2/2/2=7</em>）。从这里可以看到，AlexNet使用了两个尺寸为<code>4096</code>的全连接层，最后一个有<code>1000</code>个神经元的全连接层用于计算分类评分。我们可以将这3个全连接转化为3个卷积层：</p>
<blockquote>
<p>(1) 针对第一个连接区域是<code>[7x7x512]</code>的全连接层，令其滤波器尺寸为<code>F=7</code>，这样输出数据体就为<code>[1x1x4096]</code>了。</p>
<p>(2) 针对第二个全连接层，令其滤波器尺寸为<code>F=1</code>，这样输出数据体为<code>[1x1x4096]</code>。</p>
<p>(3) 对最后一个全连接层也做类似的，令其<code>F=1</code>，最终输出为<code>[1x1x1000]</code>。</p>
</blockquote>
<p>这样做的目的是让卷积网络在一张更大的输入图片上滑动，得到多个输出，这样的转化可以让我们在单个向前传播的过程中完成上述的操作。</p>
<p>至此，对CNN各层的学习暂时告一段落，最起码有了一定的了解。下面将对各层之间的结构进行学习。</p>
<h3 id="卷积神经网络的结构"><a href="#卷积神经网络的结构" class="headerlink" title="卷积神经网络的结构"></a>卷积神经网络的结构</h3><p>卷积神经网络通常是由三种层构成：卷积层，池化层（除非特别说明，一般就是最大值池化）和全连接层。ReLU层通常在卷积层之后，它逐元素地进行激活函数操作，常常将它与卷积层看作是同一层。</p>
<h4 id="层的排列规律"><a href="#层的排列规律" class="headerlink" title="层的排列规律"></a>层的排列规律</h4><p>卷积神经网络最常见的形式就是将一些卷积层和ReLU层放在一起，其后紧跟池化层，然后重复如此直到图像在空间上被缩小到一个足够小的尺寸，在某个地方过渡成成全连接层也较为常见。最后的全连接层得到输出，比如分类评分等。换句话说，最常见的卷积神经网络结构如下：</p>
<p><img src="http://ggb0n.cool/images/pailie.jpg" alt=""></p>
<p>其中<code>*</code>指的是重复次数，<code>POOL?</code>指的是一个可选的池化层。其中<code>N&gt;=0</code>,通常<code>N&lt;=3</code>，<code>M&gt;=0</code>，<code>K&gt;=0</code>，<code>K&lt;3</code>。例如，下面是一些常见的网络结构规律：</p>
<ul>
<li><strong>INPUT -&gt; FC</strong> ：实现一个线性分类器，此处<code>N = M = K = 0</code>；</li>
<li><strong>INPUT -&gt; CONV -&gt; RELU -&gt; FC</strong>：单层的卷积神经网络；</li>
<li><strong>INPUT -&gt; [CONV -&gt; RELU -&gt; POOL]*2 -&gt; FC -&gt; RELU -&gt; FC</strong>：此处在每个汇聚层之间有一个卷积层，这种网络就是简单的多层的卷积神经网络；</li>
<li><strong>INPUT -&gt; [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL]*3 -&gt; [FC -&gt; RELU]*2 -&gt; FC</strong>：此处每个汇聚层前有两个卷积层，这个思路适用于更大更深的网络，因为在执行具有破坏性的汇聚操作前，多重的卷积层可以从输入数据中学习到更多的复杂特征。</li>
</ul>
<h4 id="卷积层的大小选择"><a href="#卷积层的大小选择" class="headerlink" title="卷积层的大小选择"></a>卷积层的大小选择</h4><p><strong>几个小滤波器卷积层的组合比一个大滤波器卷积层好</strong>。假设你一层一层地重叠了<code>3</code>个<code>3*3</code>的卷积层（层与层之间有ReLU激活函数）。在这个排列下，第一个卷积层中的每个神经元都对输入数据体有一个<code>3*3</code>的视野。第二个卷积层上的神经元对第一个卷积层有一个<code>3*3</code>的视野，也就是对输入数据体有<code>5*5</code>的视野。同样，在第三个卷积层上的神经元对第二个卷积层有<code>3*3</code>的视野，也就是对输入数据体有<code>7*7</code>的视野。</p>
<p>假设不采用这<code>3</code>个<code>3*3</code>的卷积层，而是使用一个单独的有<code>7*7</code>的感受野的卷积层，那么所有神经元的感受野也是<code>7*7</code>。多个卷积层与非线性的激活层交替的结构，比单一卷积层的结构更能提取出深层的更好的特征。但是也会有一些缺点，假设所有的数据有<code>C</code>个通道，那么单独的<code>7*7</code>卷积层将会包含<code>C*(7*7*C)=49C^2</code>个参数，而<code>3</code>个<code>3*3</code>的卷积层的组合仅有<code>3*(C*(3*3*C))=27C^2</code>个参数</p>
<p>直观说来，最好选择带有小滤波器的卷积层组合，而不是用一个带有大的滤波器的卷积层。前者可以表达出输入数据中更多个强力特征，使用的参数也更少。唯一的不足是，在进行反向传播时，中间的卷积层可能会导致占用更多的内存。</p>
<h4 id="层的尺寸设置"><a href="#层的尺寸设置" class="headerlink" title="层的尺寸设置"></a>层的尺寸设置</h4><p>各层常见的尺寸设置如下：</p>
<ul>
<li><strong>输入层</strong>：应该能被<code>2</code>整除很多次。常用数字包括<code>32</code>，<code>64</code>，<code>96</code>或<code>224</code>（比如ImageNet卷积神经网络），<code>384</code>和<code>512</code>。</li>
<li><strong>卷积层</strong>：应该使用小尺寸滤波器（比如<code>3*3</code>或最多<code>5*5</code>），使用步长<code>S=1</code>。还有一点非常重要，就是对输入数据进行<code>零填充</code>，这样卷积层就不会改变输入数据在空间维度上的尺寸。比如，当<code>F=3</code>，那就使用<code>P=1</code>来保持输入尺寸。当<code>F=5</code>，<code>P=2</code>，一般对于任意<code>F</code>，当<code>P=(F-1)/2</code>的时候能保持输入尺寸。如果必须使用更大的滤波器尺寸（比如<code>7*7</code>之类），通常只用在第一个面对原始图像的卷积层上。</li>
<li><strong>池化层</strong>：负责对输入数据的空间维度进行降采样。最常用的设置是用<code>2*2</code>感受野（即<code>F=2</code>）的最大值池化，步长为<code>S=2</code>。注意这一操作将会把输入数据中<code>75%</code>的激活数据丢弃（因为对宽度和高度都进行了<code>2</code>的下采样）。<br>另一个不那么常用的设置是使用<code>3*3</code>的感受野，步长为<code>2</code>。最大值池化的感受野尺寸很少有超过<code>3</code>的，因为池化操作过度，易造成数据信息丢失，这通常会导致算法性能变差。</li>
</ul>
<p>至此，对卷积神经网络的学习到此告一段落，很多深层次的地方其实还没搞懂，在以后的实践中再加深学习吧。</p>
<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/37261854" target="_blank" rel="noopener">卷积神经网络入门详解</a><br><a href="https://www.bilibili.com/video/BV1hp411d7ij/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">李宏毅机器学习教学视频</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ggb0n</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://ggb0n.cool/2020/04/09/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">http://ggb0n.cool/2020/04/09/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Machine-Learning/">Machine Learning</a><a class="post-meta__tags" href="/tags/Neural-Network/">Neural Network</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="http://ggb0n.cool/images/emFuc2hhbmc=.png"><div class="post-qr-code__desc">多谢大佬支持~</div></div></div><div class="social-share pull-right" data-disabled="douban,diandian,google,linkedin"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2020/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"><span>机器学习基本知识</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://www.ggb0n.cool/images/back2.png)"><div class="layout" id="footer"><div class="copyright">&copy;2020 by ggb0n</div><div class="footer_custom_text">一生一世，爱你一人。</div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><span>豫ICP备20003023号</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>